[
  {
    "function_name": "virStorageFileGetBackingStoreStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5368-5406",
    "snippet": "int\nvirStorageFileGetBackingStoreStr(virStorageSourcePtr src,\n                                 char **backing)\n{\n    ssize_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) tmp = NULL;\n\n    *backing = NULL;\n\n    /* exit if we can't load information about the current image */\n    if (!virStorageFileSupportsBackingChainTraversal(src))\n        return 0;\n\n    rv = virStorageFileAccess(src, F_OK);\n    if (rv == -2)\n        return 0;\n    if (rv < 0) {\n        virStorageFileReportBrokenChain(errno, src, src);\n        return -1;\n    }\n\n    if ((headerLen = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER,\n                                        &buf)) < 0) {\n        if (headerLen == -2)\n            return 0;\n        return -1;\n    }\n\n    if (!(tmp = virStorageSourceCopy(src, false)))\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(tmp, buf, headerLen) < 0)\n        return -1;\n\n    *backing = g_steal_pointer(&tmp->backingStoreRaw);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp->backingStoreRaw"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataInternal",
          "args": [
            "tmp",
            "buf",
            "headerLen"
          ],
          "line": 5401
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "935-1036",
          "snippet": "static int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceCopy",
          "args": [
            "src",
            "false"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2356-2471",
          "snippet": "virStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileRead",
          "args": [
            "src",
            "0",
            "VIR_STORAGE_MAX_HEADER",
            "&buf"
          ],
          "line": 5391
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5006-5029",
          "snippet": "ssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileReportBrokenChain",
          "args": [
            "errno",
            "src",
            "src"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileReportBrokenChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5125-5157",
          "snippet": "void\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileAccess",
          "args": [
            "src",
            "F_OK"
          ],
          "line": 5383
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileAccess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5072-5083",
          "snippet": "int\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileSupportsBackingChainTraversal",
          "args": [
            "src"
          ],
          "line": 5380
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileSupportsBackingChainTraversal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4753-4765",
          "snippet": "int\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetBackingStoreStr(virStorageSourcePtr src,\n                                 char **backing)\n{\n    ssize_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) tmp = NULL;\n\n    *backing = NULL;\n\n    /* exit if we can't load information about the current image */\n    if (!virStorageFileSupportsBackingChainTraversal(src))\n        return 0;\n\n    rv = virStorageFileAccess(src, F_OK);\n    if (rv == -2)\n        return 0;\n    if (rv < 0) {\n        virStorageFileReportBrokenChain(errno, src, src);\n        return -1;\n    }\n\n    if ((headerLen = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER,\n                                        &buf)) < 0) {\n        if (headerLen == -2)\n            return 0;\n        return -1;\n    }\n\n    if (!(tmp = virStorageSourceCopy(src, false)))\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(tmp, buf, headerLen) < 0)\n        return -1;\n\n    *backing = g_steal_pointer(&tmp->backingStoreRaw);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5328-5356",
    "snippet": "int\nvirStorageFileGetMetadata(virStorageSourcePtr src,\n                          uid_t uid, gid_t gid,\n                          bool report_broken)\n{\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u report_broken=%d\",\n              src->path, src->format, (unsigned int)uid, (unsigned int)gid,\n              report_broken);\n\n    virHashTablePtr cycle = NULL;\n    virStorageType actualType = virStorageSourceGetActualType(src);\n    int ret = -1;\n\n    if (!(cycle = virHashCreate(5, NULL)))\n        return -1;\n\n    if (src->format <= VIR_STORAGE_FILE_NONE) {\n        if (actualType == VIR_STORAGE_TYPE_DIR)\n            src->format = VIR_STORAGE_FILE_DIR;\n        else\n            src->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    ret = virStorageFileGetMetadataRecurse(src, src, uid, gid,\n                                           report_broken, cycle, 1);\n\n    virHashFree(cycle);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "cycle"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataRecurse",
          "args": [
            "src",
            "src",
            "uid",
            "gid",
            "report_broken",
            "cycle",
            "1"
          ],
          "line": 5351
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5207-5304",
          "snippet": "static int\nvirStorageFileGetMetadataRecurse(virStorageSourcePtr src,\n                                 virStorageSourcePtr parent,\n                                 uid_t uid, gid_t gid,\n                                 bool report_broken,\n                                 virHashTablePtr cycle,\n                                 unsigned int depth)\n{\n    virStorageFileFormat orig_format = src->format;\n    size_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) backingStore = NULL;\n\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u\",\n              NULLSTR(src->path), src->format,\n              (unsigned int)uid, (unsigned int)gid);\n\n    if (src->format == VIR_STORAGE_FILE_AUTO_SAFE)\n        src->format = VIR_STORAGE_FILE_AUTO;\n\n    /* exit if we can't load information about the current image */\n    rv = virStorageFileSupportsBackingChainTraversal(src);\n    if (rv <= 0) {\n        if (orig_format == VIR_STORAGE_FILE_AUTO)\n            return -2;\n\n        return rv;\n    }\n\n    if (virStorageFileGetMetadataRecurseReadHeader(src, parent, uid, gid,\n                                                   &buf, &headerLen, cycle) < 0)\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(src, buf, headerLen) < 0)\n        return -1;\n\n    /* If we probed the format we MUST ensure that nothing else than the current\n     * image (this includes both backing files and external data store) is\n     * considered for security labelling and/or recursion. */\n    if (orig_format == VIR_STORAGE_FILE_AUTO) {\n        if (src->backingStoreRaw || src->externalDataStoreRaw) {\n            src->format = VIR_STORAGE_FILE_RAW;\n            VIR_FREE(src->backingStoreRaw);\n            VIR_FREE(src->externalDataStoreRaw);\n            return -2;\n        }\n    }\n\n    if (src->backingStoreRaw) {\n        if ((rv = virStorageSourceNewFromBacking(src, &backingStore)) < 0)\n            return -1;\n\n        /* the backing file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        if ((rv = virStorageFileGetMetadataRecurse(backingStore, parent,\n                                                   uid, gid,\n                                                   report_broken,\n                                                   cycle, depth + 1)) < 0) {\n            if (!report_broken)\n                return 0;\n\n            if (rv == -2) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\"),\n                               src->backingStoreRaw, NULLSTR(src->path));\n            }\n\n            return -1;\n        }\n\n        backingStore->id = depth;\n        src->backingStore = g_steal_pointer(&backingStore);\n    } else {\n        /* add terminator */\n        if (!(src->backingStore = virStorageSourceNew()))\n            return -1;\n    }\n\n    if (src->externalDataStoreRaw) {\n        g_autoptr(virStorageSource) externalDataStore = NULL;\n\n        if ((rv = virStorageSourceNewFromExternalData(src,\n                                                      &externalDataStore)) < 0)\n            return -1;\n\n        /* the file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        src->externalDataStore = g_steal_pointer(&externalDataStore);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileGetMetadataRecurse(virStorageSourcePtr src,\n                                 virStorageSourcePtr parent,\n                                 uid_t uid, gid_t gid,\n                                 bool report_broken,\n                                 virHashTablePtr cycle,\n                                 unsigned int depth)\n{\n    virStorageFileFormat orig_format = src->format;\n    size_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) backingStore = NULL;\n\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u\",\n              NULLSTR(src->path), src->format,\n              (unsigned int)uid, (unsigned int)gid);\n\n    if (src->format == VIR_STORAGE_FILE_AUTO_SAFE)\n        src->format = VIR_STORAGE_FILE_AUTO;\n\n    /* exit if we can't load information about the current image */\n    rv = virStorageFileSupportsBackingChainTraversal(src);\n    if (rv <= 0) {\n        if (orig_format == VIR_STORAGE_FILE_AUTO)\n            return -2;\n\n        return rv;\n    }\n\n    if (virStorageFileGetMetadataRecurseReadHeader(src, parent, uid, gid,\n                                                   &buf, &headerLen, cycle) < 0)\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(src, buf, headerLen) < 0)\n        return -1;\n\n    /* If we probed the format we MUST ensure that nothing else than the current\n     * image (this includes both backing files and external data store) is\n     * considered for security labelling and/or recursion. */\n    if (orig_format == VIR_STORAGE_FILE_AUTO) {\n        if (src->backingStoreRaw || src->externalDataStoreRaw) {\n            src->format = VIR_STORAGE_FILE_RAW;\n            VIR_FREE(src->backingStoreRaw);\n            VIR_FREE(src->externalDataStoreRaw);\n            return -2;\n        }\n    }\n\n    if (src->backingStoreRaw) {\n        if ((rv = virStorageSourceNewFromBacking(src, &backingStore)) < 0)\n            return -1;\n\n        /* the backing file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        if ((rv = virStorageFileGetMetadataRecurse(backingStore, parent,\n                                                   uid, gid,\n                                                   report_broken,\n                                                   cycle, depth + 1)) < 0) {\n            if (!report_broken)\n                return 0;\n\n            if (rv == -2) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\"),\n                               src->backingStoreRaw, NULLSTR(src->path));\n            }\n\n            return -1;\n        }\n\n        backingStore->id = depth;\n        src->backingStore = g_steal_pointer(&backingStore);\n    } else {\n        /* add terminator */\n        if (!(src->backingStore = virStorageSourceNew()))\n            return -1;\n    }\n\n    if (src->externalDataStoreRaw) {\n        g_autoptr(virStorageSource) externalDataStore = NULL;\n\n        if ((rv = virStorageSourceNewFromExternalData(src,\n                                                      &externalDataStore)) < 0)\n            return -1;\n\n        /* the file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        src->externalDataStore = g_steal_pointer(&externalDataStore);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "5",
            "NULL"
          ],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 5338
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"path=%s format=%d uid=%u gid=%u report_broken=%d\"",
            "src->path",
            "src->format",
            "(unsigned int)uid",
            "(unsigned int)gid",
            "report_broken"
          ],
          "line": 5333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetMetadata(virStorageSourcePtr src,\n                          uid_t uid, gid_t gid,\n                          bool report_broken)\n{\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u report_broken=%d\",\n              src->path, src->format, (unsigned int)uid, (unsigned int)gid,\n              report_broken);\n\n    virHashTablePtr cycle = NULL;\n    virStorageType actualType = virStorageSourceGetActualType(src);\n    int ret = -1;\n\n    if (!(cycle = virHashCreate(5, NULL)))\n        return -1;\n\n    if (src->format <= VIR_STORAGE_FILE_NONE) {\n        if (actualType == VIR_STORAGE_TYPE_DIR)\n            src->format = VIR_STORAGE_FILE_DIR;\n        else\n            src->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    ret = virStorageFileGetMetadataRecurse(src, src, uid, gid,\n                                           report_broken, cycle, 1);\n\n    virHashFree(cycle);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileGetMetadataRecurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5207-5304",
    "snippet": "static int\nvirStorageFileGetMetadataRecurse(virStorageSourcePtr src,\n                                 virStorageSourcePtr parent,\n                                 uid_t uid, gid_t gid,\n                                 bool report_broken,\n                                 virHashTablePtr cycle,\n                                 unsigned int depth)\n{\n    virStorageFileFormat orig_format = src->format;\n    size_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) backingStore = NULL;\n\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u\",\n              NULLSTR(src->path), src->format,\n              (unsigned int)uid, (unsigned int)gid);\n\n    if (src->format == VIR_STORAGE_FILE_AUTO_SAFE)\n        src->format = VIR_STORAGE_FILE_AUTO;\n\n    /* exit if we can't load information about the current image */\n    rv = virStorageFileSupportsBackingChainTraversal(src);\n    if (rv <= 0) {\n        if (orig_format == VIR_STORAGE_FILE_AUTO)\n            return -2;\n\n        return rv;\n    }\n\n    if (virStorageFileGetMetadataRecurseReadHeader(src, parent, uid, gid,\n                                                   &buf, &headerLen, cycle) < 0)\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(src, buf, headerLen) < 0)\n        return -1;\n\n    /* If we probed the format we MUST ensure that nothing else than the current\n     * image (this includes both backing files and external data store) is\n     * considered for security labelling and/or recursion. */\n    if (orig_format == VIR_STORAGE_FILE_AUTO) {\n        if (src->backingStoreRaw || src->externalDataStoreRaw) {\n            src->format = VIR_STORAGE_FILE_RAW;\n            VIR_FREE(src->backingStoreRaw);\n            VIR_FREE(src->externalDataStoreRaw);\n            return -2;\n        }\n    }\n\n    if (src->backingStoreRaw) {\n        if ((rv = virStorageSourceNewFromBacking(src, &backingStore)) < 0)\n            return -1;\n\n        /* the backing file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        if ((rv = virStorageFileGetMetadataRecurse(backingStore, parent,\n                                                   uid, gid,\n                                                   report_broken,\n                                                   cycle, depth + 1)) < 0) {\n            if (!report_broken)\n                return 0;\n\n            if (rv == -2) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\"),\n                               src->backingStoreRaw, NULLSTR(src->path));\n            }\n\n            return -1;\n        }\n\n        backingStore->id = depth;\n        src->backingStore = g_steal_pointer(&backingStore);\n    } else {\n        /* add terminator */\n        if (!(src->backingStore = virStorageSourceNew()))\n            return -1;\n    }\n\n    if (src->externalDataStoreRaw) {\n        g_autoptr(virStorageSource) externalDataStore = NULL;\n\n        if ((rv = virStorageSourceNewFromExternalData(src,\n                                                      &externalDataStore)) < 0)\n            return -1;\n\n        /* the file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        src->externalDataStore = g_steal_pointer(&externalDataStore);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&externalDataStore"
          ],
          "line": 5300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceNewFromExternalData",
          "args": [
            "src",
            "&externalDataStore"
          ],
          "line": 5292
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromExternalData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4045-4060",
          "snippet": "static int\nvirStorageSourceNewFromExternalData(virStorageSourcePtr parent,\n                                    virStorageSourcePtr *externalDataStore)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->externalDataStoreRaw,\n                                           externalDataStore)) < 0)\n        return rc;\n\n    /* qcow2 data_file can only be raw */\n    (*externalDataStore)->format = VIR_STORAGE_FILE_RAW;\n    (*externalDataStore)->readonly = parent->readonly;\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceNewFromExternalData(virStorageSourcePtr parent,\n                                    virStorageSourcePtr *externalDataStore)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->externalDataStoreRaw,\n                                           externalDataStore)) < 0)\n        return rc;\n\n    /* qcow2 data_file can only be raw */\n    (*externalDataStore)->format = VIR_STORAGE_FILE_RAW;\n    (*externalDataStore)->readonly = parent->readonly;\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 5285
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&backingStore"
          ],
          "line": 5282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\")",
            "src->backingStoreRaw",
            "NULLSTR(src->path)"
          ],
          "line": 5272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->path"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\""
          ],
          "line": 5273
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataRecurse",
          "args": [
            "backingStore",
            "parent",
            "uid",
            "gid",
            "report_broken",
            "cycle",
            "depth + 1"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5207-5304",
          "snippet": "static int\nvirStorageFileGetMetadataRecurse(virStorageSourcePtr src,\n                                 virStorageSourcePtr parent,\n                                 uid_t uid, gid_t gid,\n                                 bool report_broken,\n                                 virHashTablePtr cycle,\n                                 unsigned int depth)\n{\n    virStorageFileFormat orig_format = src->format;\n    size_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) backingStore = NULL;\n\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u\",\n              NULLSTR(src->path), src->format,\n              (unsigned int)uid, (unsigned int)gid);\n\n    if (src->format == VIR_STORAGE_FILE_AUTO_SAFE)\n        src->format = VIR_STORAGE_FILE_AUTO;\n\n    /* exit if we can't load information about the current image */\n    rv = virStorageFileSupportsBackingChainTraversal(src);\n    if (rv <= 0) {\n        if (orig_format == VIR_STORAGE_FILE_AUTO)\n            return -2;\n\n        return rv;\n    }\n\n    if (virStorageFileGetMetadataRecurseReadHeader(src, parent, uid, gid,\n                                                   &buf, &headerLen, cycle) < 0)\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(src, buf, headerLen) < 0)\n        return -1;\n\n    /* If we probed the format we MUST ensure that nothing else than the current\n     * image (this includes both backing files and external data store) is\n     * considered for security labelling and/or recursion. */\n    if (orig_format == VIR_STORAGE_FILE_AUTO) {\n        if (src->backingStoreRaw || src->externalDataStoreRaw) {\n            src->format = VIR_STORAGE_FILE_RAW;\n            VIR_FREE(src->backingStoreRaw);\n            VIR_FREE(src->externalDataStoreRaw);\n            return -2;\n        }\n    }\n\n    if (src->backingStoreRaw) {\n        if ((rv = virStorageSourceNewFromBacking(src, &backingStore)) < 0)\n            return -1;\n\n        /* the backing file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        if ((rv = virStorageFileGetMetadataRecurse(backingStore, parent,\n                                                   uid, gid,\n                                                   report_broken,\n                                                   cycle, depth + 1)) < 0) {\n            if (!report_broken)\n                return 0;\n\n            if (rv == -2) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\"),\n                               src->backingStoreRaw, NULLSTR(src->path));\n            }\n\n            return -1;\n        }\n\n        backingStore->id = depth;\n        src->backingStore = g_steal_pointer(&backingStore);\n    } else {\n        /* add terminator */\n        if (!(src->backingStore = virStorageSourceNew()))\n            return -1;\n    }\n\n    if (src->externalDataStoreRaw) {\n        g_autoptr(virStorageSource) externalDataStore = NULL;\n\n        if ((rv = virStorageSourceNewFromExternalData(src,\n                                                      &externalDataStore)) < 0)\n            return -1;\n\n        /* the file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        src->externalDataStore = g_steal_pointer(&externalDataStore);\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNewFromBacking",
          "args": [
            "src",
            "&backingStore"
          ],
          "line": 5257
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4028-4042",
          "snippet": "int\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->externalDataStoreRaw"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->backingStoreRaw"
          ],
          "line": 5250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataInternal",
          "args": [
            "src",
            "buf",
            "headerLen"
          ],
          "line": 5241
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "935-1036",
          "snippet": "static int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataRecurseReadHeader",
          "args": [
            "src",
            "parent",
            "uid",
            "gid",
            "&buf",
            "&headerLen",
            "cycle"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataRecurseReadHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5160-5203",
          "snippet": "static int\nvirStorageFileGetMetadataRecurseReadHeader(virStorageSourcePtr src,\n                                           virStorageSourcePtr parent,\n                                           uid_t uid,\n                                           gid_t gid,\n                                           char **buf,\n                                           size_t *headerLen,\n                                           virHashTablePtr cycle)\n{\n    int ret = -1;\n    const char *uniqueName;\n    ssize_t len;\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    if (virStorageFileAccess(src, F_OK) < 0) {\n        virStorageFileReportBrokenChain(errno, src, parent);\n        goto cleanup;\n    }\n\n    if (!(uniqueName = virStorageFileGetUniqueIdentifier(src)))\n        goto cleanup;\n\n    if (virHashHasEntry(cycle, uniqueName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store for %s (%s) is self-referential\"),\n                       NULLSTR(src->path), uniqueName);\n        goto cleanup;\n    }\n\n    if (virHashAddEntry(cycle, uniqueName, NULL) < 0)\n        goto cleanup;\n\n    if ((len = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER, buf)) < 0)\n        goto cleanup;\n\n    *headerLen = len;\n    ret = 0;\n\n cleanup:\n    virStorageFileDeinit(src);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileGetMetadataRecurseReadHeader(virStorageSourcePtr src,\n                                           virStorageSourcePtr parent,\n                                           uid_t uid,\n                                           gid_t gid,\n                                           char **buf,\n                                           size_t *headerLen,\n                                           virHashTablePtr cycle)\n{\n    int ret = -1;\n    const char *uniqueName;\n    ssize_t len;\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    if (virStorageFileAccess(src, F_OK) < 0) {\n        virStorageFileReportBrokenChain(errno, src, parent);\n        goto cleanup;\n    }\n\n    if (!(uniqueName = virStorageFileGetUniqueIdentifier(src)))\n        goto cleanup;\n\n    if (virHashHasEntry(cycle, uniqueName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store for %s (%s) is self-referential\"),\n                       NULLSTR(src->path), uniqueName);\n        goto cleanup;\n    }\n\n    if (virHashAddEntry(cycle, uniqueName, NULL) < 0)\n        goto cleanup;\n\n    if ((len = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER, buf)) < 0)\n        goto cleanup;\n\n    *headerLen = len;\n    ret = 0;\n\n cleanup:\n    virStorageFileDeinit(src);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileSupportsBackingChainTraversal",
          "args": [
            "src"
          ],
          "line": 5229
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileSupportsBackingChainTraversal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4753-4765",
          "snippet": "int\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"path=%s format=%d uid=%u gid=%u\"",
            "NULLSTR(src->path)",
            "src->format",
            "(unsigned int)uid",
            "(unsigned int)gid"
          ],
          "line": 5221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->path"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileGetMetadataRecurse(virStorageSourcePtr src,\n                                 virStorageSourcePtr parent,\n                                 uid_t uid, gid_t gid,\n                                 bool report_broken,\n                                 virHashTablePtr cycle,\n                                 unsigned int depth)\n{\n    virStorageFileFormat orig_format = src->format;\n    size_t headerLen;\n    int rv;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) backingStore = NULL;\n\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u\",\n              NULLSTR(src->path), src->format,\n              (unsigned int)uid, (unsigned int)gid);\n\n    if (src->format == VIR_STORAGE_FILE_AUTO_SAFE)\n        src->format = VIR_STORAGE_FILE_AUTO;\n\n    /* exit if we can't load information about the current image */\n    rv = virStorageFileSupportsBackingChainTraversal(src);\n    if (rv <= 0) {\n        if (orig_format == VIR_STORAGE_FILE_AUTO)\n            return -2;\n\n        return rv;\n    }\n\n    if (virStorageFileGetMetadataRecurseReadHeader(src, parent, uid, gid,\n                                                   &buf, &headerLen, cycle) < 0)\n        return -1;\n\n    if (virStorageFileGetMetadataInternal(src, buf, headerLen) < 0)\n        return -1;\n\n    /* If we probed the format we MUST ensure that nothing else than the current\n     * image (this includes both backing files and external data store) is\n     * considered for security labelling and/or recursion. */\n    if (orig_format == VIR_STORAGE_FILE_AUTO) {\n        if (src->backingStoreRaw || src->externalDataStoreRaw) {\n            src->format = VIR_STORAGE_FILE_RAW;\n            VIR_FREE(src->backingStoreRaw);\n            VIR_FREE(src->externalDataStoreRaw);\n            return -2;\n        }\n    }\n\n    if (src->backingStoreRaw) {\n        if ((rv = virStorageSourceNewFromBacking(src, &backingStore)) < 0)\n            return -1;\n\n        /* the backing file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        if ((rv = virStorageFileGetMetadataRecurse(backingStore, parent,\n                                                   uid, gid,\n                                                   report_broken,\n                                                   cycle, depth + 1)) < 0) {\n            if (!report_broken)\n                return 0;\n\n            if (rv == -2) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"format of backing image '%s' of image '%s' was not specified in the image metadata \"\n                                 \"(See https://libvirt.org/kbase/backing_chains.html for troubleshooting)\"),\n                               src->backingStoreRaw, NULLSTR(src->path));\n            }\n\n            return -1;\n        }\n\n        backingStore->id = depth;\n        src->backingStore = g_steal_pointer(&backingStore);\n    } else {\n        /* add terminator */\n        if (!(src->backingStore = virStorageSourceNew()))\n            return -1;\n    }\n\n    if (src->externalDataStoreRaw) {\n        g_autoptr(virStorageSource) externalDataStore = NULL;\n\n        if ((rv = virStorageSourceNewFromExternalData(src,\n                                                      &externalDataStore)) < 0)\n            return -1;\n\n        /* the file would not be usable for VM usage */\n        if (rv == 1)\n            return 0;\n\n        src->externalDataStore = g_steal_pointer(&externalDataStore);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetMetadataRecurseReadHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5160-5203",
    "snippet": "static int\nvirStorageFileGetMetadataRecurseReadHeader(virStorageSourcePtr src,\n                                           virStorageSourcePtr parent,\n                                           uid_t uid,\n                                           gid_t gid,\n                                           char **buf,\n                                           size_t *headerLen,\n                                           virHashTablePtr cycle)\n{\n    int ret = -1;\n    const char *uniqueName;\n    ssize_t len;\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    if (virStorageFileAccess(src, F_OK) < 0) {\n        virStorageFileReportBrokenChain(errno, src, parent);\n        goto cleanup;\n    }\n\n    if (!(uniqueName = virStorageFileGetUniqueIdentifier(src)))\n        goto cleanup;\n\n    if (virHashHasEntry(cycle, uniqueName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store for %s (%s) is self-referential\"),\n                       NULLSTR(src->path), uniqueName);\n        goto cleanup;\n    }\n\n    if (virHashAddEntry(cycle, uniqueName, NULL) < 0)\n        goto cleanup;\n\n    if ((len = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER, buf)) < 0)\n        goto cleanup;\n\n    *headerLen = len;\n    ret = 0;\n\n cleanup:\n    virStorageFileDeinit(src);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileDeinit",
          "args": [
            "src"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4830-4841",
          "snippet": "void\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileRead",
          "args": [
            "src",
            "0",
            "VIR_STORAGE_MAX_HEADER",
            "buf"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5006-5029",
          "snippet": "ssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "cycle",
            "uniqueName",
            "NULL"
          ],
          "line": 5191
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"backing store for %s (%s) is self-referential\")",
            "NULLSTR(src->path)",
            "uniqueName"
          ],
          "line": 5185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->path"
          ],
          "line": 5187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"backing store for %s (%s) is self-referential\""
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashHasEntry",
          "args": [
            "cycle",
            "uniqueName"
          ],
          "line": 5184
        },
        "resolved": true,
        "details": {
          "function_name": "virHashHasEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "494-499",
          "snippet": "bool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetUniqueIdentifier",
          "args": [
            "src"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetUniqueIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5040-5059",
          "snippet": "const char *\nvirStorageFileGetUniqueIdentifier(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return NULL;\n    }\n\n    if (!src->drv->backend->storageFileGetUniqueIdentifier) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return NULL;\n    }\n\n    return src->drv->backend->storageFileGetUniqueIdentifier(src);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nconst char *\nvirStorageFileGetUniqueIdentifier(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return NULL;\n    }\n\n    if (!src->drv->backend->storageFileGetUniqueIdentifier) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return NULL;\n    }\n\n    return src->drv->backend->storageFileGetUniqueIdentifier(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileReportBrokenChain",
          "args": [
            "errno",
            "src",
            "parent"
          ],
          "line": 5177
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileReportBrokenChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5125-5157",
          "snippet": "void\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileAccess",
          "args": [
            "src",
            "F_OK"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileAccess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5072-5083",
          "snippet": "int\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileInitAs",
          "args": [
            "src",
            "uid",
            "gid"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileInitAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4857-4890",
          "snippet": "int\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileGetMetadataRecurseReadHeader(virStorageSourcePtr src,\n                                           virStorageSourcePtr parent,\n                                           uid_t uid,\n                                           gid_t gid,\n                                           char **buf,\n                                           size_t *headerLen,\n                                           virHashTablePtr cycle)\n{\n    int ret = -1;\n    const char *uniqueName;\n    ssize_t len;\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    if (virStorageFileAccess(src, F_OK) < 0) {\n        virStorageFileReportBrokenChain(errno, src, parent);\n        goto cleanup;\n    }\n\n    if (!(uniqueName = virStorageFileGetUniqueIdentifier(src)))\n        goto cleanup;\n\n    if (virHashHasEntry(cycle, uniqueName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store for %s (%s) is self-referential\"),\n                       NULLSTR(src->path), uniqueName);\n        goto cleanup;\n    }\n\n    if (virHashAddEntry(cycle, uniqueName, NULL) < 0)\n        goto cleanup;\n\n    if ((len = virStorageFileRead(src, 0, VIR_STORAGE_MAX_HEADER, buf)) < 0)\n        goto cleanup;\n\n    *headerLen = len;\n    ret = 0;\n\n cleanup:\n    virStorageFileDeinit(src);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileReportBrokenChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5125-5157",
    "snippet": "void\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errcode",
            "_(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\")",
            "src->path",
            "parent->path"
          ],
          "line": 5151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\""
          ],
          "line": 5152
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errcode",
            "_(\"Cannot access storage file '%s'\")",
            "src->path"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errcode",
            "_(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\")",
            "src->path",
            "parent->path",
            "access_user",
            "access_group"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "virReportSystemErrorFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1322-1360",
          "snippet": "void virReportSystemErrorFull(int domcode,\n                              int theerrno,\n                              const char *filename,\n                              const char *funcname,\n                              size_t linenr,\n                              const char *fmt, ...)\n{\n    int save_errno = errno;\n    char msgDetailBuf[VIR_ERROR_MAX_LENGTH];\n\n    const char *errnoDetail = g_strerror(theerrno);\n    const char *msg = virErrorMsg(VIR_ERR_SYSTEM_ERROR, fmt);\n    const char *msgDetail = NULL;\n\n    if (fmt) {\n        va_list args;\n        int n;\n\n        va_start(args, fmt);\n        n = g_vsnprintf(msgDetailBuf, sizeof(msgDetailBuf), fmt, args);\n        va_end(args);\n\n        size_t len = strlen(errnoDetail);\n        if (0 <= n && n + 2 + len < sizeof(msgDetailBuf)) {\n          strcpy(msgDetailBuf + n, \": \");\n          n += 2;\n          strcpy(msgDetailBuf + n, errnoDetail);\n          msgDetail = msgDetailBuf;\n        }\n    }\n\n    if (!msgDetail)\n        msgDetail = errnoDetail;\n\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, VIR_ERR_SYSTEM_ERROR, VIR_ERR_ERROR,\n                      msg, msgDetail, NULL, theerrno, -1, msg, msgDetail);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportSystemErrorFull(int domcode,\n                              int theerrno,\n                              const char *filename,\n                              const char *funcname,\n                              size_t linenr,\n                              const char *fmt, ...)\n{\n    int save_errno = errno;\n    char msgDetailBuf[VIR_ERROR_MAX_LENGTH];\n\n    const char *errnoDetail = g_strerror(theerrno);\n    const char *msg = virErrorMsg(VIR_ERR_SYSTEM_ERROR, fmt);\n    const char *msgDetail = NULL;\n\n    if (fmt) {\n        va_list args;\n        int n;\n\n        va_start(args, fmt);\n        n = g_vsnprintf(msgDetailBuf, sizeof(msgDetailBuf), fmt, args);\n        va_end(args);\n\n        size_t len = strlen(errnoDetail);\n        if (0 <= n && n + 2 + len < sizeof(msgDetailBuf)) {\n          strcpy(msgDetailBuf + n, \": \");\n          n += 2;\n          strcpy(msgDetailBuf + n, errnoDetail);\n          msgDetail = msgDetailBuf;\n        }\n    }\n\n    if (!msgDetail)\n        msgDetail = errnoDetail;\n\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, VIR_ERR_SYSTEM_ERROR, VIR_ERR_ERROR,\n                      msg, msgDetail, NULL, theerrno, -1, msg, msgDetail);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errcode",
            "_(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\")",
            "src->path",
            "access_user",
            "access_group"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileReportBrokenChain(int errcode,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr parent)\n{\n    if (src->drv) {\n        unsigned int access_user = src->drv->uid;\n        unsigned int access_group = src->drv->gid;\n\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s' \"\n                                   \"(as uid:%u, gid:%u)\"),\n                                 src->path, access_user, access_group);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s' (as uid:%u, gid:%u)\"),\n                                 src->path, parent->path, access_user, access_group);\n        }\n    } else {\n        if (src == parent) {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access storage file '%s'\"),\n                                 src->path);\n        } else {\n            virReportSystemError(errcode,\n                                 _(\"Cannot access backing file '%s' \"\n                                   \"of storage file '%s'\"),\n                                 src->path, parent->path);\n        }\n    }\n}"
  },
  {
    "function_name": "virStorageFileChown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5097-5112",
    "snippet": "int\nvirStorageFileChown(const virStorageSource *src,\n                    uid_t uid,\n                    gid_t gid)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileChown) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    VIR_DEBUG(\"chown of storage file %p to %u:%u\",\n              src, (unsigned int)uid, (unsigned int)gid);\n\n    return src->drv->backend->storageFileChown(src, uid, gid);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileChown",
          "args": [
            "src",
            "uid",
            "gid"
          ],
          "line": 5111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"chown of storage file %p to %u:%u\"",
            "src",
            "(unsigned int)uid",
            "(unsigned int)gid"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 5102
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileChown(const virStorageSource *src,\n                    uid_t uid,\n                    gid_t gid)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileChown) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    VIR_DEBUG(\"chown of storage file %p to %u:%u\",\n              src, (unsigned int)uid, (unsigned int)gid);\n\n    return src->drv->backend->storageFileChown(src, uid, gid);\n}"
  },
  {
    "function_name": "virStorageFileAccess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5072-5083",
    "snippet": "int\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileAccess",
          "args": [
            "src",
            "mode"
          ],
          "line": 5082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileAccess(virStorageSourcePtr src,\n                     int mode)\n{\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileAccess) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    return src->drv->backend->storageFileAccess(src, mode);\n}"
  },
  {
    "function_name": "virStorageFileGetUniqueIdentifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5040-5059",
    "snippet": "const char *\nvirStorageFileGetUniqueIdentifier(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return NULL;\n    }\n\n    if (!src->drv->backend->storageFileGetUniqueIdentifier) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return NULL;\n    }\n\n    return src->drv->backend->storageFileGetUniqueIdentifier(src);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileGetUniqueIdentifier",
          "args": [
            "src"
          ],
          "line": 5058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\")",
            "virStorageTypeToString(src->type)",
            "virStorageNetProtocolTypeToString(src->protocol)"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeToString",
          "args": [
            "src->protocol"
          ],
          "line": 5054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "src->type"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\""
          ],
          "line": 5051
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"storage file backend not initialized\")"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nconst char *\nvirStorageFileGetUniqueIdentifier(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return NULL;\n    }\n\n    if (!src->drv->backend->storageFileGetUniqueIdentifier) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unique storage file identifier not implemented for \"\n                         \"storage type %s (protocol: %s)'\"),\n                       virStorageTypeToString(src->type),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return NULL;\n    }\n\n    return src->drv->backend->storageFileGetUniqueIdentifier(src);\n}"
  },
  {
    "function_name": "virStorageFileRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "5006-5029",
    "snippet": "ssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"read '%zd' bytes from storage '%p' starting at offset '%zu'\"",
            "ret",
            "src",
            "offset"
          ],
          "line": 5025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileRead",
          "args": [
            "src",
            "offset",
            "len",
            "buf"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"storage file backend not initialized\")"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"storage file backend not initialized\""
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 5014
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nssize_t\nvirStorageFileRead(virStorageSourcePtr src,\n                   size_t offset,\n                   size_t len,\n                   char **buf)\n{\n    ssize_t ret;\n\n    if (!virStorageFileIsInitialized(src)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"storage file backend not initialized\"));\n        return -1;\n    }\n\n    if (!src->drv->backend->storageFileRead)\n        return -2;\n\n    ret = src->drv->backend->storageFileRead(src, offset, len, buf);\n\n    VIR_DEBUG(\"read '%zd' bytes from storage '%p' starting at offset '%zu'\",\n              ret, src, offset);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileStat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4973-4991",
    "snippet": "int\nvirStorageFileStat(virStorageSourcePtr src,\n                   struct stat *st)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileStat) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileStat(src, st);\n\n    VIR_DEBUG(\"stat of storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stat of storage file %p: ret=%d, errno=%d\"",
            "src",
            "ret",
            "errno"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileStat",
          "args": [
            "src",
            "st"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 4979
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileStat(virStorageSourcePtr src,\n                   struct stat *st)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileStat) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileStat(src, st);\n\n    VIR_DEBUG(\"stat of storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileUnlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4944-4961",
    "snippet": "int\nvirStorageFileUnlink(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileUnlink) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileUnlink(src);\n\n    VIR_DEBUG(\"unlinked storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"unlinked storage file %p: ret=%d, errno=%d\"",
            "src",
            "ret",
            "errno"
          ],
          "line": 4957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileUnlink",
          "args": [
            "src"
          ],
          "line": 4955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileUnlink(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileUnlink) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileUnlink(src);\n\n    VIR_DEBUG(\"unlinked storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4914-4931",
    "snippet": "int\nvirStorageFileCreate(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileCreate) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileCreate(src);\n\n    VIR_DEBUG(\"created storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"created storage file %p: ret=%d, errno=%d\"",
            "src",
            "ret",
            "errno"
          ],
          "line": 4927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->storageFileCreate",
          "args": [
            "src"
          ],
          "line": 4925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileCreate(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileCreate) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileCreate(src);\n\n    VIR_DEBUG(\"created storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4899-4903",
    "snippet": "int\nvirStorageFileInit(virStorageSourcePtr src)\n{\n    return virStorageFileInitAs(src, -1, -1);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileInitAs",
          "args": [
            "src",
            "-1",
            "-1"
          ],
          "line": 4902
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileInitAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4857-4890",
          "snippet": "int\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileInit(virStorageSourcePtr src)\n{\n    return virStorageFileInitAs(src, -1, -1);\n}"
  },
  {
    "function_name": "virStorageFileInitAs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4857-4890",
    "snippet": "int\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->drv"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->backendInit",
          "args": [
            "src"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileBackendForType",
          "args": [
            "actualType",
            "src->protocol",
            "true",
            "&src->drv->backend"
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileBackendForType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefilebackend.c",
          "lines": "108-147",
          "snippet": "int\nvirStorageFileBackendForType(int type,\n                             int protocol,\n                             bool required,\n                             virStorageFileBackendPtr *backend)\n{\n    size_t i;\n\n    *backend = NULL;\n\n    if (virStorageFileBackendInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStorageFileBackendsCount; i++) {\n        if (virStorageFileBackends[i]->type == type) {\n            if (type == VIR_STORAGE_TYPE_NETWORK &&\n                virStorageFileBackends[i]->protocol != protocol)\n                continue;\n\n            *backend = virStorageFileBackends[i];\n            return 0;\n        }\n    }\n\n    if (!required)\n        return 0;\n\n    if (type == VIR_STORAGE_TYPE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for network files \"\n                         \"using %s protocol\"),\n                       virStorageNetProtocolTypeToString(protocol));\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for '%s' storage\"),\n                       virStorageTypeToString(type));\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virstoragefilebackend.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageFileBackendPtr virStorageFileBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageFileBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virstoragefilebackend.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virStorageFileBackendPtr virStorageFileBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageFileBackendsCount;\n\nint\nvirStorageFileBackendForType(int type,\n                             int protocol,\n                             bool required,\n                             virStorageFileBackendPtr *backend)\n{\n    size_t i;\n\n    *backend = NULL;\n\n    if (virStorageFileBackendInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStorageFileBackendsCount; i++) {\n        if (virStorageFileBackends[i]->type == type) {\n            if (type == VIR_STORAGE_TYPE_NETWORK &&\n                virStorageFileBackends[i]->protocol != protocol)\n                continue;\n\n            *backend = virStorageFileBackends[i];\n            return 0;\n        }\n    }\n\n    if (!required)\n        return 0;\n\n    if (type == VIR_STORAGE_TYPE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for network files \"\n                         \"using %s protocol\"),\n                       virStorageNetProtocolTypeToString(protocol));\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for '%s' storage\"),\n                       virStorageTypeToString(type));\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 4871
        },
        "resolved": true,
        "details": {
          "function_name": "getegid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "78-79",
          "snippet": "static inline int getegid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int getegid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "src->drv"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 4861
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileInitAs(virStorageSourcePtr src,\n                     uid_t uid, gid_t gid)\n{\n    int actualType = virStorageSourceGetActualType(src);\n    if (VIR_ALLOC(src->drv) < 0)\n        return -1;\n\n    if (uid == (uid_t) -1)\n        src->drv->uid = geteuid();\n    else\n        src->drv->uid = uid;\n\n    if (gid == (gid_t) -1)\n        src->drv->gid = getegid();\n    else\n        src->drv->gid = gid;\n\n    if (virStorageFileBackendForType(actualType,\n                                     src->protocol,\n                                     true,\n                                     &src->drv->backend) < 0)\n        goto error;\n\n    if (src->drv->backend->backendInit &&\n        src->drv->backend->backendInit(src) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(src->drv);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageFileDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4830-4841",
    "snippet": "void\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->drv"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->drv->backend->backendDeinit",
          "args": [
            "src"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsInitialized",
          "args": [
            "src"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsInitialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4709-4713",
          "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}"
  },
  {
    "function_name": "virStorageFileSupportsCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4817-4827",
    "snippet": "int\nvirStorageFileSupportsCreate(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileCreate ? 1 : 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileGetBackendForSupportCheck",
          "args": [
            "src",
            "&backend"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetBackendForSupportCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4724-4750",
          "snippet": "static int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsCreate(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileCreate ? 1 : 0;\n}"
  },
  {
    "function_name": "virStorageFileSupportsAccess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4797-4807",
    "snippet": "int\nvirStorageFileSupportsAccess(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileAccess ? 1 : 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileGetBackendForSupportCheck",
          "args": [
            "src",
            "&backend"
          ],
          "line": 4803
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetBackendForSupportCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4724-4750",
          "snippet": "static int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsAccess(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileAccess ? 1 : 0;\n}"
  },
  {
    "function_name": "virStorageFileSupportsSecurityDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4776-4786",
    "snippet": "int\nvirStorageFileSupportsSecurityDriver(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileChown ? 1 : 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileGetBackendForSupportCheck",
          "args": [
            "src",
            "&backend"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetBackendForSupportCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4724-4750",
          "snippet": "static int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsSecurityDriver(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileChown ? 1 : 0;\n}"
  },
  {
    "function_name": "virStorageFileSupportsBackingChainTraversal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4753-4765",
    "snippet": "int\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileGetBackendForSupportCheck",
          "args": [
            "src",
            "&backend"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetBackendForSupportCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4724-4750",
          "snippet": "static int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsBackingChainTraversal(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileGetUniqueIdentifier &&\n           backend->storageFileRead &&\n           backend->storageFileAccess ? 1 : 0;\n}"
  },
  {
    "function_name": "virStorageFileGetBackendForSupportCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4724-4750",
    "snippet": "static int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileBackendForType",
          "args": [
            "actualType",
            "src->protocol",
            "false",
            "backend"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileBackendForType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefilebackend.c",
          "lines": "108-147",
          "snippet": "int\nvirStorageFileBackendForType(int type,\n                             int protocol,\n                             bool required,\n                             virStorageFileBackendPtr *backend)\n{\n    size_t i;\n\n    *backend = NULL;\n\n    if (virStorageFileBackendInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStorageFileBackendsCount; i++) {\n        if (virStorageFileBackends[i]->type == type) {\n            if (type == VIR_STORAGE_TYPE_NETWORK &&\n                virStorageFileBackends[i]->protocol != protocol)\n                continue;\n\n            *backend = virStorageFileBackends[i];\n            return 0;\n        }\n    }\n\n    if (!required)\n        return 0;\n\n    if (type == VIR_STORAGE_TYPE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for network files \"\n                         \"using %s protocol\"),\n                       virStorageNetProtocolTypeToString(protocol));\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for '%s' storage\"),\n                       virStorageTypeToString(type));\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virstoragefilebackend.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageFileBackendPtr virStorageFileBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageFileBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virstoragefilebackend.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virStorageFileBackendPtr virStorageFileBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageFileBackendsCount;\n\nint\nvirStorageFileBackendForType(int type,\n                             int protocol,\n                             bool required,\n                             virStorageFileBackendPtr *backend)\n{\n    size_t i;\n\n    *backend = NULL;\n\n    if (virStorageFileBackendInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStorageFileBackendsCount; i++) {\n        if (virStorageFileBackends[i]->type == type) {\n            if (type == VIR_STORAGE_TYPE_NETWORK &&\n                virStorageFileBackends[i]->protocol != protocol)\n                continue;\n\n            *backend = virStorageFileBackends[i];\n            return 0;\n        }\n    }\n\n    if (!required)\n        return 0;\n\n    if (type == VIR_STORAGE_TYPE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for network files \"\n                         \"using %s protocol\"),\n                       virStorageNetProtocolTypeToString(protocol));\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing storage backend for '%s' storage\"),\n                       virStorageTypeToString(type));\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetBackendForSupportCheck(const virStorageSource *src,\n                                        virStorageFileBackendPtr *backend)\n{\n    int actualType;\n\n\n    if (!src) {\n        *backend = NULL;\n        return 0;\n    }\n\n    if (src->drv) {\n        *backend = src->drv->backend;\n        return 1;\n    }\n\n    actualType = virStorageSourceGetActualType(src);\n\n    if (virStorageFileBackendForType(actualType, src->protocol, false, backend) < 0)\n        return -1;\n\n    if (!*backend)\n        return 0;\n\n    return 1;\n}"
  },
  {
    "function_name": "virStorageFileIsInitialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4709-4713",
    "snippet": "static bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageFileIsInitialized(const virStorageSource *src)\n{\n    return src && src->drv;\n}"
  },
  {
    "function_name": "virStorageSourceInitiatorClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4703-4707",
    "snippet": "void\nvirStorageSourceInitiatorClear(virStorageSourceInitiatorDefPtr initiator)\n{\n    VIR_FREE(initiator->iqn);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "initiator->iqn"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceInitiatorClear(virStorageSourceInitiatorDefPtr initiator)\n{\n    VIR_FREE(initiator->iqn);\n}"
  },
  {
    "function_name": "virStorageSourceInitiatorCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4695-4701",
    "snippet": "int\nvirStorageSourceInitiatorCopy(virStorageSourceInitiatorDefPtr dest,\n                              const virStorageSourceInitiatorDef *src)\n{\n    dest->iqn = g_strdup(src->iqn);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->iqn"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceInitiatorCopy(virStorageSourceInitiatorDefPtr dest,\n                              const virStorageSourceInitiatorDef *src)\n{\n    dest->iqn = g_strdup(src->iqn);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceInitiatorFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4681-4693",
    "snippet": "void\nvirStorageSourceInitiatorFormatXML(virStorageSourceInitiatorDefPtr initiator,\n                                   virBufferPtr buf)\n{\n    if (!initiator->iqn)\n        return;\n\n    virBufferAddLit(buf, \"<initiator>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<iqn name='%s'/>\\n\", initiator->iqn);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</initiator>\\n\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</initiator>\\n\""
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<iqn name='%s'/>\\n\"",
            "initiator->iqn"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<initiator>\\n\""
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceInitiatorFormatXML(virStorageSourceInitiatorDefPtr initiator,\n                                   virBufferPtr buf)\n{\n    if (!initiator->iqn)\n        return;\n\n    virBufferAddLit(buf, \"<initiator>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<iqn name='%s'/>\\n\", initiator->iqn);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</initiator>\\n\");\n}"
  },
  {
    "function_name": "virStorageSourceInitiatorParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4674-4679",
    "snippet": "void\nvirStorageSourceInitiatorParseXML(xmlXPathContextPtr ctxt,\n                                  virStorageSourceInitiatorDefPtr initiator)\n{\n    initiator->iqn = virXPathString(\"string(./initiator/iqn/@name)\", ctxt);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./initiator/iqn/@name)\"",
            "ctxt"
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceInitiatorParseXML(xmlXPathContextPtr ctxt,\n                                  virStorageSourceInitiatorDefPtr initiator)\n{\n    initiator->iqn = virXPathString(\"string(./initiator/iqn/@name)\", ctxt);\n}"
  },
  {
    "function_name": "virStorageSourcePrivateDataFormatRelPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4664-4672",
    "snippet": "int\nvirStorageSourcePrivateDataFormatRelPath(virStorageSourcePtr src,\n                                         virBufferPtr buf)\n{\n    if (src->relPath)\n        virBufferEscapeString(buf, \"<relPath>%s</relPath>\\n\", src->relPath);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<relPath>%s</relPath>\\n\"",
            "src->relPath"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourcePrivateDataFormatRelPath(virStorageSourcePtr src,\n                                         virBufferPtr buf)\n{\n    if (src->relPath)\n        virBufferEscapeString(buf, \"<relPath>%s</relPath>\\n\", src->relPath);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourcePrivateDataParseRelPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4655-4661",
    "snippet": "int\nvirStorageSourcePrivateDataParseRelPath(xmlXPathContextPtr ctxt,\n                                        virStorageSourcePtr src)\n{\n    src->relPath = virXPathString(\"string(./relPath)\", ctxt);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./relPath)\"",
            "ctxt"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourcePrivateDataParseRelPath(xmlXPathContextPtr ctxt,\n                                        virStorageSourcePtr src)\n{\n    src->relPath = virXPathString(\"string(./relPath)\", ctxt);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceNetworkAssignDefaultPorts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4642-4652",
    "snippet": "void\nvirStorageSourceNetworkAssignDefaultPorts(virStorageSourcePtr src)\n{\n    size_t i;\n\n    for (i = 0; i < src->nhosts; i++) {\n        if (src->hosts[i].transport == VIR_STORAGE_NET_HOST_TRANS_TCP &&\n            src->hosts[i].port == 0)\n            src->hosts[i].port = virStorageSourceNetworkDefaultPort(src->protocol);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceNetworkDefaultPort",
          "args": [
            "src->protocol"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNetworkDefaultPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4592-4639",
          "snippet": "static unsigned int\nvirStorageSourceNetworkDefaultPort(virStorageNetProtocol protocol)\n{\n    switch (protocol) {\n        case VIR_STORAGE_NET_PROTOCOL_HTTP:\n            return 80;\n\n        case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n            return 443;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTP:\n            return 21;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTPS:\n            return 990;\n\n        case VIR_STORAGE_NET_PROTOCOL_TFTP:\n            return 69;\n\n        case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n            return 7000;\n\n        case VIR_STORAGE_NET_PROTOCOL_NBD:\n            return 10809;\n\n        case VIR_STORAGE_NET_PROTOCOL_SSH:\n            return 22;\n\n        case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n            return 3260;\n\n        case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n            return 24007;\n\n        case VIR_STORAGE_NET_PROTOCOL_RBD:\n            /* we don't provide a default for RBD */\n            return 0;\n\n        case VIR_STORAGE_NET_PROTOCOL_VXHS:\n            return 9999;\n\n        case VIR_STORAGE_NET_PROTOCOL_LAST:\n        case VIR_STORAGE_NET_PROTOCOL_NONE:\n            return 0;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic unsigned int\nvirStorageSourceNetworkDefaultPort(virStorageNetProtocol protocol)\n{\n    switch (protocol) {\n        case VIR_STORAGE_NET_PROTOCOL_HTTP:\n            return 80;\n\n        case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n            return 443;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTP:\n            return 21;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTPS:\n            return 990;\n\n        case VIR_STORAGE_NET_PROTOCOL_TFTP:\n            return 69;\n\n        case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n            return 7000;\n\n        case VIR_STORAGE_NET_PROTOCOL_NBD:\n            return 10809;\n\n        case VIR_STORAGE_NET_PROTOCOL_SSH:\n            return 22;\n\n        case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n            return 3260;\n\n        case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n            return 24007;\n\n        case VIR_STORAGE_NET_PROTOCOL_RBD:\n            /* we don't provide a default for RBD */\n            return 0;\n\n        case VIR_STORAGE_NET_PROTOCOL_VXHS:\n            return 9999;\n\n        case VIR_STORAGE_NET_PROTOCOL_LAST:\n        case VIR_STORAGE_NET_PROTOCOL_NONE:\n            return 0;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageSourceNetworkAssignDefaultPorts(virStorageSourcePtr src)\n{\n    size_t i;\n\n    for (i = 0; i < src->nhosts; i++) {\n        if (src->hosts[i].transport == VIR_STORAGE_NET_HOST_TRANS_TCP &&\n            src->hosts[i].port == 0)\n            src->hosts[i].port = virStorageSourceNetworkDefaultPort(src->protocol);\n    }\n}"
  },
  {
    "function_name": "virStorageSourceNetworkDefaultPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4592-4639",
    "snippet": "static unsigned int\nvirStorageSourceNetworkDefaultPort(virStorageNetProtocol protocol)\n{\n    switch (protocol) {\n        case VIR_STORAGE_NET_PROTOCOL_HTTP:\n            return 80;\n\n        case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n            return 443;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTP:\n            return 21;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTPS:\n            return 990;\n\n        case VIR_STORAGE_NET_PROTOCOL_TFTP:\n            return 69;\n\n        case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n            return 7000;\n\n        case VIR_STORAGE_NET_PROTOCOL_NBD:\n            return 10809;\n\n        case VIR_STORAGE_NET_PROTOCOL_SSH:\n            return 22;\n\n        case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n            return 3260;\n\n        case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n            return 24007;\n\n        case VIR_STORAGE_NET_PROTOCOL_RBD:\n            /* we don't provide a default for RBD */\n            return 0;\n\n        case VIR_STORAGE_NET_PROTOCOL_VXHS:\n            return 9999;\n\n        case VIR_STORAGE_NET_PROTOCOL_LAST:\n        case VIR_STORAGE_NET_PROTOCOL_NONE:\n            return 0;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic unsigned int\nvirStorageSourceNetworkDefaultPort(virStorageNetProtocol protocol)\n{\n    switch (protocol) {\n        case VIR_STORAGE_NET_PROTOCOL_HTTP:\n            return 80;\n\n        case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n            return 443;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTP:\n            return 21;\n\n        case VIR_STORAGE_NET_PROTOCOL_FTPS:\n            return 990;\n\n        case VIR_STORAGE_NET_PROTOCOL_TFTP:\n            return 69;\n\n        case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n            return 7000;\n\n        case VIR_STORAGE_NET_PROTOCOL_NBD:\n            return 10809;\n\n        case VIR_STORAGE_NET_PROTOCOL_SSH:\n            return 22;\n\n        case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n            return 3260;\n\n        case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n            return 24007;\n\n        case VIR_STORAGE_NET_PROTOCOL_RBD:\n            /* we don't provide a default for RBD */\n            return 0;\n\n        case VIR_STORAGE_NET_PROTOCOL_VXHS:\n            return 9999;\n\n        case VIR_STORAGE_NET_PROTOCOL_LAST:\n        case VIR_STORAGE_NET_PROTOCOL_NONE:\n            return 0;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceFindByNodeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4567-4589",
    "snippet": "virStorageSourcePtr\nvirStorageSourceFindByNodeName(virStorageSourcePtr top,\n                               const char *nodeName,\n                               unsigned int *idx)\n{\n    virStorageSourcePtr tmp;\n\n    if (idx)\n        *idx = 0;\n\n    for (tmp = top; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if ((tmp->nodeformat && STREQ(tmp->nodeformat, nodeName)) ||\n            (tmp->nodestorage && STREQ(tmp->nodestorage, nodeName)))\n            return tmp;\n\n        if (idx)\n            (*idx)++;\n    }\n\n    if (idx)\n        *idx = 0;\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp->nodestorage",
            "nodeName"
          ],
          "line": 4579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp->nodeformat",
            "nodeName"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "tmp"
          ],
          "line": 4577
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageSourcePtr\nvirStorageSourceFindByNodeName(virStorageSourcePtr top,\n                               const char *nodeName,\n                               unsigned int *idx)\n{\n    virStorageSourcePtr tmp;\n\n    if (idx)\n        *idx = 0;\n\n    for (tmp = top; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if ((tmp->nodeformat && STREQ(tmp->nodeformat, nodeName)) ||\n            (tmp->nodestorage && STREQ(tmp->nodestorage, nodeName)))\n            return tmp;\n\n        if (idx)\n            (*idx)++;\n    }\n\n    if (idx)\n        *idx = 0;\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageSourceIsRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4531-4554",
    "snippet": "bool\nvirStorageSourceIsRelative(virStorageSourcePtr src)\n{\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    if (!src->path)\n        return false;\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return src->path[0] != '/';\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return false;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 4534
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsRelative(virStorageSourcePtr src)\n{\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    if (!src->path)\n        return false;\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return src->path[0] != '/';\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return false;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virStorageFileCheckCompat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4504-4522",
    "snippet": "int\nvirStorageFileCheckCompat(const char *compat)\n{\n    unsigned int result;\n    VIR_AUTOSTRINGLIST version = NULL;\n\n    if (!compat)\n        return 0;\n\n    version = virStringSplit(compat, \".\", 2);\n    if (!version || !version[1] ||\n        virStrToLong_ui(version[0], NULL, 10, &result) < 0 ||\n        virStrToLong_ui(version[1], NULL, 10, &result) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"forbidden characters in 'compat' attribute\"));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"forbidden characters in 'compat' attribute\")"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"forbidden characters in 'compat' attribute\""
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "version[1]",
            "NULL",
            "10",
            "&result"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "compat",
            "\".\"",
            "2"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileCheckCompat(const char *compat)\n{\n    unsigned int result;\n    VIR_AUTOSTRINGLIST version = NULL;\n\n    if (!compat)\n        return 0;\n\n    version = virStringSplit(compat, \".\", 2);\n    if (!version || !version[1] ||\n        virStrToLong_ui(version[0], NULL, 10, &result) < 0 ||\n        virStrToLong_ui(version[1], NULL, 10, &result) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"forbidden characters in 'compat' attribute\"));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetRelativeBackingPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4461-4498",
    "snippet": "int\nvirStorageFileGetRelativeBackingPath(virStorageSourcePtr top,\n                                     virStorageSourcePtr base,\n                                     char **relpath)\n{\n    virStorageSourcePtr next;\n    g_autofree char *tmp = NULL;\n    g_autofree char *path = NULL;\n\n    *relpath = NULL;\n\n    for (next = top; virStorageSourceIsBacking(next); next = next->backingStore) {\n        if (!next->relPath)\n            return 1;\n\n        if (!(tmp = virStorageFileRemoveLastPathComponent(path)))\n            return -1;\n\n        VIR_FREE(path);\n\n        path = g_strdup_printf(\"%s%s\", tmp, next->relPath);\n\n        VIR_FREE(tmp);\n\n        if (next == base)\n            break;\n    }\n\n    if (next != base) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to resolve relative backing name: \"\n                         \"base image is not in backing chain\"));\n        return -1;\n    }\n\n    *relpath = g_steal_pointer(&path);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&path"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to resolve relative backing name: \"\n                         \"base image is not in backing chain\")"
          ],
          "line": 4490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to resolve relative backing name: \"\n                         \"base image is not in backing chain\""
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileRemoveLastPathComponent",
          "args": [
            "path"
          ],
          "line": 4476
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileRemoveLastPathComponent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4440-4450",
          "snippet": "static char *\nvirStorageFileRemoveLastPathComponent(const char *path)\n{\n    char *ret;\n\n    ret = g_strdup(NULLSTR_EMPTY(path));\n\n    virFileRemoveLastComponent(ret);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic char *\nvirStorageFileRemoveLastPathComponent(const char *path)\n{\n    char *ret;\n\n    ret = g_strdup(NULLSTR_EMPTY(path));\n\n    virFileRemoveLastComponent(ret);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "next"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetRelativeBackingPath(virStorageSourcePtr top,\n                                     virStorageSourcePtr base,\n                                     char **relpath)\n{\n    virStorageSourcePtr next;\n    g_autofree char *tmp = NULL;\n    g_autofree char *path = NULL;\n\n    *relpath = NULL;\n\n    for (next = top; virStorageSourceIsBacking(next); next = next->backingStore) {\n        if (!next->relPath)\n            return 1;\n\n        if (!(tmp = virStorageFileRemoveLastPathComponent(path)))\n            return -1;\n\n        VIR_FREE(path);\n\n        path = g_strdup_printf(\"%s%s\", tmp, next->relPath);\n\n        VIR_FREE(tmp);\n\n        if (next == base)\n            break;\n    }\n\n    if (next != base) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to resolve relative backing name: \"\n                         \"base image is not in backing chain\"));\n        return -1;\n    }\n\n    *relpath = g_steal_pointer(&path);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileRemoveLastPathComponent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4440-4450",
    "snippet": "static char *\nvirStorageFileRemoveLastPathComponent(const char *path)\n{\n    char *ret;\n\n    ret = g_strdup(NULLSTR_EMPTY(path));\n\n    virFileRemoveLastComponent(ret);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileRemoveLastComponent",
          "args": [
            "ret"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemoveLastComponent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3319-3328",
          "snippet": "void\nvirFileRemoveLastComponent(char *path)\n{\n    char *tmp;\n\n    if ((tmp = strrchr(path, G_DIR_SEPARATOR)))\n        tmp[1] = '\\0';\n    else\n        path[0] = '\\0';\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirFileRemoveLastComponent(char *path)\n{\n    char *tmp;\n\n    if ((tmp = strrchr(path, G_DIR_SEPARATOR)))\n        tmp[1] = '\\0';\n    else\n        path[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "NULLSTR_EMPTY(path)"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "path"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic char *\nvirStorageFileRemoveLastPathComponent(const char *path)\n{\n    char *ret;\n\n    ret = g_strdup(NULLSTR_EMPTY(path));\n\n    virFileRemoveLastComponent(ret);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileCanonicalizePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4282-4428",
    "snippet": "char *\nvirStorageFileCanonicalizePath(const char *path,\n                               virStorageFileSimplifyPathReadlinkCallback cb,\n                               void *cbdata)\n{\n    virHashTablePtr cycle = NULL;\n    bool beginSlash = false;\n    bool beginDoubleSlash = false;\n    char **components = NULL;\n    size_t ncomponents = 0;\n    size_t i = 0;\n    size_t j = 0;\n    int rc;\n    char *ret = NULL;\n    g_autofree char *linkpath = NULL;\n    g_autofree char *currentpath = NULL;\n\n    if (path[0] == '/') {\n        beginSlash = true;\n\n        if (path[1] == '/' && path[2] != '/')\n            beginDoubleSlash = true;\n    }\n\n    if (!(cycle = virHashCreate(10, NULL)))\n        goto cleanup;\n\n    if (!(components = virStringSplitCount(path, \"/\", 0, &ncomponents)))\n        goto cleanup;\n\n    j = 0;\n    while (j < ncomponents) {\n        /* skip slashes */\n        if (STREQ(components[j], \"\")) {\n            VIR_FREE(components[j]);\n            VIR_DELETE_ELEMENT(components, j, ncomponents);\n            continue;\n        }\n        j++;\n    }\n\n    while (i < ncomponents) {\n        /* skip '.'s unless it's the last one remaining */\n        if (STREQ(components[i], \".\") &&\n            (beginSlash || ncomponents  > 1)) {\n            VIR_FREE(components[i]);\n            VIR_DELETE_ELEMENT(components, i, ncomponents);\n            continue;\n        }\n\n        /* resolve changes to parent directory */\n        if (STREQ(components[i], \"..\")) {\n            if (!beginSlash &&\n                (i == 0 || STREQ(components[i - 1], \"..\"))) {\n                i++;\n                continue;\n            }\n\n            VIR_FREE(components[i]);\n            VIR_DELETE_ELEMENT(components, i, ncomponents);\n\n            if (i != 0) {\n                VIR_FREE(components[i - 1]);\n                VIR_DELETE_ELEMENT(components, i - 1, ncomponents);\n                i--;\n            }\n\n            continue;\n        }\n\n        /* check if the actual path isn't resulting into a symlink */\n        if (!(currentpath = virStorageFileCanonicalizeFormatPath(components,\n                                                                 i + 1,\n                                                                 beginSlash,\n                                                                 beginDoubleSlash)))\n            goto cleanup;\n\n        if ((rc = cb(currentpath, &linkpath, cbdata)) < 0)\n            goto cleanup;\n\n        if (rc == 0) {\n            if (virHashLookup(cycle, currentpath)) {\n                virReportSystemError(ELOOP,\n                                     _(\"Failed to canonicalize path '%s'\"), path);\n                goto cleanup;\n            }\n\n            if (virHashAddEntry(cycle, currentpath, (void *) 1) < 0)\n                goto cleanup;\n\n            if (linkpath[0] == '/') {\n                /* kill everything from the beginning including the actual component */\n                i++;\n                while (i--) {\n                    VIR_FREE(components[0]);\n                    VIR_DELETE_ELEMENT(components, 0, ncomponents);\n                }\n                beginSlash = true;\n\n                if (linkpath[1] == '/' && linkpath[2] != '/')\n                    beginDoubleSlash = true;\n                else\n                    beginDoubleSlash = false;\n\n                i = 0;\n            } else {\n                VIR_FREE(components[i]);\n                VIR_DELETE_ELEMENT(components, i, ncomponents);\n            }\n\n            if (virStorageFileCanonicalizeInjectSymlink(linkpath,\n                                                        i,\n                                                        &components,\n                                                        &ncomponents) < 0)\n                goto cleanup;\n\n            j = 0;\n            while (j < ncomponents) {\n                /* skip slashes */\n                if (STREQ(components[j], \"\")) {\n                    VIR_FREE(components[j]);\n                    VIR_DELETE_ELEMENT(components, j, ncomponents);\n                    continue;\n                }\n                j++;\n            }\n\n            VIR_FREE(linkpath);\n            VIR_FREE(currentpath);\n\n            continue;\n        }\n\n        VIR_FREE(currentpath);\n\n        i++;\n    }\n\n    ret = virStorageFileCanonicalizeFormatPath(components, ncomponents,\n                                               beginSlash, beginDoubleSlash);\n\n cleanup:\n    virHashFree(cycle);\n    virStringListFreeCount(components, ncomponents);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "components",
            "ncomponents"
          ],
          "line": 4425
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "cycle"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileCanonicalizeFormatPath",
          "args": [
            "components",
            "ncomponents",
            "beginSlash",
            "beginDoubleSlash"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileCanonicalizeFormatPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4221-4249",
          "snippet": "static char *\nvirStorageFileCanonicalizeFormatPath(char **components,\n                                     size_t ncomponents,\n                                     bool beginSlash,\n                                     bool beginDoubleSlash)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    char *ret = NULL;\n\n    if (beginSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    if (beginDoubleSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    for (i = 0; i < ncomponents; i++) {\n        if (i != 0)\n            virBufferAddLit(&buf, \"/\");\n\n        virBufferAdd(&buf, components[i], -1);\n    }\n\n    /* if the output string is empty just return an empty string */\n    if (!(ret = virBufferContentAndReset(&buf)))\n        ret = g_strdup(\"\");\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic char *\nvirStorageFileCanonicalizeFormatPath(char **components,\n                                     size_t ncomponents,\n                                     bool beginSlash,\n                                     bool beginDoubleSlash)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    char *ret = NULL;\n\n    if (beginSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    if (beginDoubleSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    for (i = 0; i < ncomponents; i++) {\n        if (i != 0)\n            virBufferAddLit(&buf, \"/\");\n\n        virBufferAdd(&buf, components[i], -1);\n    }\n\n    /* if the output string is empty just return an empty string */\n    if (!(ret = virBufferContentAndReset(&buf)))\n        ret = g_strdup(\"\");\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentpath"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentpath"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "linkpath"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "j",
            "ncomponents"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[j]"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "components[j]",
            "\"\""
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileCanonicalizeInjectSymlink",
          "args": [
            "linkpath",
            "i",
            "&components",
            "&ncomponents"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileCanonicalizeInjectSymlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4252-4279",
          "snippet": "static int\nvirStorageFileCanonicalizeInjectSymlink(const char *path,\n                                        size_t at,\n                                        char ***components,\n                                        size_t *ncomponents)\n{\n    char **tmp = NULL;\n    char **next;\n    size_t ntmp = 0;\n    int ret = -1;\n\n    if (!(tmp = virStringSplitCount(path, \"/\", 0, &ntmp)))\n        goto cleanup;\n\n    /* prepend */\n    for (next = tmp; *next; next++) {\n        if (VIR_INSERT_ELEMENT(*components, at, *ncomponents, *next) < 0)\n            goto cleanup;\n\n        at++;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFreeCount(tmp, ntmp);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileCanonicalizeInjectSymlink(const char *path,\n                                        size_t at,\n                                        char ***components,\n                                        size_t *ncomponents)\n{\n    char **tmp = NULL;\n    char **next;\n    size_t ntmp = 0;\n    int ret = -1;\n\n    if (!(tmp = virStringSplitCount(path, \"/\", 0, &ntmp)))\n        goto cleanup;\n\n    /* prepend */\n    for (next = tmp; *next; next++) {\n        if (VIR_INSERT_ELEMENT(*components, at, *ncomponents, *next) < 0)\n            goto cleanup;\n\n        at++;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFreeCount(tmp, ntmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "i",
            "ncomponents"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[i]"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "0",
            "ncomponents"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[0]"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "cycle",
            "currentpath",
            "(void *) 1"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ELOOP",
            "_(\"Failed to canonicalize path '%s'\")",
            "path"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to canonicalize path '%s'\""
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "cycle",
            "currentpath"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "currentpath",
            "&linkpath",
            "cbdata"
          ],
          "line": 4359
        },
        "resolved": true,
        "details": {
          "function_name": "file_iterate_pci_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "855-861",
          "snippet": "static int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "i - 1",
            "ncomponents"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[i - 1]"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "i",
            "ncomponents"
          ],
          "line": 4341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[i]"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "components[i - 1]",
            "\"..\""
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "components[i]",
            "\"..\""
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "i",
            "ncomponents"
          ],
          "line": 4328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[i]"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "components[i]",
            "\".\""
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "components",
            "j",
            "ncomponents"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "components[j]"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "components[j]",
            "\"\""
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "path",
            "\"/\"",
            "0",
            "&ncomponents"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "NULL"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nchar *\nvirStorageFileCanonicalizePath(const char *path,\n                               virStorageFileSimplifyPathReadlinkCallback cb,\n                               void *cbdata)\n{\n    virHashTablePtr cycle = NULL;\n    bool beginSlash = false;\n    bool beginDoubleSlash = false;\n    char **components = NULL;\n    size_t ncomponents = 0;\n    size_t i = 0;\n    size_t j = 0;\n    int rc;\n    char *ret = NULL;\n    g_autofree char *linkpath = NULL;\n    g_autofree char *currentpath = NULL;\n\n    if (path[0] == '/') {\n        beginSlash = true;\n\n        if (path[1] == '/' && path[2] != '/')\n            beginDoubleSlash = true;\n    }\n\n    if (!(cycle = virHashCreate(10, NULL)))\n        goto cleanup;\n\n    if (!(components = virStringSplitCount(path, \"/\", 0, &ncomponents)))\n        goto cleanup;\n\n    j = 0;\n    while (j < ncomponents) {\n        /* skip slashes */\n        if (STREQ(components[j], \"\")) {\n            VIR_FREE(components[j]);\n            VIR_DELETE_ELEMENT(components, j, ncomponents);\n            continue;\n        }\n        j++;\n    }\n\n    while (i < ncomponents) {\n        /* skip '.'s unless it's the last one remaining */\n        if (STREQ(components[i], \".\") &&\n            (beginSlash || ncomponents  > 1)) {\n            VIR_FREE(components[i]);\n            VIR_DELETE_ELEMENT(components, i, ncomponents);\n            continue;\n        }\n\n        /* resolve changes to parent directory */\n        if (STREQ(components[i], \"..\")) {\n            if (!beginSlash &&\n                (i == 0 || STREQ(components[i - 1], \"..\"))) {\n                i++;\n                continue;\n            }\n\n            VIR_FREE(components[i]);\n            VIR_DELETE_ELEMENT(components, i, ncomponents);\n\n            if (i != 0) {\n                VIR_FREE(components[i - 1]);\n                VIR_DELETE_ELEMENT(components, i - 1, ncomponents);\n                i--;\n            }\n\n            continue;\n        }\n\n        /* check if the actual path isn't resulting into a symlink */\n        if (!(currentpath = virStorageFileCanonicalizeFormatPath(components,\n                                                                 i + 1,\n                                                                 beginSlash,\n                                                                 beginDoubleSlash)))\n            goto cleanup;\n\n        if ((rc = cb(currentpath, &linkpath, cbdata)) < 0)\n            goto cleanup;\n\n        if (rc == 0) {\n            if (virHashLookup(cycle, currentpath)) {\n                virReportSystemError(ELOOP,\n                                     _(\"Failed to canonicalize path '%s'\"), path);\n                goto cleanup;\n            }\n\n            if (virHashAddEntry(cycle, currentpath, (void *) 1) < 0)\n                goto cleanup;\n\n            if (linkpath[0] == '/') {\n                /* kill everything from the beginning including the actual component */\n                i++;\n                while (i--) {\n                    VIR_FREE(components[0]);\n                    VIR_DELETE_ELEMENT(components, 0, ncomponents);\n                }\n                beginSlash = true;\n\n                if (linkpath[1] == '/' && linkpath[2] != '/')\n                    beginDoubleSlash = true;\n                else\n                    beginDoubleSlash = false;\n\n                i = 0;\n            } else {\n                VIR_FREE(components[i]);\n                VIR_DELETE_ELEMENT(components, i, ncomponents);\n            }\n\n            if (virStorageFileCanonicalizeInjectSymlink(linkpath,\n                                                        i,\n                                                        &components,\n                                                        &ncomponents) < 0)\n                goto cleanup;\n\n            j = 0;\n            while (j < ncomponents) {\n                /* skip slashes */\n                if (STREQ(components[j], \"\")) {\n                    VIR_FREE(components[j]);\n                    VIR_DELETE_ELEMENT(components, j, ncomponents);\n                    continue;\n                }\n                j++;\n            }\n\n            VIR_FREE(linkpath);\n            VIR_FREE(currentpath);\n\n            continue;\n        }\n\n        VIR_FREE(currentpath);\n\n        i++;\n    }\n\n    ret = virStorageFileCanonicalizeFormatPath(components, ncomponents,\n                                               beginSlash, beginDoubleSlash);\n\n cleanup:\n    virHashFree(cycle);\n    virStringListFreeCount(components, ncomponents);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileCanonicalizeInjectSymlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4252-4279",
    "snippet": "static int\nvirStorageFileCanonicalizeInjectSymlink(const char *path,\n                                        size_t at,\n                                        char ***components,\n                                        size_t *ncomponents)\n{\n    char **tmp = NULL;\n    char **next;\n    size_t ntmp = 0;\n    int ret = -1;\n\n    if (!(tmp = virStringSplitCount(path, \"/\", 0, &ntmp)))\n        goto cleanup;\n\n    /* prepend */\n    for (next = tmp; *next; next++) {\n        if (VIR_INSERT_ELEMENT(*components, at, *ncomponents, *next) < 0)\n            goto cleanup;\n\n        at++;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFreeCount(tmp, ntmp);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "tmp",
            "ntmp"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "*components",
            "at",
            "*ncomponents",
            "*next"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "path",
            "\"/\"",
            "0",
            "&ntmp"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageFileCanonicalizeInjectSymlink(const char *path,\n                                        size_t at,\n                                        char ***components,\n                                        size_t *ncomponents)\n{\n    char **tmp = NULL;\n    char **next;\n    size_t ntmp = 0;\n    int ret = -1;\n\n    if (!(tmp = virStringSplitCount(path, \"/\", 0, &ntmp)))\n        goto cleanup;\n\n    /* prepend */\n    for (next = tmp; *next; next++) {\n        if (VIR_INSERT_ELEMENT(*components, at, *ncomponents, *next) < 0)\n            goto cleanup;\n\n        at++;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFreeCount(tmp, ntmp);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileCanonicalizeFormatPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4221-4249",
    "snippet": "static char *\nvirStorageFileCanonicalizeFormatPath(char **components,\n                                     size_t ncomponents,\n                                     bool beginSlash,\n                                     bool beginDoubleSlash)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    char *ret = NULL;\n\n    if (beginSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    if (beginDoubleSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    for (i = 0; i < ncomponents; i++) {\n        if (i != 0)\n            virBufferAddLit(&buf, \"/\");\n\n        virBufferAdd(&buf, components[i], -1);\n    }\n\n    /* if the output string is empty just return an empty string */\n    if (!(ret = virBufferContentAndReset(&buf)))\n        ret = g_strdup(\"\");\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"\""
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "components[i]",
            "-1"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"/\""
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"/\""
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"/\""
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic char *\nvirStorageFileCanonicalizeFormatPath(char **components,\n                                     size_t ncomponents,\n                                     bool beginSlash,\n                                     bool beginDoubleSlash)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    char *ret = NULL;\n\n    if (beginSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    if (beginDoubleSlash)\n        virBufferAddLit(&buf, \"/\");\n\n    for (i = 0; i < ncomponents; i++) {\n        if (i != 0)\n            virBufferAddLit(&buf, \"/\");\n\n        virBufferAdd(&buf, components[i], -1);\n    }\n\n    /* if the output string is empty just return an empty string */\n    if (!(ret = virBufferContentAndReset(&buf)))\n        ret = g_strdup(\"\");\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageSourceUpdateCapacity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4185-4218",
    "snippet": "int\nvirStorageSourceUpdateCapacity(virStorageSourcePtr src,\n                               char *buf,\n                               ssize_t len)\n{\n    int format = src->format;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    /* Raw files: capacity is physical size.  For all other files: if\n     * the metadata has a capacity, use that, otherwise fall back to\n     * physical size.  */\n    if (format == VIR_STORAGE_FILE_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no disk format for %s was specified\"),\n                       src->path);\n        return -1;\n    }\n\n    if (format == VIR_STORAGE_FILE_RAW && !src->encryption) {\n        src->capacity = src->physical;\n    } else if ((meta = virStorageFileGetMetadataFromBuf(src->path, buf,\n                                                        len, format))) {\n        src->capacity = meta->capacity ? meta->capacity : src->physical;\n        if (src->encryption && meta->encryption)\n            src->encryption->payload_offset = meta->encryption->payload_offset;\n    } else {\n        return -1;\n    }\n\n    if (src->encryption && src->encryption->payload_offset != -1)\n        src->capacity -= src->encryption->payload_offset * 512;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataFromBuf",
          "args": [
            "src->path",
            "buf",
            "len",
            "format"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataFromBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1128-1145",
          "snippet": "virStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no disk format for %s was specified\")",
            "src->path"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no disk format for %s was specified\""
          ],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nint\nvirStorageSourceUpdateCapacity(virStorageSourcePtr src,\n                               char *buf,\n                               ssize_t len)\n{\n    int format = src->format;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    /* Raw files: capacity is physical size.  For all other files: if\n     * the metadata has a capacity, use that, otherwise fall back to\n     * physical size.  */\n    if (format == VIR_STORAGE_FILE_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no disk format for %s was specified\"),\n                       src->path);\n        return -1;\n    }\n\n    if (format == VIR_STORAGE_FILE_RAW && !src->encryption) {\n        src->capacity = src->physical;\n    } else if ((meta = virStorageFileGetMetadataFromBuf(src->path, buf,\n                                                        len, format))) {\n        src->capacity = meta->capacity ? meta->capacity : src->physical;\n        if (src->encryption && meta->encryption)\n            src->encryption->payload_offset = meta->encryption->payload_offset;\n    } else {\n        return -1;\n    }\n\n    if (src->encryption && src->encryption->payload_offset != -1)\n        src->capacity -= src->encryption->payload_offset * 512;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceUpdateBackingSizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4122-4173",
    "snippet": "int\nvirStorageSourceUpdateBackingSizes(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    /* Get info for normal formats */\n    if (S_ISREG(sb->st_mode) || fd == -1) {\n#ifndef WIN32\n        src->allocation = (unsigned long long)sb->st_blocks *\n            (unsigned long long)DEV_BSIZE;\n#else\n        src->allocation = sb->st_size;\n#endif\n        /* Regular files may be sparse, so logical size (capacity) is not same\n         * as actual allocation above\n         */\n        src->capacity = sb->st_size;\n\n        /* Allocation tracks when the file is sparse, physical is the\n         * last offset of the file. */\n        src->physical = sb->st_size;\n    } else if (S_ISDIR(sb->st_mode)) {\n        src->allocation = 0;\n        src->capacity = 0;\n        src->physical = 0;\n    } else if (fd >= 0) {\n        off_t end;\n\n        /* XXX this is POSIX compliant, but doesn't work for CHAR files,\n         * only BLOCK. There is a Linux specific ioctl() for getting\n         * size of both CHAR / BLOCK devices we should check for in\n         * configure\n         *\n         * NB. Because we configure with AC_SYS_LARGEFILE, off_t\n         * should be 64 bits on all platforms.  For block devices, we\n         * have to seek (safe even if someone else is writing) to\n         * determine physical size, and assume that allocation is the\n         * same as physical (but can refine that assumption later if\n         * qemu is still running).\n         */\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t)-1) {\n            virReportSystemError(errno,\n                                 _(\"failed to seek to end of %s\"), src->path);\n            return -1;\n        }\n        src->physical = end;\n        src->allocation = end;\n        src->capacity = end;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to seek to end of %s\")",
            "src->path"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to seek to end of %s\""
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_END"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb->st_mode"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb->st_mode"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceUpdateBackingSizes(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    /* Get info for normal formats */\n    if (S_ISREG(sb->st_mode) || fd == -1) {\n#ifndef WIN32\n        src->allocation = (unsigned long long)sb->st_blocks *\n            (unsigned long long)DEV_BSIZE;\n#else\n        src->allocation = sb->st_size;\n#endif\n        /* Regular files may be sparse, so logical size (capacity) is not same\n         * as actual allocation above\n         */\n        src->capacity = sb->st_size;\n\n        /* Allocation tracks when the file is sparse, physical is the\n         * last offset of the file. */\n        src->physical = sb->st_size;\n    } else if (S_ISDIR(sb->st_mode)) {\n        src->allocation = 0;\n        src->capacity = 0;\n        src->physical = 0;\n    } else if (fd >= 0) {\n        off_t end;\n\n        /* XXX this is POSIX compliant, but doesn't work for CHAR files,\n         * only BLOCK. There is a Linux specific ioctl() for getting\n         * size of both CHAR / BLOCK devices we should check for in\n         * configure\n         *\n         * NB. Because we configure with AC_SYS_LARGEFILE, off_t\n         * should be 64 bits on all platforms.  For block devices, we\n         * have to seek (safe even if someone else is writing) to\n         * determine physical size, and assume that allocation is the\n         * same as physical (but can refine that assumption later if\n         * qemu is still running).\n         */\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t)-1) {\n            virReportSystemError(errno,\n                                 _(\"failed to seek to end of %s\"), src->path);\n            return -1;\n        }\n        src->physical = end;\n        src->allocation = end;\n        src->capacity = end;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceUpdatePhysicalSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4074-4108",
    "snippet": "int\nvirStorageSourceUpdatePhysicalSize(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    off_t end;\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_NETWORK:\n        src->physical = sb->st_size;\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t) -1)\n            return -1;\n\n        src->physical = end;\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        src->physical = 0;\n        break;\n\n    /* We shouldn't get VOLUME, but the switch requires all cases */\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_END"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 4080
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceUpdatePhysicalSize(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    off_t end;\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_NETWORK:\n        src->physical = sb->st_size;\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t) -1)\n            return -1;\n\n        src->physical = end;\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        src->physical = 0;\n        break;\n\n    /* We shouldn't get VOLUME, but the switch requires all cases */\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceNewFromExternalData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4045-4060",
    "snippet": "static int\nvirStorageSourceNewFromExternalData(virStorageSourcePtr parent,\n                                    virStorageSourcePtr *externalDataStore)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->externalDataStoreRaw,\n                                           externalDataStore)) < 0)\n        return rc;\n\n    /* qcow2 data_file can only be raw */\n    (*externalDataStore)->format = VIR_STORAGE_FILE_RAW;\n    (*externalDataStore)->readonly = parent->readonly;\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceNewFromChild",
          "args": [
            "parent",
            "parent->externalDataStoreRaw",
            "externalDataStore"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3986-4025",
          "snippet": "static int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceNewFromExternalData(virStorageSourcePtr parent,\n                                    virStorageSourcePtr *externalDataStore)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->externalDataStoreRaw,\n                                           externalDataStore)) < 0)\n        return rc;\n\n    /* qcow2 data_file can only be raw */\n    (*externalDataStore)->format = VIR_STORAGE_FILE_RAW;\n    (*externalDataStore)->readonly = parent->readonly;\n    return rc;\n}"
  },
  {
    "function_name": "virStorageSourceNewFromBacking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "4028-4042",
    "snippet": "int\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceNewFromChild",
          "args": [
            "parent",
            "parent->backingStoreRaw",
            "backing"
          ],
          "line": 4034
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3986-4025",
          "snippet": "static int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}"
  },
  {
    "function_name": "virStorageSourceNewFromChild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3986-4025",
    "snippet": "static int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceInitChainElement",
          "args": [
            "def",
            "parent",
            "true"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceInitChainElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2536-2550",
          "snippet": "int\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "st.st_mode"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "def->path",
            "&st"
          ],
          "line": 4007
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNewFromBackingAbsolute",
          "args": [
            "parentRaw",
            "&def"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromBackingAbsolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3920-3966",
          "snippet": "int\nvirStorageSourceNewFromBackingAbsolute(const char *path,\n                                       virStorageSourcePtr *src)\n{\n    const char *json;\n    int rc = 0;\n    g_autoptr(virStorageSource) def = NULL;\n\n    *src = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return -1;\n\n    if (virStorageIsFile(path)) {\n        def->type = VIR_STORAGE_TYPE_FILE;\n\n        def->path = g_strdup(path);\n    } else {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        VIR_DEBUG(\"parsing backing store string: '%s'\", path);\n\n        /* handle URI formatted backing stores */\n        if ((json = STRSKIP(path, \"json:\")))\n            rc = virStorageSourceParseBackingJSON(def, json);\n        else if (strstr(path, \"://\"))\n            rc = virStorageSourceParseBackingURI(def, path);\n        else\n            rc = virStorageSourceParseBackingColon(def, path);\n\n        if (rc < 0)\n            return -1;\n\n        virStorageSourceNetworkAssignDefaultPorts(def);\n\n        /* Some of the legacy parsers parse authentication data since they are\n         * also used in other places. For backing store detection the\n         * authentication data would be invalid anyways, so we clear it */\n        if (def->auth) {\n            virStorageAuthDefFree(def->auth);\n            def->auth = NULL;\n        }\n    }\n\n    *src = g_steal_pointer(&def);\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceNewFromBackingAbsolute(const char *path,\n                                       virStorageSourcePtr *src)\n{\n    const char *json;\n    int rc = 0;\n    g_autoptr(virStorageSource) def = NULL;\n\n    *src = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return -1;\n\n    if (virStorageIsFile(path)) {\n        def->type = VIR_STORAGE_TYPE_FILE;\n\n        def->path = g_strdup(path);\n    } else {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        VIR_DEBUG(\"parsing backing store string: '%s'\", path);\n\n        /* handle URI formatted backing stores */\n        if ((json = STRSKIP(path, \"json:\")))\n            rc = virStorageSourceParseBackingJSON(def, json);\n        else if (strstr(path, \"://\"))\n            rc = virStorageSourceParseBackingURI(def, path);\n        else\n            rc = virStorageSourceParseBackingColon(def, path);\n\n        if (rc < 0)\n            return -1;\n\n        virStorageSourceNetworkAssignDefaultPorts(def);\n\n        /* Some of the legacy parsers parse authentication data since they are\n         * also used in other places. For backing store detection the\n         * authentication data would be invalid anyways, so we clear it */\n        if (def->auth) {\n            virStorageAuthDefFree(def->auth);\n            def->auth = NULL;\n        }\n    }\n\n    *src = g_steal_pointer(&def);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNewFromBackingRelative",
          "args": [
            "parent",
            "parentRaw"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromBackingRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2754-2795",
          "snippet": "static virStorageSourcePtr\nvirStorageSourceNewFromBackingRelative(virStorageSourcePtr parent,\n                                       const char *rel)\n{\n    g_autofree char *dirname = NULL;\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    /* store relative name */\n    def->relPath = g_strdup(rel);\n\n    dirname = g_path_get_dirname(parent->path);\n\n    if (STRNEQ(dirname, \"/\")) {\n        def->path = g_strdup_printf(\"%s/%s\", dirname, rel);\n    } else {\n        def->path = g_strdup_printf(\"/%s\", rel);\n    }\n\n    if (virStorageSourceGetActualType(parent) == VIR_STORAGE_TYPE_NETWORK) {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        /* copy the host network part */\n        def->protocol = parent->protocol;\n        if (parent->nhosts) {\n            if (!(def->hosts = virStorageNetHostDefCopy(parent->nhosts,\n                                                        parent->hosts)))\n                return NULL;\n\n            def->nhosts = parent->nhosts;\n        }\n\n        def->volume = g_strdup(parent->volume);\n    } else {\n        /* set the type to _FILE, the caller shall update it to the actual type */\n        def->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePtr\nvirStorageSourceNewFromBackingRelative(virStorageSourcePtr parent,\n                                       const char *rel)\n{\n    g_autofree char *dirname = NULL;\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    /* store relative name */\n    def->relPath = g_strdup(rel);\n\n    dirname = g_path_get_dirname(parent->path);\n\n    if (STRNEQ(dirname, \"/\")) {\n        def->path = g_strdup_printf(\"%s/%s\", dirname, rel);\n    } else {\n        def->path = g_strdup_printf(\"/%s\", rel);\n    }\n\n    if (virStorageSourceGetActualType(parent) == VIR_STORAGE_TYPE_NETWORK) {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        /* copy the host network part */\n        def->protocol = parent->protocol;\n        if (parent->nhosts) {\n            if (!(def->hosts = virStorageNetHostDefCopy(parent->nhosts,\n                                                        parent->hosts)))\n                return NULL;\n\n            def->nhosts = parent->nhosts;\n        }\n\n        def->volume = g_strdup(parent->volume);\n    } else {\n        /* set the type to _FILE, the caller shall update it to the actual type */\n        def->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageIsRelative",
          "args": [
            "parentRaw"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageIsRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "783-793",
          "snippet": "bool\nvirStorageIsRelative(const char *backing)\n{\n    if (backing[0] == '/')\n        return false;\n\n    if (!virStorageIsFile(backing))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsRelative(const char *backing)\n{\n    if (backing[0] == '/')\n        return false;\n\n    if (!virStorageIsFile(backing))\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceNewFromChild(virStorageSourcePtr parent,\n                             const char *parentRaw,\n                             virStorageSourcePtr *child)\n{\n    struct stat st;\n    g_autoptr(virStorageSource) def = NULL;\n    int rc = 0;\n\n    *child = NULL;\n\n    if (virStorageIsRelative(parentRaw)) {\n        if (!(def = virStorageSourceNewFromBackingRelative(parent, parentRaw)))\n            return -1;\n    } else {\n        if ((rc = virStorageSourceNewFromBackingAbsolute(parentRaw, &def)) < 0)\n            return -1;\n    }\n\n    /* possibly update local type */\n    if (def->type == VIR_STORAGE_TYPE_FILE) {\n        if (stat(def->path, &st) == 0) {\n            if (S_ISDIR(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_DIR;\n                def->format = VIR_STORAGE_FILE_DIR;\n            } else if (S_ISBLK(st.st_mode)) {\n                def->type = VIR_STORAGE_TYPE_BLOCK;\n            }\n        }\n    }\n\n    /* copy parent's labelling and other top level stuff */\n    if (virStorageSourceInitChainElement(def, parent, true) < 0)\n        return -1;\n\n    def->detected = true;\n\n    *child = g_steal_pointer(&def);\n    return rc;\n}"
  },
  {
    "function_name": "virStorageSourceNewFromBackingAbsolute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3920-3966",
    "snippet": "int\nvirStorageSourceNewFromBackingAbsolute(const char *path,\n                                       virStorageSourcePtr *src)\n{\n    const char *json;\n    int rc = 0;\n    g_autoptr(virStorageSource) def = NULL;\n\n    *src = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return -1;\n\n    if (virStorageIsFile(path)) {\n        def->type = VIR_STORAGE_TYPE_FILE;\n\n        def->path = g_strdup(path);\n    } else {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        VIR_DEBUG(\"parsing backing store string: '%s'\", path);\n\n        /* handle URI formatted backing stores */\n        if ((json = STRSKIP(path, \"json:\")))\n            rc = virStorageSourceParseBackingJSON(def, json);\n        else if (strstr(path, \"://\"))\n            rc = virStorageSourceParseBackingURI(def, path);\n        else\n            rc = virStorageSourceParseBackingColon(def, path);\n\n        if (rc < 0)\n            return -1;\n\n        virStorageSourceNetworkAssignDefaultPorts(def);\n\n        /* Some of the legacy parsers parse authentication data since they are\n         * also used in other places. For backing store detection the\n         * authentication data would be invalid anyways, so we clear it */\n        if (def->auth) {\n            virStorageAuthDefFree(def->auth);\n            def->auth = NULL;\n        }\n    }\n\n    *src = g_steal_pointer(&def);\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageAuthDefFree",
          "args": [
            "def->auth"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageAuthDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1769-1779",
          "snippet": "void\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNetworkAssignDefaultPorts",
          "args": [
            "def"
          ],
          "line": 3953
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNetworkAssignDefaultPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4642-4652",
          "snippet": "void\nvirStorageSourceNetworkAssignDefaultPorts(virStorageSourcePtr src)\n{\n    size_t i;\n\n    for (i = 0; i < src->nhosts; i++) {\n        if (src->hosts[i].transport == VIR_STORAGE_NET_HOST_TRANS_TCP &&\n            src->hosts[i].port == 0)\n            src->hosts[i].port = virStorageSourceNetworkDefaultPort(src->protocol);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageSourceNetworkAssignDefaultPorts(virStorageSourcePtr src)\n{\n    size_t i;\n\n    for (i = 0; i < src->nhosts; i++) {\n        if (src->hosts[i].transport == VIR_STORAGE_NET_HOST_TRANS_TCP &&\n            src->hosts[i].port == 0)\n            src->hosts[i].port = virStorageSourceNetworkDefaultPort(src->protocol);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingColon",
          "args": [
            "def",
            "path"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingColon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3105-3163",
          "snippet": "static int\nvirStorageSourceParseBackingColon(virStorageSourcePtr src,\n                                  const char *path)\n{\n    const char *p;\n    g_autofree char *protocol = NULL;\n\n    if (!(p = strchr(path, ':'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol string '%s'\"),\n                       path);\n        return -1;\n    }\n\n    protocol = g_strndup(path, p - path);\n\n    if ((src->protocol = virStorageNetProtocolTypeFromString(protocol)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       protocol);\n        return -1;\n    }\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n        if (virStorageSourceParseNBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (virStorageSourceParseRBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store parser is not implemented for protocol %s\"),\n                       protocol);\n        return -1;\n\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed backing store path for protocol %s\"),\n                       protocol);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingColon(virStorageSourcePtr src,\n                                  const char *path)\n{\n    const char *p;\n    g_autofree char *protocol = NULL;\n\n    if (!(p = strchr(path, ':'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol string '%s'\"),\n                       path);\n        return -1;\n    }\n\n    protocol = g_strndup(path, p - path);\n\n    if ((src->protocol = virStorageNetProtocolTypeFromString(protocol)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       protocol);\n        return -1;\n    }\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n        if (virStorageSourceParseNBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (virStorageSourceParseRBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store parser is not implemented for protocol %s\"),\n                       protocol);\n        return -1;\n\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed backing store path for protocol %s\"),\n                       protocol);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingURI",
          "args": [
            "def",
            "path"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2798-2892",
          "snippet": "static int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "path",
            "\"://\""
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSON",
          "args": [
            "def",
            "json"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3881-3907",
          "snippet": "static int\nvirStorageSourceParseBackingJSON(virStorageSourcePtr src,\n                                 const char *json)\n{\n    g_autoptr(virJSONValue) root = NULL;\n    g_autoptr(virJSONValue) deflattened = NULL;\n    virJSONValuePtr file = NULL;\n\n    if (!(root = virJSONValueFromString(json)))\n        return -1;\n\n    if (!(deflattened = virJSONValueObjectDeflatten(root)))\n        return -1;\n\n    /* There are 2 possible syntaxes:\n     * 1) json:{\"file\":{\"driver\":...}}\n     * 2) json:{\"driver\":...}\n     * Remove the 'file' wrapper object in case 1.\n     */\n    if (!virJSONValueObjectHasKey(deflattened, \"driver\"))\n        file = virJSONValueObjectGetObject(deflattened, \"file\");\n\n    if (!file)\n        file = deflattened;\n\n    return virStorageSourceParseBackingJSONInternal(src, file, json, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSON(virStorageSourcePtr src,\n                                 const char *json)\n{\n    g_autoptr(virJSONValue) root = NULL;\n    g_autoptr(virJSONValue) deflattened = NULL;\n    virJSONValuePtr file = NULL;\n\n    if (!(root = virJSONValueFromString(json)))\n        return -1;\n\n    if (!(deflattened = virJSONValueObjectDeflatten(root)))\n        return -1;\n\n    /* There are 2 possible syntaxes:\n     * 1) json:{\"file\":{\"driver\":...}}\n     * 2) json:{\"driver\":...}\n     * Remove the 'file' wrapper object in case 1.\n     */\n    if (!virJSONValueObjectHasKey(deflattened, \"driver\"))\n        file = virJSONValueObjectGetObject(deflattened, \"file\");\n\n    if (!file)\n        file = deflattened;\n\n    return virStorageSourceParseBackingJSONInternal(src, file, json, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "path",
            "\"json:\""
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"parsing backing store string: '%s'\"",
            "path"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageIsFile",
          "args": [
            "path"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageIsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "762-780",
          "snippet": "bool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceNewFromBackingAbsolute(const char *path,\n                                       virStorageSourcePtr *src)\n{\n    const char *json;\n    int rc = 0;\n    g_autoptr(virStorageSource) def = NULL;\n\n    *src = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return -1;\n\n    if (virStorageIsFile(path)) {\n        def->type = VIR_STORAGE_TYPE_FILE;\n\n        def->path = g_strdup(path);\n    } else {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        VIR_DEBUG(\"parsing backing store string: '%s'\", path);\n\n        /* handle URI formatted backing stores */\n        if ((json = STRSKIP(path, \"json:\")))\n            rc = virStorageSourceParseBackingJSON(def, json);\n        else if (strstr(path, \"://\"))\n            rc = virStorageSourceParseBackingURI(def, path);\n        else\n            rc = virStorageSourceParseBackingColon(def, path);\n\n        if (rc < 0)\n            return -1;\n\n        virStorageSourceNetworkAssignDefaultPorts(def);\n\n        /* Some of the legacy parsers parse authentication data since they are\n         * also used in other places. For backing store detection the\n         * authentication data would be invalid anyways, so we clear it */\n        if (def->auth) {\n            virStorageAuthDefFree(def->auth);\n            def->auth = NULL;\n        }\n    }\n\n    *src = g_steal_pointer(&def);\n    return rc;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3881-3907",
    "snippet": "static int\nvirStorageSourceParseBackingJSON(virStorageSourcePtr src,\n                                 const char *json)\n{\n    g_autoptr(virJSONValue) root = NULL;\n    g_autoptr(virJSONValue) deflattened = NULL;\n    virJSONValuePtr file = NULL;\n\n    if (!(root = virJSONValueFromString(json)))\n        return -1;\n\n    if (!(deflattened = virJSONValueObjectDeflatten(root)))\n        return -1;\n\n    /* There are 2 possible syntaxes:\n     * 1) json:{\"file\":{\"driver\":...}}\n     * 2) json:{\"driver\":...}\n     * Remove the 'file' wrapper object in case 1.\n     */\n    if (!virJSONValueObjectHasKey(deflattened, \"driver\"))\n        file = virJSONValueObjectGetObject(deflattened, \"file\");\n\n    if (!file)\n        file = deflattened;\n\n    return virStorageSourceParseBackingJSONInternal(src, file, json, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInternal",
          "args": [
            "src",
            "file",
            "json",
            "true"
          ],
          "line": 3906
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3844-3878",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);",
            "static const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);\nstatic const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};\n\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "deflattened",
            "\"file\""
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "deflattened",
            "\"driver\""
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectDeflatten",
          "args": [
            "root"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectDeflatten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "2198-2209",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectDeflatten(virJSONValuePtr json)\n{\n    virJSONValuePtr deflattened;\n\n    if (!(deflattened = virJSONValueObjectDeflattenKeys(json)))\n        return NULL;\n\n    virJSONValueObjectDeflattenArrays(deflattened);\n\n    return deflattened;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virJSONValuePtr\nvirJSONValueObjectDeflattenKeys(virJSONValuePtr json);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nstatic virJSONValuePtr\nvirJSONValueObjectDeflattenKeys(virJSONValuePtr json);\n\nvirJSONValuePtr\nvirJSONValueObjectDeflatten(virJSONValuePtr json)\n{\n    virJSONValuePtr deflattened;\n\n    if (!(deflattened = virJSONValueObjectDeflattenKeys(json)))\n        return NULL;\n\n    virJSONValueObjectDeflattenArrays(deflattened);\n\n    return deflattened;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "json"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSON(virStorageSourcePtr src,\n                                 const char *json)\n{\n    g_autoptr(virJSONValue) root = NULL;\n    g_autoptr(virJSONValue) deflattened = NULL;\n    virJSONValuePtr file = NULL;\n\n    if (!(root = virJSONValueFromString(json)))\n        return -1;\n\n    if (!(deflattened = virJSONValueObjectDeflatten(root)))\n        return -1;\n\n    /* There are 2 possible syntaxes:\n     * 1) json:{\"file\":{\"driver\":...}}\n     * 2) json:{\"driver\":...}\n     * Remove the 'file' wrapper object in case 1.\n     */\n    if (!virJSONValueObjectHasKey(deflattened, \"driver\"))\n        file = virJSONValueObjectGetObject(deflattened, \"file\");\n\n    if (!file)\n        file = deflattened;\n\n    return virStorageSourceParseBackingJSONInternal(src, file, json, true);\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3844-3878",
    "snippet": "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
      "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);",
      "static const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\")",
            "drvname"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\""
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jsonParsers[i].func",
          "args": [
            "src",
            "json",
            "jsonstr",
            "jsonParsers[i].opaque"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"JSON backing volume definition '%s' must not have nested format drivers\")",
            "jsonstr"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "drvname",
            "jsonParsers[i].drvname"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "jsonParsers"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"JSON backing volume definition '%s' lacks driver name\")",
            "jsonstr"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"driver\""
          ],
          "line": 3853
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);\nstatic const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};\n\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONVxHS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3776-3806",
    "snippet": "static int\nvirStorageSourceParseBackingJSONVxHS(virStorageSourcePtr src,\n                                     virJSONValuePtr json,\n                                     const char *jsonstr G_GNUC_UNUSED,\n                                     int opaque G_GNUC_UNUSED)\n{\n    const char *vdisk_id = virJSONValueObjectGetString(json, \"vdisk-id\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!vdisk_id || !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'vdisk-id' or 'server' attribute in \"\n                         \"JSON backing definition for VxHS volume\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_VXHS;\n\n    src->path = g_strdup(vdisk_id);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts,\n                                                          server) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInetSocketAddress",
          "args": [
            "src->hosts",
            "server"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInetSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3332-3363",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "1"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vdisk_id"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'vdisk-id' or 'server' attribute in \"\n                         \"JSON backing definition for VxHS volume\")"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3783
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"vdisk-id\""
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONVxHS(virStorageSourcePtr src,\n                                     virJSONValuePtr json,\n                                     const char *jsonstr G_GNUC_UNUSED,\n                                     int opaque G_GNUC_UNUSED)\n{\n    const char *vdisk_id = virJSONValueObjectGetString(json, \"vdisk-id\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!vdisk_id || !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'vdisk-id' or 'server' attribute in \"\n                         \"JSON backing definition for VxHS volume\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_VXHS;\n\n    src->path = g_strdup(vdisk_id);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts,\n                                                          server) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONRaw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3736-3773",
    "snippet": "static int\nvirStorageSourceParseBackingJSONRaw(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr,\n                                    int opaque G_GNUC_UNUSED)\n{\n    bool has_offset = virJSONValueObjectHasKey(json, \"offset\");\n    bool has_size = virJSONValueObjectHasKey(json, \"size\");\n    virJSONValuePtr file;\n\n    if (has_offset || has_size) {\n        src->sliceStorage = g_new0(virStorageSourceSlice, 1);\n\n        if (has_offset &&\n            virJSONValueObjectGetNumberUlong(json, \"offset\", &src->sliceStorage->offset) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"malformed 'offset' property of 'raw' driver\"));\n            return -1;\n        }\n\n        if (has_size &&\n            virJSONValueObjectGetNumberUlong(json, \"size\", &src->sliceStorage->size) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"malformed 'size' property of 'raw' driver\"));\n            return -1;\n        }\n    }\n\n    /* 'raw' is a format driver so it can have protocol driver children */\n    if (!(file = virJSONValueObjectGetObject(json, \"file\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks 'file' object\"),\n                       jsonstr);\n        return -1;\n    }\n\n    return virStorageSourceParseBackingJSONInternal(src, file, jsonstr, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInternal",
          "args": [
            "src",
            "file",
            "jsonstr",
            "false"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3844-3878",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);",
            "static const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat);\nstatic const struct virStorageSourceJSONDriverParser jsonParsers[] = {\n    {\"file\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_FILE},\n    {\"host_device\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"host_cdrom\", false, virStorageSourceParseBackingJSONPath, VIR_STORAGE_TYPE_BLOCK},\n    {\"http\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTP},\n    {\"https\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_HTTPS},\n    {\"ftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTP},\n    {\"ftps\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_FTPS},\n    {\"tftp\", false, virStorageSourceParseBackingJSONUri, VIR_STORAGE_NET_PROTOCOL_TFTP},\n    {\"gluster\", false, virStorageSourceParseBackingJSONGluster, 0},\n    {\"iscsi\", false, virStorageSourceParseBackingJSONiSCSI, 0},\n    {\"nbd\", false, virStorageSourceParseBackingJSONNbd, 0},\n    {\"sheepdog\", false, virStorageSourceParseBackingJSONSheepdog, 0},\n    {\"ssh\", false, virStorageSourceParseBackingJSONSSH, 0},\n    {\"rbd\", false, virStorageSourceParseBackingJSONRBD, 0},\n    {\"raw\", true, virStorageSourceParseBackingJSONRaw, 0},\n    {\"vxhs\", false, virStorageSourceParseBackingJSONVxHS, 0},\n};\n\nstatic int\nvirStorageSourceParseBackingJSONInternal(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr,\n                                         bool allowformat)\n{\n    const char *drvname;\n    size_t i;\n\n    if (!(drvname = virJSONValueObjectGetString(json, \"driver\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks driver name\"),\n                       jsonstr);\n        return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(jsonParsers); i++) {\n        if (STRNEQ(drvname, jsonParsers[i].drvname))\n            continue;\n\n        if (jsonParsers[i].formatdriver && !allowformat) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"JSON backing volume definition '%s' must not have nested format drivers\"),\n                           jsonstr);\n            return -1;\n        }\n\n        return jsonParsers[i].func(src, json, jsonstr, jsonParsers[i].opaque);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"missing parser implementation for JSON backing volume \"\n                     \"driver '%s'\"), drvname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"JSON backing volume definition '%s' lacks 'file' object\")",
            "jsonstr"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"JSON backing volume definition '%s' lacks 'file' object\""
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "json",
            "\"file\""
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"malformed 'size' property of 'raw' driver\")"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUlong",
          "args": [
            "json",
            "\"size\"",
            "&src->sliceStorage->size"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1373-1384",
          "snippet": "int\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"malformed 'offset' property of 'raw' driver\")"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageSourceSlice",
            "1"
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "json",
            "\"size\""
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONRaw(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr,\n                                    int opaque G_GNUC_UNUSED)\n{\n    bool has_offset = virJSONValueObjectHasKey(json, \"offset\");\n    bool has_size = virJSONValueObjectHasKey(json, \"size\");\n    virJSONValuePtr file;\n\n    if (has_offset || has_size) {\n        src->sliceStorage = g_new0(virStorageSourceSlice, 1);\n\n        if (has_offset &&\n            virJSONValueObjectGetNumberUlong(json, \"offset\", &src->sliceStorage->offset) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"malformed 'offset' property of 'raw' driver\"));\n            return -1;\n        }\n\n        if (has_size &&\n            virJSONValueObjectGetNumberUlong(json, \"size\", &src->sliceStorage->size) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"malformed 'size' property of 'raw' driver\"));\n            return -1;\n        }\n    }\n\n    /* 'raw' is a format driver so it can have protocol driver children */\n    if (!(file = virJSONValueObjectGetObject(json, \"file\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"JSON backing volume definition '%s' lacks 'file' object\"),\n                       jsonstr);\n        return -1;\n    }\n\n    return virStorageSourceParseBackingJSONInternal(src, file, jsonstr, false);\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONRBD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3684-3734",
    "snippet": "static int\nvirStorageSourceParseBackingJSONRBD(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *filename;\n    const char *pool = virJSONValueObjectGetString(json, \"pool\");\n    const char *image = virJSONValueObjectGetString(json, \"image\");\n    const char *conf = virJSONValueObjectGetString(json, \"conf\");\n    const char *snapshot = virJSONValueObjectGetString(json, \"snapshot\");\n    virJSONValuePtr servers = virJSONValueObjectGetArray(json, \"server\");\n    size_t nservers;\n    size_t i;\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n\n    /* legacy syntax passed via 'filename' option */\n    if ((filename = virJSONValueObjectGetString(json, \"filename\")))\n        return virStorageSourceParseRBDColonString(filename, src);\n\n    if (!pool || !image) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing pool or image name in ceph backing volume \"\n                         \"JSON specification\"));\n        return -1;\n    }\n\n    src->volume = g_strdup(pool);\n    src->path = g_strdup(image);\n    src->snapshot = g_strdup(snapshot);\n    src->configFile = g_strdup(conf);\n\n    if (servers) {\n        nservers = virJSONValueArraySize(servers);\n\n        if (VIR_ALLOC_N(src->hosts, nservers) < 0)\n            return -1;\n\n        src->nhosts = nservers;\n\n        for (i = 0; i < nservers; i++) {\n            if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts + i,\n                                                                  virJSONValueArrayGet(servers, i)) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInetSocketAddress",
          "args": [
            "src->hosts + i",
            "virJSONValueArrayGet(servers, i)"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInetSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3332-3363",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "servers",
            "i"
          ],
          "line": 3728
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "nservers"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "servers"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "conf"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing pool or image name in ceph backing volume \"\n                         \"JSON specification\")"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseRBDColonString",
          "args": [
            "filename",
            "src"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseRBDColonString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2940-3042",
          "snippet": "int\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"filename\""
          ],
          "line": 3703
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceParseBackingJSONRBD(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *filename;\n    const char *pool = virJSONValueObjectGetString(json, \"pool\");\n    const char *image = virJSONValueObjectGetString(json, \"image\");\n    const char *conf = virJSONValueObjectGetString(json, \"conf\");\n    const char *snapshot = virJSONValueObjectGetString(json, \"snapshot\");\n    virJSONValuePtr servers = virJSONValueObjectGetArray(json, \"server\");\n    size_t nservers;\n    size_t i;\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n\n    /* legacy syntax passed via 'filename' option */\n    if ((filename = virJSONValueObjectGetString(json, \"filename\")))\n        return virStorageSourceParseRBDColonString(filename, src);\n\n    if (!pool || !image) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing pool or image name in ceph backing volume \"\n                         \"JSON specification\"));\n        return -1;\n    }\n\n    src->volume = g_strdup(pool);\n    src->path = g_strdup(image);\n    src->snapshot = g_strdup(snapshot);\n    src->configFile = g_strdup(conf);\n\n    if (servers) {\n        nservers = virJSONValueArraySize(servers);\n\n        if (VIR_ALLOC_N(src->hosts, nservers) < 0)\n            return -1;\n\n        src->nhosts = nservers;\n\n        for (i = 0; i < nservers; i++) {\n            if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts + i,\n                                                                  virJSONValueArrayGet(servers, i)) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONSSH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3634-3681",
    "snippet": "static int\nvirStorageSourceParseBackingJSONSSH(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    const char *host = virJSONValueObjectGetString(json, \"host\");\n    const char *port = virJSONValueObjectGetString(json, \"port\");\n    const char *user = virJSONValueObjectGetString(json, \"user\");\n    const char *host_key_check = virJSONValueObjectGetString(json, \"host_key_check\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!(host || server) || !path) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing host/server or path of SSH JSON backing \"\n                         \"volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_SSH;\n\n    src->path = g_strdup(path);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (server) {\n        if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts,\n                                                              server) < 0)\n            return -1;\n    } else {\n        src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n        src->hosts[0].name = g_strdup(host);\n\n        if (virStringParsePort(port, &src->hosts[0].port) < 0)\n            return -1;\n    }\n\n    /* these two are parsed just to be passed back as we don't model them yet */\n    src->ssh_user = g_strdup(user);\n    if (STREQ_NULLABLE(host_key_check, \"no\"))\n        src->ssh_host_key_check_disabled = true;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "host_key_check",
            "\"no\""
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "user"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "port",
            "&src->hosts[0].port"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInetSocketAddress",
          "args": [
            "src->hosts",
            "server"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInetSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3332-3363",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "1"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing host/server or path of SSH JSON backing \"\n                         \"volume definition\")"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"host_key_check\""
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSSH(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    const char *host = virJSONValueObjectGetString(json, \"host\");\n    const char *port = virJSONValueObjectGetString(json, \"port\");\n    const char *user = virJSONValueObjectGetString(json, \"user\");\n    const char *host_key_check = virJSONValueObjectGetString(json, \"host_key_check\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!(host || server) || !path) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing host/server or path of SSH JSON backing \"\n                         \"volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_SSH;\n\n    src->path = g_strdup(path);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (server) {\n        if (virStorageSourceParseBackingJSONInetSocketAddress(src->hosts,\n                                                              server) < 0)\n            return -1;\n    } else {\n        src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n        src->hosts[0].name = g_strdup(host);\n\n        if (virStringParsePort(port, &src->hosts[0].port) < 0)\n            return -1;\n    }\n\n    /* these two are parsed just to be passed back as we don't model them yet */\n    src->ssh_user = g_strdup(user);\n    if (STREQ_NULLABLE(host_key_check, \"no\"))\n        src->ssh_host_key_check_disabled = true;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONSheepdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3590-3631",
    "snippet": "static int\nvirStorageSourceParseBackingJSONSheepdog(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr G_GNUC_UNUSED,\n                                         int opaque G_GNUC_UNUSED)\n{\n    const char *filename;\n    const char *vdi = virJSONValueObjectGetString(json, \"vdi\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if ((filename = virJSONValueObjectGetString(json, \"filename\"))) {\n        if (strstr(filename, \"://\"))\n            return virStorageSourceParseBackingJSONUriStr(src, filename,\n                                                          VIR_STORAGE_NET_PROTOCOL_SHEEPDOG);\n\n        /* libvirt doesn't implement a parser for the legacy non-URI syntax */\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing sheepdog URI in JSON backing volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_SHEEPDOG;\n\n    if (!vdi) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing sheepdog vdi name\"));\n        return -1;\n    }\n\n    src->path = g_strdup(vdi);\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (virStorageSourceParseBackingJSONSocketAddress(src->hosts, server) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONSocketAddress",
          "args": [
            "src->hosts",
            "server"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3366-3415",
          "snippet": "static int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "src->hosts"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vdi"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing sheepdog vdi name\")"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing sheepdog URI in JSON backing volume definition\")"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONUriStr",
          "args": [
            "src",
            "filename",
            "VIR_STORAGE_NET_PROTOCOL_SHEEPDOG"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONUriStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3195-3215",
          "snippet": "static int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "filename",
            "\"://\""
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"filename\""
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSheepdog(virStorageSourcePtr src,\n                                         virJSONValuePtr json,\n                                         const char *jsonstr G_GNUC_UNUSED,\n                                         int opaque G_GNUC_UNUSED)\n{\n    const char *filename;\n    const char *vdi = virJSONValueObjectGetString(json, \"vdi\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if ((filename = virJSONValueObjectGetString(json, \"filename\"))) {\n        if (strstr(filename, \"://\"))\n            return virStorageSourceParseBackingJSONUriStr(src, filename,\n                                                          VIR_STORAGE_NET_PROTOCOL_SHEEPDOG);\n\n        /* libvirt doesn't implement a parser for the legacy non-URI syntax */\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing sheepdog URI in JSON backing volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_SHEEPDOG;\n\n    if (!vdi) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing sheepdog vdi name\"));\n        return -1;\n    }\n\n    src->path = g_strdup(vdi);\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (virStorageSourceParseBackingJSONSocketAddress(src->hosts, server) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONNbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3542-3587",
    "snippet": "static int\nvirStorageSourceParseBackingJSONNbd(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    const char *host = virJSONValueObjectGetString(json, \"host\");\n    const char *port = virJSONValueObjectGetString(json, \"port\");\n    const char *export = virJSONValueObjectGetString(json, \"export\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!path && !host && !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing host specification of NBD server in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n\n    src->path = g_strdup(export);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (server) {\n        if (virStorageSourceParseBackingJSONSocketAddress(src->hosts, server) < 0)\n            return -1;\n    } else {\n        if (path) {\n            src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n            src->hosts[0].socket = g_strdup(path);\n        } else {\n            src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            src->hosts[0].name = g_strdup(host);\n\n            if (virStringParsePort(port, &src->hosts[0].port) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "port",
            "&src->hosts[0].port"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "host"
          ],
          "line": 3579
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONSocketAddress",
          "args": [
            "src->hosts",
            "server"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3366-3415",
          "snippet": "static int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "1"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing host specification of NBD server in JSON \"\n                         \"backing volume definition\")"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"export\""
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONNbd(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr G_GNUC_UNUSED,\n                                    int opaque G_GNUC_UNUSED)\n{\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    const char *host = virJSONValueObjectGetString(json, \"host\");\n    const char *port = virJSONValueObjectGetString(json, \"port\");\n    const char *export = virJSONValueObjectGetString(json, \"export\");\n    virJSONValuePtr server = virJSONValueObjectGetObject(json, \"server\");\n\n    if (!path && !host && !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing host specification of NBD server in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n\n    src->path = g_strdup(export);\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n    src->nhosts = 1;\n\n    if (server) {\n        if (virStorageSourceParseBackingJSONSocketAddress(src->hosts, server) < 0)\n            return -1;\n    } else {\n        if (path) {\n            src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n            src->hosts[0].socket = g_strdup(path);\n        } else {\n            src->hosts[0].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            src->hosts[0].name = g_strdup(host);\n\n            if (virStringParsePort(port, &src->hosts[0].port) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONiSCSI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3472-3539",
    "snippet": "static int\nvirStorageSourceParseBackingJSONiSCSI(virStorageSourcePtr src,\n                                      virJSONValuePtr json,\n                                      const char *jsonstr G_GNUC_UNUSED,\n                                      int opaque G_GNUC_UNUSED)\n{\n    const char *transport = virJSONValueObjectGetString(json, \"transport\");\n    const char *portal = virJSONValueObjectGetString(json, \"portal\");\n    const char *target = virJSONValueObjectGetString(json, \"target\");\n    const char *lun = virJSONValueObjectGetStringOrNumber(json, \"lun\");\n    const char *uri;\n    char *port;\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if ((uri = virJSONValueObjectGetString(json, \"filename\")))\n        return virStorageSourceParseBackingJSONUriStr(src, uri,\n                                                      VIR_STORAGE_NET_PROTOCOL_ISCSI);\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_ISCSI;\n\n    if (!lun)\n        lun = \"0\";\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (STRNEQ_NULLABLE(transport, \"tcp\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"only TCP transport is supported for iSCSI volumes\"));\n        return -1;\n    }\n\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    if (!portal) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'portal' address in iSCSI backing definition\"));\n        return -1;\n    }\n\n    if (!target) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'target' in iSCSI backing definition\"));\n        return -1;\n    }\n\n    src->hosts->name = g_strdup(portal);\n\n    if ((port = strrchr(src->hosts->name, ':')) &&\n        !strchr(port, ']')) {\n        if (virStringParsePort(port + 1, &src->hosts->port) < 0)\n            return -1;\n\n        *port = '\\0';\n    }\n\n    src->path = g_strdup_printf(\"%s/%s\", target, lun);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (virJSONValueObjectGetString(json, \"user\") ||\n        virJSONValueObjectGetString(json, \"password\"))\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"password\""
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "target",
            "lun"
          ],
          "line": 3531
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "port + 1",
            "&src->hosts->port"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "port",
            "']'"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "src->hosts->name",
            "':'"
          ],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'target' in iSCSI backing definition\")"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'portal' address in iSCSI backing definition\")"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"only TCP transport is supported for iSCSI volumes\")"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "transport",
            "\"tcp\""
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "src->hosts"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONUriStr",
          "args": [
            "src",
            "uri",
            "VIR_STORAGE_NET_PROTOCOL_ISCSI"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONUriStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3195-3215",
          "snippet": "static int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONiSCSI(virStorageSourcePtr src,\n                                      virJSONValuePtr json,\n                                      const char *jsonstr G_GNUC_UNUSED,\n                                      int opaque G_GNUC_UNUSED)\n{\n    const char *transport = virJSONValueObjectGetString(json, \"transport\");\n    const char *portal = virJSONValueObjectGetString(json, \"portal\");\n    const char *target = virJSONValueObjectGetString(json, \"target\");\n    const char *lun = virJSONValueObjectGetStringOrNumber(json, \"lun\");\n    const char *uri;\n    char *port;\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if ((uri = virJSONValueObjectGetString(json, \"filename\")))\n        return virStorageSourceParseBackingJSONUriStr(src, uri,\n                                                      VIR_STORAGE_NET_PROTOCOL_ISCSI);\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_ISCSI;\n\n    if (!lun)\n        lun = \"0\";\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (STRNEQ_NULLABLE(transport, \"tcp\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"only TCP transport is supported for iSCSI volumes\"));\n        return -1;\n    }\n\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    if (!portal) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'portal' address in iSCSI backing definition\"));\n        return -1;\n    }\n\n    if (!target) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'target' in iSCSI backing definition\"));\n        return -1;\n    }\n\n    src->hosts->name = g_strdup(portal);\n\n    if ((port = strrchr(src->hosts->name, ':')) &&\n        !strchr(port, ']')) {\n        if (virStringParsePort(port + 1, &src->hosts->port) < 0)\n            return -1;\n\n        *port = '\\0';\n    }\n\n    src->path = g_strdup_printf(\"%s/%s\", target, lun);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (virJSONValueObjectGetString(json, \"user\") ||\n        virJSONValueObjectGetString(json, \"password\"))\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONGluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3418-3469",
    "snippet": "static int\nvirStorageSourceParseBackingJSONGluster(virStorageSourcePtr src,\n                                        virJSONValuePtr json,\n                                        const char *jsonstr G_GNUC_UNUSED,\n                                        int opaque G_GNUC_UNUSED)\n{\n    const char *uri = virJSONValueObjectGetString(json, \"filename\");\n    const char *volume = virJSONValueObjectGetString(json, \"volume\");\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    virJSONValuePtr server = virJSONValueObjectGetArray(json, \"server\");\n    size_t nservers;\n    size_t i;\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if (uri)\n        return virStorageSourceParseBackingJSONUriStr(src, uri,\n                                                      VIR_STORAGE_NET_PROTOCOL_GLUSTER);\n\n    if (!volume || !path || !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'volume', 'path' or 'server' attribute in \"\n                         \"JSON backing definition for gluster volume\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_GLUSTER;\n\n    src->volume = g_strdup(volume);\n    src->path = g_strdup(path);\n\n    nservers = virJSONValueArraySize(server);\n    if (nservers == 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"at least 1 server is necessary in \"\n                         \"JSON backing definition for gluster volume\"));\n\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(src->hosts, nservers) < 0)\n        return -1;\n    src->nhosts = nservers;\n\n    for (i = 0; i < nservers; i++) {\n        if (virStorageSourceParseBackingJSONSocketAddress(src->hosts + i,\n                                                          virJSONValueArrayGet(server, i)) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONSocketAddress",
          "args": [
            "src->hosts + i",
            "virJSONValueArrayGet(server, i)"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3366-3415",
          "snippet": "static int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "server",
            "i"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "nservers"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"at least 1 server is necessary in \"\n                         \"JSON backing definition for gluster volume\")"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"at least 1 server is necessary in \"\n                         \"JSON backing definition for gluster volume\""
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "server"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'volume', 'path' or 'server' attribute in \"\n                         \"JSON backing definition for gluster volume\")"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONUriStr",
          "args": [
            "src",
            "uri",
            "VIR_STORAGE_NET_PROTOCOL_GLUSTER"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONUriStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3195-3215",
          "snippet": "static int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "json",
            "\"server\""
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"path\""
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceParseBackingJSONGluster(virStorageSourcePtr src,\n                                        virJSONValuePtr json,\n                                        const char *jsonstr G_GNUC_UNUSED,\n                                        int opaque G_GNUC_UNUSED)\n{\n    const char *uri = virJSONValueObjectGetString(json, \"filename\");\n    const char *volume = virJSONValueObjectGetString(json, \"volume\");\n    const char *path = virJSONValueObjectGetString(json, \"path\");\n    virJSONValuePtr server = virJSONValueObjectGetArray(json, \"server\");\n    size_t nservers;\n    size_t i;\n\n    /* legacy URI based syntax passed via 'filename' option */\n    if (uri)\n        return virStorageSourceParseBackingJSONUriStr(src, uri,\n                                                      VIR_STORAGE_NET_PROTOCOL_GLUSTER);\n\n    if (!volume || !path || !server) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'volume', 'path' or 'server' attribute in \"\n                         \"JSON backing definition for gluster volume\"));\n        return -1;\n    }\n\n    src->type = VIR_STORAGE_TYPE_NETWORK;\n    src->protocol = VIR_STORAGE_NET_PROTOCOL_GLUSTER;\n\n    src->volume = g_strdup(volume);\n    src->path = g_strdup(path);\n\n    nservers = virJSONValueArraySize(server);\n    if (nservers == 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"at least 1 server is necessary in \"\n                         \"JSON backing definition for gluster volume\"));\n\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(src->hosts, nservers) < 0)\n        return -1;\n    src->nhosts = nservers;\n\n    for (i = 0; i < nservers; i++) {\n        if (virStorageSourceParseBackingJSONSocketAddress(src->hosts + i,\n                                                          virJSONValueArrayGet(server, i)) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONSocketAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3366-3415",
    "snippet": "static int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"backing store protocol '%s' is not yet supported\")",
            "type"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"backing store protocol '%s' is not yet supported\""
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\")"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"socket\""
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"unix\""
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONInetSocketAddress",
          "args": [
            "host",
            "json"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONInetSocketAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3332-3363",
          "snippet": "static int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"inet\""
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"tcp\""
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing socket address type in \"\n                         \"JSON backing volume definition\")"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing remote server specification in JSON \"\n                         \"backing volume definition\")"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONSocketAddress(virStorageNetHostDefPtr host,\n                                              virJSONValuePtr json)\n{\n    const char *type;\n    const char *socket;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    if (!(type = virJSONValueObjectGetString(json, \"type\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing socket address type in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (STREQ(type, \"tcp\") || STREQ(type, \"inet\")) {\n        return virStorageSourceParseBackingJSONInetSocketAddress(host, json);\n\n    } else if (STREQ(type, \"unix\")) {\n        host->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n\n        socket = virJSONValueObjectGetString(json, \"path\");\n\n        /* check for old spelling for gluster protocol */\n        if (!socket)\n            socket = virJSONValueObjectGetString(json, \"socket\");\n\n        if (!socket) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing socket path for udp backing server in \"\n                             \"JSON backing volume definition\"));\n            return -1;\n        }\n\n        host->socket = g_strdup(socket);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store protocol '%s' is not yet supported\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONInetSocketAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3332-3363",
    "snippet": "static int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "port",
            "&host->port"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hostname"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\")"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"port\""
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing remote server specification in JSON \"\n                         \"backing volume definition\")"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONInetSocketAddress(virStorageNetHostDefPtr host,\n                                                  virJSONValuePtr json)\n{\n    const char *hostname;\n    const char *port;\n\n    if (!json) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing remote server specification in JSON \"\n                         \"backing volume definition\"));\n        return -1;\n    }\n\n    hostname = virJSONValueObjectGetString(json, \"host\");\n    port = virJSONValueObjectGetString(json, \"port\");\n\n    if (!hostname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing hostname for tcp backing server in \"\n                         \"JSON backing volume definition\"));\n        return -1;\n    }\n\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    host->name = g_strdup(hostname);\n\n    if (virStringParsePort(port, &host->port) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONUri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3269-3329",
    "snippet": "static int\nvirStorageSourceParseBackingJSONUri(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr,\n                                    int protocol)\n{\n    const char *uri;\n\n    if (!(uri = virJSONValueObjectGetString(json, \"url\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'url' in JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (protocol == VIR_STORAGE_NET_PROTOCOL_HTTPS ||\n        protocol == VIR_STORAGE_NET_PROTOCOL_FTPS) {\n        if (virJSONValueObjectHasKey(json, \"sslverify\")) {\n            const char *tmpstr;\n            bool tmp;\n\n            /* libguestfs still uses undocumented legacy value of 'off' */\n            if ((tmpstr = virJSONValueObjectGetString(json, \"sslverify\")) &&\n                STREQ(tmpstr, \"off\")) {\n                src->sslverify = VIR_TRISTATE_BOOL_NO;\n            } else {\n                if (virJSONValueObjectGetBoolean(json, \"sslverify\", &tmp) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"malformed 'sslverify' field in backing store definition '%s'\"),\n                                   jsonstr);\n                    return -1;\n                }\n\n                src->sslverify = virTristateBoolFromBool(tmp);\n            }\n        }\n    }\n\n    if (protocol == VIR_STORAGE_NET_PROTOCOL_HTTPS ||\n        protocol == VIR_STORAGE_NET_PROTOCOL_HTTP) {\n        if (virStorageSourceParseBackingJSONUriCookies(src, json, jsonstr) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectHasKey(json, \"readahead\") &&\n        virJSONValueObjectGetNumberUlong(json, \"readahead\", &src->readahead) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"malformed 'readahead' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (virJSONValueObjectHasKey(json, \"timeout\") &&\n        virJSONValueObjectGetNumberUlong(json, \"timeout\", &src->timeout) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"malformed 'timeout' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    return virStorageSourceParseBackingJSONUriStr(src, uri, protocol);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONUriStr",
          "args": [
            "src",
            "uri",
            "protocol"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONUriStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3195-3215",
          "snippet": "static int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"malformed 'timeout' field in backing store definition '%s'\")",
            "jsonstr"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed 'timeout' field in backing store definition '%s'\""
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUlong",
          "args": [
            "json",
            "\"timeout\"",
            "&src->timeout"
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1373-1384",
          "snippet": "int\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "json",
            "\"timeout\""
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"malformed 'readahead' field in backing store definition '%s'\")",
            "jsonstr"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingJSONUriCookies",
          "args": [
            "src",
            "json",
            "jsonstr"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingJSONUriCookies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3218-3266",
          "snippet": "static int\nvirStorageSourceParseBackingJSONUriCookies(virStorageSourcePtr src,\n                                           virJSONValuePtr json,\n                                           const char *jsonstr)\n{\n    const char *cookiestr;\n    VIR_AUTOSTRINGLIST cookies = NULL;\n    size_t ncookies = 0;\n    size_t i;\n\n    if (!virJSONValueObjectHasKey(json, \"cookie\"))\n        return 0;\n\n    if (!(cookiestr = virJSONValueObjectGetString(json, \"cookie\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"wrong format of 'cookie' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (!(cookies = virStringSplitCount(cookiestr, \";\", 0, &ncookies)))\n        return -1;\n\n    src->cookies = g_new0(virStorageNetCookieDefPtr, ncookies);\n    src->ncookies = ncookies;\n\n    for (i = 0; i < ncookies; i++) {\n        char *cookiename = cookies[i];\n        char *cookievalue;\n\n        virSkipSpaces((const char **) &cookiename);\n\n        if (!(cookievalue = strchr(cookiename, '='))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed http cookie '%s' in backing store definition '%s'\"),\n                           cookies[i], jsonstr);\n            return -1;\n        }\n\n        *cookievalue = '\\0';\n        cookievalue++;\n\n        src->cookies[i] = g_new0(virStorageNetCookieDef, 1);\n        src->cookies[i]->name = g_strdup(cookiename);\n        src->cookies[i]->value = g_strdup(cookievalue);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceParseBackingJSONUriCookies(virStorageSourcePtr src,\n                                           virJSONValuePtr json,\n                                           const char *jsonstr)\n{\n    const char *cookiestr;\n    VIR_AUTOSTRINGLIST cookies = NULL;\n    size_t ncookies = 0;\n    size_t i;\n\n    if (!virJSONValueObjectHasKey(json, \"cookie\"))\n        return 0;\n\n    if (!(cookiestr = virJSONValueObjectGetString(json, \"cookie\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"wrong format of 'cookie' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (!(cookies = virStringSplitCount(cookiestr, \";\", 0, &ncookies)))\n        return -1;\n\n    src->cookies = g_new0(virStorageNetCookieDefPtr, ncookies);\n    src->ncookies = ncookies;\n\n    for (i = 0; i < ncookies; i++) {\n        char *cookiename = cookies[i];\n        char *cookievalue;\n\n        virSkipSpaces((const char **) &cookiename);\n\n        if (!(cookievalue = strchr(cookiename, '='))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed http cookie '%s' in backing store definition '%s'\"),\n                           cookies[i], jsonstr);\n            return -1;\n        }\n\n        *cookievalue = '\\0';\n        cookievalue++;\n\n        src->cookies[i] = g_new0(virStorageNetCookieDef, 1);\n        src->cookies[i]->name = g_strdup(cookiename);\n        src->cookies[i]->value = g_strdup(cookievalue);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolFromBool",
          "args": [
            "tmp"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "virTristateBoolFromBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virenum.c",
          "lines": "40-47",
          "snippet": "virTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virenum.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virenum.h\"\n#include <config.h>\n\nvirTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"malformed 'sslverify' field in backing store definition '%s'\")",
            "jsonstr"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetBoolean",
          "args": [
            "json",
            "\"sslverify\"",
            "&tmp"
          ],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1401-1412",
          "snippet": "int\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmpstr",
            "\"off\""
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"sslverify\""
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'url' in JSON backing volume definition\")"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUri(virStorageSourcePtr src,\n                                    virJSONValuePtr json,\n                                    const char *jsonstr,\n                                    int protocol)\n{\n    const char *uri;\n\n    if (!(uri = virJSONValueObjectGetString(json, \"url\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'url' in JSON backing volume definition\"));\n        return -1;\n    }\n\n    if (protocol == VIR_STORAGE_NET_PROTOCOL_HTTPS ||\n        protocol == VIR_STORAGE_NET_PROTOCOL_FTPS) {\n        if (virJSONValueObjectHasKey(json, \"sslverify\")) {\n            const char *tmpstr;\n            bool tmp;\n\n            /* libguestfs still uses undocumented legacy value of 'off' */\n            if ((tmpstr = virJSONValueObjectGetString(json, \"sslverify\")) &&\n                STREQ(tmpstr, \"off\")) {\n                src->sslverify = VIR_TRISTATE_BOOL_NO;\n            } else {\n                if (virJSONValueObjectGetBoolean(json, \"sslverify\", &tmp) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"malformed 'sslverify' field in backing store definition '%s'\"),\n                                   jsonstr);\n                    return -1;\n                }\n\n                src->sslverify = virTristateBoolFromBool(tmp);\n            }\n        }\n    }\n\n    if (protocol == VIR_STORAGE_NET_PROTOCOL_HTTPS ||\n        protocol == VIR_STORAGE_NET_PROTOCOL_HTTP) {\n        if (virStorageSourceParseBackingJSONUriCookies(src, json, jsonstr) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectHasKey(json, \"readahead\") &&\n        virJSONValueObjectGetNumberUlong(json, \"readahead\", &src->readahead) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"malformed 'readahead' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (virJSONValueObjectHasKey(json, \"timeout\") &&\n        virJSONValueObjectGetNumberUlong(json, \"timeout\", &src->timeout) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"malformed 'timeout' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    return virStorageSourceParseBackingJSONUriStr(src, uri, protocol);\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONUriCookies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3218-3266",
    "snippet": "static int\nvirStorageSourceParseBackingJSONUriCookies(virStorageSourcePtr src,\n                                           virJSONValuePtr json,\n                                           const char *jsonstr)\n{\n    const char *cookiestr;\n    VIR_AUTOSTRINGLIST cookies = NULL;\n    size_t ncookies = 0;\n    size_t i;\n\n    if (!virJSONValueObjectHasKey(json, \"cookie\"))\n        return 0;\n\n    if (!(cookiestr = virJSONValueObjectGetString(json, \"cookie\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"wrong format of 'cookie' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (!(cookies = virStringSplitCount(cookiestr, \";\", 0, &ncookies)))\n        return -1;\n\n    src->cookies = g_new0(virStorageNetCookieDefPtr, ncookies);\n    src->ncookies = ncookies;\n\n    for (i = 0; i < ncookies; i++) {\n        char *cookiename = cookies[i];\n        char *cookievalue;\n\n        virSkipSpaces((const char **) &cookiename);\n\n        if (!(cookievalue = strchr(cookiename, '='))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed http cookie '%s' in backing store definition '%s'\"),\n                           cookies[i], jsonstr);\n            return -1;\n        }\n\n        *cookievalue = '\\0';\n        cookievalue++;\n\n        src->cookies[i] = g_new0(virStorageNetCookieDef, 1);\n        src->cookies[i]->name = g_strdup(cookiename);\n        src->cookies[i]->value = g_strdup(cookievalue);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "cookievalue"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageNetCookieDef",
            "1"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"malformed http cookie '%s' in backing store definition '%s'\")",
            "cookies[i]",
            "jsonstr"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cookiename",
            "'='"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSkipSpaces",
          "args": [
            "(const char **) &cookiename"
          ],
          "line": 3248
        },
        "resolved": true,
        "details": {
          "function_name": "virSkipSpacesAndBackslash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "810-818",
          "snippet": "void\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageNetCookieDefPtr",
            "ncookies"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "cookiestr",
            "\";\"",
            "0",
            "&ncookies"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"wrong format of 'cookie' field in backing store definition '%s'\")",
            "jsonstr"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"cookie\""
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "json",
            "\"cookie\""
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceParseBackingJSONUriCookies(virStorageSourcePtr src,\n                                           virJSONValuePtr json,\n                                           const char *jsonstr)\n{\n    const char *cookiestr;\n    VIR_AUTOSTRINGLIST cookies = NULL;\n    size_t ncookies = 0;\n    size_t i;\n\n    if (!virJSONValueObjectHasKey(json, \"cookie\"))\n        return 0;\n\n    if (!(cookiestr = virJSONValueObjectGetString(json, \"cookie\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"wrong format of 'cookie' field in backing store definition '%s'\"),\n                       jsonstr);\n        return -1;\n    }\n\n    if (!(cookies = virStringSplitCount(cookiestr, \";\", 0, &ncookies)))\n        return -1;\n\n    src->cookies = g_new0(virStorageNetCookieDefPtr, ncookies);\n    src->ncookies = ncookies;\n\n    for (i = 0; i < ncookies; i++) {\n        char *cookiename = cookies[i];\n        char *cookievalue;\n\n        virSkipSpaces((const char **) &cookiename);\n\n        if (!(cookievalue = strchr(cookiename, '='))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed http cookie '%s' in backing store definition '%s'\"),\n                           cookies[i], jsonstr);\n            return -1;\n        }\n\n        *cookievalue = '\\0';\n        cookievalue++;\n\n        src->cookies[i] = g_new0(virStorageNetCookieDef, 1);\n        src->cookies[i]->name = g_strdup(cookiename);\n        src->cookies[i]->value = g_strdup(cookievalue);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONUriStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3195-3215",
    "snippet": "static int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\")",
            "virStorageNetProtocolTypeToString(protocol)",
            "virStorageNetProtocolTypeToString(src->protocol)"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeToString",
          "args": [
            "src->protocol"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeToString",
          "args": [
            "protocol"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\""
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseBackingURI",
          "args": [
            "src",
            "uri"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseBackingURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2798-2892",
          "snippet": "static int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONUriStr(virStorageSourcePtr src,\n                                       const char *uri,\n                                       int protocol)\n{\n    int rc;\n\n    if ((rc = virStorageSourceParseBackingURI(src, uri)) < 0)\n        return -1;\n\n    if (src->protocol != protocol) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"expected protocol '%s' but got '%s' in URI JSON volume \"\n                         \"definition\"),\n                       virStorageNetProtocolTypeToString(protocol),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        return -1;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingJSONPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3173-3192",
    "snippet": "static int\nvirStorageSourceParseBackingJSONPath(virStorageSourcePtr src,\n                                     virJSONValuePtr json,\n                                     const char *jsonstr G_GNUC_UNUSED,\n                                     int type)\n{\n    const char *path;\n\n    if (!(path = virJSONValueObjectGetString(json, \"filename\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'filename' field in JSON backing volume \"\n                         \"definition\"));\n        return -1;\n    }\n\n    src->path = g_strdup(path);\n\n    src->type = type;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing 'filename' field in JSON backing volume \"\n                         \"definition\")"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "json",
            "\"filename\""
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingJSONPath(virStorageSourcePtr src,\n                                     virJSONValuePtr json,\n                                     const char *jsonstr G_GNUC_UNUSED,\n                                     int type)\n{\n    const char *path;\n\n    if (!(path = virJSONValueObjectGetString(json, \"filename\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"missing 'filename' field in JSON backing volume \"\n                         \"definition\"));\n        return -1;\n    }\n\n    src->path = g_strdup(path);\n\n    src->type = type;\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingColon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3105-3163",
    "snippet": "static int\nvirStorageSourceParseBackingColon(virStorageSourcePtr src,\n                                  const char *path)\n{\n    const char *p;\n    g_autofree char *protocol = NULL;\n\n    if (!(p = strchr(path, ':'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol string '%s'\"),\n                       path);\n        return -1;\n    }\n\n    protocol = g_strndup(path, p - path);\n\n    if ((src->protocol = virStorageNetProtocolTypeFromString(protocol)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       protocol);\n        return -1;\n    }\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n        if (virStorageSourceParseNBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (virStorageSourceParseRBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store parser is not implemented for protocol %s\"),\n                       protocol);\n        return -1;\n\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed backing store path for protocol %s\"),\n                       protocol);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed backing store path for protocol %s\")",
            "protocol"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed backing store path for protocol %s\""
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"backing store parser is not implemented for protocol %s\")",
            "protocol"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseRBDColonString",
          "args": [
            "path",
            "src"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseRBDColonString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2940-3042",
          "snippet": "int\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseNBDColonString",
          "args": [
            "path",
            "src"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseNBDColonString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "3045-3102",
          "snippet": "static int\nvirStorageSourceParseNBDColonString(const char *nbdstr,\n                                    virStorageSourcePtr src)\n{\n    VIR_AUTOSTRINGLIST backing = NULL;\n    const char *exportname;\n\n    if (!(backing = virStringSplit(nbdstr, \":\", 0)))\n        return -1;\n\n    /* we know that backing[0] now equals to \"nbd\" */\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n\n    src->nhosts = 1;\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* format: [] denotes optional sections, uppercase are variable strings\n     * nbd:unix:/PATH/TO/SOCKET[:exportname=EXPORTNAME]\n     * nbd:HOSTNAME:PORT[:exportname=EXPORTNAME]\n     */\n    if (!backing[1]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing remote information in '%s' for protocol nbd\"),\n                       nbdstr);\n        return -1;\n    } else if (STREQ(backing[1], \"unix\")) {\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing unix socket path in nbd backing string %s\"),\n                           nbdstr);\n            return -1;\n        }\n\n        src->hosts->socket = g_strdup(backing[2]);\n        src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n   } else {\n        src->hosts->name = g_strdup(backing[1]);\n\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing port in nbd string '%s'\"),\n                           nbdstr);\n            return -1;\n        }\n\n        if (virStringParsePort(backing[2], &src->hosts->port) < 0)\n            return -1;\n    }\n\n    if ((exportname = strstr(nbdstr, \"exportname=\"))) {\n        exportname += strlen(\"exportname=\");\n        src->path = g_strdup(exportname);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseNBDColonString(const char *nbdstr,\n                                    virStorageSourcePtr src)\n{\n    VIR_AUTOSTRINGLIST backing = NULL;\n    const char *exportname;\n\n    if (!(backing = virStringSplit(nbdstr, \":\", 0)))\n        return -1;\n\n    /* we know that backing[0] now equals to \"nbd\" */\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n\n    src->nhosts = 1;\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* format: [] denotes optional sections, uppercase are variable strings\n     * nbd:unix:/PATH/TO/SOCKET[:exportname=EXPORTNAME]\n     * nbd:HOSTNAME:PORT[:exportname=EXPORTNAME]\n     */\n    if (!backing[1]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing remote information in '%s' for protocol nbd\"),\n                       nbdstr);\n        return -1;\n    } else if (STREQ(backing[1], \"unix\")) {\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing unix socket path in nbd backing string %s\"),\n                           nbdstr);\n            return -1;\n        }\n\n        src->hosts->socket = g_strdup(backing[2]);\n        src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n   } else {\n        src->hosts->name = g_strdup(backing[1]);\n\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing port in nbd string '%s'\"),\n                           nbdstr);\n            return -1;\n        }\n\n        if (virStringParsePort(backing[2], &src->hosts->port) < 0)\n            return -1;\n    }\n\n    if ((exportname = strstr(nbdstr, \"exportname=\"))) {\n        exportname += strlen(\"exportname=\");\n        src->path = g_strdup(exportname);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid backing protocol '%s'\")",
            "protocol"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeFromString",
          "args": [
            "protocol"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "path",
            "p - path"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid backing protocol string '%s'\")",
            "path"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "':'"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingColon(virStorageSourcePtr src,\n                                  const char *path)\n{\n    const char *p;\n    g_autofree char *protocol = NULL;\n\n    if (!(p = strchr(path, ':'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol string '%s'\"),\n                       path);\n        return -1;\n    }\n\n    protocol = g_strndup(path, p - path);\n\n    if ((src->protocol = virStorageNetProtocolTypeFromString(protocol)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       protocol);\n        return -1;\n    }\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n        if (virStorageSourceParseNBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (virStorageSourceParseRBDColonString(path, src) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"backing store parser is not implemented for protocol %s\"),\n                       protocol);\n        return -1;\n\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed backing store path for protocol %s\"),\n                       protocol);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseNBDColonString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "3045-3102",
    "snippet": "static int\nvirStorageSourceParseNBDColonString(const char *nbdstr,\n                                    virStorageSourcePtr src)\n{\n    VIR_AUTOSTRINGLIST backing = NULL;\n    const char *exportname;\n\n    if (!(backing = virStringSplit(nbdstr, \":\", 0)))\n        return -1;\n\n    /* we know that backing[0] now equals to \"nbd\" */\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n\n    src->nhosts = 1;\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* format: [] denotes optional sections, uppercase are variable strings\n     * nbd:unix:/PATH/TO/SOCKET[:exportname=EXPORTNAME]\n     * nbd:HOSTNAME:PORT[:exportname=EXPORTNAME]\n     */\n    if (!backing[1]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing remote information in '%s' for protocol nbd\"),\n                       nbdstr);\n        return -1;\n    } else if (STREQ(backing[1], \"unix\")) {\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing unix socket path in nbd backing string %s\"),\n                           nbdstr);\n            return -1;\n        }\n\n        src->hosts->socket = g_strdup(backing[2]);\n        src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n   } else {\n        src->hosts->name = g_strdup(backing[1]);\n\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing port in nbd string '%s'\"),\n                           nbdstr);\n            return -1;\n        }\n\n        if (virStringParsePort(backing[2], &src->hosts->port) < 0)\n            return -1;\n    }\n\n    if ((exportname = strstr(nbdstr, \"exportname=\"))) {\n        exportname += strlen(\"exportname=\");\n        src->path = g_strdup(exportname);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "exportname"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"exportname=\""
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "nbdstr",
            "\"exportname=\""
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "backing[2]",
            "&src->hosts->port"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing port in nbd string '%s'\")",
            "nbdstr"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing unix socket path in nbd backing string %s\")",
            "nbdstr"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "backing[1]",
            "\"unix\""
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing remote information in '%s' for protocol nbd\")",
            "nbdstr"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "1"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "nbdstr",
            "\":\"",
            "0"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseNBDColonString(const char *nbdstr,\n                                    virStorageSourcePtr src)\n{\n    VIR_AUTOSTRINGLIST backing = NULL;\n    const char *exportname;\n\n    if (!(backing = virStringSplit(nbdstr, \":\", 0)))\n        return -1;\n\n    /* we know that backing[0] now equals to \"nbd\" */\n\n    if (VIR_ALLOC_N(src->hosts, 1) < 0)\n        return -1;\n\n    src->nhosts = 1;\n    src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* format: [] denotes optional sections, uppercase are variable strings\n     * nbd:unix:/PATH/TO/SOCKET[:exportname=EXPORTNAME]\n     * nbd:HOSTNAME:PORT[:exportname=EXPORTNAME]\n     */\n    if (!backing[1]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing remote information in '%s' for protocol nbd\"),\n                       nbdstr);\n        return -1;\n    } else if (STREQ(backing[1], \"unix\")) {\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing unix socket path in nbd backing string %s\"),\n                           nbdstr);\n            return -1;\n        }\n\n        src->hosts->socket = g_strdup(backing[2]);\n        src->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_UNIX;\n   } else {\n        src->hosts->name = g_strdup(backing[1]);\n\n        if (!backing[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing port in nbd string '%s'\"),\n                           nbdstr);\n            return -1;\n        }\n\n        if (virStringParsePort(backing[2], &src->hosts->port) < 0)\n            return -1;\n    }\n\n    if ((exportname = strstr(nbdstr, \"exportname=\"))) {\n        exportname += strlen(\"exportname=\");\n        src->path = g_strdup(exportname);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceParseRBDColonString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2940-3042",
    "snippet": "int\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "p + strlen(\"conf=\")"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"conf=\""
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "p",
            "\"conf=\""
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceRBDAddHost",
          "args": [
            "src",
            "h"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceRBDAddHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2895-2937",
          "snippet": "static int\nvirStorageSourceRBDAddHost(virStorageSourcePtr src,\n                           char *hostport)\n{\n    char *port;\n    size_t skip;\n    VIR_AUTOSTRINGLIST parts = NULL;\n\n    if (VIR_EXPAND_N(src->hosts, src->nhosts, 1) < 0)\n        return -1;\n\n    if ((port = strchr(hostport, ']'))) {\n        /* ipv6, strip brackets */\n        hostport += 1;\n        skip = 3;\n    } else {\n        port = strstr(hostport, \"\\\\:\");\n        skip = 2;\n    }\n\n    if (port) {\n        *port = '\\0';\n        port += skip;\n        if (virStringParsePort(port, &src->hosts[src->nhosts - 1].port) < 0)\n            goto error;\n    }\n\n    parts = virStringSplit(hostport, \"\\\\:\", 0);\n    if (!parts)\n        goto error;\n    src->hosts[src->nhosts-1].name = virStringListJoin((const char **)parts, \":\");\n    if (!src->hosts[src->nhosts-1].name)\n        goto error;\n\n    src->hosts[src->nhosts-1].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    src->hosts[src->nhosts-1].socket = NULL;\n\n    return 0;\n\n error:\n    VIR_FREE(src->hosts[src->nhosts-1].name);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceRBDAddHost(virStorageSourcePtr src,\n                           char *hostport)\n{\n    char *port;\n    size_t skip;\n    VIR_AUTOSTRINGLIST parts = NULL;\n\n    if (VIR_EXPAND_N(src->hosts, src->nhosts, 1) < 0)\n        return -1;\n\n    if ((port = strchr(hostport, ']'))) {\n        /* ipv6, strip brackets */\n        hostport += 1;\n        skip = 3;\n    } else {\n        port = strstr(hostport, \"\\\\:\");\n        skip = 2;\n    }\n\n    if (port) {\n        *port = '\\0';\n        port += skip;\n        if (virStringParsePort(port, &src->hosts[src->nhosts - 1].port) < 0)\n            goto error;\n    }\n\n    parts = virStringSplit(hostport, \"\\\\:\", 0);\n    if (!parts)\n        goto error;\n    src->hosts[src->nhosts-1].name = virStringListJoin((const char **)parts, \":\");\n    if (!src->hosts[src->nhosts-1].name)\n        goto error;\n\n    src->hosts[src->nhosts-1].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    src->hosts[src->nhosts-1].socket = NULL;\n\n    return 0;\n\n error:\n    VIR_FREE(src->hosts[src->nhosts-1].name);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"mon_host=\""
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "p",
            "\"mon_host=\""
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&authdef"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretUsageTypeToString",
          "args": [
            "VIR_SECRET_USAGE_TYPE_CEPH"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id=\""
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "authdef"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"duplicate 'id' found in '%s'\")",
            "src->path"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "p",
            "\"id=\""
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&src->path"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "'/'"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "'@'"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "':'"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rbd:\""
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "rbdstr",
            "\"rbd:\""
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceRBDAddHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2895-2937",
    "snippet": "static int\nvirStorageSourceRBDAddHost(virStorageSourcePtr src,\n                           char *hostport)\n{\n    char *port;\n    size_t skip;\n    VIR_AUTOSTRINGLIST parts = NULL;\n\n    if (VIR_EXPAND_N(src->hosts, src->nhosts, 1) < 0)\n        return -1;\n\n    if ((port = strchr(hostport, ']'))) {\n        /* ipv6, strip brackets */\n        hostport += 1;\n        skip = 3;\n    } else {\n        port = strstr(hostport, \"\\\\:\");\n        skip = 2;\n    }\n\n    if (port) {\n        *port = '\\0';\n        port += skip;\n        if (virStringParsePort(port, &src->hosts[src->nhosts - 1].port) < 0)\n            goto error;\n    }\n\n    parts = virStringSplit(hostport, \"\\\\:\", 0);\n    if (!parts)\n        goto error;\n    src->hosts[src->nhosts-1].name = virStringListJoin((const char **)parts, \":\");\n    if (!src->hosts[src->nhosts-1].name)\n        goto error;\n\n    src->hosts[src->nhosts-1].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    src->hosts[src->nhosts-1].socket = NULL;\n\n    return 0;\n\n error:\n    VIR_FREE(src->hosts[src->nhosts-1].name);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->hosts[src->nhosts-1].name"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListJoin",
          "args": [
            "(const char **)parts",
            "\":\""
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "147-162",
          "snippet": "char *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "hostport",
            "\"\\\\:\"",
            "0"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringParsePort",
          "args": [
            "port",
            "&src->hosts[src->nhosts - 1].port"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParsePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1358-1384",
          "snippet": "int\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringParsePort(const char *str,\n                   unsigned int *port)\n{\n    unsigned int p = 0;\n\n    *port = 0;\n\n    if (!str)\n        return 0;\n\n    if (virStrToLong_uip(str, NULL, 10, &p) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to parse port number '%s'\"), str);\n        return -1;\n    }\n\n    if (p > UINT16_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"port '%s' out of range\"), str);\n        return -1;\n    }\n\n    *port = p;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "hostport",
            "\"\\\\:\""
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hostport",
            "']'"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "src->hosts",
            "src->nhosts",
            "1"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceRBDAddHost(virStorageSourcePtr src,\n                           char *hostport)\n{\n    char *port;\n    size_t skip;\n    VIR_AUTOSTRINGLIST parts = NULL;\n\n    if (VIR_EXPAND_N(src->hosts, src->nhosts, 1) < 0)\n        return -1;\n\n    if ((port = strchr(hostport, ']'))) {\n        /* ipv6, strip brackets */\n        hostport += 1;\n        skip = 3;\n    } else {\n        port = strstr(hostport, \"\\\\:\");\n        skip = 2;\n    }\n\n    if (port) {\n        *port = '\\0';\n        port += skip;\n        if (virStringParsePort(port, &src->hosts[src->nhosts - 1].port) < 0)\n            goto error;\n    }\n\n    parts = virStringSplit(hostport, \"\\\\:\", 0);\n    if (!parts)\n        goto error;\n    src->hosts[src->nhosts-1].name = virStringListJoin((const char **)parts, \":\");\n    if (!src->hosts[src->nhosts-1].name)\n        goto error;\n\n    src->hosts[src->nhosts-1].transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    src->hosts[src->nhosts-1].socket = NULL;\n\n    return 0;\n\n error:\n    VIR_FREE(src->hosts[src->nhosts-1].name);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageSourceParseBackingURI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2798-2892",
    "snippet": "static int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "uri->server"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\")",
            "src->path"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "'/'"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"missing volume name and path for gluster volume\")"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "uri->query",
            "\"socket=\""
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid protocol transport type '%s'\")",
            "scheme[1]"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetHostTransportTypeFromString",
          "args": [
            "scheme[1]"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid backing protocol '%s'\")",
            "NULLSTR(scheme[0])"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "scheme[0]"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeFromString",
          "args": [
            "scheme[0]"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "uri->scheme",
            "\"+\"",
            "2"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "src->hosts"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse backing file location '%s'\")",
            "uristr"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uristr"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceParseBackingURI(virStorageSourcePtr src,\n                                const char *uristr)\n{\n    g_autoptr(virURI) uri = NULL;\n    const char *path = NULL;\n    VIR_AUTOSTRINGLIST scheme = NULL;\n\n    if (!(uri = virURIParse(uristr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse backing file location '%s'\"),\n                       uristr);\n        return -1;\n    }\n\n    if (VIR_ALLOC(src->hosts) < 0)\n        return -1;\n\n    src->nhosts = 1;\n\n    if (!(scheme = virStringSplit(uri->scheme, \"+\", 2)))\n        return -1;\n\n    if (!scheme[0] ||\n        (src->protocol = virStorageNetProtocolTypeFromString(scheme[0])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid backing protocol '%s'\"),\n                       NULLSTR(scheme[0]));\n        return -1;\n    }\n\n    if (scheme[1] &&\n        (src->hosts->transport = virStorageNetHostTransportTypeFromString(scheme[1])) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid protocol transport type '%s'\"),\n                       scheme[1]);\n        return -1;\n    }\n\n    /* handle socket stored as a query */\n    if (uri->query)\n        src->hosts->socket = g_strdup(STRSKIP(uri->query, \"socket=\"));\n\n    /* uri->path is NULL if the URI does not contain slash after host:\n     * transport://host:port */\n    if (uri->path)\n        path = uri->path;\n    else\n        path = \"\";\n\n    /* possibly skip the leading slash  */\n    if (path[0] == '/')\n        path++;\n\n    /* NBD allows empty export name (path) */\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_NBD &&\n        path[0] == '\\0')\n        path = NULL;\n\n    src->path = g_strdup(path);\n\n    if (src->protocol == VIR_STORAGE_NET_PROTOCOL_GLUSTER) {\n        char *tmp;\n\n        if (!src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"missing volume name and path for gluster volume\"));\n            return -1;\n        }\n\n        if (!(tmp = strchr(src->path, '/')) ||\n            tmp == src->path) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"missing volume name or file name in \"\n                             \"gluster source path '%s'\"), src->path);\n            return -1;\n        }\n\n        src->volume = src->path;\n\n        src->path = g_strdup(tmp + 1);\n\n        tmp[0] = '\\0';\n    }\n\n    src->hosts->port = uri->port;\n\n    src->hosts->name = g_strdup(uri->server);\n\n    /* Libvirt doesn't handle inline authentication. Make the caller aware. */\n    if (uri->user)\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceNewFromBackingRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2754-2795",
    "snippet": "static virStorageSourcePtr\nvirStorageSourceNewFromBackingRelative(virStorageSourcePtr parent,\n                                       const char *rel)\n{\n    g_autofree char *dirname = NULL;\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    /* store relative name */\n    def->relPath = g_strdup(rel);\n\n    dirname = g_path_get_dirname(parent->path);\n\n    if (STRNEQ(dirname, \"/\")) {\n        def->path = g_strdup_printf(\"%s/%s\", dirname, rel);\n    } else {\n        def->path = g_strdup_printf(\"/%s\", rel);\n    }\n\n    if (virStorageSourceGetActualType(parent) == VIR_STORAGE_TYPE_NETWORK) {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        /* copy the host network part */\n        def->protocol = parent->protocol;\n        if (parent->nhosts) {\n            if (!(def->hosts = virStorageNetHostDefCopy(parent->nhosts,\n                                                        parent->hosts)))\n                return NULL;\n\n            def->nhosts = parent->nhosts;\n        }\n\n        def->volume = g_strdup(parent->volume);\n    } else {\n        /* set the type to _FILE, the caller shall update it to the actual type */\n        def->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "parent->volume"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageNetHostDefCopy",
          "args": [
            "parent->nhosts",
            "parent->hosts"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1740-1766",
          "snippet": "virStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "parent"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "dirname",
            "\"/\""
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "parent->path"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePtr\nvirStorageSourceNewFromBackingRelative(virStorageSourcePtr parent,\n                                       const char *rel)\n{\n    g_autofree char *dirname = NULL;\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    /* store relative name */\n    def->relPath = g_strdup(rel);\n\n    dirname = g_path_get_dirname(parent->path);\n\n    if (STRNEQ(dirname, \"/\")) {\n        def->path = g_strdup_printf(\"%s/%s\", dirname, rel);\n    } else {\n        def->path = g_strdup_printf(\"/%s\", rel);\n    }\n\n    if (virStorageSourceGetActualType(parent) == VIR_STORAGE_TYPE_NETWORK) {\n        def->type = VIR_STORAGE_TYPE_NETWORK;\n\n        /* copy the host network part */\n        def->protocol = parent->protocol;\n        if (parent->nhosts) {\n            if (!(def->hosts = virStorageNetHostDefCopy(parent->nhosts,\n                                                        parent->hosts)))\n                return NULL;\n\n            def->nhosts = parent->nhosts;\n        }\n\n        def->volume = g_strdup(parent->volume);\n    } else {\n        /* set the type to _FILE, the caller shall update it to the actual type */\n        def->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virStorageSourceNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2744-2751",
    "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virStorageSourceClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virStorageSourceClass"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceInitialize",
          "args": [],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
  },
  {
    "function_name": "virStorageSourceOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2731-2738",
    "snippet": "static int\nvirStorageSourceOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virStorageSource, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virStorageSource",
            "virClassForObject()"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageSourceOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virStorageSource, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2722-2728",
    "snippet": "static void\nvirStorageSourceDispose(void *obj)\n{\n    virStorageSourcePtr src = obj;\n\n    virStorageSourceClear(src);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceClear",
          "args": [
            "src"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2672-2719",
          "snippet": "void\nvirStorageSourceClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->path);\n    VIR_FREE(def->volume);\n    VIR_FREE(def->snapshot);\n    VIR_FREE(def->configFile);\n    virStorageSourceNetCookiesClear(def);\n    virStorageSourcePoolDefFree(def->srcpool);\n    virBitmapFree(def->features);\n    VIR_FREE(def->compat);\n    virStorageEncryptionFree(def->encryption);\n    virStoragePRDefFree(def->pr);\n    virStorageSourceNVMeDefFree(def->nvme);\n    virStorageSourceSeclabelsClear(def);\n    virStoragePermsFree(def->perms);\n    VIR_FREE(def->timestamps);\n    VIR_FREE(def->externalDataStoreRaw);\n\n    virStorageSourceSliceFree(def->sliceStorage);\n\n    virObjectUnref(def->externalDataStore);\n    def->externalDataStore = NULL;\n\n    virStorageNetHostDefFree(def->nhosts, def->hosts);\n    virStorageAuthDefFree(def->auth);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def->nodestorage);\n    VIR_FREE(def->nodeformat);\n\n    virStorageSourceBackingStoreClear(def);\n\n    VIR_FREE(def->tlsAlias);\n    VIR_FREE(def->tlsCertdir);\n\n    VIR_FREE(def->ssh_user);\n\n    virStorageSourceInitiatorClear(&def->initiator);\n\n    /* clear everything except the class header as the object APIs\n     * will break otherwise */\n    memset((char *) def + sizeof(def->parent), 0,\n           sizeof(*def) - sizeof(def->parent));\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->path);\n    VIR_FREE(def->volume);\n    VIR_FREE(def->snapshot);\n    VIR_FREE(def->configFile);\n    virStorageSourceNetCookiesClear(def);\n    virStorageSourcePoolDefFree(def->srcpool);\n    virBitmapFree(def->features);\n    VIR_FREE(def->compat);\n    virStorageEncryptionFree(def->encryption);\n    virStoragePRDefFree(def->pr);\n    virStorageSourceNVMeDefFree(def->nvme);\n    virStorageSourceSeclabelsClear(def);\n    virStoragePermsFree(def->perms);\n    VIR_FREE(def->timestamps);\n    VIR_FREE(def->externalDataStoreRaw);\n\n    virStorageSourceSliceFree(def->sliceStorage);\n\n    virObjectUnref(def->externalDataStore);\n    def->externalDataStore = NULL;\n\n    virStorageNetHostDefFree(def->nhosts, def->hosts);\n    virStorageAuthDefFree(def->auth);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def->nodestorage);\n    VIR_FREE(def->nodeformat);\n\n    virStorageSourceBackingStoreClear(def);\n\n    VIR_FREE(def->tlsAlias);\n    VIR_FREE(def->tlsCertdir);\n\n    VIR_FREE(def->ssh_user);\n\n    virStorageSourceInitiatorClear(&def->initiator);\n\n    /* clear everything except the class header as the object APIs\n     * will break otherwise */\n    memset((char *) def + sizeof(def->parent), 0,\n           sizeof(*def) - sizeof(def->parent));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic void\nvirStorageSourceDispose(void *obj)\n{\n    virStorageSourcePtr src = obj;\n\n    virStorageSourceClear(src);\n}"
  },
  {
    "function_name": "virStorageSourceClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2672-2719",
    "snippet": "void\nvirStorageSourceClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->path);\n    VIR_FREE(def->volume);\n    VIR_FREE(def->snapshot);\n    VIR_FREE(def->configFile);\n    virStorageSourceNetCookiesClear(def);\n    virStorageSourcePoolDefFree(def->srcpool);\n    virBitmapFree(def->features);\n    VIR_FREE(def->compat);\n    virStorageEncryptionFree(def->encryption);\n    virStoragePRDefFree(def->pr);\n    virStorageSourceNVMeDefFree(def->nvme);\n    virStorageSourceSeclabelsClear(def);\n    virStoragePermsFree(def->perms);\n    VIR_FREE(def->timestamps);\n    VIR_FREE(def->externalDataStoreRaw);\n\n    virStorageSourceSliceFree(def->sliceStorage);\n\n    virObjectUnref(def->externalDataStore);\n    def->externalDataStore = NULL;\n\n    virStorageNetHostDefFree(def->nhosts, def->hosts);\n    virStorageAuthDefFree(def->auth);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def->nodestorage);\n    VIR_FREE(def->nodeformat);\n\n    virStorageSourceBackingStoreClear(def);\n\n    VIR_FREE(def->tlsAlias);\n    VIR_FREE(def->tlsCertdir);\n\n    VIR_FREE(def->ssh_user);\n\n    virStorageSourceInitiatorClear(&def->initiator);\n\n    /* clear everything except the class header as the object APIs\n     * will break otherwise */\n    memset((char *) def + sizeof(def->parent), 0,\n           sizeof(*def) - sizeof(def->parent));\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) def + sizeof(def->parent)",
            "0",
            "sizeof(*def) - sizeof(def->parent)"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceInitiatorClear",
          "args": [
            "&def->initiator"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceInitiatorClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4703-4707",
          "snippet": "void\nvirStorageSourceInitiatorClear(virStorageSourceInitiatorDefPtr initiator)\n{\n    VIR_FREE(initiator->iqn);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceInitiatorClear(virStorageSourceInitiatorDefPtr initiator)\n{\n    VIR_FREE(initiator->iqn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ssh_user"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->tlsCertdir"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->tlsAlias"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceBackingStoreClear",
          "args": [
            "def"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceBackingStoreClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2657-2669",
          "snippet": "void\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->nodeformat"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->nodestorage"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "def->privateData"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageAuthDefFree",
          "args": [
            "def->auth"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageAuthDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1769-1779",
          "snippet": "void\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageNetHostDefFree",
          "args": [
            "def->nhosts",
            "def->hosts"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1713-1726",
          "snippet": "void\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceSliceFree",
          "args": [
            "def->sliceStorage"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSliceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2336-2344",
          "snippet": "static void\nvirStorageSourceSliceFree(virStorageSourceSlicePtr slice)\n{\n    if (!slice)\n        return;\n\n    g_free(slice->nodename);\n    g_free(slice);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic void\nvirStorageSourceSliceFree(virStorageSourceSlicePtr slice)\n{\n    if (!slice)\n        return;\n\n    g_free(slice->nodename);\n    g_free(slice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->externalDataStoreRaw"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->timestamps"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePermsFree",
          "args": [
            "def->perms"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePermsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1729-1737",
          "snippet": "static void\nvirStoragePermsFree(virStoragePermsPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic void\nvirStoragePermsFree(virStoragePermsPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceSeclabelsClear",
          "args": [
            "def"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSeclabelsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2120-2130",
          "snippet": "static void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNVMeDefFree",
          "args": [
            "def->nvme"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNVMeDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2081-2088",
          "snippet": "void\nvirStorageSourceNVMeDefFree(virStorageSourceNVMeDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceNVMeDefFree(virStorageSourceNVMeDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePRDefFree",
          "args": [
            "def->pr"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePRDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1882-1891",
          "snippet": "void\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageEncryptionFree",
          "args": [
            "def->encryption"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageEncryptionFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstorageencryption.c",
          "lines": "70-83",
          "snippet": "void\nvirStorageEncryptionFree(virStorageEncryptionPtr enc)\n{\n    size_t i;\n\n    if (!enc)\n        return;\n\n    for (i = 0; i < enc->nsecrets; i++)\n        virStorageEncryptionSecretFree(enc->secrets[i]);\n    virStorageEncryptionInfoDefFree(&enc->encinfo);\n    VIR_FREE(enc->secrets);\n    VIR_FREE(enc);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virerror.h\"",
            "#include \"virxml.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virerror.h\"\n#include \"virxml.h\"\n#include \"virstorageencryption.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirStorageEncryptionFree(virStorageEncryptionPtr enc)\n{\n    size_t i;\n\n    if (!enc)\n        return;\n\n    for (i = 0; i < enc->nsecrets; i++)\n        virStorageEncryptionSecretFree(enc->secrets[i]);\n    virStorageEncryptionInfoDefFree(&enc->encinfo);\n    VIR_FREE(enc->secrets);\n    VIR_FREE(enc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->compat"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "def->features"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourcePoolDefFree",
          "args": [
            "def->srcpool"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourcePoolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2553-2563",
          "snippet": "void\nvirStorageSourcePoolDefFree(virStorageSourcePoolDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->pool);\n    VIR_FREE(def->volume);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourcePoolDefFree(virStorageSourcePoolDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->pool);\n    VIR_FREE(def->volume);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNetCookiesClear",
          "args": [
            "def"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNetCookiesClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2172-2185",
          "snippet": "static void\nvirStorageSourceNetCookiesClear(virStorageSourcePtr src)\n{\n    size_t i;\n\n    if (!src || !src->cookies)\n        return;\n\n    for (i = 0; i < src->ncookies; i++)\n        virStorageNetCookieDefFree(src->cookies[i]);\n\n    g_clear_pointer(&src->cookies, g_free);\n    src->ncookies = 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceNetCookiesClear(virStorageSourcePtr src)\n{\n    size_t i;\n\n    if (!src || !src->cookies)\n        return;\n\n    for (i = 0; i < src->ncookies; i++)\n        virStorageNetCookieDefFree(src->cookies[i]);\n\n    g_clear_pointer(&src->cookies, g_free);\n    src->ncookies = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->configFile"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->snapshot"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->volume"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->path"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->path);\n    VIR_FREE(def->volume);\n    VIR_FREE(def->snapshot);\n    VIR_FREE(def->configFile);\n    virStorageSourceNetCookiesClear(def);\n    virStorageSourcePoolDefFree(def->srcpool);\n    virBitmapFree(def->features);\n    VIR_FREE(def->compat);\n    virStorageEncryptionFree(def->encryption);\n    virStoragePRDefFree(def->pr);\n    virStorageSourceNVMeDefFree(def->nvme);\n    virStorageSourceSeclabelsClear(def);\n    virStoragePermsFree(def->perms);\n    VIR_FREE(def->timestamps);\n    VIR_FREE(def->externalDataStoreRaw);\n\n    virStorageSourceSliceFree(def->sliceStorage);\n\n    virObjectUnref(def->externalDataStore);\n    def->externalDataStore = NULL;\n\n    virStorageNetHostDefFree(def->nhosts, def->hosts);\n    virStorageAuthDefFree(def->auth);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def->nodestorage);\n    VIR_FREE(def->nodeformat);\n\n    virStorageSourceBackingStoreClear(def);\n\n    VIR_FREE(def->tlsAlias);\n    VIR_FREE(def->tlsCertdir);\n\n    VIR_FREE(def->ssh_user);\n\n    virStorageSourceInitiatorClear(&def->initiator);\n\n    /* clear everything except the class header as the object APIs\n     * will break otherwise */\n    memset((char *) def + sizeof(def->parent), 0,\n           sizeof(*def) - sizeof(def->parent));\n}"
  },
  {
    "function_name": "virStorageSourceBackingStoreClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2657-2669",
    "snippet": "void\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "def->backingStore"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->backingStoreRaw"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->relPath"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}"
  },
  {
    "function_name": "virStorageSourceIsBlockLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2643-2647",
    "snippet": "bool\nvirStorageSourceIsBlockLocal(const virStorageSource *src)\n{\n    return virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_BLOCK;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBlockLocal(const virStorageSource *src)\n{\n    return virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_BLOCK;\n}"
  },
  {
    "function_name": "virStorageSourceIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2619-2633",
    "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virStorageSourceIsLocalStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2586-2608",
    "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virStorageSourceGetActualType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2574-2583",
    "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
  },
  {
    "function_name": "virStorageSourcePoolDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2553-2563",
    "snippet": "void\nvirStorageSourcePoolDefFree(virStorageSourcePoolDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->pool);\n    VIR_FREE(def->volume);\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->volume"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->pool"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourcePoolDefFree(virStorageSourcePoolDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->pool);\n    VIR_FREE(def->volume);\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virStorageSourceInitChainElement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2536-2550",
    "snippet": "int\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceSeclabelsCopy",
          "args": [
            "newelem",
            "old"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSeclabelsCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2133-2156",
          "snippet": "static int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceIsSameLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2480-2518",
    "snippet": "bool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceNVMeDefIsEqual",
          "args": [
            "a->nvme",
            "b->nvme"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNVMeDefIsEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2062-2078",
          "snippet": "static bool\nvirStorageSourceNVMeDefIsEqual(const virStorageSourceNVMeDef *a,\n                               const virStorageSourceNVMeDef *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->namespace != b->namespace ||\n        a->managed != b->managed ||\n        !virPCIDeviceAddressEqual(&a->pciAddr, &b->pciAddr))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageSourceNVMeDefIsEqual(const virStorageSourceNVMeDef *a,\n                               const virStorageSourceNVMeDef *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->namespace != b->namespace ||\n        a->managed != b->managed ||\n        !virPCIDeviceAddressEqual(&a->pciAddr, &b->pciAddr))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->hosts[i].socket",
            "b->hosts[i].socket"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->hosts[i].name",
            "b->hosts[i].name"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->snapshot",
            "b->snapshot"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->volume",
            "b->volume"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->path",
            "b->path"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "b"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "b"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nbool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStorageSourceCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2356-2471",
    "snippet": "virStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->ssh_user"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceCopy",
          "args": [
            "src->externalDataStore",
            "true"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2356-2471",
          "snippet": "virStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceInitiatorCopy",
          "args": [
            "&def->initiator",
            "&src->initiator"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceInitiatorCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4695-4701",
          "snippet": "int\nvirStorageSourceInitiatorCopy(virStorageSourceInitiatorDefPtr dest,\n                              const virStorageSourceInitiatorDef *src)\n{\n    dest->iqn = g_strdup(src->iqn);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceInitiatorCopy(virStorageSourceInitiatorDefPtr dest,\n                              const virStorageSourceInitiatorDef *src)\n{\n    dest->iqn = g_strdup(src->iqn);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNVMeDefCopy",
          "args": [
            "src->nvme"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNVMeDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2048-2059",
          "snippet": "static virStorageSourceNVMeDefPtr\nvirStorageSourceNVMeDefCopy(const virStorageSourceNVMeDef *src)\n{\n    virStorageSourceNVMeDefPtr ret = NULL;\n\n    ret = g_new0(virStorageSourceNVMeDef, 1);\n\n    ret->namespace = src->namespace;\n    ret->managed = src->managed;\n    virPCIDeviceAddressCopy(&ret->pciAddr, &src->pciAddr);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourceNVMeDefPtr\nvirStorageSourceNVMeDefCopy(const virStorageSourceNVMeDef *src)\n{\n    virStorageSourceNVMeDefPtr ret = NULL;\n\n    ret = g_new0(virStorageSourceNVMeDef, 1);\n\n    ret->namespace = src->namespace;\n    ret->managed = src->managed;\n    virPCIDeviceAddressCopy(&ret->pciAddr, &src->pciAddr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePRDefCopy",
          "args": [
            "src->pr"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePRDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2027-2045",
          "snippet": "static virStoragePRDefPtr\nvirStoragePRDefCopy(virStoragePRDefPtr src)\n{\n    virStoragePRDefPtr copy = NULL;\n    virStoragePRDefPtr ret = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->managed = src->managed;\n\n    copy->path = g_strdup(src->path);\n    copy->mgralias = g_strdup(src->mgralias);\n\n    ret = g_steal_pointer(&copy);\n\n    virStoragePRDefFree(copy);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStoragePRDefPtr\nvirStoragePRDefCopy(virStoragePRDefPtr src)\n{\n    virStoragePRDefPtr copy = NULL;\n    virStoragePRDefPtr ret = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->managed = src->managed;\n\n    copy->path = g_strdup(src->path);\n    copy->mgralias = g_strdup(src->mgralias);\n\n    ret = g_steal_pointer(&copy);\n\n    virStoragePRDefFree(copy);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageAuthDefCopy",
          "args": [
            "src->auth"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageAuthDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1782-1798",
          "snippet": "virStorageAuthDefPtr\nvirStorageAuthDefCopy(const virStorageAuthDef *src)\n{\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    if (VIR_ALLOC(authdef) < 0)\n        return NULL;\n\n    authdef->username = g_strdup(src->username);\n    /* Not present for storage pool, but used for disk source */\n    authdef->secrettype = g_strdup(src->secrettype);\n    authdef->authType = src->authType;\n\n    virSecretLookupDefCopy(&authdef->seclookupdef, &src->seclookupdef);\n\n    return g_steal_pointer(&authdef);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageAuthDefPtr\nvirStorageAuthDefCopy(const virStorageAuthDef *src)\n{\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    if (VIR_ALLOC(authdef) < 0)\n        return NULL;\n\n    authdef->username = g_strdup(src->username);\n    /* Not present for storage pool, but used for disk source */\n    authdef->secrettype = g_strdup(src->secrettype);\n    authdef->authType = src->authType;\n\n    virSecretLookupDefCopy(&authdef->seclookupdef, &src->seclookupdef);\n\n    return g_steal_pointer(&authdef);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceSeclabelsCopy",
          "args": [
            "def",
            "src"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSeclabelsCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2133-2156",
          "snippet": "static int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTimestampsCopy",
          "args": [
            "src->timestamps"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageTimestampsCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2271-2282",
          "snippet": "static virStorageTimestampsPtr\nvirStorageTimestampsCopy(const virStorageTimestamps *src)\n{\n    virStorageTimestampsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    memcpy(ret, src, sizeof(*src));\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageTimestampsPtr\nvirStorageTimestampsCopy(const virStorageTimestamps *src)\n{\n    virStorageTimestampsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    memcpy(ret, src, sizeof(*src));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePermsCopy",
          "args": [
            "src->perms"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePermsCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2285-2300",
          "snippet": "static virStoragePermsPtr\nvirStoragePermsCopy(const virStoragePerms *src)\n{\n    virStoragePermsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->mode = src->mode;\n    ret->uid = src->uid;\n    ret->gid = src->gid;\n\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStoragePermsPtr\nvirStoragePermsCopy(const virStoragePerms *src)\n{\n    virStoragePermsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->mode = src->mode;\n    ret->uid = src->uid;\n    ret->gid = src->gid;\n\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageEncryptionCopy",
          "args": [
            "src->encryption"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageEncryptionCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstorageencryption.c",
          "lines": "112-140",
          "snippet": "virStorageEncryptionPtr\nvirStorageEncryptionCopy(const virStorageEncryption *src)\n{\n    virStorageEncryptionPtr ret;\n    size_t i;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(ret->secrets, src->nsecrets) < 0)\n        goto error;\n\n    ret->nsecrets = src->nsecrets;\n    ret->format = src->format;\n\n    for (i = 0; i < src->nsecrets; i++) {\n        if (!(ret->secrets[i] = virStorageEncryptionSecretCopy(src->secrets[i])))\n            goto error;\n    }\n\n    if (virStorageEncryptionInfoDefCopy(&src->encinfo, &ret->encinfo) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virStorageEncryptionFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virerror.h\"",
            "#include \"virxml.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virerror.h\"\n#include \"virxml.h\"\n#include \"virstorageencryption.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirStorageEncryptionPtr\nvirStorageEncryptionCopy(const virStorageEncryption *src)\n{\n    virStorageEncryptionPtr ret;\n    size_t i;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(ret->secrets, src->nsecrets) < 0)\n        goto error;\n\n    ret->nsecrets = src->nsecrets;\n    ret->format = src->format;\n\n    for (i = 0; i < src->nsecrets; i++) {\n        if (!(ret->secrets[i] = virStorageEncryptionSecretCopy(src->secrets[i])))\n            goto error;\n    }\n\n    if (virStorageEncryptionInfoDefCopy(&src->encinfo, &ret->encinfo) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virStorageEncryptionFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewCopy",
          "args": [
            "src->features"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "707-721",
          "snippet": "virBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourcePoolDefCopy",
          "args": [
            "src->srcpool"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourcePoolDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2303-2320",
          "snippet": "static virStorageSourcePoolDefPtr\nvirStorageSourcePoolDefCopy(const virStorageSourcePoolDef *src)\n{\n    virStorageSourcePoolDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->voltype = src->voltype;\n    ret->pooltype = src->pooltype;\n    ret->actualtype = src->actualtype;\n    ret->mode = src->mode;\n\n    ret->pool = g_strdup(src->pool);\n    ret->volume = g_strdup(src->volume);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePoolDefPtr\nvirStorageSourcePoolDefCopy(const virStorageSourcePoolDef *src)\n{\n    virStorageSourcePoolDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->voltype = src->voltype;\n    ret->pooltype = src->pooltype;\n    ret->actualtype = src->actualtype;\n    ret->mode = src->mode;\n\n    ret->pool = g_strdup(src->pool);\n    ret->volume = g_strdup(src->volume);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNetCookiesCopy",
          "args": [
            "def",
            "src"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNetCookiesCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2188-2204",
          "snippet": "static void\nvirStorageSourceNetCookiesCopy(virStorageSourcePtr to,\n                               const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->ncookies == 0)\n        return;\n\n    to->cookies = g_new0(virStorageNetCookieDefPtr, from->ncookies);\n    to->ncookies = from->ncookies;\n\n    for (i = 0; i < from->ncookies; i++) {\n        to->cookies[i]->name = g_strdup(from->cookies[i]->name);\n        to->cookies[i]->value = g_strdup(from->cookies[i]->value);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceNetCookiesCopy(virStorageSourcePtr to,\n                               const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->ncookies == 0)\n        return;\n\n    to->cookies = g_new0(virStorageNetCookieDefPtr, from->ncookies);\n    to->ncookies = from->ncookies;\n\n    for (i = 0; i < from->ncookies; i++) {\n        to->cookies[i]->name = g_strdup(from->cookies[i]->name);\n        to->cookies[i]->value = g_strdup(from->cookies[i]->value);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageNetHostDefCopy",
          "args": [
            "src->nhosts",
            "src->hosts"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1740-1766",
          "snippet": "virStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceSliceCopy",
          "args": [
            "src->sliceStorage"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSliceCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2323-2333",
          "snippet": "static virStorageSourceSlicePtr\nvirStorageSourceSliceCopy(const virStorageSourceSlice *src)\n{\n    virStorageSourceSlicePtr ret = g_new0(virStorageSourceSlice, 1);\n\n    ret->offset = src->offset;\n    ret->size = src->size;\n    ret->nodename = g_strdup(src->nodename);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourceSlicePtr\nvirStorageSourceSliceCopy(const virStorageSourceSlice *src)\n{\n    virStorageSourceSlicePtr ret = g_new0(virStorageSourceSlice, 1);\n\n    ret->offset = src->offset;\n    ret->size = src->size;\n    ret->nodename = g_strdup(src->nodename);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virStorageSourceSliceFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2336-2344",
    "snippet": "static void\nvirStorageSourceSliceFree(virStorageSourceSlicePtr slice)\n{\n    if (!slice)\n        return;\n\n    g_free(slice->nodename);\n    g_free(slice);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "slice"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "slice->nodename"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic void\nvirStorageSourceSliceFree(virStorageSourceSlicePtr slice)\n{\n    if (!slice)\n        return;\n\n    g_free(slice->nodename);\n    g_free(slice);\n}"
  },
  {
    "function_name": "virStorageSourceSliceCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2323-2333",
    "snippet": "static virStorageSourceSlicePtr\nvirStorageSourceSliceCopy(const virStorageSourceSlice *src)\n{\n    virStorageSourceSlicePtr ret = g_new0(virStorageSourceSlice, 1);\n\n    ret->offset = src->offset;\n    ret->size = src->size;\n    ret->nodename = g_strdup(src->nodename);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->nodename"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageSourceSlice",
            "1"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourceSlicePtr\nvirStorageSourceSliceCopy(const virStorageSourceSlice *src)\n{\n    virStorageSourceSlicePtr ret = g_new0(virStorageSourceSlice, 1);\n\n    ret->offset = src->offset;\n    ret->size = src->size;\n    ret->nodename = g_strdup(src->nodename);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageSourcePoolDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2303-2320",
    "snippet": "static virStorageSourcePoolDefPtr\nvirStorageSourcePoolDefCopy(const virStorageSourcePoolDef *src)\n{\n    virStorageSourcePoolDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->voltype = src->voltype;\n    ret->pooltype = src->pooltype;\n    ret->actualtype = src->actualtype;\n    ret->mode = src->mode;\n\n    ret->pool = g_strdup(src->pool);\n    ret->volume = g_strdup(src->volume);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->volume"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePoolDefPtr\nvirStorageSourcePoolDefCopy(const virStorageSourcePoolDef *src)\n{\n    virStorageSourcePoolDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->voltype = src->voltype;\n    ret->pooltype = src->pooltype;\n    ret->actualtype = src->actualtype;\n    ret->mode = src->mode;\n\n    ret->pool = g_strdup(src->pool);\n    ret->volume = g_strdup(src->volume);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStoragePermsCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2285-2300",
    "snippet": "static virStoragePermsPtr\nvirStoragePermsCopy(const virStoragePerms *src)\n{\n    virStoragePermsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->mode = src->mode;\n    ret->uid = src->uid;\n    ret->gid = src->gid;\n\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->label"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStoragePermsPtr\nvirStoragePermsCopy(const virStoragePerms *src)\n{\n    virStoragePermsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->mode = src->mode;\n    ret->uid = src->uid;\n    ret->gid = src->gid;\n\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageTimestampsCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2271-2282",
    "snippet": "static virStorageTimestampsPtr\nvirStorageTimestampsCopy(const virStorageTimestamps *src)\n{\n    virStorageTimestampsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    memcpy(ret, src, sizeof(*src));\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "src",
            "sizeof(*src)"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageTimestampsPtr\nvirStorageTimestampsCopy(const virStorageTimestamps *src)\n{\n    virStorageTimestampsPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    memcpy(ret, src, sizeof(*src));\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageSourceNetCookiesValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2248-2268",
    "snippet": "int\nvirStorageSourceNetCookiesValidate(virStorageSourcePtr src)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < src->ncookies; i++) {\n        if (virStorageSourceNetCookieValidate(src->cookies[i]) < 0)\n            return -1;\n\n        for (j = i + 1; j < src->ncookies; j++) {\n            if (STREQ(src->cookies[i]->name, src->cookies[j]->name)) {\n                virReportError(VIR_ERR_XML_ERROR, _(\"duplicate cookie '%s'\"),\n                               src->cookies[i]->name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"duplicate cookie '%s'\")",
            "src->cookies[i]->name"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"duplicate cookie '%s'\""
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "src->cookies[i]->name",
            "src->cookies[j]->name"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceNetCookieValidate",
          "args": [
            "src->cookies[i]"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNetCookieValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2217-2245",
          "snippet": "static int\nvirStorageSourceNetCookieValidate(virStorageNetCookieDefPtr def)\n{\n    /* name must have at least 1 character */\n    if (*(def->name) == '\\0') {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"cookie name must not be empty\"));\n        return -1;\n    }\n\n    /* check invalid characters in name */\n    if (virStringHasChars(def->name, virStorageSourceCookieValueInvalidChars) ||\n        virStringHasChars(def->name, virStorageSourceCookieNameInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"cookie name '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    /* check invalid characters in value */\n    if (virStringHasChars(def->value, virStorageSourceCookieValueInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"value of cookie '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char virStorageSourceCookieValueInvalidChars[] =\n \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\"\n \" \\\",;\\\\\";",
            "static const char virStorageSourceCookieNameInvalidChars[] =\n \"()<>@:/[]?={}\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic const char virStorageSourceCookieValueInvalidChars[] =\n \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\"\n \" \\\",;\\\\\";\nstatic const char virStorageSourceCookieNameInvalidChars[] =\n \"()<>@:/[]?={}\";\n\nstatic int\nvirStorageSourceNetCookieValidate(virStorageNetCookieDefPtr def)\n{\n    /* name must have at least 1 character */\n    if (*(def->name) == '\\0') {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"cookie name must not be empty\"));\n        return -1;\n    }\n\n    /* check invalid characters in name */\n    if (virStringHasChars(def->name, virStorageSourceCookieValueInvalidChars) ||\n        virStringHasChars(def->name, virStorageSourceCookieNameInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"cookie name '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    /* check invalid characters in value */\n    if (virStringHasChars(def->value, virStorageSourceCookieValueInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"value of cookie '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nint\nvirStorageSourceNetCookiesValidate(virStorageSourcePtr src)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < src->ncookies; i++) {\n        if (virStorageSourceNetCookieValidate(src->cookies[i]) < 0)\n            return -1;\n\n        for (j = i + 1; j < src->ncookies; j++) {\n            if (STREQ(src->cookies[i]->name, src->cookies[j]->name)) {\n                virReportError(VIR_ERR_XML_ERROR, _(\"duplicate cookie '%s'\"),\n                               src->cookies[i]->name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceNetCookieValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2217-2245",
    "snippet": "static int\nvirStorageSourceNetCookieValidate(virStorageNetCookieDefPtr def)\n{\n    /* name must have at least 1 character */\n    if (*(def->name) == '\\0') {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"cookie name must not be empty\"));\n        return -1;\n    }\n\n    /* check invalid characters in name */\n    if (virStringHasChars(def->name, virStorageSourceCookieValueInvalidChars) ||\n        virStringHasChars(def->name, virStorageSourceCookieNameInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"cookie name '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    /* check invalid characters in value */\n    if (virStringHasChars(def->value, virStorageSourceCookieValueInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"value of cookie '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char virStorageSourceCookieValueInvalidChars[] =\n \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\"\n \" \\\",;\\\\\";",
      "static const char virStorageSourceCookieNameInvalidChars[] =\n \"()<>@:/[]?={}\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"value of cookie '%s' contains invalid characters\")",
            "def->name"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"value of cookie '%s' contains invalid characters\""
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringHasChars",
          "args": [
            "def->value",
            "virStorageSourceCookieValueInvalidChars"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1188-1196",
          "snippet": "bool\nvirStringHasChars(const char *str,\n                  const char *chars)\n{\n    if (!str)\n        return false;\n\n    return str[strcspn(str, chars)] != '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasChars(const char *str,\n                  const char *chars)\n{\n    if (!str)\n        return false;\n\n    return str[strcspn(str, chars)] != '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"cookie name '%s' contains invalid characters\")",
            "def->name"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cookie name must not be empty\")"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic const char virStorageSourceCookieValueInvalidChars[] =\n \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\"\n \" \\\",;\\\\\";\nstatic const char virStorageSourceCookieNameInvalidChars[] =\n \"()<>@:/[]?={}\";\n\nstatic int\nvirStorageSourceNetCookieValidate(virStorageNetCookieDefPtr def)\n{\n    /* name must have at least 1 character */\n    if (*(def->name) == '\\0') {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"cookie name must not be empty\"));\n        return -1;\n    }\n\n    /* check invalid characters in name */\n    if (virStringHasChars(def->name, virStorageSourceCookieValueInvalidChars) ||\n        virStringHasChars(def->name, virStorageSourceCookieNameInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"cookie name '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    /* check invalid characters in value */\n    if (virStringHasChars(def->value, virStorageSourceCookieValueInvalidChars)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"value of cookie '%s' contains invalid characters\"),\n                       def->name);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageSourceNetCookiesCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2188-2204",
    "snippet": "static void\nvirStorageSourceNetCookiesCopy(virStorageSourcePtr to,\n                               const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->ncookies == 0)\n        return;\n\n    to->cookies = g_new0(virStorageNetCookieDefPtr, from->ncookies);\n    to->ncookies = from->ncookies;\n\n    for (i = 0; i < from->ncookies; i++) {\n        to->cookies[i]->name = g_strdup(from->cookies[i]->name);\n        to->cookies[i]->value = g_strdup(from->cookies[i]->value);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "from->cookies[i]->value"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageNetCookieDefPtr",
            "from->ncookies"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceNetCookiesCopy(virStorageSourcePtr to,\n                               const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->ncookies == 0)\n        return;\n\n    to->cookies = g_new0(virStorageNetCookieDefPtr, from->ncookies);\n    to->ncookies = from->ncookies;\n\n    for (i = 0; i < from->ncookies; i++) {\n        to->cookies[i]->name = g_strdup(from->cookies[i]->name);\n        to->cookies[i]->value = g_strdup(from->cookies[i]->value);\n    }\n}"
  },
  {
    "function_name": "virStorageSourceNetCookiesClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2172-2185",
    "snippet": "static void\nvirStorageSourceNetCookiesClear(virStorageSourcePtr src)\n{\n    size_t i;\n\n    if (!src || !src->cookies)\n        return;\n\n    for (i = 0; i < src->ncookies; i++)\n        virStorageNetCookieDefFree(src->cookies[i]);\n\n    g_clear_pointer(&src->cookies, g_free);\n    src->ncookies = 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_clear_pointer",
          "args": [
            "&src->cookies",
            "g_free"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetCookieDefFree",
          "args": [
            "src->cookies[i]"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetCookieDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2159-2169",
          "snippet": "void\nvirStorageNetCookieDefFree(virStorageNetCookieDefPtr def)\n{\n    if (!def)\n        return;\n\n    g_free(def->name);\n    g_free(def->value);\n\n    g_free(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageNetCookieDefFree(virStorageNetCookieDefPtr def)\n{\n    if (!def)\n        return;\n\n    g_free(def->name);\n    g_free(def->value);\n\n    g_free(def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceNetCookiesClear(virStorageSourcePtr src)\n{\n    size_t i;\n\n    if (!src || !src->cookies)\n        return;\n\n    for (i = 0; i < src->ncookies; i++)\n        virStorageNetCookieDefFree(src->cookies[i]);\n\n    g_clear_pointer(&src->cookies, g_free);\n    src->ncookies = 0;\n}"
  },
  {
    "function_name": "virStorageNetCookieDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2159-2169",
    "snippet": "void\nvirStorageNetCookieDefFree(virStorageNetCookieDefPtr def)\n{\n    if (!def)\n        return;\n\n    g_free(def->name);\n    g_free(def->value);\n\n    g_free(def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def->value"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def->name"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageNetCookieDefFree(virStorageNetCookieDefPtr def)\n{\n    if (!def)\n        return;\n\n    g_free(def->name);\n    g_free(def->value);\n\n    g_free(def);\n}"
  },
  {
    "function_name": "virStorageSourceSeclabelsCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2133-2156",
    "snippet": "static int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceSeclabelsClear",
          "args": [
            "to"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceSeclabelsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2120-2130",
          "snippet": "static void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDeviceLabelDefCopy",
          "args": [
            "from->seclabels[i]"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDeviceLabelDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "89-104",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirSecurityDeviceLabelDefCopy(const virSecurityDeviceLabelDef *src)\n{\n    virSecurityDeviceLabelDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->relabel = src->relabel;\n    ret->labelskip = src->labelskip;\n\n    ret->model = g_strdup(src->model);\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirSecurityDeviceLabelDefCopy(const virSecurityDeviceLabelDef *src)\n{\n    virSecurityDeviceLabelDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->relabel = src->relabel;\n    ret->labelskip = src->labelskip;\n\n    ret->model = g_strdup(src->model);\n    ret->label = g_strdup(src->label);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "to->seclabels",
            "from->nseclabels"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvirStorageSourceSeclabelsCopy(virStorageSourcePtr to,\n                              const virStorageSource *from)\n{\n    size_t i;\n\n    if (from->nseclabels == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(to->seclabels, from->nseclabels) < 0)\n        return -1;\n    to->nseclabels = from->nseclabels;\n\n    for (i = 0; i < to->nseclabels; i++) {\n        if (!(to->seclabels[i] = virSecurityDeviceLabelDefCopy(from->seclabels[i])))\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virStorageSourceSeclabelsClear(to);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageSourceSeclabelsClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2120-2130",
    "snippet": "static void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->seclabels"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDeviceLabelDefFree",
          "args": [
            "def->seclabels[i]"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDeviceLabelDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "45-53",
          "snippet": "void\nvirSecurityDeviceLabelDefFree(virSecurityDeviceLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirSecurityDeviceLabelDefFree(virSecurityDeviceLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic void\nvirStorageSourceSeclabelsClear(virStorageSourcePtr def)\n{\n    size_t i;\n\n    if (def->seclabels) {\n        for (i = 0; i < def->nseclabels; i++)\n            virSecurityDeviceLabelDefFree(def->seclabels[i]);\n        VIR_FREE(def->seclabels);\n    }\n}"
  },
  {
    "function_name": "virStorageSourceGetSecurityLabelDef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2105-2117",
    "snippet": "virSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "src->seclabels[i]->model",
            "model"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageSourceChainHasNVMe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2091-2102",
    "snippet": "bool\nvirStorageSourceChainHasNVMe(const virStorageSource *src)\n{\n    const virStorageSource *n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type == VIR_STORAGE_TYPE_NVME)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceChainHasNVMe(const virStorageSource *src)\n{\n    const virStorageSource *n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type == VIR_STORAGE_TYPE_NVME)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virStorageSourceNVMeDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2081-2088",
    "snippet": "void\nvirStorageSourceNVMeDefFree(virStorageSourceNVMeDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceNVMeDefFree(virStorageSourceNVMeDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virStorageSourceNVMeDefIsEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2062-2078",
    "snippet": "static bool\nvirStorageSourceNVMeDefIsEqual(const virStorageSourceNVMeDef *a,\n                               const virStorageSourceNVMeDef *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->namespace != b->namespace ||\n        a->managed != b->managed ||\n        !virPCIDeviceAddressEqual(&a->pciAddr, &b->pciAddr))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "&a->pciAddr",
            "&b->pciAddr"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic bool\nvirStorageSourceNVMeDefIsEqual(const virStorageSourceNVMeDef *a,\n                               const virStorageSourceNVMeDef *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->namespace != b->namespace ||\n        a->managed != b->managed ||\n        !virPCIDeviceAddressEqual(&a->pciAddr, &b->pciAddr))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStorageSourceNVMeDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2048-2059",
    "snippet": "static virStorageSourceNVMeDefPtr\nvirStorageSourceNVMeDefCopy(const virStorageSourceNVMeDef *src)\n{\n    virStorageSourceNVMeDefPtr ret = NULL;\n\n    ret = g_new0(virStorageSourceNVMeDef, 1);\n\n    ret->namespace = src->namespace;\n    ret->managed = src->managed;\n    virPCIDeviceAddressCopy(&ret->pciAddr, &src->pciAddr);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressCopy",
          "args": [
            "&ret->pciAddr",
            "&src->pciAddr"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1345-1349",
          "snippet": "void virPCIDeviceAddressCopy(virPCIDeviceAddressPtr dst,\n                             const virPCIDeviceAddress *src)\n{\n    memcpy(dst, src, sizeof(*src));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid virPCIDeviceAddressCopy(virPCIDeviceAddressPtr dst,\n                             const virPCIDeviceAddress *src)\n{\n    memcpy(dst, src, sizeof(*src));\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageSourceNVMeDef",
            "1"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourceNVMeDefPtr\nvirStorageSourceNVMeDefCopy(const virStorageSourceNVMeDef *src)\n{\n    virStorageSourceNVMeDefPtr ret = NULL;\n\n    ret = g_new0(virStorageSourceNVMeDef, 1);\n\n    ret->namespace = src->namespace;\n    ret->managed = src->managed;\n    virPCIDeviceAddressCopy(&ret->pciAddr, &src->pciAddr);\n    return ret;\n}"
  },
  {
    "function_name": "virStoragePRDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2027-2045",
    "snippet": "static virStoragePRDefPtr\nvirStoragePRDefCopy(virStoragePRDefPtr src)\n{\n    virStoragePRDefPtr copy = NULL;\n    virStoragePRDefPtr ret = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->managed = src->managed;\n\n    copy->path = g_strdup(src->path);\n    copy->mgralias = g_strdup(src->mgralias);\n\n    ret = g_steal_pointer(&copy);\n\n    virStoragePRDefFree(copy);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePRDefFree",
          "args": [
            "copy"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePRDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1882-1891",
          "snippet": "void\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&copy"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->mgralias"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStoragePRDefPtr\nvirStoragePRDefCopy(virStoragePRDefPtr src)\n{\n    virStoragePRDefPtr copy = NULL;\n    virStoragePRDefPtr ret = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->managed = src->managed;\n\n    copy->path = g_strdup(src->path);\n    copy->mgralias = g_strdup(src->mgralias);\n\n    ret = g_steal_pointer(&copy);\n\n    virStoragePRDefFree(copy);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageSourceChainHasManagedPR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2013-2024",
    "snippet": "bool\nvirStorageSourceChainHasManagedPR(virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (virStoragePRDefIsManaged(n->pr))\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePRDefIsManaged",
          "args": [
            "n->pr"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePRDefIsManaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2006-2010",
          "snippet": "bool\nvirStoragePRDefIsManaged(virStoragePRDefPtr prd)\n{\n    return prd && prd->managed == VIR_TRISTATE_BOOL_YES;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStoragePRDefIsManaged(virStoragePRDefPtr prd)\n{\n    return prd && prd->managed == VIR_TRISTATE_BOOL_YES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceChainHasManagedPR(virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (virStoragePRDefIsManaged(n->pr))\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virStoragePRDefIsManaged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "2006-2010",
    "snippet": "bool\nvirStoragePRDefIsManaged(virStoragePRDefPtr prd)\n{\n    return prd && prd->managed == VIR_TRISTATE_BOOL_YES;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStoragePRDefIsManaged(virStoragePRDefPtr prd)\n{\n    return prd && prd->managed == VIR_TRISTATE_BOOL_YES;\n}"
  },
  {
    "function_name": "virStoragePRDefIsEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1988-2003",
    "snippet": "bool\nvirStoragePRDefIsEqual(virStoragePRDefPtr a,\n                       virStoragePRDefPtr b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->managed != b->managed ||\n        STRNEQ_NULLABLE(a->path, b->path))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "a->path",
            "b->path"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStoragePRDefIsEqual(virStoragePRDefPtr a,\n                       virStoragePRDefPtr b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->managed != b->managed ||\n        STRNEQ_NULLABLE(a->path, b->path))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStoragePRDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1966-1985",
    "snippet": "void\nvirStoragePRDefFormat(virBufferPtr buf,\n                      virStoragePRDefPtr prd,\n                      bool migratable)\n{\n    virBufferAsprintf(buf, \"<reservations managed='%s'\",\n                      virTristateBoolTypeToString(prd->managed));\n    if (prd->path &&\n        (prd->managed == VIR_TRISTATE_BOOL_NO || !migratable)) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAddLit(buf, \"<source type='unix'\");\n        virBufferEscapeString(buf, \" path='%s'\", prd->path);\n        virBufferAddLit(buf, \" mode='client'/>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</reservations>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</reservations>\\n\""
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='client'/>\\n\""
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" path='%s'\"",
            "prd->path"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<source type='unix'\""
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<reservations managed='%s'\"",
            "virTristateBoolTypeToString(prd->managed)"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "prd->managed"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStoragePRDefFormat(virBufferPtr buf,\n                      virStoragePRDefPtr prd,\n                      bool migratable)\n{\n    virBufferAsprintf(buf, \"<reservations managed='%s'\",\n                      virTristateBoolTypeToString(prd->managed));\n    if (prd->path &&\n        (prd->managed == VIR_TRISTATE_BOOL_NO || !migratable)) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAddLit(buf, \"<source type='unix'\");\n        virBufferEscapeString(buf, \" path='%s'\", prd->path);\n        virBufferAddLit(buf, \" mode='client'/>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</reservations>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
  },
  {
    "function_name": "virStoragePRDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1894-1963",
    "snippet": "virStoragePRDefPtr\nvirStoragePRDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virStoragePRDefPtr prd;\n    virStoragePRDefPtr ret = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *type = NULL;\n    g_autofree char *path = NULL;\n    g_autofree char *mode = NULL;\n\n    if (VIR_ALLOC(prd) < 0)\n        return NULL;\n\n    if (!(managed = virXPathString(\"string(./@managed)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing @managed attribute for <reservations/>\"));\n        goto cleanup;\n    }\n\n    if ((prd->managed = virTristateBoolTypeFromString(managed)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid value for 'managed': %s\"), managed);\n        goto cleanup;\n    }\n\n    type = virXPathString(\"string(./source[1]/@type)\", ctxt);\n    path = virXPathString(\"string(./source[1]/@path)\", ctxt);\n    mode = virXPathString(\"string(./source[1]/@mode)\", ctxt);\n\n    if (prd->managed == VIR_TRISTATE_BOOL_NO || type || path || mode) {\n        if (!type) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing connection type for <reservations/>\"));\n            goto cleanup;\n        }\n\n        if (!path) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing path for <reservations/>\"));\n            goto cleanup;\n        }\n\n        if (!mode) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing connection mode for <reservations/>\"));\n            goto cleanup;\n        }\n    }\n\n    if (type && STRNEQ(type, \"unix\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unsupported connection type for <reservations/>: %s\"),\n                       type);\n        goto cleanup;\n    }\n\n    if (mode && STRNEQ(mode, \"client\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unsupported connection mode for <reservations/>: %s\"),\n                       mode);\n        goto cleanup;\n    }\n\n    prd->path = g_steal_pointer(&path);\n    ret = g_steal_pointer(&prd);\n\n cleanup:\n    virStoragePRDefFree(prd);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePRDefFree",
          "args": [
            "prd"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePRDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1882-1891",
          "snippet": "void\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&prd"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&path"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unsupported connection mode for <reservations/>: %s\")",
            "mode"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported connection mode for <reservations/>: %s\""
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "mode",
            "\"client\""
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unsupported connection type for <reservations/>: %s\")",
            "type"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "type",
            "\"unix\""
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing connection mode for <reservations/>\")"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing path for <reservations/>\")"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing connection type for <reservations/>\")"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./source[1]/@mode)\"",
            "ctxt"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid value for 'managed': %s\")",
            "managed"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "managed"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing @managed attribute for <reservations/>\")"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "prd"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStoragePRDefPtr\nvirStoragePRDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virStoragePRDefPtr prd;\n    virStoragePRDefPtr ret = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *type = NULL;\n    g_autofree char *path = NULL;\n    g_autofree char *mode = NULL;\n\n    if (VIR_ALLOC(prd) < 0)\n        return NULL;\n\n    if (!(managed = virXPathString(\"string(./@managed)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing @managed attribute for <reservations/>\"));\n        goto cleanup;\n    }\n\n    if ((prd->managed = virTristateBoolTypeFromString(managed)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid value for 'managed': %s\"), managed);\n        goto cleanup;\n    }\n\n    type = virXPathString(\"string(./source[1]/@type)\", ctxt);\n    path = virXPathString(\"string(./source[1]/@path)\", ctxt);\n    mode = virXPathString(\"string(./source[1]/@mode)\", ctxt);\n\n    if (prd->managed == VIR_TRISTATE_BOOL_NO || type || path || mode) {\n        if (!type) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing connection type for <reservations/>\"));\n            goto cleanup;\n        }\n\n        if (!path) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing path for <reservations/>\"));\n            goto cleanup;\n        }\n\n        if (!mode) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing connection mode for <reservations/>\"));\n            goto cleanup;\n        }\n    }\n\n    if (type && STRNEQ(type, \"unix\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unsupported connection type for <reservations/>: %s\"),\n                       type);\n        goto cleanup;\n    }\n\n    if (mode && STRNEQ(mode, \"client\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unsupported connection mode for <reservations/>: %s\"),\n                       mode);\n        goto cleanup;\n    }\n\n    prd->path = g_steal_pointer(&path);\n    ret = g_steal_pointer(&prd);\n\n cleanup:\n    virStoragePRDefFree(prd);\n    return ret;\n}"
  },
  {
    "function_name": "virStoragePRDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1882-1891",
    "snippet": "void\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prd"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prd->mgralias"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prd->path"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStoragePRDefFree(virStoragePRDefPtr prd)\n{\n    if (!prd)\n        return;\n\n    VIR_FREE(prd->path);\n    VIR_FREE(prd->mgralias);\n    VIR_FREE(prd);\n}"
  },
  {
    "function_name": "virStorageAuthDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1862-1879",
    "snippet": "void\nvirStorageAuthDefFormat(virBufferPtr buf,\n                        virStorageAuthDefPtr authdef)\n{\n    if (authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE) {\n        virBufferEscapeString(buf, \"<auth username='%s'>\\n\", authdef->username);\n    } else {\n        virBufferAsprintf(buf, \"<auth type='%s' \",\n                          virStorageAuthTypeToString(authdef->authType));\n        virBufferEscapeString(buf, \"username='%s'>\\n\", authdef->username);\n    }\n\n    virBufferAdjustIndent(buf, 2);\n    virSecretLookupFormatSecret(buf, authdef->secrettype,\n                                &authdef->seclookupdef);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</auth>\\n\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</auth>\\n\""
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecretLookupFormatSecret",
          "args": [
            "buf",
            "authdef->secrettype",
            "&authdef->seclookupdef"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretLookupFormatSecret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "107-127",
          "snippet": "void\nvirSecretLookupFormatSecret(virBufferPtr buf,\n                            const char *secrettype,\n                            virSecretLookupTypeDefPtr def)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (secrettype)\n        virBufferAsprintf(buf, \"<secret type='%s'\", secrettype);\n    else\n        virBufferAddLit(buf, \"<secret\");\n\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        virUUIDFormat(def->u.uuid, uuidstr);\n        virBufferAsprintf(buf, \" uuid='%s'/>\\n\", uuidstr);\n    } else if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        virBufferEscapeString(buf, \" usage='%s'/>\\n\", def->u.usage);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupFormatSecret(virBufferPtr buf,\n                            const char *secrettype,\n                            virSecretLookupTypeDefPtr def)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (secrettype)\n        virBufferAsprintf(buf, \"<secret type='%s'\", secrettype);\n    else\n        virBufferAddLit(buf, \"<secret\");\n\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        virUUIDFormat(def->u.uuid, uuidstr);\n        virBufferAsprintf(buf, \" uuid='%s'/>\\n\", uuidstr);\n    } else if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        virBufferEscapeString(buf, \" usage='%s'/>\\n\", def->u.usage);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"username='%s'>\\n\"",
            "authdef->username"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<auth type='%s' \"",
            "virStorageAuthTypeToString(authdef->authType)"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageAuthTypeToString",
          "args": [
            "authdef->authType"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageAuthDefFormat(virBufferPtr buf,\n                        virStorageAuthDefPtr authdef)\n{\n    if (authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE) {\n        virBufferEscapeString(buf, \"<auth username='%s'>\\n\", authdef->username);\n    } else {\n        virBufferAsprintf(buf, \"<auth type='%s' \",\n                          virStorageAuthTypeToString(authdef->authType));\n        virBufferEscapeString(buf, \"username='%s'>\\n\", authdef->username);\n    }\n\n    virBufferAdjustIndent(buf, 2);\n    virSecretLookupFormatSecret(buf, authdef->secrettype,\n                                &authdef->seclookupdef);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</auth>\\n\");\n}"
  },
  {
    "function_name": "virStorageAuthDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1801-1859",
    "snippet": "virStorageAuthDefPtr\nvirStorageAuthDefParse(xmlNodePtr node,\n                       xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr saveNode = ctxt->node;\n    virStorageAuthDefPtr ret = NULL;\n    xmlNodePtr secretnode = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n    g_autofree char *authtype = NULL;\n\n    ctxt->node = node;\n\n    if (VIR_ALLOC(authdef) < 0)\n        goto cleanup;\n\n    if (!(authdef->username = virXPathString(\"string(./@username)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing username for auth\"));\n        goto cleanup;\n    }\n\n    authdef->authType = VIR_STORAGE_AUTH_TYPE_NONE;\n    authtype = virXPathString(\"string(./@type)\", ctxt);\n    if (authtype) {\n        /* Used by the storage pool instead of the secret type field\n         * to define whether chap or ceph being used\n         */\n        if ((authdef->authType = virStorageAuthTypeFromString(authtype)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown auth type '%s'\"), authtype);\n            goto cleanup;\n        }\n    }\n\n    if (!(secretnode = virXPathNode(\"./secret \", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing <secret> element in auth\"));\n        goto cleanup;\n    }\n\n    /* Used by the domain disk xml parsing in order to ensure the\n     * <secret type='%s' value matches the expected secret type for\n     * the style of disk (iscsi is chap, nbd is ceph). For some reason\n     * the virSecretUsageType{From|To}String() cannot be linked here\n     * and because only the domain parsing code cares - just keep\n     * it as a string.\n     */\n    authdef->secrettype = virXMLPropString(secretnode, \"type\");\n\n    if (virSecretLookupParseSecret(secretnode, &authdef->seclookupdef) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&authdef);\n\n cleanup:\n    ctxt->node = saveNode;\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&authdef"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretLookupParseSecret",
          "args": [
            "secretnode",
            "&authdef->seclookupdef"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretLookupParseSecret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "64-104",
          "snippet": "int\nvirSecretLookupParseSecret(xmlNodePtr secretnode,\n                           virSecretLookupTypeDefPtr def)\n{\n    char *uuid;\n    char *usage;\n    int ret = -1;\n\n    uuid = virXMLPropString(secretnode, \"uuid\");\n    usage = virXMLPropString(secretnode, \"usage\");\n    if (uuid == NULL && usage == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing secret uuid or usage attribute\"));\n        goto cleanup;\n    }\n\n    if (uuid && usage) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"either secret uuid or usage expected\"));\n        goto cleanup;\n    }\n\n    if (uuid) {\n        if (virUUIDParse(uuid, def->u.uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid secret uuid '%s'\"), uuid);\n            goto cleanup;\n        }\n        def->type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    } else {\n        def->u.usage = usage;\n        usage = NULL;\n        def->type = VIR_SECRET_LOOKUP_TYPE_USAGE;\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(usage);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretLookupParseSecret(xmlNodePtr secretnode,\n                           virSecretLookupTypeDefPtr def)\n{\n    char *uuid;\n    char *usage;\n    int ret = -1;\n\n    uuid = virXMLPropString(secretnode, \"uuid\");\n    usage = virXMLPropString(secretnode, \"usage\");\n    if (uuid == NULL && usage == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing secret uuid or usage attribute\"));\n        goto cleanup;\n    }\n\n    if (uuid && usage) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"either secret uuid or usage expected\"));\n        goto cleanup;\n    }\n\n    if (uuid) {\n        if (virUUIDParse(uuid, def->u.uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid secret uuid '%s'\"), uuid);\n            goto cleanup;\n        }\n        def->type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    } else {\n        def->u.usage = usage;\n        usage = NULL;\n        def->type = VIR_SECRET_LOOKUP_TYPE_USAGE;\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(usage);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "secretnode",
            "\"type\""
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing <secret> element in auth\")"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing <secret> element in auth\""
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./secret \"",
            "ctxt"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown auth type '%s'\")",
            "authtype"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageAuthTypeFromString",
          "args": [
            "authtype"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@type)\"",
            "ctxt"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing username for auth\")"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "authdef"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageAuthDefPtr\nvirStorageAuthDefParse(xmlNodePtr node,\n                       xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr saveNode = ctxt->node;\n    virStorageAuthDefPtr ret = NULL;\n    xmlNodePtr secretnode = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n    g_autofree char *authtype = NULL;\n\n    ctxt->node = node;\n\n    if (VIR_ALLOC(authdef) < 0)\n        goto cleanup;\n\n    if (!(authdef->username = virXPathString(\"string(./@username)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing username for auth\"));\n        goto cleanup;\n    }\n\n    authdef->authType = VIR_STORAGE_AUTH_TYPE_NONE;\n    authtype = virXPathString(\"string(./@type)\", ctxt);\n    if (authtype) {\n        /* Used by the storage pool instead of the secret type field\n         * to define whether chap or ceph being used\n         */\n        if ((authdef->authType = virStorageAuthTypeFromString(authtype)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown auth type '%s'\"), authtype);\n            goto cleanup;\n        }\n    }\n\n    if (!(secretnode = virXPathNode(\"./secret \", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing <secret> element in auth\"));\n        goto cleanup;\n    }\n\n    /* Used by the domain disk xml parsing in order to ensure the\n     * <secret type='%s' value matches the expected secret type for\n     * the style of disk (iscsi is chap, nbd is ceph). For some reason\n     * the virSecretUsageType{From|To}String() cannot be linked here\n     * and because only the domain parsing code cares - just keep\n     * it as a string.\n     */\n    authdef->secrettype = virXMLPropString(secretnode, \"type\");\n\n    if (virSecretLookupParseSecret(secretnode, &authdef->seclookupdef) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&authdef);\n\n cleanup:\n    ctxt->node = saveNode;\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageAuthDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1782-1798",
    "snippet": "virStorageAuthDefPtr\nvirStorageAuthDefCopy(const virStorageAuthDef *src)\n{\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    if (VIR_ALLOC(authdef) < 0)\n        return NULL;\n\n    authdef->username = g_strdup(src->username);\n    /* Not present for storage pool, but used for disk source */\n    authdef->secrettype = g_strdup(src->secrettype);\n    authdef->authType = src->authType;\n\n    virSecretLookupDefCopy(&authdef->seclookupdef, &src->seclookupdef);\n\n    return g_steal_pointer(&authdef);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&authdef"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretLookupDefCopy",
          "args": [
            "&authdef->seclookupdef",
            "&src->seclookupdef"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretLookupDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "51-61",
          "snippet": "void\nvirSecretLookupDefCopy(virSecretLookupTypeDefPtr dst,\n                       const virSecretLookupTypeDef *src)\n{\n    dst->type = src->type;\n    if (dst->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        memcpy(dst->u.uuid, src->u.uuid, VIR_UUID_BUFLEN);\n    } else if (dst->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        dst->u.usage = g_strdup(src->u.usage);\n    }\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupDefCopy(virSecretLookupTypeDefPtr dst,\n                       const virSecretLookupTypeDef *src)\n{\n    dst->type = src->type;\n    if (dst->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        memcpy(dst->u.uuid, src->u.uuid, VIR_UUID_BUFLEN);\n    } else if (dst->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        dst->u.usage = g_strdup(src->u.usage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->secrettype"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "authdef"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageAuthDefPtr\nvirStorageAuthDefCopy(const virStorageAuthDef *src)\n{\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    if (VIR_ALLOC(authdef) < 0)\n        return NULL;\n\n    authdef->username = g_strdup(src->username);\n    /* Not present for storage pool, but used for disk source */\n    authdef->secrettype = g_strdup(src->secrettype);\n    authdef->authType = src->authType;\n\n    virSecretLookupDefCopy(&authdef->seclookupdef, &src->seclookupdef);\n\n    return g_steal_pointer(&authdef);\n}"
  },
  {
    "function_name": "virStorageAuthDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1769-1779",
    "snippet": "void\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "authdef"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretLookupDefClear",
          "args": [
            "&authdef->seclookupdef"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretLookupDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "41-48",
          "snippet": "void\nvirSecretLookupDefClear(virSecretLookupTypeDefPtr def)\n{\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE)\n        VIR_FREE(def->u.usage);\n    else if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID)\n        memset(&def->u.uuid, 0, VIR_UUID_BUFLEN);\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupDefClear(virSecretLookupTypeDefPtr def)\n{\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE)\n        VIR_FREE(def->u.usage);\n    else if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID)\n        memset(&def->u.uuid, 0, VIR_UUID_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "authdef->secrettype"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "authdef->username"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageAuthDefFree(virStorageAuthDefPtr authdef)\n{\n    if (!authdef)\n        return;\n\n    VIR_FREE(authdef->username);\n    VIR_FREE(authdef->secrettype);\n    virSecretLookupDefClear(&authdef->seclookupdef);\n    VIR_FREE(authdef);\n}"
  },
  {
    "function_name": "virStorageNetHostDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1740-1766",
    "snippet": "virStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageNetHostDefFree",
          "args": [
            "nhosts",
            "ret"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1713-1726",
          "snippet": "void\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->socket"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "nhosts"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageNetHostDefPtr\nvirStorageNetHostDefCopy(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    virStorageNetHostDefPtr ret = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_N(ret, nhosts) < 0)\n        goto error;\n\n    for (i = 0; i < nhosts; i++) {\n        virStorageNetHostDefPtr src = &hosts[i];\n        virStorageNetHostDefPtr dst = &ret[i];\n\n        dst->transport = src->transport;\n        dst->port = src->port;\n\n        dst->name = g_strdup(src->name);\n        dst->socket = g_strdup(src->socket);\n    }\n\n    return ret;\n\n error:\n    virStorageNetHostDefFree(nhosts, ret);\n    return NULL;\n}"
  },
  {
    "function_name": "virStoragePermsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1729-1737",
    "snippet": "static void\nvirStoragePermsFree(virStoragePermsPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->label"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic void\nvirStoragePermsFree(virStoragePermsPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virStorageNetHostDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1713-1726",
    "snippet": "void\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hosts"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetHostDefClear",
          "args": [
            "&hosts[i]"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1702-1710",
          "snippet": "void\nvirStorageNetHostDefClear(virStorageNetHostDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->socket);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageNetHostDefClear(virStorageNetHostDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->socket);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}"
  },
  {
    "function_name": "virStorageNetHostDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1702-1710",
    "snippet": "void\nvirStorageNetHostDefClear(virStorageNetHostDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->socket);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->socket"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageNetHostDefClear(virStorageNetHostDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->socket);\n}"
  },
  {
    "function_name": "virStorageFileChainLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1612-1699",
    "snippet": "virStorageSourcePtr\nvirStorageFileChainLookup(virStorageSourcePtr chain,\n                          virStorageSourcePtr startFrom,\n                          const char *name,\n                          unsigned int idx,\n                          virStorageSourcePtr *parent)\n{\n    virStorageSourcePtr prev;\n    const char *start = chain->path;\n    char *parentDir = NULL;\n    bool nameIsFile = virStorageIsFile(name);\n\n    if (!parent)\n        parent = &prev;\n    *parent = NULL;\n\n    if (startFrom) {\n        while (virStorageSourceIsBacking(chain) &&\n               chain != startFrom->backingStore)\n            chain = chain->backingStore;\n\n        *parent = startFrom;\n    }\n\n    while (virStorageSourceIsBacking(chain)) {\n        if (!name && !idx) {\n            if (!virStorageSourceHasBacking(chain))\n                break;\n        } else if (idx) {\n            VIR_DEBUG(\"%u: %s\", chain->id, chain->path);\n            if (idx == chain->id)\n                break;\n        } else {\n            if (STREQ_NULLABLE(name, chain->relPath) ||\n                STREQ_NULLABLE(name, chain->path))\n                break;\n\n            if (nameIsFile && virStorageSourceIsLocalStorage(chain)) {\n                if (*parent && virStorageSourceIsLocalStorage(*parent))\n                    parentDir = g_path_get_dirname((*parent)->path);\n                else\n                    parentDir = g_strdup(\".\");\n\n                int result = virFileRelLinkPointsTo(parentDir, name,\n                                                    chain->path);\n\n                VIR_FREE(parentDir);\n\n                if (result < 0)\n                    goto error;\n\n                if (result > 0)\n                    break;\n            }\n        }\n        *parent = chain;\n        chain = chain->backingStore;\n    }\n\n    if (!virStorageSourceIsBacking(chain))\n        goto error;\n\n    return chain;\n\n error:\n    if (idx) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find backing store index %u in chain \"\n                         \"for '%s'\"),\n                       idx, NULLSTR(start));\n    } else if (name) {\n        if (startFrom)\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"could not find image '%s' beneath '%s' in \"\n                             \"chain for '%s'\"), name, NULLSTR(startFrom->path),\n                           NULLSTR(start));\n        else\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"could not find image '%s' in chain for '%s'\"),\n                           name, NULLSTR(start));\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find base image in chain for '%s'\"),\n                       NULLSTR(start));\n    }\n    *parent = NULL;\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"could not find base image in chain for '%s'\")",
            "NULLSTR(start)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "start"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not find base image in chain for '%s'\""
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"could not find image '%s' in chain for '%s'\")",
            "name",
            "NULLSTR(start)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "start"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"could not find image '%s' beneath '%s' in \"\n                             \"chain for '%s'\")",
            "name",
            "NULLSTR(startFrom->path)",
            "NULLSTR(start)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "start"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "startFrom->path"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"could not find backing store index %u in chain \"\n                         \"for '%s'\")",
            "idx",
            "NULLSTR(start)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "start"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "chain"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "parentDir"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRelLinkPointsTo",
          "args": [
            "parentDir",
            "name",
            "chain->path"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRelLinkPointsTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1551-1568",
          "snippet": "int\nvirFileRelLinkPointsTo(const char *directory,\n                       const char *checkLink,\n                       const char *checkDest)\n{\n    g_autofree char *candidate = NULL;\n\n    if (*checkLink == '/')\n        return virFileLinkPointsTo(checkLink, checkDest);\n    if (!directory) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot resolve '%s' without starting directory\"),\n                       checkLink);\n        return -1;\n    }\n    candidate = g_strdup_printf(\"%s/%s\", directory, checkLink);\n    return virFileLinkPointsTo(candidate, checkDest);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRelLinkPointsTo(const char *directory,\n                       const char *checkLink,\n                       const char *checkDest)\n{\n    g_autofree char *candidate = NULL;\n\n    if (*checkLink == '/')\n        return virFileLinkPointsTo(checkLink, checkDest);\n    if (!directory) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot resolve '%s' without starting directory\"),\n                       checkLink);\n        return -1;\n    }\n    candidate = g_strdup_printf(\"%s/%s\", directory, checkLink);\n    return virFileLinkPointsTo(candidate, checkDest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "(*parent)->path"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "*parent"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "name",
            "chain->path"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "name",
            "chain->relPath"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%u: %s\"",
            "chain->id",
            "chain->path"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "chain"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageIsFile",
          "args": [
            "name"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageIsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "762-780",
          "snippet": "bool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageSourcePtr\nvirStorageFileChainLookup(virStorageSourcePtr chain,\n                          virStorageSourcePtr startFrom,\n                          const char *name,\n                          unsigned int idx,\n                          virStorageSourcePtr *parent)\n{\n    virStorageSourcePtr prev;\n    const char *start = chain->path;\n    char *parentDir = NULL;\n    bool nameIsFile = virStorageIsFile(name);\n\n    if (!parent)\n        parent = &prev;\n    *parent = NULL;\n\n    if (startFrom) {\n        while (virStorageSourceIsBacking(chain) &&\n               chain != startFrom->backingStore)\n            chain = chain->backingStore;\n\n        *parent = startFrom;\n    }\n\n    while (virStorageSourceIsBacking(chain)) {\n        if (!name && !idx) {\n            if (!virStorageSourceHasBacking(chain))\n                break;\n        } else if (idx) {\n            VIR_DEBUG(\"%u: %s\", chain->id, chain->path);\n            if (idx == chain->id)\n                break;\n        } else {\n            if (STREQ_NULLABLE(name, chain->relPath) ||\n                STREQ_NULLABLE(name, chain->path))\n                break;\n\n            if (nameIsFile && virStorageSourceIsLocalStorage(chain)) {\n                if (*parent && virStorageSourceIsLocalStorage(*parent))\n                    parentDir = g_path_get_dirname((*parent)->path);\n                else\n                    parentDir = g_strdup(\".\");\n\n                int result = virFileRelLinkPointsTo(parentDir, name,\n                                                    chain->path);\n\n                VIR_FREE(parentDir);\n\n                if (result < 0)\n                    goto error;\n\n                if (result > 0)\n                    break;\n            }\n        }\n        *parent = chain;\n        chain = chain->backingStore;\n    }\n\n    if (!virStorageSourceIsBacking(chain))\n        goto error;\n\n    return chain;\n\n error:\n    if (idx) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find backing store index %u in chain \"\n                         \"for '%s'\"),\n                       idx, NULLSTR(start));\n    } else if (name) {\n        if (startFrom)\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"could not find image '%s' beneath '%s' in \"\n                             \"chain for '%s'\"), name, NULLSTR(startFrom->path),\n                           NULLSTR(start));\n        else\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"could not find image '%s' in chain for '%s'\"),\n                           name, NULLSTR(start));\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find base image in chain for '%s'\"),\n                       NULLSTR(start));\n    }\n    *parent = NULL;\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageSourceHasBacking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1593-1598",
    "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "src"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
  },
  {
    "function_name": "virStorageSourceIsBacking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1581-1585",
    "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
  },
  {
    "function_name": "virStorageFileParseChainIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1542-1571",
    "snippet": "int\nvirStorageFileParseChainIndex(const char *diskTarget,\n                              const char *name,\n                              unsigned int *chainIndex)\n{\n    unsigned int idx = 0;\n    g_autofree char *target = NULL;\n\n    *chainIndex = 0;\n\n    if (!name || !diskTarget)\n        return 0;\n\n    if (virStorageFileParseBackingStoreStr(name, &target, &idx) < 0)\n        return 0;\n\n    if (idx == 0)\n        return 0;\n\n    if (STRNEQ(diskTarget, target)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"requested target '%s' does not match target '%s'\"),\n                       target, diskTarget);\n        return -1;\n    }\n\n    *chainIndex = idx;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"requested target '%s' does not match target '%s'\")",
            "target",
            "diskTarget"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"requested target '%s' does not match target '%s'\""
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "diskTarget",
            "target"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileParseBackingStoreStr",
          "args": [
            "name",
            "&target",
            "&idx"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileParseBackingStoreStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1513-1539",
          "snippet": "int\nvirStorageFileParseBackingStoreStr(const char *str,\n                                   char **target,\n                                   unsigned int *chainIndex)\n{\n    size_t nstrings;\n    unsigned int idx = 0;\n    char *suffix;\n    VIR_AUTOSTRINGLIST strings = NULL;\n\n    *chainIndex = 0;\n\n    if (!(strings = virStringSplitCount(str, \"[\", 2, &nstrings)))\n        return -1;\n\n    if (nstrings == 2) {\n        if (virStrToLong_uip(strings[1], &suffix, 10, &idx) < 0 ||\n            STRNEQ(suffix, \"]\"))\n            return -1;\n    }\n\n    if (target)\n        *target = g_strdup(strings[0]);\n\n    *chainIndex = idx;\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nint\nvirStorageFileParseBackingStoreStr(const char *str,\n                                   char **target,\n                                   unsigned int *chainIndex)\n{\n    size_t nstrings;\n    unsigned int idx = 0;\n    char *suffix;\n    VIR_AUTOSTRINGLIST strings = NULL;\n\n    *chainIndex = 0;\n\n    if (!(strings = virStringSplitCount(str, \"[\", 2, &nstrings)))\n        return -1;\n\n    if (nstrings == 2) {\n        if (virStrToLong_uip(strings[1], &suffix, 10, &idx) < 0 ||\n            STRNEQ(suffix, \"]\"))\n            return -1;\n    }\n\n    if (target)\n        *target = g_strdup(strings[0]);\n\n    *chainIndex = idx;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileParseChainIndex(const char *diskTarget,\n                              const char *name,\n                              unsigned int *chainIndex)\n{\n    unsigned int idx = 0;\n    g_autofree char *target = NULL;\n\n    *chainIndex = 0;\n\n    if (!name || !diskTarget)\n        return 0;\n\n    if (virStorageFileParseBackingStoreStr(name, &target, &idx) < 0)\n        return 0;\n\n    if (idx == 0)\n        return 0;\n\n    if (STRNEQ(diskTarget, target)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"requested target '%s' does not match target '%s'\"),\n                       target, diskTarget);\n        return -1;\n    }\n\n    *chainIndex = idx;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileParseBackingStoreStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1513-1539",
    "snippet": "int\nvirStorageFileParseBackingStoreStr(const char *str,\n                                   char **target,\n                                   unsigned int *chainIndex)\n{\n    size_t nstrings;\n    unsigned int idx = 0;\n    char *suffix;\n    VIR_AUTOSTRINGLIST strings = NULL;\n\n    *chainIndex = 0;\n\n    if (!(strings = virStringSplitCount(str, \"[\", 2, &nstrings)))\n        return -1;\n\n    if (nstrings == 2) {\n        if (virStrToLong_uip(strings[1], &suffix, 10, &idx) < 0 ||\n            STRNEQ(suffix, \"]\"))\n            return -1;\n    }\n\n    if (target)\n        *target = g_strdup(strings[0]);\n\n    *chainIndex = idx;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "strings[0]"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "suffix",
            "\"]\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "strings[1]",
            "&suffix",
            "10",
            "&idx"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "str",
            "\"[\"",
            "2",
            "&nstrings"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nint\nvirStorageFileParseBackingStoreStr(const char *str,\n                                   char **target,\n                                   unsigned int *chainIndex)\n{\n    size_t nstrings;\n    unsigned int idx = 0;\n    char *suffix;\n    VIR_AUTOSTRINGLIST strings = NULL;\n\n    *chainIndex = 0;\n\n    if (!(strings = virStringSplitCount(str, \"[\", 2, &nstrings)))\n        return -1;\n\n    if (nstrings == 2) {\n        if (virStrToLong_uip(strings[1], &suffix, 10, &idx) < 0 ||\n            STRNEQ(suffix, \"]\"))\n            return -1;\n    }\n\n    if (target)\n        *target = g_strdup(strings[0]);\n\n    *chainIndex = idx;\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetNPIVKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1494-1498",
    "snippet": "int virStorageFileGetNPIVKey(const char *path G_GNUC_UNUSED,\n                             char **key G_GNUC_UNUSED)\n{\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetNPIVKey(const char *path G_GNUC_UNUSED,\n                             char **key G_GNUC_UNUSED)\n{\n    return -1;\n}"
  },
  {
    "function_name": "virStorageFileGetNPIVKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1445-1492",
    "snippet": "int\nvirStorageFileGetNPIVKey(const char *path,\n                         char **key)\n{\n    int status;\n    const char *serial;\n    const char *port;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(\"/lib/udev/scsi_id\",\n                               \"--replace-whitespace\",\n                               \"--whitelisted\",\n                               \"--export\",\n                               \"--device\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &status) < 0)\n        return -2;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n    if (status == 0 && *outbuf &&\n        (serial = strstr(outbuf, ID_SERIAL)) &&\n        (port = strstr(outbuf, ID_TARGET_PORT))) {\n        char *tmp;\n\n        serial += strlen(ID_SERIAL);\n        port += strlen(ID_TARGET_PORT);\n\n        if ((tmp = strchr(serial, '\\n')))\n            *tmp = '\\0';\n\n        if ((tmp = strchr(port, '\\n')))\n            *tmp = '\\0';\n\n        if (*serial != '\\0' && *port != '\\0')\n            *key = g_strdup_printf(\"%s_PORT%s\", serial, port);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s_PORT%s\"",
            "serial",
            "port"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "port",
            "'\\n'"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "serial",
            "'\\n'"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ID_TARGET_PORT"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ID_SERIAL"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "outbuf",
            "ID_TARGET_PORT"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "outbuf",
            "ID_SERIAL"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "\"/lib/udev/scsi_id\"",
            "\"--replace-whitespace\"",
            "\"--whitelisted\"",
            "\"--export\"",
            "\"--device\"",
            "path",
            "NULL"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetNPIVKey(const char *path,\n                         char **key)\n{\n    int status;\n    const char *serial;\n    const char *port;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(\"/lib/udev/scsi_id\",\n                               \"--replace-whitespace\",\n                               \"--whitelisted\",\n                               \"--export\",\n                               \"--device\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &status) < 0)\n        return -2;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n    if (status == 0 && *outbuf &&\n        (serial = strstr(outbuf, ID_SERIAL)) &&\n        (port = strstr(outbuf, ID_TARGET_PORT))) {\n        char *tmp;\n\n        serial += strlen(ID_SERIAL);\n        port += strlen(ID_TARGET_PORT);\n\n        if ((tmp = strchr(serial, '\\n')))\n            *tmp = '\\0';\n\n        if ((tmp = strchr(port, '\\n')))\n            *tmp = '\\0';\n\n        if (*serial != '\\0' && *port != '\\0')\n            *key = g_strdup_printf(\"%s_PORT%s\", serial, port);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetSCSIKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1416-1423",
    "snippet": "int virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "_(\"Unable to get SCSI key for %s\")",
            "path"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get SCSI key for %s\""
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageFileGetSCSIKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1379-1414",
    "snippet": "int\nvirStorageFileGetSCSIKey(const char *path,\n                         char **key,\n                         bool ignoreError G_GNUC_UNUSED)\n{\n    int status;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(\"/lib/udev/scsi_id\",\n                               \"--replace-whitespace\",\n                               \"--whitelisted\",\n                               \"--device\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, key);\n    if (virCommandRun(cmd, &status) < 0)\n        return -2;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n    if (status == 0 && *key) {\n        char *nl = strchr(*key, '\\n');\n        if (nl)\n            *nl = '\\0';\n    }\n\n    if (*key && STREQ(*key, \"\"))\n        VIR_FREE(*key);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*key"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "*key",
            "\"\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*key",
            "'\\n'"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "key"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "\"/lib/udev/scsi_id\"",
            "\"--replace-whitespace\"",
            "\"--whitelisted\"",
            "\"--device\"",
            "path",
            "NULL"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetSCSIKey(const char *path,\n                         char **key,\n                         bool ignoreError G_GNUC_UNUSED)\n{\n    int status;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(\"/lib/udev/scsi_id\",\n                               \"--replace-whitespace\",\n                               \"--whitelisted\",\n                               \"--device\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, key);\n    if (virCommandRun(cmd, &status) < 0)\n        return -2;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n    if (status == 0 && *key) {\n        char *nl = strchr(*key, '\\n');\n        if (nl)\n            *nl = '\\0';\n    }\n\n    if (*key && STREQ(*key, \"\"))\n        VIR_FREE(*key);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetLVMKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1356-1361",
    "snippet": "int virStorageFileGetLVMKey(const char *path,\n                            char **key G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"Unable to get LVM key for %s\"), path);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "_(\"Unable to get LVM key for %s\")",
            "path"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get LVM key for %s\""
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetLVMKey(const char *path,\n                            char **key G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"Unable to get LVM key for %s\"), path);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageFileGetLVMKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1303-1354",
    "snippet": "int virStorageFileGetLVMKey(const char *path,\n                            char **key)\n{\n    /*\n     *  # lvs --noheadings --unbuffered --nosuffix --options \"uuid\" LVNAME\n     *    06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky\n     */\n    int status;\n    int ret = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS, \"--noheadings\",\n                               \"--unbuffered\", \"--nosuffix\",\n                               \"--options\", \"uuid\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, key);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n\n    if (status == 0 && *key) {\n        char *nl;\n        char *tmp = *key;\n\n        /* Find first non-space character */\n        while (*tmp && g_ascii_isspace(*tmp))\n            tmp++;\n        /* Kill leading spaces */\n        if (tmp != *key)\n            memmove(*key, tmp, strlen(tmp)+1);\n\n        /* Kill trailing newline */\n        if ((nl = strchr(*key, '\\n')))\n            *nl = '\\0';\n    }\n\n    ret = 0;\n\n cleanup:\n    if (*key && STREQ(*key, \"\"))\n        VIR_FREE(*key);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*key"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "*key",
            "\"\""
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*key",
            "'\\n'"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "*key",
            "tmp",
            "strlen(tmp)+1"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*tmp"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "key"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "LVS",
            "\"--noheadings\"",
            "\"--unbuffered\"",
            "\"--nosuffix\"",
            "\"--options\"",
            "\"uuid\"",
            "path",
            "NULL"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetLVMKey(const char *path,\n                            char **key)\n{\n    /*\n     *  # lvs --noheadings --unbuffered --nosuffix --options \"uuid\" LVNAME\n     *    06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky\n     */\n    int status;\n    int ret = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS, \"--noheadings\",\n                               \"--unbuffered\", \"--nosuffix\",\n                               \"--options\", \"uuid\", path,\n                               NULL\n                               );\n    *key = NULL;\n\n    /* Run the program and capture its output */\n    virCommandSetOutputBuffer(cmd, key);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    /* Explicitly check status == 0, rather than passing NULL\n     * to virCommandRun because we don't want to raise an actual\n     * error in this scenario, just return a NULL key.\n     */\n\n    if (status == 0 && *key) {\n        char *nl;\n        char *tmp = *key;\n\n        /* Find first non-space character */\n        while (*tmp && g_ascii_isspace(*tmp))\n            tmp++;\n        /* Kill leading spaces */\n        if (tmp != *key)\n            memmove(*key, tmp, strlen(tmp)+1);\n\n        /* Kill trailing newline */\n        if ((nl = strchr(*key, '\\n')))\n            *nl = '\\0';\n    }\n\n    ret = 0;\n\n cleanup:\n    if (*key && STREQ(*key, \"\"))\n        VIR_FREE(*key);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileIsClusterFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1291-1300",
    "snippet": "int virStorageFileIsClusterFS(const char *path)\n{\n    /* These are coherent cluster filesystems known to be safe for\n     * migration with cache != none\n     */\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_CEPH);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileIsSharedFSType",
          "args": [
            "path",
            "VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_CEPH"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFSType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3648-3653",
          "snippet": "int virFileIsSharedFSType(const char *path G_GNUC_UNUSED,\n                          int fstypes G_GNUC_UNUSED)\n{\n    /* XXX implement me :-) */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFSType(const char *path G_GNUC_UNUSED,\n                          int fstypes G_GNUC_UNUSED)\n{\n    /* XXX implement me :-) */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileIsClusterFS(const char *path)\n{\n    /* These are coherent cluster filesystems known to be safe for\n     * migration with cache != none\n     */\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_CEPH);\n}"
  },
  {
    "function_name": "virStorageFileResize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1249-1288",
    "snippet": "int\nvirStorageFileResize(const char *path,\n                     unsigned long long capacity,\n                     bool pre_allocate)\n{\n    int rc;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((fd = open(path, O_RDWR)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open '%s'\"), path);\n        return -1;\n    }\n\n    if (pre_allocate) {\n        if ((rc = virFileAllocate(fd, 0, capacity)) != 0) {\n            if (rc == -2) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"preallocate is not supported on this platform\"));\n            } else {\n                virReportSystemError(errno,\n                                     _(\"Failed to pre-allocate space for \"\n                                       \"file '%s'\"), path);\n            }\n            return -1;\n        }\n    }\n\n    if (ftruncate(fd, capacity) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate file '%s'\"), path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"Unable to save '%s'\"), path);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to save '%s'\")",
            "path"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to save '%s'\""
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to truncate file '%s'\")",
            "path"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "capacity"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to pre-allocate space for \"\n                                       \"file '%s'\")",
            "path"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"preallocate is not supported on this platform\")"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileAllocate",
          "args": [
            "fd",
            "0",
            "capacity"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "virFileAllocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1246-1255",
          "snippet": "int virFileAllocate(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    return safezero_sys_fallocate(fd, offset, len);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileAllocate(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    return safezero_sys_fallocate(fd, offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open '%s'\")",
            "path"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileResize(const char *path,\n                     unsigned long long capacity,\n                     bool pre_allocate)\n{\n    int rc;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((fd = open(path, O_RDWR)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open '%s'\"), path);\n        return -1;\n    }\n\n    if (pre_allocate) {\n        if ((rc = virFileAllocate(fd, 0, capacity)) != 0) {\n            if (rc == -2) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"preallocate is not supported on this platform\"));\n            } else {\n                virReportSystemError(errno,\n                                     _(\"Failed to pre-allocate space for \"\n                                       \"file '%s'\"), path);\n            }\n            return -1;\n        }\n    }\n\n    if (ftruncate(fd, capacity) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate file '%s'\"), path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"Unable to save '%s'\"), path);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileChainGetBroken",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1219-1241",
    "snippet": "int\nvirStorageFileChainGetBroken(virStorageSourcePtr chain,\n                             char **brokenFile)\n{\n    virStorageSourcePtr tmp;\n\n    *brokenFile = NULL;\n\n    if (!chain)\n        return 0;\n\n    for (tmp = chain; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        /* Break when we hit end of chain; report error if we detected\n         * a missing backing file, infinite loop, or other error */\n        if (!tmp->backingStore && tmp->backingStoreRaw) {\n            *brokenFile = g_strdup(tmp->backingStoreRaw);\n\n           return 0;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "tmp->backingStoreRaw"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "tmp"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileChainGetBroken(virStorageSourcePtr chain,\n                             char **brokenFile)\n{\n    virStorageSourcePtr tmp;\n\n    *brokenFile = NULL;\n\n    if (!chain)\n        return 0;\n\n    for (tmp = chain; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        /* Break when we hit end of chain; report error if we detected\n         * a missing backing file, infinite loop, or other error */\n        if (!tmp->backingStore && tmp->backingStoreRaw) {\n            *brokenFile = g_strdup(tmp->backingStoreRaw);\n\n           return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetMetadataFromFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1161-1208",
    "snippet": "virStorageSourcePtr\nvirStorageFileGetMetadataFromFD(const char *path,\n                                int fd,\n                                int format)\n\n{\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    struct stat sb;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"), path);\n        return NULL;\n    }\n\n    if (!(meta = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (S_ISDIR(sb.st_mode)) {\n        /* No header to probe for directories, but also no backing file. Just\n         * update the metadata.*/\n        meta->type = VIR_STORAGE_TYPE_DIR;\n        meta->format = VIR_STORAGE_FILE_DIR;\n        return g_steal_pointer(&meta);\n    }\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if (virStorageFileGetMetadataInternal(meta, buf, len) < 0)\n        return NULL;\n\n    if (S_ISREG(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_FILE;\n    else if (S_ISBLK(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_BLOCK;\n\n    return g_steal_pointer(&meta);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&meta"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "sb.st_mode"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataInternal",
          "args": [
            "meta",
            "buf",
            "len"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "935-1036",
          "snippet": "static int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read header '%s'\")",
            "meta->path"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read header '%s'\""
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadHeaderFD",
          "args": [
            "fd",
            "len",
            "&buf"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadHeaderFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1377-1392",
          "snippet": "int\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot seek to start of '%s'\")",
            "meta->path"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&meta"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileMetadataNew",
          "args": [
            "path",
            "format"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMetadataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1088-1103",
          "snippet": "static virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat file '%s'\")",
            "path"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nvirStorageSourcePtr\nvirStorageFileGetMetadataFromFD(const char *path,\n                                int fd,\n                                int format)\n\n{\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    struct stat sb;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"), path);\n        return NULL;\n    }\n\n    if (!(meta = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (S_ISDIR(sb.st_mode)) {\n        /* No header to probe for directories, but also no backing file. Just\n         * update the metadata.*/\n        meta->type = VIR_STORAGE_TYPE_DIR;\n        meta->format = VIR_STORAGE_FILE_DIR;\n        return g_steal_pointer(&meta);\n    }\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if (virStorageFileGetMetadataInternal(meta, buf, len) < 0)\n        return NULL;\n\n    if (S_ISREG(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_FILE;\n    else if (S_ISBLK(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_BLOCK;\n\n    return g_steal_pointer(&meta);\n}"
  },
  {
    "function_name": "virStorageFileGetMetadataFromBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1128-1145",
    "snippet": "virStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataInternal",
          "args": [
            "ret",
            "buf",
            "len"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "935-1036",
          "snippet": "static int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileMetadataNew",
          "args": [
            "path",
            "format"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMetadataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1088-1103",
          "snippet": "static virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageFileMetadataNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1088-1103",
    "snippet": "static virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virStorageSourcePtr\nvirStorageFileMetadataNew(const char *path,\n                          int format)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->format = format;\n    def->type = VIR_STORAGE_TYPE_FILE;\n\n    def->path = g_strdup(path);\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virStorageFileProbeFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "1052-1085",
    "snippet": "int\nvirStorageFileProbeFormat(const char *path, uid_t uid, gid_t gid)\n{\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    VIR_AUTOCLOSE fd = -1;\n    g_autofree char *header = NULL;\n\n    if ((fd = virFileOpenAs(path, O_RDONLY, 0, uid, gid, 0)) < 0) {\n        virReportSystemError(-fd, _(\"Failed to open file '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        return -1;\n    }\n\n    /* No header to probe for directories */\n    if (S_ISDIR(sb.st_mode))\n        return VIR_STORAGE_FILE_DIR;\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot set to start of '%s'\"), path);\n        return -1;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &header)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), path);\n        return -1;\n    }\n\n    return virStorageFileProbeFormatFromBuf(path, header, len);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageFileProbeFormatFromBuf",
          "args": [
            "path",
            "header",
            "len"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileProbeFormatFromBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "796-832",
          "snippet": "static int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read header '%s'\")",
            "path"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read header '%s'\""
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadHeaderFD",
          "args": [
            "fd",
            "len",
            "&header"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadHeaderFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1377-1392",
          "snippet": "int\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot set to start of '%s'\")",
            "path"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat file '%s'\")",
            "path"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-fd",
            "_(\"Failed to open file '%s'\")",
            "path"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileOpenAs",
          "args": [
            "path",
            "O_RDONLY",
            "0",
            "uid",
            "gid",
            "0"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2817-2829",
          "snippet": "int\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nint\nvirStorageFileProbeFormat(const char *path, uid_t uid, gid_t gid)\n{\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    VIR_AUTOCLOSE fd = -1;\n    g_autofree char *header = NULL;\n\n    if ((fd = virFileOpenAs(path, O_RDONLY, 0, uid, gid, 0)) < 0) {\n        virReportSystemError(-fd, _(\"Failed to open file '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        return -1;\n    }\n\n    /* No header to probe for directories */\n    if (S_ISDIR(sb.st_mode))\n        return VIR_STORAGE_FILE_DIR;\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot set to start of '%s'\"), path);\n        return -1;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &header)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), path);\n        return -1;\n    }\n\n    return virStorageFileProbeFormatFromBuf(path, header, len);\n}"
  },
  {
    "function_name": "virStorageFileGetMetadataInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "935-1036",
    "snippet": "static int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
      "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"1.1\""
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "meta->compat"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qcow2GetExtensions",
          "args": [
            "buf",
            "len",
            "NULL",
            "&meta->externalDataStoreRaw"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "qcow2GetExtensions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "426-541",
          "snippet": "static int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)",
            "#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441",
            "#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA",
            "#define QCOW2_HDR_EXTENSION_END 0",
            "#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)",
            "#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)",
            "#define QCOWX_HDR_VERSION (4)"
          ],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)\n#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441\n#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA\n#define QCOW2_HDR_EXTENSION_END 0\n#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)\n#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)\n#define QCOWX_HDR_VERSION (4)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "meta->externalDataStoreRaw"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileTypeInfo[meta->format].getFeatures",
          "args": [
            "&meta->features",
            "meta->format",
            "buf",
            "len"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "meta->features"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileTypeInfo[meta->format].getBackingStore",
          "args": [
            "&meta->backingStoreRaw",
            "&format",
            "buf",
            "len"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "meta->backingStoreRaw"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt64BE",
          "args": [
            "buf +\n                                               fileTypeInfo[meta->format].sizeOffset"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt64LE",
          "args": [
            "buf +\n                                               fileTypeInfo[meta->format].sizeOffset"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetEncryptionPayloadOffset",
          "args": [
            "&fileTypeInfo[meta->format].cryptInfo[i]",
            "buf"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetEncryptionPayloadOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "909-923",
          "snippet": "static int\nvirStorageFileGetEncryptionPayloadOffset(const struct FileEncryptionInfo *info,\n                                         char *buf)\n{\n    int payload_offset = -1;\n\n    if (info->payloadOffset != -1) {\n        if (info->endian == LV_LITTLE_ENDIAN)\n            payload_offset = virReadBufInt32LE(buf + info->payloadOffset);\n        else\n            payload_offset = virReadBufInt32BE(buf + info->payloadOffset);\n    }\n\n    return payload_offset;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetEncryptionPayloadOffset(const struct FileEncryptionInfo *info,\n                                         char *buf)\n{\n    int payload_offset = -1;\n\n    if (info->payloadOffset != -1) {\n        if (info->endian == LV_LITTLE_ENDIAN)\n            payload_offset = virReadBufInt32LE(buf + info->payloadOffset);\n        else\n            payload_offset = virReadBufInt32BE(buf + info->payloadOffset);\n    }\n\n    return payload_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"encryption format %d doesn't match \"\n                                         \"expected format %d\")",
            "meta->encryption->format",
            "expt_fmt"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "meta->encryption"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileHasEncryptionFormat",
          "args": [
            "&fileTypeInfo[meta->format].cryptInfo[i]",
            "buf",
            "len"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileHasEncryptionFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "869-906",
          "snippet": "static bool\nvirStorageFileHasEncryptionFormat(const struct FileEncryptionInfo *info,\n                                  char *buf,\n                                  size_t len)\n{\n    if (!info->magic && info->modeOffset == -1)\n        return false; /* Shouldn't happen - expect at least one */\n\n    if (info->magic) {\n        if (!virStorageFileMatchesMagic(info->magicOffset,\n                                        info->magic,\n                                        buf, len))\n            return false;\n\n        if (info->versionOffset != -1 &&\n            !virStorageFileMatchesVersion(info->versionOffset,\n                                          info->versionSize,\n                                          info->versionNumbers,\n                                          info->endian,\n                                          buf, len))\n            return false;\n\n        return true;\n    } else if (info->modeOffset != -1) {\n        int crypt_format;\n\n        if (info->modeOffset >= len)\n            return false;\n\n        crypt_format = virReadBufInt32BE(buf + info->modeOffset);\n        if (crypt_format != info->modeValue)\n            return false;\n\n        return true;\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileHasEncryptionFormat(const struct FileEncryptionInfo *info,\n                                  char *buf,\n                                  size_t len)\n{\n    if (!info->magic && info->modeOffset == -1)\n        return false; /* Shouldn't happen - expect at least one */\n\n    if (info->magic) {\n        if (!virStorageFileMatchesMagic(info->magicOffset,\n                                        info->magic,\n                                        buf, len))\n            return false;\n\n        if (info->versionOffset != -1 &&\n            !virStorageFileMatchesVersion(info->versionOffset,\n                                          info->versionSize,\n                                          info->versionNumbers,\n                                          info->endian,\n                                          buf, len))\n            return false;\n\n        return true;\n    } else if (info->modeOffset != -1) {\n        int crypt_format;\n\n        if (info->modeOffset >= len)\n            return false;\n\n        crypt_format = virReadBufInt32BE(buf + info->modeOffset);\n        if (crypt_format != info->modeValue)\n            return false;\n\n        return true;\n    } else {\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"unknown storage file meta->format %d\")",
            "meta->format"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileProbeFormatFromBuf",
          "args": [
            "meta->path",
            "buf",
            "len"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileProbeFormatFromBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "796-832",
          "snippet": "static int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
            "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"path=%s, buf=%p, len=%zu, meta->format=%d\"",
            "meta->path",
            "buf",
            "len",
            "meta->format"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileGetMetadataInternal(virStorageSourcePtr meta,\n                                  char *buf,\n                                  size_t len)\n{\n    int format;\n    size_t i;\n\n    VIR_DEBUG(\"path=%s, buf=%p, len=%zu, meta->format=%d\",\n              meta->path, buf, len, meta->format);\n\n    if (meta->format == VIR_STORAGE_FILE_AUTO)\n        meta->format = virStorageFileProbeFormatFromBuf(meta->path, buf, len);\n\n    if (meta->format <= VIR_STORAGE_FILE_NONE ||\n        meta->format >= VIR_STORAGE_FILE_LAST) {\n        virReportSystemError(EINVAL, _(\"unknown storage file meta->format %d\"),\n                             meta->format);\n        return -1;\n    }\n\n    if (fileTypeInfo[meta->format].cryptInfo != NULL) {\n        for (i = 0; fileTypeInfo[meta->format].cryptInfo[i].format != 0; i++) {\n            if (virStorageFileHasEncryptionFormat(&fileTypeInfo[meta->format].cryptInfo[i],\n                                                  buf, len)) {\n                int expt_fmt = fileTypeInfo[meta->format].cryptInfo[i].format;\n                if (!meta->encryption) {\n                    if (VIR_ALLOC(meta->encryption) < 0)\n                        return -1;\n\n                    meta->encryption->format = expt_fmt;\n                } else {\n                    if (meta->encryption->format != expt_fmt) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"encryption format %d doesn't match \"\n                                         \"expected format %d\"),\n                                       meta->encryption->format, expt_fmt);\n                        return -1;\n                    }\n                }\n                meta->encryption->payload_offset =\n                    virStorageFileGetEncryptionPayloadOffset(&fileTypeInfo[meta->format].cryptInfo[i], buf);\n            }\n        }\n    }\n\n    /* XXX we should consider moving virStorageBackendUpdateVolInfo\n     * code into this method, for non-magic files\n     */\n    if (!fileTypeInfo[meta->format].magic)\n        return 0;\n\n    /* Optionally extract capacity from file */\n    if (fileTypeInfo[meta->format].sizeOffset != -1) {\n        if ((fileTypeInfo[meta->format].sizeOffset + 8) > len)\n            return 0;\n\n        if (fileTypeInfo[meta->format].endian == LV_LITTLE_ENDIAN)\n            meta->capacity = virReadBufInt64LE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        else\n            meta->capacity = virReadBufInt64BE(buf +\n                                               fileTypeInfo[meta->format].sizeOffset);\n        /* Avoid unlikely, but theoretically possible overflow */\n        if (meta->capacity > (ULLONG_MAX /\n                              fileTypeInfo[meta->format].sizeMultiplier))\n            return 0;\n        meta->capacity *= fileTypeInfo[meta->format].sizeMultiplier;\n    }\n\n    VIR_FREE(meta->backingStoreRaw);\n    if (fileTypeInfo[meta->format].getBackingStore != NULL) {\n        int store = fileTypeInfo[meta->format].getBackingStore(&meta->backingStoreRaw,\n                                                               &format,\n                                                               buf, len);\n        meta->backingStoreRawFormat = format;\n\n        if (store == BACKING_STORE_INVALID)\n            return 0;\n\n        if (store == BACKING_STORE_ERROR)\n            return -1;\n    }\n\n    virBitmapFree(meta->features);\n    meta->features = NULL;\n    if (fileTypeInfo[meta->format].getFeatures != NULL &&\n        fileTypeInfo[meta->format].getFeatures(&meta->features, meta->format, buf, len) < 0)\n        return -1;\n\n    VIR_FREE(meta->externalDataStoreRaw);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 &&\n        qcow2GetExtensions(buf, len, NULL, &meta->externalDataStoreRaw) < 0) {\n        return -1;\n    }\n\n    VIR_FREE(meta->compat);\n    if (meta->format == VIR_STORAGE_FILE_QCOW2 && meta->features)\n        meta->compat = g_strdup(\"1.1\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileGetEncryptionPayloadOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "909-923",
    "snippet": "static int\nvirStorageFileGetEncryptionPayloadOffset(const struct FileEncryptionInfo *info,\n                                         char *buf)\n{\n    int payload_offset = -1;\n\n    if (info->payloadOffset != -1) {\n        if (info->endian == LV_LITTLE_ENDIAN)\n            payload_offset = virReadBufInt32LE(buf + info->payloadOffset);\n        else\n            payload_offset = virReadBufInt32BE(buf + info->payloadOffset);\n    }\n\n    return payload_offset;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + info->payloadOffset"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "buf + info->payloadOffset"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int\nvirStorageFileGetEncryptionPayloadOffset(const struct FileEncryptionInfo *info,\n                                         char *buf)\n{\n    int payload_offset = -1;\n\n    if (info->payloadOffset != -1) {\n        if (info->endian == LV_LITTLE_ENDIAN)\n            payload_offset = virReadBufInt32LE(buf + info->payloadOffset);\n        else\n            payload_offset = virReadBufInt32BE(buf + info->payloadOffset);\n    }\n\n    return payload_offset;\n}"
  },
  {
    "function_name": "virStorageFileHasEncryptionFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "869-906",
    "snippet": "static bool\nvirStorageFileHasEncryptionFormat(const struct FileEncryptionInfo *info,\n                                  char *buf,\n                                  size_t len)\n{\n    if (!info->magic && info->modeOffset == -1)\n        return false; /* Shouldn't happen - expect at least one */\n\n    if (info->magic) {\n        if (!virStorageFileMatchesMagic(info->magicOffset,\n                                        info->magic,\n                                        buf, len))\n            return false;\n\n        if (info->versionOffset != -1 &&\n            !virStorageFileMatchesVersion(info->versionOffset,\n                                          info->versionSize,\n                                          info->versionNumbers,\n                                          info->endian,\n                                          buf, len))\n            return false;\n\n        return true;\n    } else if (info->modeOffset != -1) {\n        int crypt_format;\n\n        if (info->modeOffset >= len)\n            return false;\n\n        crypt_format = virReadBufInt32BE(buf + info->modeOffset);\n        if (crypt_format != info->modeValue)\n            return false;\n\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + info->modeOffset"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileMatchesVersion",
          "args": [
            "info->versionOffset",
            "info->versionSize",
            "info->versionNumbers",
            "info->endian",
            "buf",
            "len"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMatchesVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "708-760",
          "snippet": "static bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define FILE_TYPE_VERSIONS_LAST 3"
          ],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define FILE_TYPE_VERSIONS_LAST 3\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileMatchesMagic",
          "args": [
            "info->magicOffset",
            "info->magic",
            "buf",
            "len"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMatchesMagic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "685-705",
          "snippet": "static bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileHasEncryptionFormat(const struct FileEncryptionInfo *info,\n                                  char *buf,\n                                  size_t len)\n{\n    if (!info->magic && info->modeOffset == -1)\n        return false; /* Shouldn't happen - expect at least one */\n\n    if (info->magic) {\n        if (!virStorageFileMatchesMagic(info->magicOffset,\n                                        info->magic,\n                                        buf, len))\n            return false;\n\n        if (info->versionOffset != -1 &&\n            !virStorageFileMatchesVersion(info->versionOffset,\n                                          info->versionSize,\n                                          info->versionNumbers,\n                                          info->endian,\n                                          buf, len))\n            return false;\n\n        return true;\n    } else if (info->modeOffset != -1) {\n        int crypt_format;\n\n        if (info->modeOffset >= len)\n            return false;\n\n        crypt_format = virReadBufInt32BE(buf + info->modeOffset);\n        if (crypt_format != info->modeValue)\n            return false;\n\n        return true;\n    } else {\n        return false;\n    }\n}"
  },
  {
    "function_name": "qcow2GetFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "835-866",
    "snippet": "static int\nqcow2GetFeatures(virBitmapPtr *features,\n                 int format,\n                 char *buf,\n                 ssize_t len)\n{\n    int version = -1;\n    virBitmapPtr feat = NULL;\n    uint64_t bits;\n    size_t i;\n\n    version = virReadBufInt32BE(buf + fileTypeInfo[format].versionOffset);\n\n    if (version == 2)\n        return 0;\n\n    if (len < QCOW2v3_HDR_SIZE)\n        return -1;\n\n    if (!(feat = virBitmapNew(VIR_STORAGE_FILE_FEATURE_LAST)))\n        return -1;\n\n    /* todo: check for incompatible or autoclear features? */\n    bits = virReadBufInt64BE(buf + QCOW2v3_HDR_FEATURES_COMPATIBLE);\n    for (i = 0; i < QCOW2_COMPATIBLE_FEATURE_LAST; i++) {\n        if (bits & ((uint64_t) 1 << i))\n            ignore_value(virBitmapSetBit(feat, qcow2CompatibleFeatureArray[i]));\n    }\n\n    *features = feat;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)",
      "#define QCOW2v3_HDR_FEATURES_COMPATIBLE (QCOW2v3_HDR_FEATURES_INCOMPATIBLE+8)"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
      "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};",
      "static const int qcow2CompatibleFeatureArray[] = {\n    VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(feat, qcow2CompatibleFeatureArray[i])"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "feat",
            "qcow2CompatibleFeatureArray[i]"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReadBufInt64BE",
          "args": [
            "buf + QCOW2v3_HDR_FEATURES_COMPATIBLE"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "VIR_STORAGE_FILE_FEATURE_LAST"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + fileTypeInfo[format].versionOffset"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)\n#define QCOW2v3_HDR_FEATURES_COMPATIBLE (QCOW2v3_HDR_FEATURES_INCOMPATIBLE+8)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\nstatic const int qcow2CompatibleFeatureArray[] = {\n    VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS,\n};\n\nstatic int\nqcow2GetFeatures(virBitmapPtr *features,\n                 int format,\n                 char *buf,\n                 ssize_t len)\n{\n    int version = -1;\n    virBitmapPtr feat = NULL;\n    uint64_t bits;\n    size_t i;\n\n    version = virReadBufInt32BE(buf + fileTypeInfo[format].versionOffset);\n\n    if (version == 2)\n        return 0;\n\n    if (len < QCOW2v3_HDR_SIZE)\n        return -1;\n\n    if (!(feat = virBitmapNew(VIR_STORAGE_FILE_FEATURE_LAST)))\n        return -1;\n\n    /* todo: check for incompatible or autoclear features? */\n    bits = virReadBufInt64BE(buf + QCOW2v3_HDR_FEATURES_COMPATIBLE);\n    for (i = 0; i < QCOW2_COMPATIBLE_FEATURE_LAST; i++) {\n        if (bits & ((uint64_t) 1 << i))\n            ignore_value(virBitmapSetBit(feat, qcow2CompatibleFeatureArray[i]));\n    }\n\n    *features = feat;\n    return 0;\n}"
  },
  {
    "function_name": "virStorageFileProbeFormatFromBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "796-832",
    "snippet": "static int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);",
      "static struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"format=%d\"",
            "format"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\"",
            "path",
            "virStorageFileFormatTypeToString(possibleFormat)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "possibleFormat"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileMatchesVersion",
          "args": [
            "fileTypeInfo[i].versionOffset",
            "fileTypeInfo[i].versionSize",
            "fileTypeInfo[i].versionNumbers",
            "fileTypeInfo[i].endian",
            "buf",
            "buflen"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMatchesVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "708-760",
          "snippet": "static bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define FILE_TYPE_VERSIONS_LAST 3"
          ],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define FILE_TYPE_VERSIONS_LAST 3\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileMatchesMagic",
          "args": [
            "fileTypeInfo[i].magicOffset",
            "fileTypeInfo[i].magic",
            "buf",
            "buflen"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileMatchesMagic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "685-705",
          "snippet": "static bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"path=%s, buf=%p, buflen=%zu\"",
            "path",
            "buf",
            "buflen"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\nstatic struct FileTypeInfo const fileTypeInfo[] = {\n    [VIR_STORAGE_FILE_NONE] = { 0, NULL, LV_LITTLE_ENDIAN,\n                                -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_RAW] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0,\n                               luksEncryptionInfo,\n                               NULL, NULL },\n    [VIR_STORAGE_FILE_DIR] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_BOCHS] = {\n        /*\"Bochs Virtual HD Image\", */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, 64, 4, {0x20000},\n        32+16+16+4+4+4+4+4, 8, 1, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_CLOOP] = {\n        /* #!/bin/sh\n           #V2.0 Format\n           modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n        */ /* Untested */\n        0, NULL,\n        LV_LITTLE_ENDIAN, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_DMG] = {\n        /* XXX QEMU says there's no magic for dmg,\n         * /usr/share/misc/magic lists double magic (both offsets\n         * would have to match) but then disables that check. */\n        0, NULL,\n        0, -1, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_ISO] = {\n        32769, \"CD001\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        -1, 0, 0, NULL, NULL, NULL\n    },\n    [VIR_STORAGE_FILE_VPC] = {\n        0, \"conectix\",\n        LV_BIG_ENDIAN, 12, 4, {0x10000},\n        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, NULL, NULL, NULL\n    },\n    /* TODO: add getBackingStore function */\n    [VIR_STORAGE_FILE_VDI] = {\n        64, \"\\x7f\\x10\\xda\\xbe\",\n        LV_LITTLE_ENDIAN, 68, 4, {0x00010001},\n        64 + 5 * 4 + 256 + 7 * 4, 8, 1, NULL, NULL, NULL},\n\n    /* Not direct file formats, but used for various drivers */\n    [VIR_STORAGE_FILE_FAT] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_VHD] = { 0, NULL, LV_LITTLE_ENDIAN,\n                               -1, 0, {0}, 0, 0, 0, NULL, NULL, NULL },\n    [VIR_STORAGE_FILE_PLOOP] = { 0, \"WithouFreSpacExt\", LV_LITTLE_ENDIAN,\n                                 -2, 0, {0}, PLOOP_IMAGE_SIZE_OFFSET, 0,\n                                 PLOOP_SIZE_MULTIPLIER, NULL, NULL, NULL },\n\n    /* All formats with a backing store probe below here */\n    [VIR_STORAGE_FILE_COW] = {\n        0, \"OOOM\",\n        LV_BIG_ENDIAN, 4, 4, {2},\n        4+4+1024+4, 8, 1, NULL, cowGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {1},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow1EncryptionInfo,\n        qcowXGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_QCOW2] = {\n        0, \"QFI\",\n        LV_BIG_ENDIAN, 4, 4, {2, 3},\n        QCOWX_HDR_IMAGE_SIZE, 8, 1,\n        qcow2EncryptionInfo,\n        qcowXGetBackingStore,\n        qcow2GetFeatures\n    },\n    [VIR_STORAGE_FILE_QED] = {\n        /* https://wiki.qemu.org/Features/QED */\n        0, \"QED\",\n        LV_LITTLE_ENDIAN, -2, 0, {0},\n        QED_HDR_IMAGE_SIZE, 8, 1, NULL, qedGetBackingStore, NULL\n    },\n    [VIR_STORAGE_FILE_VMDK] = {\n        0, \"KDMV\",\n        LV_LITTLE_ENDIAN, 4, 4, {1, 2, 3},\n        4+4+4, 8, 512, NULL, vmdk4GetBackingStore, NULL\n    },\n};\n\nstatic int\nvirStorageFileProbeFormatFromBuf(const char *path,\n                                 char *buf,\n                                 size_t buflen)\n{\n    int format = VIR_STORAGE_FILE_RAW;\n    size_t i;\n    int possibleFormat = VIR_STORAGE_FILE_RAW;\n    VIR_DEBUG(\"path=%s, buf=%p, buflen=%zu\", path, buf, buflen);\n\n    /* First check file magic */\n    for (i = 0; i < VIR_STORAGE_FILE_LAST; i++) {\n        if (virStorageFileMatchesMagic(fileTypeInfo[i].magicOffset,\n                                       fileTypeInfo[i].magic,\n                                       buf, buflen)) {\n            if (!virStorageFileMatchesVersion(fileTypeInfo[i].versionOffset,\n                                              fileTypeInfo[i].versionSize,\n                                              fileTypeInfo[i].versionNumbers,\n                                              fileTypeInfo[i].endian,\n                                              buf, buflen)) {\n                possibleFormat = i;\n                continue;\n            }\n            format = i;\n            goto cleanup;\n        }\n    }\n\n    if (possibleFormat != VIR_STORAGE_FILE_RAW)\n        VIR_WARN(\"File %s matches %s magic, but version is wrong. \"\n                 \"Please report new version to libvir-list@redhat.com\",\n                 path, virStorageFileFormatTypeToString(possibleFormat));\n\n cleanup:\n    VIR_DEBUG(\"format=%d\", format);\n    return format;\n}"
  },
  {
    "function_name": "virStorageIsRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "783-793",
    "snippet": "bool\nvirStorageIsRelative(const char *backing)\n{\n    if (backing[0] == '/')\n        return false;\n\n    if (!virStorageIsFile(backing))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageIsFile",
          "args": [
            "backing"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageIsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "762-780",
          "snippet": "bool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsRelative(const char *backing)\n{\n    if (backing[0] == '/')\n        return false;\n\n    if (!virStorageIsFile(backing))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStorageIsFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "762-780",
    "snippet": "bool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "backing",
            "'/'"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "backing",
            "':'"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageIsFile(const char *backing)\n{\n    char *colon;\n    char *slash;\n\n    if (!backing)\n        return false;\n\n    colon = strchr(backing, ':');\n    slash = strchr(backing, '/');\n\n    /* Reject anything that looks like a protocol (such as nbd: or\n     * rbd:); if someone really does want a relative file name that\n     * includes ':', they can always prefix './'.  */\n    if (colon && (!slash || colon < slash))\n        return false;\n    return true;\n}"
  },
  {
    "function_name": "virStorageFileMatchesVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "708-760",
    "snippet": "static bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define FILE_TYPE_VERSIONS_LAST 3"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Compare detected version %d vs one of the expected versions %d\"",
            "version",
            "versionNumbers[i]"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt16BE",
          "args": [
            "buf +\n                                        versionOffset"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf +\n                                        versionOffset"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt16LE",
          "args": [
            "buf +\n                                        versionOffset"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "buf +\n                                        versionOffset"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define FILE_TYPE_VERSIONS_LAST 3\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesVersion(int versionOffset,\n                             int versionSize,\n                             const int *versionNumbers,\n                             int endian,\n                             char *buf,\n                             size_t buflen)\n{\n    int version;\n    size_t i;\n\n    /* Validate version number info */\n    if (versionOffset == -1)\n        return false;\n\n    /* -2 == non-versioned file format, so trivially match */\n    if (versionOffset == -2)\n        return true;\n\n    /* A positive versionOffset, requires using a valid versionSize */\n    if (versionSize != 2 && versionSize != 4)\n        return false;\n\n    if ((versionOffset + versionSize) > buflen)\n        return false;\n\n    if (endian == LV_LITTLE_ENDIAN) {\n        if (versionSize == 4)\n            version = virReadBufInt32LE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16LE(buf +\n                                        versionOffset);\n    } else {\n        if (versionSize == 4)\n            version = virReadBufInt32BE(buf +\n                                        versionOffset);\n        else\n            version = virReadBufInt16BE(buf +\n                                        versionOffset);\n    }\n\n    for (i = 0;\n         i < FILE_TYPE_VERSIONS_LAST && versionNumbers[i];\n         i++) {\n        VIR_DEBUG(\"Compare detected version %d vs one of the expected versions %d\",\n                  version, versionNumbers[i]);\n        if (version == versionNumbers[i])\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virStorageFileMatchesMagic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "685-705",
    "snippet": "static bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf + magicOffset",
            "magic",
            "mlen"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "magic"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic bool\nvirStorageFileMatchesMagic(int magicOffset,\n                           const char *magic,\n                           char *buf,\n                           size_t buflen)\n{\n    int mlen;\n\n    if (magic == NULL)\n        return false;\n\n    /* Validate magic data */\n    mlen = strlen(magic);\n    if (magicOffset + mlen > buflen)\n        return false;\n\n    if (memcmp(buf + magicOffset, magic, mlen) != 0)\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "qedGetBackingStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "641-682",
    "snippet": "static int\nqedGetBackingStore(char **res,\n                   int *format,\n                   const char *buf,\n                   size_t buf_size)\n{\n    unsigned long long flags;\n    unsigned long offset, size;\n\n    *res = NULL;\n    /* Check if this image has a backing file */\n    if (buf_size < QED_HDR_FEATURES_OFFSET+8)\n        return BACKING_STORE_INVALID;\n    flags = virReadBufInt64LE(buf + QED_HDR_FEATURES_OFFSET);\n    if (!(flags & QED_F_BACKING_FILE)) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    /* Parse the backing file */\n    if (buf_size < QED_HDR_BACKING_FILE_OFFSET+8)\n        return BACKING_STORE_INVALID;\n    offset = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_OFFSET);\n    if (offset > buf_size)\n        return BACKING_STORE_INVALID;\n    size = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_SIZE);\n    if (size == 0)\n        return BACKING_STORE_OK;\n    if (offset + size > buf_size || offset + size < offset)\n        return BACKING_STORE_INVALID;\n    if (VIR_ALLOC_N(*res, size + 1) < 0)\n        return BACKING_STORE_ERROR;\n    memcpy(*res, buf + offset, size);\n    (*res)[size] = '\\0';\n\n    if (flags & QED_F_BACKING_FORMAT_NO_PROBE)\n        *format = VIR_STORAGE_FILE_RAW;\n    else\n        *format = VIR_STORAGE_FILE_AUTO_SAFE;\n\n    return BACKING_STORE_OK;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QED_F_BACKING_FORMAT_NO_PROBE 0x04",
      "#define QED_F_BACKING_FILE 0x01",
      "#define QED_HDR_BACKING_FILE_SIZE (QED_HDR_BACKING_FILE_OFFSET+4)",
      "#define QED_HDR_BACKING_FILE_OFFSET (QED_HDR_IMAGE_SIZE+8)",
      "#define QED_HDR_FEATURES_OFFSET (4+4+4+4)"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*res",
            "buf + offset",
            "size"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*res",
            "size + 1"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "buf + QED_HDR_BACKING_FILE_SIZE"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "buf + QED_HDR_BACKING_FILE_OFFSET"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt64LE",
          "args": [
            "buf + QED_HDR_FEATURES_OFFSET"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QED_F_BACKING_FORMAT_NO_PROBE 0x04\n#define QED_F_BACKING_FILE 0x01\n#define QED_HDR_BACKING_FILE_SIZE (QED_HDR_BACKING_FILE_OFFSET+4)\n#define QED_HDR_BACKING_FILE_OFFSET (QED_HDR_IMAGE_SIZE+8)\n#define QED_HDR_FEATURES_OFFSET (4+4+4+4)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nqedGetBackingStore(char **res,\n                   int *format,\n                   const char *buf,\n                   size_t buf_size)\n{\n    unsigned long long flags;\n    unsigned long offset, size;\n\n    *res = NULL;\n    /* Check if this image has a backing file */\n    if (buf_size < QED_HDR_FEATURES_OFFSET+8)\n        return BACKING_STORE_INVALID;\n    flags = virReadBufInt64LE(buf + QED_HDR_FEATURES_OFFSET);\n    if (!(flags & QED_F_BACKING_FILE)) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    /* Parse the backing file */\n    if (buf_size < QED_HDR_BACKING_FILE_OFFSET+8)\n        return BACKING_STORE_INVALID;\n    offset = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_OFFSET);\n    if (offset > buf_size)\n        return BACKING_STORE_INVALID;\n    size = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_SIZE);\n    if (size == 0)\n        return BACKING_STORE_OK;\n    if (offset + size > buf_size || offset + size < offset)\n        return BACKING_STORE_INVALID;\n    if (VIR_ALLOC_N(*res, size + 1) < 0)\n        return BACKING_STORE_ERROR;\n    memcpy(*res, buf + offset, size);\n    (*res)[size] = '\\0';\n\n    if (flags & QED_F_BACKING_FORMAT_NO_PROBE)\n        *format = VIR_STORAGE_FILE_RAW;\n    else\n        *format = VIR_STORAGE_FILE_AUTO_SAFE;\n\n    return BACKING_STORE_OK;\n}"
  },
  {
    "function_name": "vmdk4GetBackingStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "589-639",
    "snippet": "static int\nvmdk4GetBackingStore(char **res,\n                     int *format,\n                     const char *buf,\n                     size_t buf_size)\n{\n    static const char prefix[] = \"parentFileNameHint=\\\"\";\n    char *start, *end;\n    size_t len;\n    g_autofree char *desc = NULL;\n\n    if (VIR_ALLOC_N(desc, VIR_STORAGE_MAX_HEADER) < 0)\n        return BACKING_STORE_ERROR;\n\n    *res = NULL;\n    /*\n     * Technically this should have been VMDK, since\n     * VMDK spec / VMware impl only support VMDK backed\n     * by VMDK. QEMU isn't following this though and\n     * does probing on VMDK backing files, hence we set\n     * AUTO\n     */\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size <= 0x200)\n        return BACKING_STORE_INVALID;\n\n    len = buf_size - 0x200;\n    if (len > VIR_STORAGE_MAX_HEADER)\n        len = VIR_STORAGE_MAX_HEADER;\n    memcpy(desc, buf + 0x200, len);\n    desc[len] = '\\0';\n    start = strstr(desc, prefix);\n    if (start == NULL) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    start += strlen(prefix);\n    end = strchr(start, '\"');\n    if (end == NULL)\n        return BACKING_STORE_INVALID;\n\n    if (end == start) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    *end = '\\0';\n    *res = g_strdup(start);\n\n    return BACKING_STORE_OK;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "start"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start",
            "'\"'"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "desc",
            "prefix"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "desc",
            "buf + 0x200",
            "len"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "desc",
            "VIR_STORAGE_MAX_HEADER"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nvmdk4GetBackingStore(char **res,\n                     int *format,\n                     const char *buf,\n                     size_t buf_size)\n{\n    static const char prefix[] = \"parentFileNameHint=\\\"\";\n    char *start, *end;\n    size_t len;\n    g_autofree char *desc = NULL;\n\n    if (VIR_ALLOC_N(desc, VIR_STORAGE_MAX_HEADER) < 0)\n        return BACKING_STORE_ERROR;\n\n    *res = NULL;\n    /*\n     * Technically this should have been VMDK, since\n     * VMDK spec / VMware impl only support VMDK backed\n     * by VMDK. QEMU isn't following this though and\n     * does probing on VMDK backing files, hence we set\n     * AUTO\n     */\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size <= 0x200)\n        return BACKING_STORE_INVALID;\n\n    len = buf_size - 0x200;\n    if (len > VIR_STORAGE_MAX_HEADER)\n        len = VIR_STORAGE_MAX_HEADER;\n    memcpy(desc, buf + 0x200, len);\n    desc[len] = '\\0';\n    start = strstr(desc, prefix);\n    if (start == NULL) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    start += strlen(prefix);\n    end = strchr(start, '\"');\n    if (end == NULL)\n        return BACKING_STORE_INVALID;\n\n    if (end == start) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    *end = '\\0';\n    *res = g_strdup(start);\n\n    return BACKING_STORE_OK;\n}"
  },
  {
    "function_name": "qcowXGetBackingStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "544-586",
    "snippet": "static int\nqcowXGetBackingStore(char **res,\n                     int *format,\n                     const char *buf,\n                     size_t buf_size)\n{\n    unsigned long long offset;\n    unsigned int size;\n\n    *res = NULL;\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size < QCOWX_HDR_BACKING_FILE_OFFSET+8+4)\n        return BACKING_STORE_INVALID;\n\n    offset = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (offset > buf_size)\n        return BACKING_STORE_INVALID;\n\n    if (offset == 0) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    size = virReadBufInt32BE(buf + QCOWX_HDR_BACKING_FILE_SIZE);\n    if (size == 0) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    if (size > 1023)\n        return BACKING_STORE_INVALID;\n    if (offset + size > buf_size || offset + size < offset)\n        return BACKING_STORE_INVALID;\n    if (VIR_ALLOC_N(*res, size + 1) < 0)\n        return BACKING_STORE_ERROR;\n    memcpy(*res, buf + offset, size);\n    (*res)[size] = '\\0';\n\n    if (qcow2GetExtensions(buf, buf_size, format, NULL) < 0)\n        return BACKING_STORE_INVALID;\n\n    return BACKING_STORE_OK;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QCOWX_HDR_BACKING_FILE_SIZE (QCOWX_HDR_BACKING_FILE_OFFSET+8)",
      "#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qcow2GetExtensions",
          "args": [
            "buf",
            "buf_size",
            "format",
            "NULL"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "qcow2GetExtensions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "426-541",
          "snippet": "static int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)",
            "#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441",
            "#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA",
            "#define QCOW2_HDR_EXTENSION_END 0",
            "#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)",
            "#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)",
            "#define QCOWX_HDR_VERSION (4)"
          ],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)\n#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441\n#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA\n#define QCOW2_HDR_EXTENSION_END 0\n#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)\n#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)\n#define QCOWX_HDR_VERSION (4)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*res",
            "buf + offset",
            "size"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*res",
            "size + 1"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + QCOWX_HDR_BACKING_FILE_SIZE"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt64BE",
          "args": [
            "buf + QCOWX_HDR_BACKING_FILE_OFFSET"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QCOWX_HDR_BACKING_FILE_SIZE (QCOWX_HDR_BACKING_FILE_OFFSET+8)\n#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nqcowXGetBackingStore(char **res,\n                     int *format,\n                     const char *buf,\n                     size_t buf_size)\n{\n    unsigned long long offset;\n    unsigned int size;\n\n    *res = NULL;\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size < QCOWX_HDR_BACKING_FILE_OFFSET+8+4)\n        return BACKING_STORE_INVALID;\n\n    offset = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (offset > buf_size)\n        return BACKING_STORE_INVALID;\n\n    if (offset == 0) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    size = virReadBufInt32BE(buf + QCOWX_HDR_BACKING_FILE_SIZE);\n    if (size == 0) {\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n    if (size > 1023)\n        return BACKING_STORE_INVALID;\n    if (offset + size > buf_size || offset + size < offset)\n        return BACKING_STORE_INVALID;\n    if (VIR_ALLOC_N(*res, size + 1) < 0)\n        return BACKING_STORE_ERROR;\n    memcpy(*res, buf + offset, size);\n    (*res)[size] = '\\0';\n\n    if (qcow2GetExtensions(buf, buf_size, format, NULL) < 0)\n        return BACKING_STORE_INVALID;\n\n    return BACKING_STORE_OK;\n}"
  },
  {
    "function_name": "qcow2GetExtensions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "426-541",
    "snippet": "static int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)",
      "#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441",
      "#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA",
      "#define QCOW2_HDR_EXTENSION_END 0",
      "#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)",
      "#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)",
      "#define QCOWX_HDR_VERSION (4)"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"parsed externalDataStoreRaw='%s'\"",
            "*externalDataStoreRaw"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*externalDataStoreRaw",
            "buf + offset",
            "len"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*externalDataStoreRaw",
            "len + 1"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "buf + offset",
            "len"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "tmp",
            "len + 1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + offset + 4"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + offset"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt64BE",
          "args": [
            "buf + QCOWX_HDR_BACKING_FILE_OFFSET"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + QCOW2v3_HDR_SIZE"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32BE",
          "args": [
            "buf + QCOWX_HDR_VERSION"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define QCOW2v3_HDR_SIZE       (QCOW2_HDR_TOTAL_SIZE+8+8+8+4)\n#define QCOW2_HDR_EXTENSION_DATA_FILE 0x44415441\n#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA\n#define QCOW2_HDR_EXTENSION_END 0\n#define QCOW2_HDR_TOTAL_SIZE (QCOW2_HDR_CRYPT+4+4+8+8+4+4+8)\n#define QCOWX_HDR_BACKING_FILE_OFFSET (QCOWX_HDR_VERSION+4)\n#define QCOWX_HDR_VERSION (4)\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\nqcow2GetExtensions(const char *buf,\n                   size_t buf_size,\n                   int *backingFormat,\n                   char **externalDataStoreRaw)\n{\n    size_t offset;\n    size_t extension_start;\n    size_t extension_end;\n    int version = virReadBufInt32BE(buf + QCOWX_HDR_VERSION);\n\n    if (version < 2) {\n        /* QCow1 doesn't have the extensions capability\n         * used to store backing format */\n        return 0;\n    }\n\n    if (version == 2)\n        extension_start = QCOW2_HDR_TOTAL_SIZE;\n    else\n        extension_start = virReadBufInt32BE(buf + QCOW2v3_HDR_SIZE);\n\n    /*\n     * Traditionally QCow2 files had a layout of\n     *\n     * [header]\n     * [backingStoreName]\n     *\n     * Although the backingStoreName typically followed\n     * the header immediately, this was not required by\n     * the format. By specifying a higher byte offset for\n     * the backing file offset in the header, it was\n     * possible to leave space between the header and\n     * start of backingStore.\n     *\n     * This hack is now used to store extensions to the\n     * qcow2 format:\n     *\n     * [header]\n     * [extensions]\n     * [backingStoreName]\n     *\n     * Thus the file region to search for extensions is\n     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)\n     * and the start of the backingStoreName (offset)\n     *\n     * for qcow2 v3 images, the length of the header\n     * is stored at QCOW2v3_HDR_SIZE\n     */\n    extension_end = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);\n    if (extension_end > buf_size)\n        return -1;\n\n    /*\n     * The extensions take format of\n     *\n     * int32: magic\n     * int32: length\n     * byte[length]: payload\n     *\n     * Unknown extensions can be ignored by skipping\n     * over \"length\" bytes in the data stream.\n     */\n    offset = extension_start;\n    while (offset < (buf_size-8) &&\n           offset < (extension_end-8)) {\n        unsigned int magic = virReadBufInt32BE(buf + offset);\n        unsigned int len = virReadBufInt32BE(buf + offset + 4);\n\n        offset += 8;\n\n        if ((offset + len) < offset)\n            break;\n\n        if ((offset + len) > buf_size)\n            break;\n\n        switch (magic) {\n        case QCOW2_HDR_EXTENSION_BACKING_FORMAT: {\n            g_autofree char *tmp = NULL;\n            if (!backingFormat)\n                break;\n\n            if (VIR_ALLOC_N(tmp, len + 1) < 0)\n                return -1;\n            memcpy(tmp, buf + offset, len);\n            tmp[len] = '\\0';\n\n            *backingFormat = virStorageFileFormatTypeFromString(tmp);\n            if (*backingFormat <= VIR_STORAGE_FILE_NONE)\n                return -1;\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_DATA_FILE: {\n            if (!externalDataStoreRaw)\n                break;\n\n            if (VIR_ALLOC_N(*externalDataStoreRaw, len + 1) < 0)\n                return -1;\n            memcpy(*externalDataStoreRaw, buf + offset, len);\n            (*externalDataStoreRaw)[len] = '\\0';\n            VIR_DEBUG(\"parsed externalDataStoreRaw='%s'\",\n                      *externalDataStoreRaw);\n            break;\n        }\n\n        case QCOW2_HDR_EXTENSION_END:\n            return 0;\n        }\n\n        offset += len;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "cowGetBackingStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
    "lines": "404-423",
    "snippet": "static int\ncowGetBackingStore(char **res,\n                   int *format,\n                   const char *buf,\n                   size_t buf_size)\n{\n#define COW_FILENAME_MAXLEN 1024\n    *res = NULL;\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size < 4+4+ COW_FILENAME_MAXLEN)\n        return BACKING_STORE_INVALID;\n    if (buf[4+4] == '\\0') { /* cow_header_v2.backing_file[0] */\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    *res = g_strndup((const char *)buf + 4 + 4, COW_FILENAME_MAXLEN);\n    return BACKING_STORE_OK;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstorageencryption.h\"",
      "#include \"virjson.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virhash.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"virstoragefilebackend.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define COW_FILENAME_MAXLEN 1024"
    ],
    "globals_used": [
      "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
      "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
      "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "(const char *)buf + 4 + 4",
            "COW_FILENAME_MAXLEN"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\n#define COW_FILENAME_MAXLEN 1024\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nstatic int\ncowGetBackingStore(char **res,\n                   int *format,\n                   const char *buf,\n                   size_t buf_size)\n{\n#define COW_FILENAME_MAXLEN 1024\n    *res = NULL;\n    *format = VIR_STORAGE_FILE_AUTO;\n\n    if (buf_size < 4+4+ COW_FILENAME_MAXLEN)\n        return BACKING_STORE_INVALID;\n    if (buf[4+4] == '\\0') { /* cow_header_v2.backing_file[0] */\n        *format = VIR_STORAGE_FILE_NONE;\n        return BACKING_STORE_OK;\n    }\n\n    *res = g_strndup((const char *)buf + 4 + 4, COW_FILENAME_MAXLEN);\n    return BACKING_STORE_OK;\n}"
  }
]