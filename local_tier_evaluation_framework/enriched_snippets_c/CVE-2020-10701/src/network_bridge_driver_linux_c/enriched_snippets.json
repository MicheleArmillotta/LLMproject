[
  {
    "function_name": "networkRemoveFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "907-932",
    "snippet": "void networkRemoveFirewallRules(virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    virFirewallPtr fw = NULL;\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    networkRemoveChecksumFirewallRules(fw, def);\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkRemoveIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n    networkRemoveGeneralFirewallRules(fw, def);\n\n    virFirewallApply(fw);\n\n cleanup:\n    virFirewallFree(fw);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveGeneralFirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveGeneralFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "686-692",
          "snippet": "static void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveIPSpecificFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveIPSpecificFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "762-776",
          "snippet": "static int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_UNSPEC",
            "i"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveChecksumFirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveChecksumFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "720-738",
          "snippet": "static void\nnetworkRemoveChecksumFirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    if (ipv4def)\n        iptablesRemoveOutputFixUdpChecksum(fw, def->bridge, 68);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveChecksumFirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    if (ipv4def)\n        iptablesRemoveOutputFixUdpChecksum(fw, def->bridge, 68);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid networkRemoveFirewallRules(virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    virFirewallPtr fw = NULL;\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    networkRemoveChecksumFirewallRules(fw, def);\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkRemoveIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n    networkRemoveGeneralFirewallRules(fw, def);\n\n    virFirewallApply(fw);\n\n cleanup:\n    virFirewallFree(fw);\n}"
  },
  {
    "function_name": "networkAddFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "780-904",
    "snippet": "int networkAddFirewallRules(virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    virFirewallPtr fw = NULL;\n    int ret = -1;\n\n    if (virOnce(&createdOnce, networkSetupPrivateChains) < 0)\n        return -1;\n\n    if (errInitV4 &&\n        (virNetworkDefGetIPByIndex(def, AF_INET, 0) ||\n         virNetworkDefGetRouteByIndex(def, AF_INET, 0))) {\n        virSetError(errInitV4);\n        return -1;\n    }\n\n    if (errInitV6 &&\n        (virNetworkDefGetIPByIndex(def, AF_INET6, 0) ||\n         virNetworkDefGetRouteByIndex(def, AF_INET6, 0) ||\n         def->ipv6nogw)) {\n        virSetError(errInitV6);\n        return -1;\n    }\n\n    if (def->bridgeZone) {\n\n        /* if a firewalld zone has been specified, fail/log an error\n         * if we can't honor it\n         */\n        if (virFirewallDIsRegistered() < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"zone %s requested for network %s \"\n                             \"but firewalld is not active\"),\n                           def->bridgeZone, def->name);\n            goto cleanup;\n        }\n\n        if (virFirewallDInterfaceSetZone(def->bridge, def->bridgeZone) < 0)\n            goto cleanup;\n\n    } else {\n\n        /* if firewalld is active, try to set the \"libvirt\" zone. This is\n         * desirable (for consistency) if firewalld is using the iptables\n         * backend, but is necessary (for basic network connectivity) if\n         * firewalld is using the nftables backend\n         */\n        if (virFirewallDIsRegistered() == 0) {\n\n            /* if the \"libvirt\" zone exists, then set it. If not, and\n             * if firewalld is using the nftables backend, then we\n             * need to log an error because the combination of\n             * nftables + default zone means that traffic cannot be\n             * forwarded (and even DHCP and DNS from guest to host\n             * will probably no be permitted by the default zone\n             */\n            if (virFirewallDZoneExists(\"libvirt\")) {\n                if (virFirewallDInterfaceSetZone(def->bridge, \"libvirt\") < 0)\n                    goto cleanup;\n            } else {\n                unsigned long version;\n                int vresult = virFirewallDGetVersion(&version);\n\n                if (vresult < 0)\n                    goto cleanup;\n\n                /* Support for nftables backend was added in firewalld\n                 * 0.6.0. Support for rule priorities (required by the\n                 * 'libvirt' zone, which should be installed by a\n                 * libvirt package, *not* by firewalld) was not added\n                 * until firewalld 0.7.0 (unless it was backported).\n                 */\n                if (version >= 6000 &&\n                    virFirewallDGetBackend() == VIR_FIREWALLD_BACKEND_NFTABLES) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld is set to use the nftables \"\n                                     \"backend, but the required firewalld \"\n                                     \"'libvirt' zone is missing. Either set \"\n                                     \"the firewalld backend to 'iptables', or \"\n                                     \"ensure that firewalld has a 'libvirt' \"\n                                     \"zone by upgrading firewalld to a \"\n                                     \"version supporting rule priorities \"\n                                     \"(0.7.0+) and/or rebuilding \"\n                                     \"libvirt with --with-firewalld-zone\"));\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, 0);\n\n    networkAddGeneralFirewallRules(fw, def);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkAddIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n\n    virFirewallStartRollback(fw, 0);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkRemoveIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n    networkRemoveGeneralFirewallRules(fw, def);\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    networkAddChecksumFirewallRules(fw, def);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virOnceControl createdOnce;",
      "static virErrorPtr errInitV4;",
      "static virErrorPtr errInitV6;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddChecksumFirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddChecksumFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "694-717",
          "snippet": "static void\nnetworkAddChecksumFirewallRules(virFirewallPtr fw,\n                                virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    /* If we are doing local DHCP service on this network, attempt to\n     * add a rule that will fixup the checksum of DHCP response\n     * packets back to the guests (but report failure without\n     * aborting, since not all iptables implementations support it).\n     */\n    if (ipv4def)\n        iptablesAddOutputFixUdpChecksum(fw, def->bridge, 68);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddChecksumFirewallRules(virFirewallPtr fw,\n                                virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    /* If we are doing local DHCP service on this network, attempt to\n     * add a rule that will fixup the checksum of DHCP response\n     * packets back to the guests (but report failure without\n     * aborting, since not all iptables implementations support it).\n     */\n    if (ipv4def)\n        iptablesAddOutputFixUdpChecksum(fw, def->bridge, 68);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveGeneralFirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveGeneralFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "686-692",
          "snippet": "static void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveIPSpecificFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveIPSpecificFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "762-776",
          "snippet": "static int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_UNSPEC",
            "i"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartRollback",
          "args": [
            "fw",
            "0"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "622-637",
          "snippet": "void virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddIPSpecificFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddIPSpecificFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "741-759",
          "snippet": "static int\nnetworkAddIPSpecificFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    /* NB: in the case of IPv6, routing rules are added when the\n     * forward mode is NAT. This is because IPv6 has no NAT.\n     */\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkAddMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkAddRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkAddRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkAddIPSpecificFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    /* NB: in the case of IPv6, routing rules are added when the\n     * forward mode is NAT. This is because IPv6 has no NAT.\n     */\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkAddMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkAddRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkAddRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddGeneralFirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddGeneralFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "677-683",
          "snippet": "static void\nnetworkAddGeneralFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def)\n{\n    networkAddGeneralIPv4FirewallRules(fw, def);\n    networkAddGeneralIPv6FirewallRules(fw, def);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def)\n{\n    networkAddGeneralIPv4FirewallRules(fw, def);\n    networkAddGeneralIPv6FirewallRules(fw, def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"firewalld is set to use the nftables \"\n                                     \"backend, but the required firewalld \"\n                                     \"'libvirt' zone is missing. Either set \"\n                                     \"the firewalld backend to 'iptables', or \"\n                                     \"ensure that firewalld has a 'libvirt' \"\n                                     \"zone by upgrading firewalld to a \"\n                                     \"version supporting rule priorities \"\n                                     \"(0.7.0+) and/or rebuilding \"\n                                     \"libvirt with --with-firewalld-zone\")"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"firewalld is set to use the nftables \"\n                                     \"backend, but the required firewalld \"\n                                     \"'libvirt' zone is missing. Either set \"\n                                     \"the firewalld backend to 'iptables', or \"\n                                     \"ensure that firewalld has a 'libvirt' \"\n                                     \"zone by upgrading firewalld to a \"\n                                     \"version supporting rule priorities \"\n                                     \"(0.7.0+) and/or rebuilding \"\n                                     \"libvirt with --with-firewalld-zone\""
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallDGetBackend",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDGetBackend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "129-182",
          "snippet": "int\nvirFirewallDGetBackend(void)\n{\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    virError error;\n    g_autofree char *backendStr = NULL;\n    int backend = -1;\n\n    if (!sysbus)\n        return -1;\n\n    memset(&error, 0, sizeof(error));\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          &error,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1/config\",\n                          \"org.freedesktop.DBus.Properties\",\n                          \"Get\",\n                          \"ss\",\n                          \"org.fedoraproject.FirewallD1.config\",\n                          \"FirewallBackend\") < 0)\n        goto cleanup;\n\n    if (error.level == VIR_ERR_ERROR) {\n        /* we don't want to log any error in the case that\n         * FirewallBackend isn't implemented in this firewalld, since\n         * that just means that it is an old version, and only has an\n         * iptables backend.\n         */\n        VIR_DEBUG(\"Failed to get FirewallBackend setting, assuming 'iptables'\");\n        backend = VIR_FIREWALLD_BACKEND_IPTABLES;\n        goto cleanup;\n    }\n\n    if (virDBusMessageDecode(reply, \"v\", \"s\", &backendStr) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"FirewallD backend: %s\", backendStr);\n\n    if ((backend = virFirewallDBackendTypeFromString(backendStr)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unrecognized firewalld backend type: %s\"),\n                       backendStr);\n        goto cleanup;\n    }\n\n cleanup:\n    virResetError(&error);\n    virDBusMessageUnref(reply);\n    return backend;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDGetBackend(void)\n{\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    virError error;\n    g_autofree char *backendStr = NULL;\n    int backend = -1;\n\n    if (!sysbus)\n        return -1;\n\n    memset(&error, 0, sizeof(error));\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          &error,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1/config\",\n                          \"org.freedesktop.DBus.Properties\",\n                          \"Get\",\n                          \"ss\",\n                          \"org.fedoraproject.FirewallD1.config\",\n                          \"FirewallBackend\") < 0)\n        goto cleanup;\n\n    if (error.level == VIR_ERR_ERROR) {\n        /* we don't want to log any error in the case that\n         * FirewallBackend isn't implemented in this firewalld, since\n         * that just means that it is an old version, and only has an\n         * iptables backend.\n         */\n        VIR_DEBUG(\"Failed to get FirewallBackend setting, assuming 'iptables'\");\n        backend = VIR_FIREWALLD_BACKEND_IPTABLES;\n        goto cleanup;\n    }\n\n    if (virDBusMessageDecode(reply, \"v\", \"s\", &backendStr) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"FirewallD backend: %s\", backendStr);\n\n    if ((backend = virFirewallDBackendTypeFromString(backendStr)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unrecognized firewalld backend type: %s\"),\n                       backendStr);\n        goto cleanup;\n    }\n\n cleanup:\n    virResetError(&error);\n    virDBusMessageUnref(reply);\n    return backend;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallDGetVersion",
          "args": [
            "&version"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "82-121",
          "snippet": "int\nvirFirewallDGetVersion(unsigned long *version)\n{\n    int ret = -1;\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    g_autofree char *versionStr = NULL;\n\n    if (!sysbus)\n        return -1;\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          NULL,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1\",\n                          \"org.freedesktop.DBus.Properties\",\n                          \"Get\",\n                          \"ss\",\n                          \"org.fedoraproject.FirewallD1\",\n                          \"version\") < 0)\n        goto cleanup;\n\n    if (virDBusMessageDecode(reply, \"v\", \"s\", &versionStr) < 0)\n        goto cleanup;\n\n    if (virParseVersionString(versionStr, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse firewalld version '%s'\"),\n                       versionStr);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"FirewallD version: %s - %lu\", versionStr, *version);\n\n    ret = 0;\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDGetVersion(unsigned long *version)\n{\n    int ret = -1;\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    g_autofree char *versionStr = NULL;\n\n    if (!sysbus)\n        return -1;\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          NULL,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1\",\n                          \"org.freedesktop.DBus.Properties\",\n                          \"Get\",\n                          \"ss\",\n                          \"org.fedoraproject.FirewallD1\",\n                          \"version\") < 0)\n        goto cleanup;\n\n    if (virDBusMessageDecode(reply, \"v\", \"s\", &versionStr) < 0)\n        goto cleanup;\n\n    if (virParseVersionString(versionStr, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse firewalld version '%s'\"),\n                       versionStr);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"FirewallD version: %s - %lu\", versionStr, *version);\n\n    ret = 0;\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallDInterfaceSetZone",
          "args": [
            "def->bridge",
            "\"libvirt\""
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDInterfaceSetZone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "353-372",
          "snippet": "int\nvirFirewallDInterfaceSetZone(const char *iface,\n                             const char *zone)\n{\n    DBusConnection *sysbus = virDBusGetSystemBus();\n\n    if (!sysbus)\n        return -1;\n\n    return virDBusCallMethod(sysbus,\n                             NULL,\n                             NULL,\n                             VIR_FIREWALL_FIREWALLD_SERVICE,\n                             \"/org/fedoraproject/FirewallD1\",\n                             \"org.fedoraproject.FirewallD1.zone\",\n                             \"changeZoneOfInterface\",\n                             \"ss\",\n                             zone,\n                             iface);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDInterfaceSetZone(const char *iface,\n                             const char *zone)\n{\n    DBusConnection *sysbus = virDBusGetSystemBus();\n\n    if (!sysbus)\n        return -1;\n\n    return virDBusCallMethod(sysbus,\n                             NULL,\n                             NULL,\n                             VIR_FIREWALL_FIREWALLD_SERVICE,\n                             \"/org/fedoraproject/FirewallD1\",\n                             \"org.fedoraproject.FirewallD1.zone\",\n                             \"changeZoneOfInterface\",\n                             \"ss\",\n                             zone,\n                             iface);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallDZoneExists",
          "args": [
            "\"libvirt\""
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDZoneExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "235-257",
          "snippet": "bool\nvirFirewallDZoneExists(const char *match)\n{\n    size_t nzones = 0, i;\n    char **zones = NULL;\n    bool result = false;\n\n    if (virFirewallDGetZones(&zones, &nzones) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nzones; i++) {\n        if (STREQ_NULLABLE(zones[i], match))\n            result = true;\n    }\n\n cleanup:\n    VIR_DEBUG(\"Requested zone '%s' %s exist\",\n              match, result ? \"does\" : \"doesn't\");\n    for (i = 0; i < nzones; i++)\n       VIR_FREE(zones[i]);\n    VIR_FREE(zones);\n    return result;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirFirewallDZoneExists(const char *match)\n{\n    size_t nzones = 0, i;\n    char **zones = NULL;\n    bool result = false;\n\n    if (virFirewallDGetZones(&zones, &nzones) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nzones; i++) {\n        if (STREQ_NULLABLE(zones[i], match))\n            result = true;\n    }\n\n cleanup:\n    VIR_DEBUG(\"Requested zone '%s' %s exist\",\n              match, result ? \"does\" : \"doesn't\");\n    for (i = 0; i < nzones; i++)\n       VIR_FREE(zones[i]);\n    VIR_FREE(zones);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallDIsRegistered",
          "args": [],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDIsRegistered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "66-70",
          "snippet": "int\nvirFirewallDIsRegistered(void)\n{\n    return virDBusIsServiceRegistered(VIR_FIREWALL_FIREWALLD_SERVICE);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDIsRegistered(void)\n{\n    return virDBusIsServiceRegistered(VIR_FIREWALL_FIREWALLD_SERVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"zone %s requested for network %s \"\n                             \"but firewalld is not active\")",
            "def->bridgeZone",
            "def->name"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "errInitV6"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetRouteByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetRouteByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "337-361",
          "snippet": "virNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virOnce",
          "args": [
            "&createdOnce",
            "networkSetupPrivateChains"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virOnce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "40-43",
          "snippet": "int virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virOnceControl createdOnce;\nstatic virErrorPtr errInitV4;\nstatic virErrorPtr errInitV6;\n\nint networkAddFirewallRules(virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    virFirewallPtr fw = NULL;\n    int ret = -1;\n\n    if (virOnce(&createdOnce, networkSetupPrivateChains) < 0)\n        return -1;\n\n    if (errInitV4 &&\n        (virNetworkDefGetIPByIndex(def, AF_INET, 0) ||\n         virNetworkDefGetRouteByIndex(def, AF_INET, 0))) {\n        virSetError(errInitV4);\n        return -1;\n    }\n\n    if (errInitV6 &&\n        (virNetworkDefGetIPByIndex(def, AF_INET6, 0) ||\n         virNetworkDefGetRouteByIndex(def, AF_INET6, 0) ||\n         def->ipv6nogw)) {\n        virSetError(errInitV6);\n        return -1;\n    }\n\n    if (def->bridgeZone) {\n\n        /* if a firewalld zone has been specified, fail/log an error\n         * if we can't honor it\n         */\n        if (virFirewallDIsRegistered() < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"zone %s requested for network %s \"\n                             \"but firewalld is not active\"),\n                           def->bridgeZone, def->name);\n            goto cleanup;\n        }\n\n        if (virFirewallDInterfaceSetZone(def->bridge, def->bridgeZone) < 0)\n            goto cleanup;\n\n    } else {\n\n        /* if firewalld is active, try to set the \"libvirt\" zone. This is\n         * desirable (for consistency) if firewalld is using the iptables\n         * backend, but is necessary (for basic network connectivity) if\n         * firewalld is using the nftables backend\n         */\n        if (virFirewallDIsRegistered() == 0) {\n\n            /* if the \"libvirt\" zone exists, then set it. If not, and\n             * if firewalld is using the nftables backend, then we\n             * need to log an error because the combination of\n             * nftables + default zone means that traffic cannot be\n             * forwarded (and even DHCP and DNS from guest to host\n             * will probably no be permitted by the default zone\n             */\n            if (virFirewallDZoneExists(\"libvirt\")) {\n                if (virFirewallDInterfaceSetZone(def->bridge, \"libvirt\") < 0)\n                    goto cleanup;\n            } else {\n                unsigned long version;\n                int vresult = virFirewallDGetVersion(&version);\n\n                if (vresult < 0)\n                    goto cleanup;\n\n                /* Support for nftables backend was added in firewalld\n                 * 0.6.0. Support for rule priorities (required by the\n                 * 'libvirt' zone, which should be installed by a\n                 * libvirt package, *not* by firewalld) was not added\n                 * until firewalld 0.7.0 (unless it was backported).\n                 */\n                if (version >= 6000 &&\n                    virFirewallDGetBackend() == VIR_FIREWALLD_BACKEND_NFTABLES) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld is set to use the nftables \"\n                                     \"backend, but the required firewalld \"\n                                     \"'libvirt' zone is missing. Either set \"\n                                     \"the firewalld backend to 'iptables', or \"\n                                     \"ensure that firewalld has a 'libvirt' \"\n                                     \"zone by upgrading firewalld to a \"\n                                     \"version supporting rule priorities \"\n                                     \"(0.7.0+) and/or rebuilding \"\n                                     \"libvirt with --with-firewalld-zone\"));\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, 0);\n\n    networkAddGeneralFirewallRules(fw, def);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkAddIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n\n    virFirewallStartRollback(fw, 0);\n\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (networkRemoveIPSpecificFirewallRules(fw, def, ipdef) < 0)\n            goto cleanup;\n    }\n    networkRemoveGeneralFirewallRules(fw, def);\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    networkAddChecksumFirewallRules(fw, def);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "networkRemoveIPSpecificFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "762-776",
    "snippet": "static int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkRemoveRoutingFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveRoutingFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "511-537",
          "snippet": "static int\nnetworkRemoveRoutingFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveForwardAllowIn(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     def->bridge,\n                                     forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkRemoveRoutingFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveForwardAllowIn(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     def->bridge,\n                                     forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRemoveMasqueradingFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveMasqueradingFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "406-473",
          "snippet": "static int\nnetworkRemoveMasqueradingFirewallRules(virFirewallPtr fw,\n                                       virNetworkDefPtr def,\n                                       virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalMulticast) < 0)\n        return -1;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalBroadcast) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"tcp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"udp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        NULL) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowRelatedIn(fw,\n                                            &ipdef->address,\n                                            prefix,\n                                            def->bridge,\n                                            forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char networkLocalMulticast[] = \"224.0.0.0/24\";",
            "static const char networkLocalBroadcast[] = \"255.255.255.255/32\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic const char networkLocalMulticast[] = \"224.0.0.0/24\";\nstatic const char networkLocalBroadcast[] = \"255.255.255.255/32\";\n\nstatic int\nnetworkRemoveMasqueradingFirewallRules(virFirewallPtr fw,\n                                       virNetworkDefPtr def,\n                                       virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalMulticast) < 0)\n        return -1;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalBroadcast) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"tcp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"udp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        NULL) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowRelatedIn(fw,\n                                            &ipdef->address,\n                                            prefix,\n                                            def->bridge,\n                                            forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkRemoveIPSpecificFirewallRules(virFirewallPtr fw,\n                                     virNetworkDefPtr def,\n                                     virNetworkIPDefPtr ipdef)\n{\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkRemoveMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkRemoveRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "networkAddIPSpecificFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "741-759",
    "snippet": "static int\nnetworkAddIPSpecificFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    /* NB: in the case of IPv6, routing rules are added when the\n     * forward mode is NAT. This is because IPv6 has no NAT.\n     */\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkAddMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkAddRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkAddRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkAddRoutingFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddRoutingFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "476-508",
          "snippet": "static int\nnetworkAddRoutingFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def,\n                               virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow routing packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow routing packets to the bridge interface */\n    if (iptablesAddForwardAllowIn(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  def->bridge,\n                                  forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkAddRoutingFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def,\n                               virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow routing packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow routing packets to the bridge interface */\n    if (iptablesAddForwardAllowIn(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  def->bridge,\n                                  forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkAddMasqueradingFirewallRules",
          "args": [
            "fw",
            "def",
            "ipdef"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddMasqueradingFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "292-404",
          "snippet": "static int\nnetworkAddMasqueradingFirewallRules(virFirewallPtr fw,\n                                    virNetworkDefPtr def,\n                                    virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow forwarding packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow forwarding packets to the bridge interface if they are\n     * part of an existing connection\n     */\n    if (iptablesAddForwardAllowRelatedIn(fw,\n                                         &ipdef->address,\n                                         prefix,\n                                         def->bridge,\n                                         forwardIf) < 0)\n        return -1;\n\n    /*\n     * Enable masquerading.\n     *\n     * We need to end up with 5 rules in the table in this order\n     *\n     *  1. do not masquerade packets targeting 224.0.0.0/24\n     *  2. do not masquerade packets targeting 255.255.255.255/32\n     *  3. masquerade protocol=tcp with sport mapping restriction\n     *  4. masquerade protocol=udp with sport mapping restriction\n     *  5. generic, masquerade any protocol\n     *\n     * 224.0.0.0/24 is the local network multicast range. Packets are not\n     * forwarded outside.\n     *\n     * 255.255.255.255/32 is the broadcast address of any local network. Again,\n     * such packets are never forwarded, but strict DHCP clients don't accept\n     * DHCP replies with changed source ports.\n     *\n     * The sport mappings are required, because default IPtables\n     * MASQUERADE maintain port numbers unchanged where possible.\n     *\n     * NFS can be configured to only \"trust\" port numbers < 1023.\n     *\n     * Guests using NAT thus need to be prevented from having port\n     * numbers < 1023, otherwise they can bypass the NFS \"security\"\n     * check on the source port number.\n     *\n     * Since we use '--insert' to add rules to the header of the\n     * chain, we actually need to add them in the reverse of the\n     * order just mentioned !\n     */\n\n    /* First the generic masquerade rule for other protocols */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     NULL) < 0)\n        return -1;\n\n    /* UDP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"udp\") < 0)\n        return -1;\n\n    /* TCP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"tcp\") < 0)\n        return -1;\n\n    /* exempt local network broadcast address as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalBroadcast) < 0)\n        return -1;\n\n    /* exempt local multicast range as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalMulticast) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char networkLocalMulticast[] = \"224.0.0.0/24\";",
            "static const char networkLocalBroadcast[] = \"255.255.255.255/32\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic const char networkLocalMulticast[] = \"224.0.0.0/24\";\nstatic const char networkLocalBroadcast[] = \"255.255.255.255/32\";\n\nstatic int\nnetworkAddMasqueradingFirewallRules(virFirewallPtr fw,\n                                    virNetworkDefPtr def,\n                                    virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow forwarding packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow forwarding packets to the bridge interface if they are\n     * part of an existing connection\n     */\n    if (iptablesAddForwardAllowRelatedIn(fw,\n                                         &ipdef->address,\n                                         prefix,\n                                         def->bridge,\n                                         forwardIf) < 0)\n        return -1;\n\n    /*\n     * Enable masquerading.\n     *\n     * We need to end up with 5 rules in the table in this order\n     *\n     *  1. do not masquerade packets targeting 224.0.0.0/24\n     *  2. do not masquerade packets targeting 255.255.255.255/32\n     *  3. masquerade protocol=tcp with sport mapping restriction\n     *  4. masquerade protocol=udp with sport mapping restriction\n     *  5. generic, masquerade any protocol\n     *\n     * 224.0.0.0/24 is the local network multicast range. Packets are not\n     * forwarded outside.\n     *\n     * 255.255.255.255/32 is the broadcast address of any local network. Again,\n     * such packets are never forwarded, but strict DHCP clients don't accept\n     * DHCP replies with changed source ports.\n     *\n     * The sport mappings are required, because default IPtables\n     * MASQUERADE maintain port numbers unchanged where possible.\n     *\n     * NFS can be configured to only \"trust\" port numbers < 1023.\n     *\n     * Guests using NAT thus need to be prevented from having port\n     * numbers < 1023, otherwise they can bypass the NFS \"security\"\n     * check on the source port number.\n     *\n     * Since we use '--insert' to add rules to the header of the\n     * chain, we actually need to add them in the reverse of the\n     * order just mentioned !\n     */\n\n    /* First the generic masquerade rule for other protocols */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     NULL) < 0)\n        return -1;\n\n    /* UDP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"udp\") < 0)\n        return -1;\n\n    /* TCP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"tcp\") < 0)\n        return -1;\n\n    /* exempt local network broadcast address as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalBroadcast) < 0)\n        return -1;\n\n    /* exempt local multicast range as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalMulticast) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkAddIPSpecificFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    /* NB: in the case of IPv6, routing rules are added when the\n     * forward mode is NAT. This is because IPv6 has no NAT.\n     */\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            return networkAddMasqueradingFirewallRules(fw, def, ipdef);\n        else if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            return networkAddRoutingFirewallRules(fw, def, ipdef);\n    } else if (def->forward.type == VIR_NETWORK_FORWARD_ROUTE) {\n        return networkAddRoutingFirewallRules(fw, def, ipdef);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "networkRemoveChecksumFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "720-738",
    "snippet": "static void\nnetworkRemoveChecksumFirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    if (ipv4def)\n        iptablesRemoveOutputFixUdpChecksum(fw, def->bridge, 68);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveOutputFixUdpChecksum",
          "args": [
            "fw",
            "def->bridge",
            "68"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveOutputFixUdpChecksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "1144-1150",
          "snippet": "void\niptablesRemoveOutputFixUdpChecksum(virFirewallPtr fw,\n                                   const char *iface,\n                                   int port)\n{\n    iptablesOutputFixUdpChecksum(fw, deletePrivate, iface, port, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveOutputFixUdpChecksum(virFirewallPtr fw,\n                                   const char *iface,\n                                   int port)\n{\n    iptablesOutputFixUdpChecksum(fw, deletePrivate, iface, port, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveChecksumFirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    if (ipv4def)\n        iptablesRemoveOutputFixUdpChecksum(fw, def->bridge, 68);\n}"
  },
  {
    "function_name": "networkAddChecksumFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "694-717",
    "snippet": "static void\nnetworkAddChecksumFirewallRules(virFirewallPtr fw,\n                                virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    /* If we are doing local DHCP service on this network, attempt to\n     * add a rule that will fixup the checksum of DHCP response\n     * packets back to the guests (but report failure without\n     * aborting, since not all iptables implementations support it).\n     */\n    if (ipv4def)\n        iptablesAddOutputFixUdpChecksum(fw, def->bridge, 68);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesAddOutputFixUdpChecksum",
          "args": [
            "fw",
            "def->bridge",
            "68"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddOutputFixUdpChecksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "1127-1133",
          "snippet": "void\niptablesAddOutputFixUdpChecksum(virFirewallPtr fw,\n                                const char *iface,\n                                int port)\n{\n    iptablesOutputFixUdpChecksum(fw, true, iface, port, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddOutputFixUdpChecksum(virFirewallPtr fw,\n                                const char *iface,\n                                int port)\n{\n    iptablesOutputFixUdpChecksum(fw, true, iface, port, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddChecksumFirewallRules(virFirewallPtr fw,\n                                virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts)\n            break;\n    }\n\n    /* If we are doing local DHCP service on this network, attempt to\n     * add a rule that will fixup the checksum of DHCP response\n     * packets back to the guests (but report failure without\n     * aborting, since not all iptables implementations support it).\n     */\n    if (ipv4def)\n        iptablesAddOutputFixUdpChecksum(fw, def->bridge, 68);\n}"
  },
  {
    "function_name": "networkRemoveGeneralFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "686-692",
    "snippet": "static void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkRemoveGeneralIPv6FirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveGeneralIPv6FirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "650-674",
          "snippet": "static void\nnetworkRemoveGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n    }\n\n    /* the following rules are there if no IPv6 address has been defined\n     * but def->ipv6nogw == true\n     */\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n    }\n\n    /* the following rules are there if no IPv6 address has been defined\n     * but def->ipv6nogw == true\n     */\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveGeneralIPv4FirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveGeneralIPv4FirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "582-614",
          "snippet": "static void\nnetworkRemoveGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def)\n{\n    networkRemoveGeneralIPv4FirewallRules(fw, def);\n    networkRemoveGeneralIPv6FirewallRules(fw, def);\n}"
  },
  {
    "function_name": "networkAddGeneralFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "677-683",
    "snippet": "static void\nnetworkAddGeneralFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def)\n{\n    networkAddGeneralIPv4FirewallRules(fw, def);\n    networkAddGeneralIPv6FirewallRules(fw, def);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkAddGeneralIPv6FirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddGeneralIPv6FirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "622-648",
          "snippet": "static void\nnetworkAddGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* allow DNS over IPv6 & back out */\n        iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        /* allow DHCPv6 & back out */\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n    }\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* allow DNS over IPv6 & back out */\n        iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        /* allow DHCPv6 & back out */\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddGeneralIPv4FirewallRules",
          "args": [
            "fw",
            "def"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddGeneralIPv4FirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "540-580",
          "snippet": "static void\nnetworkAddGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    /* allow DHCP requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n\n    /* allow DNS requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    /* allow TFTP requests through to dnsmasq if necessary & back out */\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    /* allow DHCP requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n\n    /* allow DNS requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    /* allow TFTP requests through to dnsmasq if necessary & back out */\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def)\n{\n    networkAddGeneralIPv4FirewallRules(fw, def);\n    networkAddGeneralIPv6FirewallRules(fw, def);\n}"
  },
  {
    "function_name": "networkRemoveGeneralIPv6FirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "650-674",
    "snippet": "static void\nnetworkRemoveGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n    }\n\n    /* the following rules are there if no IPv6 address has been defined\n     * but def->ipv6nogw == true\n     */\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveForwardRejectOut",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardRejectOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "775-781",
          "snippet": "void\niptablesRemoveForwardRejectOut(virFirewallPtr fw,\n                               virFirewallLayer layer,\n                               const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardRejectOut(virFirewallPtr fw,\n                               virFirewallLayer layer,\n                               const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardRejectIn",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardRejectIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "828-834",
          "snippet": "void\niptablesRemoveForwardRejectIn(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardRejectIn(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowCross",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowCross",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "723-729",
          "snippet": "void\niptablesRemoveForwardAllowCross(virFirewallPtr fw,\n                                virFirewallLayer layer,\n                                const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardAllowCross(virFirewallPtr fw,\n                                virFirewallLayer layer,\n                                const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveTcpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTcpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "260-267",
          "snippet": "void\niptablesRemoveTcpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveTcpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveUdpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveUdpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "296-303",
          "snippet": "void\niptablesRemoveUdpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveUdpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveTcpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTcpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "332-339",
          "snippet": "void\niptablesRemoveTcpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveTcpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveUdpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveUdpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "368-375",
          "snippet": "void\niptablesRemoveUdpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveUdpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n    }\n\n    /* the following rules are there if no IPv6 address has been defined\n     * but def->ipv6nogw == true\n     */\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n}"
  },
  {
    "function_name": "networkAddGeneralIPv6FirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "622-648",
    "snippet": "static void\nnetworkAddGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* allow DNS over IPv6 & back out */\n        iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        /* allow DHCPv6 & back out */\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n    }\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesAddUdpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "546"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddUdpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "350-357",
          "snippet": "void\niptablesAddUdpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddUdpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddUdpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "547"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddUdpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "278-285",
          "snippet": "void\niptablesAddUdpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddUdpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddTcpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddTcpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "314-321",
          "snippet": "void\niptablesAddTcpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddTcpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddTcpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge",
            "53"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddTcpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "242-249",
          "snippet": "void\niptablesAddTcpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddTcpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowCross",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowCross",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "704-710",
          "snippet": "void\niptablesAddForwardAllowCross(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardAllowCross(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, true, iface, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardRejectIn",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardRejectIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "810-816",
          "snippet": "void\niptablesAddForwardRejectIn(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardRejectIn(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, true, iface, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardRejectOut",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "def->bridge"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardRejectOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "757-763",
          "snippet": "void\niptablesAddForwardRejectOut(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardRejectOut(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, true, iface, ADD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralIPv6FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0) &&\n        !def->ipv6nogw) {\n        return;\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge);\n\n    if (virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* allow DNS over IPv6 & back out */\n        iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 53);\n        /* allow DHCPv6 & back out */\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 547);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV6, def->bridge, 546);\n    }\n}"
  },
  {
    "function_name": "networkRemoveGeneralIPv4FirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "582-614",
    "snippet": "static void\nnetworkRemoveGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveTcpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "67"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTcpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "260-267",
          "snippet": "void\niptablesRemoveTcpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveTcpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveUdpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "67"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveUdpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "296-303",
          "snippet": "void\niptablesRemoveUdpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveUdpInput(virFirewallPtr fw,\n                       virFirewallLayer layer,\n                       const char *iface,\n                       int port)\n{\n    iptablesInput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveTcpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "68"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTcpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "332-339",
          "snippet": "void\niptablesRemoveTcpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveTcpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveUdpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "68"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveUdpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "368-375",
          "snippet": "void\niptablesRemoveUdpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveUdpOutput(virFirewallPtr fw,\n                        virFirewallLayer layer,\n                        const char *iface,\n                        int port)\n{\n    iptablesOutput(fw, layer, deletePrivate, iface, port, REMOVE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardRejectOut",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardRejectOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "775-781",
          "snippet": "void\niptablesRemoveForwardRejectOut(virFirewallPtr fw,\n                               virFirewallLayer layer,\n                               const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardRejectOut(virFirewallPtr fw,\n                               virFirewallLayer layer,\n                               const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardRejectIn",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardRejectIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "828-834",
          "snippet": "void\niptablesRemoveForwardRejectIn(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardRejectIn(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowCross",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowCross",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "723-729",
          "snippet": "void\niptablesRemoveForwardAllowCross(virFirewallPtr fw,\n                                virFirewallLayer layer,\n                                const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, deletePrivate, iface, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesRemoveForwardAllowCross(virFirewallPtr fw,\n                                virFirewallLayer layer,\n                                const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, deletePrivate, iface, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkRemoveGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                      virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    iptablesRemoveForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesRemoveForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    iptablesRemoveUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesRemoveUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesRemoveTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n}"
  },
  {
    "function_name": "networkAddGeneralIPv4FirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "540-580",
    "snippet": "static void\nnetworkAddGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    /* allow DHCP requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n\n    /* allow DNS requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    /* allow TFTP requests through to dnsmasq if necessary & back out */\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowCross",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowCross",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "704-710",
          "snippet": "void\niptablesAddForwardAllowCross(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardAllowCross(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *iface)\n{\n    iptablesForwardAllowCross(fw, layer, true, iface, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardRejectIn",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardRejectIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "810-816",
          "snippet": "void\niptablesAddForwardRejectIn(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardRejectIn(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *iface)\n{\n    iptablesForwardRejectIn(fw, layer, true, iface, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardRejectOut",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardRejectOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "757-763",
          "snippet": "void\niptablesAddForwardRejectOut(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, true, iface, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddForwardRejectOut(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *iface)\n{\n    iptablesForwardRejectOut(fw, layer, true, iface, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddUdpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "69"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddUdpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "350-357",
          "snippet": "void\niptablesAddUdpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddUdpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddUdpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "69"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddUdpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "278-285",
          "snippet": "void\niptablesAddUdpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 0);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddUdpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddTcpOutput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "53"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddTcpOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "314-321",
          "snippet": "void\niptablesAddTcpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddTcpOutput(virFirewallPtr fw,\n                     virFirewallLayer layer,\n                     const char *iface,\n                     int port)\n{\n    iptablesOutput(fw, layer, true, iface, port, ADD, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddTcpInput",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "def->bridge",
            "53"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddTcpInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "242-249",
          "snippet": "void\niptablesAddTcpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 1);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\niptablesAddTcpInput(virFirewallPtr fw,\n                    virFirewallLayer layer,\n                    const char *iface,\n                    int port)\n{\n    iptablesInput(fw, layer, true, iface, port, ADD, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nnetworkAddGeneralIPv4FirewallRules(virFirewallPtr fw,\n                                   virNetworkDefPtr def)\n{\n    size_t i;\n    virNetworkIPDefPtr ipv4def;\n\n    /* First look for first IPv4 address that has dhcp or tftpboot defined. */\n    /* We support dhcp config on 1 IPv4 interface only. */\n    for (i = 0;\n         (ipv4def = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipv4def->nranges || ipv4def->nhosts || ipv4def->tftproot)\n            break;\n    }\n\n    /* allow DHCP requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 67);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 68);\n\n    /* allow DNS requests through to dnsmasq & back out */\n    iptablesAddTcpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddTcpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n    iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 53);\n\n    /* allow TFTP requests through to dnsmasq if necessary & back out */\n    if (ipv4def && ipv4def->tftproot) {\n        iptablesAddUdpInput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n        iptablesAddUdpOutput(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge, 69);\n    }\n\n    /* Catch all rules to block forwarding to/from bridges */\n    iptablesAddForwardRejectOut(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n    iptablesAddForwardRejectIn(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n\n    /* Allow traffic between guests on the same bridge */\n    iptablesAddForwardAllowCross(fw, VIR_FIREWALL_LAYER_IPV4, def->bridge);\n}"
  },
  {
    "function_name": "networkRemoveRoutingFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "511-537",
    "snippet": "static int\nnetworkRemoveRoutingFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveForwardAllowIn(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     def->bridge,\n                                     forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowOut",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "487-495",
          "snippet": "int\niptablesRemoveForwardAllowOut(virFirewallPtr fw,\n                              virSocketAddr *netaddr,\n                              unsigned int prefix,\n                              const char *iface,\n                              const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveForwardAllowOut(virFirewallPtr fw,\n                              virSocketAddr *netaddr,\n                              unsigned int prefix,\n                              const char *iface,\n                              const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowIn",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "666-674",
          "snippet": "int\niptablesRemoveForwardAllowIn(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *iface,\n                             const char *physdev)\n{\n    return iptablesForwardAllowIn(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveForwardAllowIn(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *iface,\n                             const char *physdev)\n{\n    return iptablesForwardAllowIn(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefForwardIf",
          "args": [
            "def",
            "0"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefForwardIf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2691-2698",
          "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkRemoveRoutingFirewallRules(virFirewallPtr fw,\n                                  virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveForwardAllowIn(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     def->bridge,\n                                     forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkAddRoutingFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "476-508",
    "snippet": "static int\nnetworkAddRoutingFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def,\n                               virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow routing packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow routing packets to the bridge interface */\n    if (iptablesAddForwardAllowIn(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  def->bridge,\n                                  forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowIn",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "643-651",
          "snippet": "int\niptablesAddForwardAllowIn(virFirewallPtr fw,\n                          virSocketAddr *netaddr,\n                          unsigned int prefix,\n                          const char *iface,\n                          const char *physdev)\n{\n    return iptablesForwardAllowIn(fw, true, netaddr, prefix, iface, physdev, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddForwardAllowIn(virFirewallPtr fw,\n                          virSocketAddr *netaddr,\n                          unsigned int prefix,\n                          const char *iface,\n                          const char *physdev)\n{\n    return iptablesForwardAllowIn(fw, true, netaddr, prefix, iface, physdev, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowOut",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "464-472",
          "snippet": "int\niptablesAddForwardAllowOut(virFirewallPtr fw,\n                           virSocketAddr *netaddr,\n                           unsigned int prefix,\n                           const char *iface,\n                           const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, true, netaddr, prefix, iface, physdev, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddForwardAllowOut(virFirewallPtr fw,\n                           virSocketAddr *netaddr,\n                           unsigned int prefix,\n                           const char *iface,\n                           const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, true, netaddr, prefix, iface, physdev, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid prefix or netmask for '%s'\")",
            "def->bridge"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid prefix or netmask for '%s'\""
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefForwardIf",
          "args": [
            "def",
            "0"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefForwardIf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2691-2698",
          "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkAddRoutingFirewallRules(virFirewallPtr fw,\n                               virNetworkDefPtr def,\n                               virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow routing packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow routing packets to the bridge interface */\n    if (iptablesAddForwardAllowIn(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  def->bridge,\n                                  forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkRemoveMasqueradingFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "406-473",
    "snippet": "static int\nnetworkRemoveMasqueradingFirewallRules(virFirewallPtr fw,\n                                       virNetworkDefPtr def,\n                                       virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalMulticast) < 0)\n        return -1;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalBroadcast) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"tcp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"udp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        NULL) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowRelatedIn(fw,\n                                            &ipdef->address,\n                                            prefix,\n                                            def->bridge,\n                                            forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char networkLocalMulticast[] = \"224.0.0.0/24\";",
      "static const char networkLocalBroadcast[] = \"255.255.255.255/32\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowOut",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "487-495",
          "snippet": "int\niptablesRemoveForwardAllowOut(virFirewallPtr fw,\n                              virSocketAddr *netaddr,\n                              unsigned int prefix,\n                              const char *iface,\n                              const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveForwardAllowOut(virFirewallPtr fw,\n                              virSocketAddr *netaddr,\n                              unsigned int prefix,\n                              const char *iface,\n                              const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardAllowRelatedIn",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardAllowRelatedIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "580-588",
          "snippet": "int\niptablesRemoveForwardAllowRelatedIn(virFirewallPtr fw,\n                                    virSocketAddr *netaddr,\n                                    unsigned int prefix,\n                                    const char *iface,\n                                    const char *physdev)\n{\n    return iptablesForwardAllowRelatedIn(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveForwardAllowRelatedIn(virFirewallPtr fw,\n                                    virSocketAddr *netaddr,\n                                    unsigned int prefix,\n                                    const char *iface,\n                                    const char *physdev)\n{\n    return iptablesForwardAllowRelatedIn(fw, deletePrivate, netaddr, prefix, iface, physdev, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveForwardMasquerade",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "forwardIf",
            "&def->forward.addr",
            "&def->forward.port",
            "NULL"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveForwardMasquerade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "980-991",
          "snippet": "int\niptablesRemoveForwardMasquerade(virFirewallPtr fw,\n                                virSocketAddr *netaddr,\n                                unsigned int prefix,\n                                const char *physdev,\n                                virSocketAddrRangePtr addr,\n                                virPortRangePtr port,\n                                const char *protocol)\n{\n    return iptablesForwardMasquerade(fw, deletePrivate, netaddr, prefix,\n                                     physdev, addr, port, protocol, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveForwardMasquerade(virFirewallPtr fw,\n                                virSocketAddr *netaddr,\n                                unsigned int prefix,\n                                const char *physdev,\n                                virSocketAddrRangePtr addr,\n                                virPortRangePtr port,\n                                const char *protocol)\n{\n    return iptablesForwardMasquerade(fw, deletePrivate, netaddr, prefix,\n                                     physdev, addr, port, protocol, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveDontMasquerade",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "forwardIf",
            "networkLocalBroadcast"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveDontMasquerade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "1081-1090",
          "snippet": "int\niptablesRemoveDontMasquerade(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *physdev,\n                             const char *destaddr)\n{\n    return iptablesForwardDontMasquerade(fw, deletePrivate, netaddr, prefix,\n                                         physdev, destaddr, REMOVE);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nint\niptablesRemoveDontMasquerade(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *physdev,\n                             const char *destaddr)\n{\n    return iptablesForwardDontMasquerade(fw, deletePrivate, netaddr, prefix,\n                                         physdev, destaddr, REMOVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefForwardIf",
          "args": [
            "def",
            "0"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefForwardIf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2691-2698",
          "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic const char networkLocalMulticast[] = \"224.0.0.0/24\";\nstatic const char networkLocalBroadcast[] = \"255.255.255.255/32\";\n\nstatic int\nnetworkRemoveMasqueradingFirewallRules(virFirewallPtr fw,\n                                       virNetworkDefPtr def,\n                                       virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0)\n        return 0;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalMulticast) < 0)\n        return -1;\n\n    if (iptablesRemoveDontMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     networkLocalBroadcast) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"tcp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        \"udp\") < 0)\n        return -1;\n\n    if (iptablesRemoveForwardMasquerade(fw,\n                                        &ipdef->address,\n                                        prefix,\n                                        forwardIf,\n                                        &def->forward.addr,\n                                        &def->forward.port,\n                                        NULL) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowRelatedIn(fw,\n                                            &ipdef->address,\n                                            prefix,\n                                            def->bridge,\n                                            forwardIf) < 0)\n        return -1;\n\n    if (iptablesRemoveForwardAllowOut(fw,\n                                      &ipdef->address,\n                                      prefix,\n                                      def->bridge,\n                                      forwardIf) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkAddMasqueradingFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "292-404",
    "snippet": "static int\nnetworkAddMasqueradingFirewallRules(virFirewallPtr fw,\n                                    virNetworkDefPtr def,\n                                    virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow forwarding packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow forwarding packets to the bridge interface if they are\n     * part of an existing connection\n     */\n    if (iptablesAddForwardAllowRelatedIn(fw,\n                                         &ipdef->address,\n                                         prefix,\n                                         def->bridge,\n                                         forwardIf) < 0)\n        return -1;\n\n    /*\n     * Enable masquerading.\n     *\n     * We need to end up with 5 rules in the table in this order\n     *\n     *  1. do not masquerade packets targeting 224.0.0.0/24\n     *  2. do not masquerade packets targeting 255.255.255.255/32\n     *  3. masquerade protocol=tcp with sport mapping restriction\n     *  4. masquerade protocol=udp with sport mapping restriction\n     *  5. generic, masquerade any protocol\n     *\n     * 224.0.0.0/24 is the local network multicast range. Packets are not\n     * forwarded outside.\n     *\n     * 255.255.255.255/32 is the broadcast address of any local network. Again,\n     * such packets are never forwarded, but strict DHCP clients don't accept\n     * DHCP replies with changed source ports.\n     *\n     * The sport mappings are required, because default IPtables\n     * MASQUERADE maintain port numbers unchanged where possible.\n     *\n     * NFS can be configured to only \"trust\" port numbers < 1023.\n     *\n     * Guests using NAT thus need to be prevented from having port\n     * numbers < 1023, otherwise they can bypass the NFS \"security\"\n     * check on the source port number.\n     *\n     * Since we use '--insert' to add rules to the header of the\n     * chain, we actually need to add them in the reverse of the\n     * order just mentioned !\n     */\n\n    /* First the generic masquerade rule for other protocols */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     NULL) < 0)\n        return -1;\n\n    /* UDP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"udp\") < 0)\n        return -1;\n\n    /* TCP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"tcp\") < 0)\n        return -1;\n\n    /* exempt local network broadcast address as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalBroadcast) < 0)\n        return -1;\n\n    /* exempt local multicast range as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalMulticast) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char networkLocalMulticast[] = \"224.0.0.0/24\";",
      "static const char networkLocalBroadcast[] = \"255.255.255.255/32\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesAddDontMasquerade",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "forwardIf",
            "networkLocalMulticast"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddDontMasquerade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "1056-1065",
          "snippet": "int\niptablesAddDontMasquerade(virFirewallPtr fw,\n                          virSocketAddr *netaddr,\n                          unsigned int prefix,\n                          const char *physdev,\n                          const char *destaddr)\n{\n    return iptablesForwardDontMasquerade(fw, true, netaddr, prefix,\n                                         physdev, destaddr, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddDontMasquerade(virFirewallPtr fw,\n                          virSocketAddr *netaddr,\n                          unsigned int prefix,\n                          const char *physdev,\n                          const char *destaddr)\n{\n    return iptablesForwardDontMasquerade(fw, true, netaddr, prefix,\n                                         physdev, destaddr, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardMasquerade",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "forwardIf",
            "&def->forward.addr",
            "&def->forward.port",
            "\"tcp\""
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardMasquerade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "954-965",
          "snippet": "int\niptablesAddForwardMasquerade(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *physdev,\n                             virSocketAddrRangePtr addr,\n                             virPortRangePtr port,\n                             const char *protocol)\n{\n    return iptablesForwardMasquerade(fw, true, netaddr, prefix,\n                                     physdev, addr, port, protocol, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddForwardMasquerade(virFirewallPtr fw,\n                             virSocketAddr *netaddr,\n                             unsigned int prefix,\n                             const char *physdev,\n                             virSocketAddrRangePtr addr,\n                             virPortRangePtr port,\n                             const char *protocol)\n{\n    return iptablesForwardMasquerade(fw, true, netaddr, prefix,\n                                     physdev, addr, port, protocol, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowRelatedIn",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowRelatedIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "557-565",
          "snippet": "int\niptablesAddForwardAllowRelatedIn(virFirewallPtr fw,\n                                 virSocketAddr *netaddr,\n                                 unsigned int prefix,\n                                 const char *iface,\n                                 const char *physdev)\n{\n    return iptablesForwardAllowRelatedIn(fw, true, netaddr, prefix, iface, physdev, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddForwardAllowRelatedIn(virFirewallPtr fw,\n                                 virSocketAddr *netaddr,\n                                 unsigned int prefix,\n                                 const char *iface,\n                                 const char *physdev)\n{\n    return iptablesForwardAllowRelatedIn(fw, true, netaddr, prefix, iface, physdev, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesAddForwardAllowOut",
          "args": [
            "fw",
            "&ipdef->address",
            "prefix",
            "def->bridge",
            "forwardIf"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesAddForwardAllowOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "464-472",
          "snippet": "int\niptablesAddForwardAllowOut(virFirewallPtr fw,\n                           virSocketAddr *netaddr,\n                           unsigned int prefix,\n                           const char *iface,\n                           const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, true, netaddr, prefix, iface, physdev, ADD);\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesAddForwardAllowOut(virFirewallPtr fw,\n                           virSocketAddr *netaddr,\n                           unsigned int prefix,\n                           const char *iface,\n                           const char *physdev)\n{\n    return iptablesForwardAllowOut(fw, true, netaddr, prefix, iface, physdev, ADD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid prefix or netmask for '%s'\")",
            "def->bridge"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid prefix or netmask for '%s'\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefForwardIf",
          "args": [
            "def",
            "0"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefForwardIf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2691-2698",
          "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic const char networkLocalMulticast[] = \"224.0.0.0/24\";\nstatic const char networkLocalBroadcast[] = \"255.255.255.255/32\";\n\nstatic int\nnetworkAddMasqueradingFirewallRules(virFirewallPtr fw,\n                                    virNetworkDefPtr def,\n                                    virNetworkIPDefPtr ipdef)\n{\n    int prefix = virNetworkIPDefPrefix(ipdef);\n    const char *forwardIf = virNetworkDefForwardIf(def, 0);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid prefix or netmask for '%s'\"),\n                       def->bridge);\n        return -1;\n    }\n\n    /* allow forwarding packets from the bridge interface */\n    if (iptablesAddForwardAllowOut(fw,\n                                   &ipdef->address,\n                                   prefix,\n                                   def->bridge,\n                                   forwardIf) < 0)\n        return -1;\n\n    /* allow forwarding packets to the bridge interface if they are\n     * part of an existing connection\n     */\n    if (iptablesAddForwardAllowRelatedIn(fw,\n                                         &ipdef->address,\n                                         prefix,\n                                         def->bridge,\n                                         forwardIf) < 0)\n        return -1;\n\n    /*\n     * Enable masquerading.\n     *\n     * We need to end up with 5 rules in the table in this order\n     *\n     *  1. do not masquerade packets targeting 224.0.0.0/24\n     *  2. do not masquerade packets targeting 255.255.255.255/32\n     *  3. masquerade protocol=tcp with sport mapping restriction\n     *  4. masquerade protocol=udp with sport mapping restriction\n     *  5. generic, masquerade any protocol\n     *\n     * 224.0.0.0/24 is the local network multicast range. Packets are not\n     * forwarded outside.\n     *\n     * 255.255.255.255/32 is the broadcast address of any local network. Again,\n     * such packets are never forwarded, but strict DHCP clients don't accept\n     * DHCP replies with changed source ports.\n     *\n     * The sport mappings are required, because default IPtables\n     * MASQUERADE maintain port numbers unchanged where possible.\n     *\n     * NFS can be configured to only \"trust\" port numbers < 1023.\n     *\n     * Guests using NAT thus need to be prevented from having port\n     * numbers < 1023, otherwise they can bypass the NFS \"security\"\n     * check on the source port number.\n     *\n     * Since we use '--insert' to add rules to the header of the\n     * chain, we actually need to add them in the reverse of the\n     * order just mentioned !\n     */\n\n    /* First the generic masquerade rule for other protocols */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     NULL) < 0)\n        return -1;\n\n    /* UDP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"udp\") < 0)\n        return -1;\n\n    /* TCP with a source port restriction */\n    if (iptablesAddForwardMasquerade(fw,\n                                     &ipdef->address,\n                                     prefix,\n                                     forwardIf,\n                                     &def->forward.addr,\n                                     &def->forward.port,\n                                     \"tcp\") < 0)\n        return -1;\n\n    /* exempt local network broadcast address as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalBroadcast) < 0)\n        return -1;\n\n    /* exempt local multicast range as destination */\n    if (iptablesAddDontMasquerade(fw,\n                                  &ipdef->address,\n                                  prefix,\n                                  forwardIf,\n                                  networkLocalMulticast) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkCheckRouteCollision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "170-287",
    "snippet": "int networkCheckRouteCollision(virNetworkDefPtr def)\n{\n    int ret = 0, len;\n    char *cur, *buf = NULL;\n    /* allow for up to 100000 routes (each line is 128 bytes) */\n    enum {MAX_ROUTE_SIZE = 128*100000};\n\n    /* Read whole routing table into memory */\n    if ((len = virFileReadAll(PROC_NET_ROUTE, MAX_ROUTE_SIZE, &buf)) < 0)\n        goto out;\n\n    /* Dropping the last character shouldn't hurt */\n    if (len > 0)\n        buf[len-1] = '\\0';\n\n    VIR_DEBUG(\"%s output:\\n%s\", PROC_NET_ROUTE, buf);\n\n    if (!STRPREFIX(buf, \"Iface\"))\n        goto out;\n\n    /* First line is just headings, skip it */\n    cur = strchr(buf, '\\n');\n    if (cur)\n        cur++;\n\n    while (cur) {\n        char iface[17], dest[128], mask[128];\n        unsigned int addr_val, mask_val;\n        virNetworkIPDefPtr ipdef;\n        virNetDevIPRoutePtr routedef;\n        int num;\n        size_t i;\n\n        /* NUL-terminate the line, so sscanf doesn't go beyond a newline.  */\n        char *nl = strchr(cur, '\\n');\n        if (nl)\n            *nl++ = '\\0';\n\n        num = sscanf(cur, \"%16s %127s %*s %*s %*s %*s %*s %127s\",\n                     iface, dest, mask);\n        cur = nl;\n\n        if (num != 3) {\n            VIR_DEBUG(\"Failed to parse %s\", PROC_NET_ROUTE);\n            continue;\n        }\n\n        if (virStrToLong_ui(dest, NULL, 16, &addr_val) < 0) {\n            VIR_DEBUG(\"Failed to convert network address %s to uint\", dest);\n            continue;\n        }\n\n        if (virStrToLong_ui(mask, NULL, 16, &mask_val) < 0) {\n            VIR_DEBUG(\"Failed to convert network mask %s to uint\", mask);\n            continue;\n        }\n\n        addr_val &= mask_val;\n\n        for (i = 0;\n             (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n             i++) {\n\n            unsigned int net_dest;\n            virSocketAddr netmask;\n\n            if (virNetworkIPDefNetmask(ipdef, &netmask) < 0) {\n                VIR_WARN(\"Failed to get netmask of '%s'\",\n                         def->bridge);\n                continue;\n            }\n\n            net_dest = (ipdef->address.data.inet4.sin_addr.s_addr &\n                        netmask.data.inet4.sin_addr.s_addr);\n\n            if ((net_dest == addr_val) &&\n                (netmask.data.inet4.sin_addr.s_addr == mask_val)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Network is already in use by interface %s\"),\n                               iface);\n                ret = -1;\n                goto out;\n            }\n        }\n\n        for (i = 0;\n             (routedef = virNetworkDefGetRouteByIndex(def, AF_INET, i));\n             i++) {\n\n            virSocketAddr r_mask, r_addr;\n            virSocketAddrPtr tmp_addr = virNetDevIPRouteGetAddress(routedef);\n            int r_prefix = virNetDevIPRouteGetPrefix(routedef);\n\n            if (!tmp_addr ||\n                virSocketAddrMaskByPrefix(tmp_addr, r_prefix, &r_addr) < 0 ||\n                virSocketAddrPrefixToNetmask(r_prefix, &r_mask, AF_INET) < 0)\n                continue;\n\n            if ((r_addr.data.inet4.sin_addr.s_addr == addr_val) &&\n                (r_mask.data.inet4.sin_addr.s_addr == mask_val)) {\n                char *addr_str = virSocketAddrFormat(&r_addr);\n                if (!addr_str)\n                    virResetLastError();\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Route address '%s' conflicts \"\n                                 \"with IP address for '%s'\"),\n                               NULLSTR(addr_str), iface);\n                VIR_FREE(addr_str);\n                ret = -1;\n                goto out;\n            }\n        }\n    }\n\n out:\n    VIR_FREE(buf);\n    return ret;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PROC_NET_ROUTE \"/proc/net/route\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr_str"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Route address '%s' conflicts \"\n                                 \"with IP address for '%s'\")",
            "NULLSTR(addr_str)",
            "iface"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "addr_str"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Route address '%s' conflicts \"\n                                 \"with IP address for '%s'\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&r_addr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "r_prefix",
            "&r_mask",
            "AF_INET"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrMaskByPrefix",
          "args": [
            "tmp_addr",
            "r_prefix",
            "&r_addr"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrMaskByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "679-693",
          "snippet": "int\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetPrefix",
          "args": [
            "routedef"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "993-1024",
          "snippet": "int\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetAddress",
          "args": [
            "routedef"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "984-991",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetRouteByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetRouteByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "337-361",
          "snippet": "virNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Network is already in use by interface %s\")",
            "iface"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get netmask of '%s'\"",
            "def->bridge"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefNetmask",
          "args": [
            "ipdef",
            "&netmask"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "380-390",
          "snippet": "int virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to convert network mask %s to uint\"",
            "mask"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "mask",
            "NULL",
            "16",
            "&mask_val"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to convert network address %s to uint\"",
            "dest"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to parse %s\"",
            "PROC_NET_ROUTE"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cur",
            "\"%16s %127s %*s %*s %*s %*s %*s %127s\"",
            "iface",
            "dest",
            "mask"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cur",
            "'\\n'"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "buf",
            "\"Iface\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s output:\\n%s\"",
            "PROC_NET_ROUTE",
            "buf"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "PROC_NET_ROUTE",
            "MAX_ROUTE_SIZE",
            "&buf"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\n#define PROC_NET_ROUTE \"/proc/net/route\"\n\nint networkCheckRouteCollision(virNetworkDefPtr def)\n{\n    int ret = 0, len;\n    char *cur, *buf = NULL;\n    /* allow for up to 100000 routes (each line is 128 bytes) */\n    enum {MAX_ROUTE_SIZE = 128*100000};\n\n    /* Read whole routing table into memory */\n    if ((len = virFileReadAll(PROC_NET_ROUTE, MAX_ROUTE_SIZE, &buf)) < 0)\n        goto out;\n\n    /* Dropping the last character shouldn't hurt */\n    if (len > 0)\n        buf[len-1] = '\\0';\n\n    VIR_DEBUG(\"%s output:\\n%s\", PROC_NET_ROUTE, buf);\n\n    if (!STRPREFIX(buf, \"Iface\"))\n        goto out;\n\n    /* First line is just headings, skip it */\n    cur = strchr(buf, '\\n');\n    if (cur)\n        cur++;\n\n    while (cur) {\n        char iface[17], dest[128], mask[128];\n        unsigned int addr_val, mask_val;\n        virNetworkIPDefPtr ipdef;\n        virNetDevIPRoutePtr routedef;\n        int num;\n        size_t i;\n\n        /* NUL-terminate the line, so sscanf doesn't go beyond a newline.  */\n        char *nl = strchr(cur, '\\n');\n        if (nl)\n            *nl++ = '\\0';\n\n        num = sscanf(cur, \"%16s %127s %*s %*s %*s %*s %*s %127s\",\n                     iface, dest, mask);\n        cur = nl;\n\n        if (num != 3) {\n            VIR_DEBUG(\"Failed to parse %s\", PROC_NET_ROUTE);\n            continue;\n        }\n\n        if (virStrToLong_ui(dest, NULL, 16, &addr_val) < 0) {\n            VIR_DEBUG(\"Failed to convert network address %s to uint\", dest);\n            continue;\n        }\n\n        if (virStrToLong_ui(mask, NULL, 16, &mask_val) < 0) {\n            VIR_DEBUG(\"Failed to convert network mask %s to uint\", mask);\n            continue;\n        }\n\n        addr_val &= mask_val;\n\n        for (i = 0;\n             (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n             i++) {\n\n            unsigned int net_dest;\n            virSocketAddr netmask;\n\n            if (virNetworkIPDefNetmask(ipdef, &netmask) < 0) {\n                VIR_WARN(\"Failed to get netmask of '%s'\",\n                         def->bridge);\n                continue;\n            }\n\n            net_dest = (ipdef->address.data.inet4.sin_addr.s_addr &\n                        netmask.data.inet4.sin_addr.s_addr);\n\n            if ((net_dest == addr_val) &&\n                (netmask.data.inet4.sin_addr.s_addr == mask_val)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Network is already in use by interface %s\"),\n                               iface);\n                ret = -1;\n                goto out;\n            }\n        }\n\n        for (i = 0;\n             (routedef = virNetworkDefGetRouteByIndex(def, AF_INET, i));\n             i++) {\n\n            virSocketAddr r_mask, r_addr;\n            virSocketAddrPtr tmp_addr = virNetDevIPRouteGetAddress(routedef);\n            int r_prefix = virNetDevIPRouteGetPrefix(routedef);\n\n            if (!tmp_addr ||\n                virSocketAddrMaskByPrefix(tmp_addr, r_prefix, &r_addr) < 0 ||\n                virSocketAddrPrefixToNetmask(r_prefix, &r_mask, AF_INET) < 0)\n                continue;\n\n            if ((r_addr.data.inet4.sin_addr.s_addr == addr_val) &&\n                (r_mask.data.inet4.sin_addr.s_addr == mask_val)) {\n                char *addr_str = virSocketAddrFormat(&r_addr);\n                if (!addr_str)\n                    virResetLastError();\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Route address '%s' conflicts \"\n                                 \"with IP address for '%s'\"),\n                               NULLSTR(addr_str), iface);\n                VIR_FREE(addr_str);\n                ret = -1;\n                goto out;\n            }\n        }\n    }\n\n out:\n    VIR_FREE(buf);\n    return ret;\n}"
  },
  {
    "function_name": "networkPostReloadFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "160-163",
    "snippet": "void networkPostReloadFirewallRules(bool startup G_GNUC_UNUSED)\n{\n    iptablesSetDeletePrivate(true);\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesSetDeletePrivate",
          "args": [
            "true"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesSetDeletePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "176-180",
          "snippet": "void\niptablesSetDeletePrivate(bool pvt)\n{\n    deletePrivate = pvt;\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesSetDeletePrivate(bool pvt)\n{\n    deletePrivate = pvt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid networkPostReloadFirewallRules(bool startup G_GNUC_UNUSED)\n{\n    iptablesSetDeletePrivate(true);\n}"
  },
  {
    "function_name": "networkPreReloadFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "114-157",
    "snippet": "void networkPreReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    /*\n     * If there are any running networks, we need to\n     * create the global rules upfront. This allows us\n     * convert rules created by old libvirt into the new\n     * format.\n     *\n     * If there are not any running networks, then we\n     * must not create rules, because the rules will\n     * cause the conntrack kernel module to be loaded.\n     * This imposes a significant performance hit on\n     * the networking stack. Thus we will only create\n     * rules if a network is later startup.\n     *\n     * Any errors here are saved to be reported at time\n     * of starting the network though as that makes them\n     * more likely to be seen by a human\n     */\n    if (!networkHasRunningNetworks(driver)) {\n        VIR_DEBUG(\"Delayed global rule setup as no networks are running\");\n        return;\n    }\n\n    ignore_value(virOnce(&createdOnce, networkSetupPrivateChains));\n\n    /*\n     * If this is initial startup, and we just created the\n     * top level private chains we either\n     *\n     *   - upgraded from old libvirt\n     *   - freshly booted from clean state\n     *\n     * In the first case we must delete the old rules from\n     * the built-in chains, instead of our new private chains.\n     * In the second case it doesn't matter, since no existing\n     * rules will be present. Thus we can safely just tell it\n     * to always delete from the builin chain\n     */\n    if (startup && createdChains) {\n        VIR_DEBUG(\"Requesting cleanup of legacy firewall rules\");\n        iptablesSetDeletePrivate(false);\n    }\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virOnceControl createdOnce;",
      "static bool createdChains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesSetDeletePrivate",
          "args": [
            "false"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesSetDeletePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "176-180",
          "snippet": "void\niptablesSetDeletePrivate(bool pvt)\n{\n    deletePrivate = pvt;\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool deletePrivate = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool deletePrivate = true;\n\nvoid\niptablesSetDeletePrivate(bool pvt)\n{\n    deletePrivate = pvt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Requesting cleanup of legacy firewall rules\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virOnce(&createdOnce, networkSetupPrivateChains)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virOnce",
          "args": [
            "&createdOnce",
            "networkSetupPrivateChains"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virOnce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "40-43",
          "snippet": "int virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Delayed global rule setup as no networks are running\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkHasRunningNetworks",
          "args": [
            "driver"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "networkHasRunningNetworks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
          "lines": "103-111",
          "snippet": "static bool\nnetworkHasRunningNetworks(virNetworkDriverStatePtr driver)\n{\n    bool running = false;\n    virNetworkObjListForEach(driver->networks,\n                             networkHasRunningNetworksHelper,\n                             &running);\n    return running;\n}",
          "includes": [
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viriptables.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nnetworkHasRunningNetworks(virNetworkDriverStatePtr driver)\n{\n    bool running = false;\n    virNetworkObjListForEach(driver->networks,\n                             networkHasRunningNetworksHelper,\n                             &running);\n    return running;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virOnceControl createdOnce;\nstatic bool createdChains;\n\nvoid networkPreReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    /*\n     * If there are any running networks, we need to\n     * create the global rules upfront. This allows us\n     * convert rules created by old libvirt into the new\n     * format.\n     *\n     * If there are not any running networks, then we\n     * must not create rules, because the rules will\n     * cause the conntrack kernel module to be loaded.\n     * This imposes a significant performance hit on\n     * the networking stack. Thus we will only create\n     * rules if a network is later startup.\n     *\n     * Any errors here are saved to be reported at time\n     * of starting the network though as that makes them\n     * more likely to be seen by a human\n     */\n    if (!networkHasRunningNetworks(driver)) {\n        VIR_DEBUG(\"Delayed global rule setup as no networks are running\");\n        return;\n    }\n\n    ignore_value(virOnce(&createdOnce, networkSetupPrivateChains));\n\n    /*\n     * If this is initial startup, and we just created the\n     * top level private chains we either\n     *\n     *   - upgraded from old libvirt\n     *   - freshly booted from clean state\n     *\n     * In the first case we must delete the old rules from\n     * the built-in chains, instead of our new private chains.\n     * In the second case it doesn't matter, since no existing\n     * rules will be present. Thus we can safely just tell it\n     * to always delete from the builin chain\n     */\n    if (startup && createdChains) {\n        VIR_DEBUG(\"Requesting cleanup of legacy firewall rules\");\n        iptablesSetDeletePrivate(false);\n    }\n}"
  },
  {
    "function_name": "networkHasRunningNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "103-111",
    "snippet": "static bool\nnetworkHasRunningNetworks(virNetworkDriverStatePtr driver)\n{\n    bool running = false;\n    virNetworkObjListForEach(driver->networks,\n                             networkHasRunningNetworksHelper,\n                             &running);\n    return running;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListForEach",
          "args": [
            "driver->networks",
            "networkHasRunningNetworksHelper",
            "&running"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1472-1483",
          "snippet": "int\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nnetworkHasRunningNetworks(virNetworkDriverStatePtr driver)\n{\n    bool running = false;\n    virNetworkObjListForEach(driver->networks,\n                             networkHasRunningNetworksHelper,\n                             &running);\n    return running;\n}"
  },
  {
    "function_name": "networkHasRunningNetworksHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "88-100",
    "snippet": "static int\nnetworkHasRunningNetworksHelper(virNetworkObjPtr obj,\n                                void *opaque)\n{\n    bool *running = opaque;\n\n    virObjectLock(obj);\n    if (virNetworkObjIsActive(obj))\n        *running = true;\n    virObjectUnlock(obj);\n\n    return 0;\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "obj"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "obj"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nnetworkHasRunningNetworksHelper(virNetworkObjPtr obj,\n                                void *opaque)\n{\n    bool *running = opaque;\n\n    virObjectLock(obj);\n    if (virNetworkObjIsActive(obj))\n        *running = true;\n    virObjectUnlock(obj);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkSetupPrivateChains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_linux.c",
    "lines": "44-85",
    "snippet": "static void networkSetupPrivateChains(void)\n{\n    int rc;\n\n    VIR_DEBUG(\"Setting up global firewall chains\");\n\n    createdChains = false;\n\n    rc = iptablesSetupPrivateChains(VIR_FIREWALL_LAYER_IPV4);\n    if (rc < 0) {\n        VIR_DEBUG(\"Failed to create global IPv4 chains: %s\",\n                  virGetLastErrorMessage());\n        errInitV4 = virSaveLastError();\n        virResetLastError();\n    } else {\n        virFreeError(errInitV4);\n        errInitV4 = NULL;\n        if (rc) {\n            VIR_DEBUG(\"Created global IPv4 chains\");\n            createdChains = true;\n        } else {\n            VIR_DEBUG(\"Global IPv4 chains already exist\");\n        }\n    }\n\n    rc = iptablesSetupPrivateChains(VIR_FIREWALL_LAYER_IPV6);\n    if (rc < 0) {\n        VIR_DEBUG(\"Failed to create global IPv6 chains: %s\",\n                  virGetLastErrorMessage());\n        errInitV6 = virSaveLastError();\n        virResetLastError();\n    } else {\n        virFreeError(errInitV6);\n        errInitV6 = NULL;\n        if (rc) {\n            VIR_DEBUG(\"Created global IPv6 chains\");\n            createdChains = true;\n        } else {\n            VIR_DEBUG(\"Global IPv6 chains already exist\");\n        }\n    }\n}",
    "includes": [
      "#include \"virfirewalld.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viriptables.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool createdChains;",
      "static virErrorPtr errInitV4;",
      "static virErrorPtr errInitV6;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Global IPv6 chains already exist\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Created global IPv6 chains\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "errInitV6"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSaveLastError",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virSaveLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "401-413",
          "snippet": "virErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to create global IPv6 chains: %s\"",
            "virGetLastErrorMessage()"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesSetupPrivateChains",
          "args": [
            "VIR_FIREWALL_LAYER_IPV6"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesSetupPrivateChains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriptables.c",
          "lines": "128-173",
          "snippet": "int\niptablesSetupPrivateChains(virFirewallLayer layer)\n{\n    virFirewallPtr fw = NULL;\n    int ret = -1;\n    iptablesGlobalChain filter_chains[] = {\n        {\"INPUT\", \"LIBVIRT_INP\"},\n        {\"OUTPUT\", \"LIBVIRT_OUT\"},\n        {\"FORWARD\", \"LIBVIRT_FWO\"},\n        {\"FORWARD\", \"LIBVIRT_FWI\"},\n        {\"FORWARD\", \"LIBVIRT_FWX\"},\n    };\n    iptablesGlobalChain natmangle_chains[] = {\n        {\"POSTROUTING\",  \"LIBVIRT_PRT\"},\n    };\n    bool changed = false;\n    iptablesGlobalChainData data[] = {\n        { layer, \"filter\",\n          filter_chains, G_N_ELEMENTS(filter_chains), &changed },\n        { layer, \"nat\",\n          natmangle_chains, G_N_ELEMENTS(natmangle_chains), &changed },\n        { layer, \"mangle\",\n          natmangle_chains, G_N_ELEMENTS(natmangle_chains), &changed },\n    };\n    size_t i;\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, 0);\n\n    for (i = 0; i < G_N_ELEMENTS(data); i++)\n        virFirewallAddRuleFull(fw, data[i].layer,\n                               false, iptablesPrivateChainCreate,\n                               &(data[i]), \"--table\", data[i].table,\n                               \"--list-rules\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = changed ? 1 : 0;\n\n cleanup:\n\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virhash.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"viriptables.h\"",
            "#include \"internal.h\"",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhash.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"viriptables.h\"\n#include \"internal.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\niptablesSetupPrivateChains(virFirewallLayer layer)\n{\n    virFirewallPtr fw = NULL;\n    int ret = -1;\n    iptablesGlobalChain filter_chains[] = {\n        {\"INPUT\", \"LIBVIRT_INP\"},\n        {\"OUTPUT\", \"LIBVIRT_OUT\"},\n        {\"FORWARD\", \"LIBVIRT_FWO\"},\n        {\"FORWARD\", \"LIBVIRT_FWI\"},\n        {\"FORWARD\", \"LIBVIRT_FWX\"},\n    };\n    iptablesGlobalChain natmangle_chains[] = {\n        {\"POSTROUTING\",  \"LIBVIRT_PRT\"},\n    };\n    bool changed = false;\n    iptablesGlobalChainData data[] = {\n        { layer, \"filter\",\n          filter_chains, G_N_ELEMENTS(filter_chains), &changed },\n        { layer, \"nat\",\n          natmangle_chains, G_N_ELEMENTS(natmangle_chains), &changed },\n        { layer, \"mangle\",\n          natmangle_chains, G_N_ELEMENTS(natmangle_chains), &changed },\n    };\n    size_t i;\n\n    fw = virFirewallNew();\n\n    virFirewallStartTransaction(fw, 0);\n\n    for (i = 0; i < G_N_ELEMENTS(data); i++)\n        virFirewallAddRuleFull(fw, data[i].layer,\n                               false, iptablesPrivateChainCreate,\n                               &(data[i]), \"--table\", data[i].table,\n                               \"--list-rules\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = changed ? 1 : 0;\n\n cleanup:\n\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Global IPv4 chains already exist\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Created global IPv4 chains\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to create global IPv4 chains: %s\"",
            "virGetLastErrorMessage()"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting up global firewall chains\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viriptables.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool createdChains;\nstatic virErrorPtr errInitV4;\nstatic virErrorPtr errInitV6;\n\nstatic void networkSetupPrivateChains(void)\n{\n    int rc;\n\n    VIR_DEBUG(\"Setting up global firewall chains\");\n\n    createdChains = false;\n\n    rc = iptablesSetupPrivateChains(VIR_FIREWALL_LAYER_IPV4);\n    if (rc < 0) {\n        VIR_DEBUG(\"Failed to create global IPv4 chains: %s\",\n                  virGetLastErrorMessage());\n        errInitV4 = virSaveLastError();\n        virResetLastError();\n    } else {\n        virFreeError(errInitV4);\n        errInitV4 = NULL;\n        if (rc) {\n            VIR_DEBUG(\"Created global IPv4 chains\");\n            createdChains = true;\n        } else {\n            VIR_DEBUG(\"Global IPv4 chains already exist\");\n        }\n    }\n\n    rc = iptablesSetupPrivateChains(VIR_FIREWALL_LAYER_IPV6);\n    if (rc < 0) {\n        VIR_DEBUG(\"Failed to create global IPv6 chains: %s\",\n                  virGetLastErrorMessage());\n        errInitV6 = virSaveLastError();\n        virResetLastError();\n    } else {\n        virFreeError(errInitV6);\n        errInitV6 = NULL;\n        if (rc) {\n            VIR_DEBUG(\"Created global IPv6 chains\");\n            createdChains = true;\n        } else {\n            VIR_DEBUG(\"Global IPv6 chains already exist\");\n        }\n    }\n}"
  }
]