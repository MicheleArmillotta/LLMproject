[
  {
    "function_name": "esxNetworkIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "857-862",
    "snippet": "static int\nesxNetworkIsPersistent(virNetworkPtr network G_GNUC_UNUSED)\n{\n    /* ESX has no concept of transient networks, so all of them are persistent */\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNetworkIsPersistent(virNetworkPtr network G_GNUC_UNUSED)\n{\n    /* ESX has no concept of transient networks, so all of them are persistent */\n    return 1;\n}"
  },
  {
    "function_name": "esxNetworkIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "848-853",
    "snippet": "static int\nesxNetworkIsActive(virNetworkPtr network G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNetworkIsActive(virNetworkPtr network G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 1;\n}"
  },
  {
    "function_name": "esxNetworkSetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "830-844",
    "snippet": "static int\nesxNetworkSetAutostart(virNetworkPtr network G_GNUC_UNUSED,\n                       int autostart)\n{\n    /* Just accept autostart activation, but fail on autostart deactivation */\n    autostart = (autostart != 0);\n\n    if (! autostart) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot deactivate network autostart\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot deactivate network autostart\")"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot deactivate network autostart\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNetworkSetAutostart(virNetworkPtr network G_GNUC_UNUSED,\n                       int autostart)\n{\n    /* Just accept autostart activation, but fail on autostart deactivation */\n    autostart = (autostart != 0);\n\n    if (! autostart) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot deactivate network autostart\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxNetworkGetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "818-826",
    "snippet": "static int\nesxNetworkGetAutostart(virNetworkPtr network G_GNUC_UNUSED,\n                       int *autostart)\n{\n    /* ESX networks are always active */\n    *autostart = 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNetworkGetAutostart(virNetworkPtr network G_GNUC_UNUSED,\n                       int *autostart)\n{\n    /* ESX networks are always active */\n    *autostart = 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "esxNetworkGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "635-814",
    "snippet": "static char *\nesxNetworkGetXMLDesc(virNetworkPtr network_, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = network_->conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    esxVI_String *physicalNicKey = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *networkList = NULL;\n    esxVI_ObjectContent *network = NULL;\n    esxVI_String *networkNameList = NULL;\n    esxVI_String *hostPortGroupKey = NULL;\n    esxVI_String *networkName = NULL;\n    virNetworkDefPtr def;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        goto cleanup;\n\n    /* Lookup HostVirtualSwitch */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, network_->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, def->uuid) < 0)\n        goto cleanup;\n\n    def->name = g_strdup(hostVirtualSwitch->name);\n\n    def->forward.type = VIR_NETWORK_FORWARD_NONE;\n\n    /* Count PhysicalNics on HostVirtualSwitch */\n    count = 0;\n\n    for (physicalNicKey = hostVirtualSwitch->pnic;\n         physicalNicKey; physicalNicKey = physicalNicKey->_next) {\n        ++count;\n    }\n\n    if (count > 0) {\n        def->forward.type = VIR_NETWORK_FORWARD_BRIDGE;\n\n        if (VIR_ALLOC_N(def->forward.ifs, count) < 0)\n            goto cleanup;\n\n        /* Find PhysicalNic by key */\n        if (esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0)\n            goto cleanup;\n\n        for (physicalNicKey = hostVirtualSwitch->pnic;\n             physicalNicKey; physicalNicKey = physicalNicKey->_next) {\n            bool found = false;\n\n            for (physicalNic = physicalNicList; physicalNic;\n                 physicalNic = physicalNic->_next) {\n                if (STREQ(physicalNicKey->value, physicalNic->key)) {\n                    def->forward.ifs[def->forward.nifs].type\n                        = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                    def->forward.ifs[def->forward.nifs].device.dev = g_strdup(physicalNic->device);\n\n                    ++def->forward.nifs;\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find PhysicalNic with key '%s'\"),\n                               physicalNicKey->value);\n                goto cleanup;\n            }\n        }\n    }\n\n    /* Count HostPortGroups on HostVirtualSwitch */\n    count = 0;\n\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        ++count;\n    }\n\n    if (count > 0) {\n        if (VIR_ALLOC_N(def->portGroups, count) < 0)\n            goto cleanup;\n\n        /* Lookup Network list and create name list */\n        if (esxVI_String_AppendValueToList(&propertyNameList, \"name\") < 0 ||\n            esxVI_LookupNetworkList(priv->primary, propertyNameList,\n                                    &networkList) < 0) {\n            goto cleanup;\n        }\n\n        for (network = networkList; network; network = network->_next) {\n            char *tmp = NULL;\n\n            if (esxVI_GetStringValue(network, \"name\", &tmp,\n                                     esxVI_Occurrence_RequiredItem) < 0 ||\n                esxVI_String_AppendValueToList(&networkNameList, tmp) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Find HostPortGroup by key */\n        if (esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0)\n            goto cleanup;\n\n        for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n             hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n            bool found = false;\n\n            for (hostPortGroup = hostPortGroupList; hostPortGroup;\n                 hostPortGroup = hostPortGroup->_next) {\n                if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                    /* Find Network for HostPortGroup, there might be none */\n                    for (networkName = networkNameList; networkName;\n                         networkName = networkName->_next) {\n                        if (STREQ(networkName->value, hostPortGroup->spec->name)) {\n                            def->portGroups[def->nPortGroups].name = g_strdup(networkName->value);\n\n                            if (hostPortGroup->spec->policy) {\n                                if (esxShapingPolicyToBandwidth\n                                      (hostPortGroup->spec->policy->shapingPolicy,\n                                       &def->portGroups[def->nPortGroups].bandwidth) < 0) {\n                                    ++def->nPortGroups;\n                                    goto cleanup;\n                                }\n                            }\n\n                            ++def->nPortGroups;\n                            break;\n                        }\n                    }\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find HostPortGroup with key '%s'\"),\n                               hostPortGroupKey->value);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (hostVirtualSwitch->spec->policy) {\n        if (esxShapingPolicyToBandwidth\n              (hostVirtualSwitch->spec->policy->shapingPolicy,\n               &def->bandwidth) < 0) {\n            goto cleanup;\n        }\n    }\n\n    xml = virNetworkDefFormat(def, NULL, flags);\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_PhysicalNic_Free(&physicalNicList);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&networkList);\n    esxVI_String_Free(&networkNameList);\n    virNetworkDefFree(def);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&networkNameList"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&networkList"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostPortGroup_Free",
          "args": [
            "&hostPortGroupList"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitch"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormat",
          "args": [
            "def",
            "NULL",
            "flags"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2673-2688",
          "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxShapingPolicyToBandwidth",
          "args": [
            "hostVirtualSwitch->spec->policy->shapingPolicy",
            "&def->bandwidth"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "esxShapingPolicyToBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
          "lines": "598-631",
          "snippet": "static int\nesxShapingPolicyToBandwidth(esxVI_HostNetworkTrafficShapingPolicy *shapingPolicy,\n                            virNetDevBandwidthPtr *bandwidth)\n{\n    ESX_VI_CHECK_ARG_LIST(bandwidth);\n\n    if (!shapingPolicy || shapingPolicy->enabled != esxVI_Boolean_True)\n        return 0;\n\n    if (VIR_ALLOC(*bandwidth) < 0 ||\n        VIR_ALLOC((*bandwidth)->in) < 0 ||\n        VIR_ALLOC((*bandwidth)->out) < 0)\n        return -1;\n\n    if (shapingPolicy->averageBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->peakBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->burstSize) {\n        /* Scale bytes to kilobytes */\n        (*bandwidth)->in->burst = shapingPolicy->burstSize->value / 1024;\n        (*bandwidth)->out->burst = shapingPolicy->burstSize->value / 1024;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_private.h\"",
            "#include \"network_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxShapingPolicyToBandwidth(esxVI_HostNetworkTrafficShapingPolicy *shapingPolicy,\n                            virNetDevBandwidthPtr *bandwidth)\n{\n    ESX_VI_CHECK_ARG_LIST(bandwidth);\n\n    if (!shapingPolicy || shapingPolicy->enabled != esxVI_Boolean_True)\n        return 0;\n\n    if (VIR_ALLOC(*bandwidth) < 0 ||\n        VIR_ALLOC((*bandwidth)->in) < 0 ||\n        VIR_ALLOC((*bandwidth)->out) < 0)\n        return -1;\n\n    if (shapingPolicy->averageBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->peakBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->burstSize) {\n        /* Scale bytes to kilobytes */\n        (*bandwidth)->in->burst = shapingPolicy->burstSize->value / 1024;\n        (*bandwidth)->out->burst = shapingPolicy->burstSize->value / 1024;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find HostPortGroup with key '%s'\")",
            "hostPortGroupKey->value"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find HostPortGroup with key '%s'\""
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "networkName->value"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "networkName->value",
            "hostPortGroup->spec->name"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostPortGroupKey->value",
            "hostPortGroup->key"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostPortGroupList",
          "args": [
            "priv->primary",
            "&hostPortGroupList"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostPortGroupList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4070-4109",
          "snippet": "int\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&networkNameList",
            "tmp"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "network",
            "\"name\"",
            "&tmp",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupNetworkList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&networkList"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupNetworkList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4113-4121",
          "snippet": "int\nesxVI_LookupNetworkList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                        esxVI_ObjectContent **networkList)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->datacenter->_reference,\n                                           \"Network\", propertyNameList,\n                                           networkList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupNetworkList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                        esxVI_ObjectContent **networkList)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->datacenter->_reference,\n                                           \"Network\", propertyNameList,\n                                           networkList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->portGroups",
            "count"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find PhysicalNic with key '%s'\")",
            "physicalNicKey->value"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "physicalNicKey->value",
            "physicalNic->key"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "priv->primary",
            "&physicalNicList"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->forward.ifs",
            "count"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostVirtualSwitch->key",
            "def->uuid"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchByName",
          "args": [
            "priv->primary",
            "network_->name",
            "&hostVirtualSwitch",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4022-4066",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxNetworkGetXMLDesc(virNetworkPtr network_, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = network_->conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    esxVI_String *physicalNicKey = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *networkList = NULL;\n    esxVI_ObjectContent *network = NULL;\n    esxVI_String *networkNameList = NULL;\n    esxVI_String *hostPortGroupKey = NULL;\n    esxVI_String *networkName = NULL;\n    virNetworkDefPtr def;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        goto cleanup;\n\n    /* Lookup HostVirtualSwitch */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, network_->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, def->uuid) < 0)\n        goto cleanup;\n\n    def->name = g_strdup(hostVirtualSwitch->name);\n\n    def->forward.type = VIR_NETWORK_FORWARD_NONE;\n\n    /* Count PhysicalNics on HostVirtualSwitch */\n    count = 0;\n\n    for (physicalNicKey = hostVirtualSwitch->pnic;\n         physicalNicKey; physicalNicKey = physicalNicKey->_next) {\n        ++count;\n    }\n\n    if (count > 0) {\n        def->forward.type = VIR_NETWORK_FORWARD_BRIDGE;\n\n        if (VIR_ALLOC_N(def->forward.ifs, count) < 0)\n            goto cleanup;\n\n        /* Find PhysicalNic by key */\n        if (esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0)\n            goto cleanup;\n\n        for (physicalNicKey = hostVirtualSwitch->pnic;\n             physicalNicKey; physicalNicKey = physicalNicKey->_next) {\n            bool found = false;\n\n            for (physicalNic = physicalNicList; physicalNic;\n                 physicalNic = physicalNic->_next) {\n                if (STREQ(physicalNicKey->value, physicalNic->key)) {\n                    def->forward.ifs[def->forward.nifs].type\n                        = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                    def->forward.ifs[def->forward.nifs].device.dev = g_strdup(physicalNic->device);\n\n                    ++def->forward.nifs;\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find PhysicalNic with key '%s'\"),\n                               physicalNicKey->value);\n                goto cleanup;\n            }\n        }\n    }\n\n    /* Count HostPortGroups on HostVirtualSwitch */\n    count = 0;\n\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        ++count;\n    }\n\n    if (count > 0) {\n        if (VIR_ALLOC_N(def->portGroups, count) < 0)\n            goto cleanup;\n\n        /* Lookup Network list and create name list */\n        if (esxVI_String_AppendValueToList(&propertyNameList, \"name\") < 0 ||\n            esxVI_LookupNetworkList(priv->primary, propertyNameList,\n                                    &networkList) < 0) {\n            goto cleanup;\n        }\n\n        for (network = networkList; network; network = network->_next) {\n            char *tmp = NULL;\n\n            if (esxVI_GetStringValue(network, \"name\", &tmp,\n                                     esxVI_Occurrence_RequiredItem) < 0 ||\n                esxVI_String_AppendValueToList(&networkNameList, tmp) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Find HostPortGroup by key */\n        if (esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0)\n            goto cleanup;\n\n        for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n             hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n            bool found = false;\n\n            for (hostPortGroup = hostPortGroupList; hostPortGroup;\n                 hostPortGroup = hostPortGroup->_next) {\n                if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                    /* Find Network for HostPortGroup, there might be none */\n                    for (networkName = networkNameList; networkName;\n                         networkName = networkName->_next) {\n                        if (STREQ(networkName->value, hostPortGroup->spec->name)) {\n                            def->portGroups[def->nPortGroups].name = g_strdup(networkName->value);\n\n                            if (hostPortGroup->spec->policy) {\n                                if (esxShapingPolicyToBandwidth\n                                      (hostPortGroup->spec->policy->shapingPolicy,\n                                       &def->portGroups[def->nPortGroups].bandwidth) < 0) {\n                                    ++def->nPortGroups;\n                                    goto cleanup;\n                                }\n                            }\n\n                            ++def->nPortGroups;\n                            break;\n                        }\n                    }\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find HostPortGroup with key '%s'\"),\n                               hostPortGroupKey->value);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (hostVirtualSwitch->spec->policy) {\n        if (esxShapingPolicyToBandwidth\n              (hostVirtualSwitch->spec->policy->shapingPolicy,\n               &def->bandwidth) < 0) {\n            goto cleanup;\n        }\n    }\n\n    xml = virNetworkDefFormat(def, NULL, flags);\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_PhysicalNic_Free(&physicalNicList);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&networkList);\n    esxVI_String_Free(&networkNameList);\n    virNetworkDefFree(def);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxShapingPolicyToBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "598-631",
    "snippet": "static int\nesxShapingPolicyToBandwidth(esxVI_HostNetworkTrafficShapingPolicy *shapingPolicy,\n                            virNetDevBandwidthPtr *bandwidth)\n{\n    ESX_VI_CHECK_ARG_LIST(bandwidth);\n\n    if (!shapingPolicy || shapingPolicy->enabled != esxVI_Boolean_True)\n        return 0;\n\n    if (VIR_ALLOC(*bandwidth) < 0 ||\n        VIR_ALLOC((*bandwidth)->in) < 0 ||\n        VIR_ALLOC((*bandwidth)->out) < 0)\n        return -1;\n\n    if (shapingPolicy->averageBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->peakBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->burstSize) {\n        /* Scale bytes to kilobytes */\n        (*bandwidth)->in->burst = shapingPolicy->burstSize->value / 1024;\n        (*bandwidth)->out->burst = shapingPolicy->burstSize->value / 1024;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "(*bandwidth)->out"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "(*bandwidth)->in"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*bandwidth"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "bandwidth"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxShapingPolicyToBandwidth(esxVI_HostNetworkTrafficShapingPolicy *shapingPolicy,\n                            virNetDevBandwidthPtr *bandwidth)\n{\n    ESX_VI_CHECK_ARG_LIST(bandwidth);\n\n    if (!shapingPolicy || shapingPolicy->enabled != esxVI_Boolean_True)\n        return 0;\n\n    if (VIR_ALLOC(*bandwidth) < 0 ||\n        VIR_ALLOC((*bandwidth)->in) < 0 ||\n        VIR_ALLOC((*bandwidth)->out) < 0)\n        return -1;\n\n    if (shapingPolicy->averageBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->average = shapingPolicy->averageBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->peakBandwidth) {\n        /* Scale bits per second to kilobytes per second */\n        (*bandwidth)->in->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n        (*bandwidth)->out->peak = shapingPolicy->peakBandwidth->value / 8 / 1000;\n    }\n\n    if (shapingPolicy->burstSize) {\n        /* Scale bytes to kilobytes */\n        (*bandwidth)->in->burst = shapingPolicy->burstSize->value / 1024;\n        (*bandwidth)->out->burst = shapingPolicy->burstSize->value / 1024;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxNetworkUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "497-594",
    "snippet": "static int\nesxNetworkUndefine(virNetworkPtr network)\n{\n    int result = -1;\n    esxPrivate *priv = network->conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_String *hostPortGroupKey = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_HostPortGroupPort *hostPortGroupPort = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Lookup HostVirtualSwitch and HostPortGroup list */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, network->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0) {\n        goto cleanup;\n    }\n\n    /* Verify that the HostVirtualSwitch is connected to virtual machines only */\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        bool found = false;\n\n        for (hostPortGroup = hostPortGroupList; hostPortGroup;\n             hostPortGroup = hostPortGroup->_next) {\n            if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                for (hostPortGroupPort = hostPortGroup->port;\n                     hostPortGroupPort;\n                     hostPortGroupPort = hostPortGroupPort->_next) {\n                    if (STRNEQ(hostPortGroupPort->type, \"virtualMachine\")) {\n                        virReportError(VIR_ERR_OPERATION_INVALID,\n                                       _(\"Cannot undefine HostVirtualSwitch that has a '%s' port\"),\n                                       hostPortGroupPort->type);\n                        goto cleanup;\n                    }\n                }\n\n                found = true;\n                break;\n            }\n        }\n\n        if (! found) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not find HostPortGroup for key '%s'\"),\n                           hostPortGroupKey->value);\n            goto cleanup;\n        }\n    }\n\n    /* Remove all HostPortGroups from the HostVirtualSwitch */\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        bool found = false;\n\n        for (hostPortGroup = hostPortGroupList; hostPortGroup;\n             hostPortGroup = hostPortGroup->_next) {\n            if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                if (esxVI_RemovePortGroup\n                      (priv->primary,\n                       priv->primary->hostSystem->configManager->networkSystem,\n                       hostPortGroup->spec->name) < 0) {\n                    goto cleanup;\n                }\n\n                found = true;\n                break;\n            }\n        }\n\n        if (! found) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not find HostPortGroup for key '%s'\"),\n                           hostPortGroupKey->value);\n            goto cleanup;\n        }\n    }\n\n    /* Finally, remove HostVirtualSwitch itself */\n    if (esxVI_RemoveVirtualSwitch\n          (priv->primary,\n           priv->primary->hostSystem->configManager->networkSystem,\n           network->name) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostPortGroup_Free",
          "args": [
            "&hostPortGroupList"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitch"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RemoveVirtualSwitch",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->networkSystem",
            "network->name"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find HostPortGroup for key '%s'\")",
            "hostPortGroupKey->value"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find HostPortGroup for key '%s'\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_RemovePortGroup",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->networkSystem",
            "hostPortGroup->spec->name"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostPortGroupKey->value",
            "hostPortGroup->key"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find HostPortGroup for key '%s'\")",
            "hostPortGroupKey->value"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Cannot undefine HostVirtualSwitch that has a '%s' port\")",
            "hostPortGroupPort->type"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "hostPortGroupPort->type",
            "\"virtualMachine\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostPortGroupKey->value",
            "hostPortGroup->key"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostPortGroupList",
          "args": [
            "priv->primary",
            "&hostPortGroupList"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostPortGroupList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4070-4109",
          "snippet": "int\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchByName",
          "args": [
            "priv->primary",
            "network->name",
            "&hostVirtualSwitch",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4022-4066",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNetworkUndefine(virNetworkPtr network)\n{\n    int result = -1;\n    esxPrivate *priv = network->conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_String *hostPortGroupKey = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_HostPortGroupPort *hostPortGroupPort = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Lookup HostVirtualSwitch and HostPortGroup list */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, network->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0) {\n        goto cleanup;\n    }\n\n    /* Verify that the HostVirtualSwitch is connected to virtual machines only */\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        bool found = false;\n\n        for (hostPortGroup = hostPortGroupList; hostPortGroup;\n             hostPortGroup = hostPortGroup->_next) {\n            if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                for (hostPortGroupPort = hostPortGroup->port;\n                     hostPortGroupPort;\n                     hostPortGroupPort = hostPortGroupPort->_next) {\n                    if (STRNEQ(hostPortGroupPort->type, \"virtualMachine\")) {\n                        virReportError(VIR_ERR_OPERATION_INVALID,\n                                       _(\"Cannot undefine HostVirtualSwitch that has a '%s' port\"),\n                                       hostPortGroupPort->type);\n                        goto cleanup;\n                    }\n                }\n\n                found = true;\n                break;\n            }\n        }\n\n        if (! found) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not find HostPortGroup for key '%s'\"),\n                           hostPortGroupKey->value);\n            goto cleanup;\n        }\n    }\n\n    /* Remove all HostPortGroups from the HostVirtualSwitch */\n    for (hostPortGroupKey = hostVirtualSwitch->portgroup;\n         hostPortGroupKey; hostPortGroupKey = hostPortGroupKey->_next) {\n        bool found = false;\n\n        for (hostPortGroup = hostPortGroupList; hostPortGroup;\n             hostPortGroup = hostPortGroup->_next) {\n            if (STREQ(hostPortGroupKey->value, hostPortGroup->key)) {\n                if (esxVI_RemovePortGroup\n                      (priv->primary,\n                       priv->primary->hostSystem->configManager->networkSystem,\n                       hostPortGroup->spec->name) < 0) {\n                    goto cleanup;\n                }\n\n                found = true;\n                break;\n            }\n        }\n\n        if (! found) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not find HostPortGroup for key '%s'\"),\n                           hostPortGroupKey->value);\n            goto cleanup;\n        }\n    }\n\n    /* Finally, remove HostVirtualSwitch itself */\n    if (esxVI_RemoveVirtualSwitch\n          (priv->primary,\n           priv->primary->hostSystem->configManager->networkSystem,\n           network->name) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxNetworkDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "276-493",
    "snippet": "static virNetworkPtr\nesxNetworkDefineXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    virNetworkDefPtr def = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_HostVirtualSwitchSpec *hostVirtualSwitchSpec = NULL;\n    esxVI_HostVirtualSwitchBondBridge *hostVirtualSwitchBondBridge = NULL;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    esxVI_HostPortGroupSpec *hostPortGroupSpec = NULL;\n    size_t i;\n\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse network XML */\n    def = virNetworkDefParseString(xml, NULL);\n\n    if (!def)\n        return NULL;\n\n    /* Check if an existing HostVirtualSwitch should be edited */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, def->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (hostVirtualSwitch) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"HostVirtualSwitch already exists, editing existing \"\n                         \"ones is not supported yet\"));\n        goto cleanup;\n    }\n\n    /* UUID is derived from the HostVirtualSwitch's key and cannot be specified */\n    if (def->uuid_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Cannot use predefined UUID\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Add support for NAT */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        break;\n\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported forward mode '%s'\"),\n                       virNetworkForwardTypeToString(def->forward.type));\n        goto cleanup;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    /* Verify that specified HostPortGroups don't exist already */\n    if (def->nPortGroups > 0) {\n        if (esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0)\n            goto cleanup;\n\n        for (i = 0; i < def->nPortGroups; ++i) {\n            for (hostPortGroup = hostPortGroupList; hostPortGroup;\n                 hostPortGroup = hostPortGroup->_next) {\n                if (STREQ(def->portGroups[i].name, hostPortGroup->spec->name)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"HostPortGroup with name '%s' exists already\"),\n                                   def->portGroups[i].name);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    /* Create HostVirtualSwitch */\n    if (esxVI_HostVirtualSwitchSpec_Alloc(&hostVirtualSwitchSpec) < 0 ||\n        esxVI_Int_Alloc(&hostVirtualSwitchSpec->numPorts) < 0) {\n        goto cleanup;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE && def->forward.nifs > 0) {\n        if (esxVI_HostVirtualSwitchBondBridge_Alloc\n              (&hostVirtualSwitchBondBridge) < 0) {\n            goto cleanup;\n        }\n\n        hostVirtualSwitchSpec->bridge =\n          (esxVI_HostVirtualSwitchBridge *)hostVirtualSwitchBondBridge;\n\n        /* Lookup PhysicalNic list and match by name to get key */\n        if (esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0)\n            goto cleanup;\n\n        for (i = 0; i < def->forward.nifs; ++i) {\n            bool found = false;\n\n            if (def->forward.ifs[i].type !=\n                VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unsupported device type in network %s \"\n                                 \"interface pool\"),\n                               def->name);\n                goto cleanup;\n            }\n\n            for (physicalNic = physicalNicList; physicalNic;\n                 physicalNic = physicalNic->_next) {\n                if (STREQ(def->forward.ifs[i].device.dev, physicalNic->device)) {\n                    if (esxVI_String_AppendValueToList\n                          (&hostVirtualSwitchBondBridge->nicDevice,\n                           physicalNic->key) < 0) {\n                        goto cleanup;\n                    }\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find PhysicalNic with name '%s'\"),\n                               def->forward.ifs[i].device.dev);\n                goto cleanup;\n            }\n        }\n    }\n\n    hostVirtualSwitchSpec->numPorts->value = 128;\n\n    if (def->bandwidth) {\n        if (esxVI_HostNetworkPolicy_Alloc(&hostVirtualSwitchSpec->policy) < 0)\n            goto cleanup;\n\n        if (esxBandwidthToShapingPolicy\n              (def->bandwidth,\n               &hostVirtualSwitchSpec->policy->shapingPolicy) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_AddVirtualSwitch\n          (priv->primary,\n           priv->primary->hostSystem->configManager->networkSystem,\n           def->name, hostVirtualSwitchSpec) < 0) {\n        goto cleanup;\n    }\n\n    /* Create HostPortGroup(s) */\n    for (i = 0; i < def->nPortGroups; ++i) {\n        esxVI_HostPortGroupSpec_Free(&hostPortGroupSpec);\n\n        if (esxVI_HostPortGroupSpec_Alloc(&hostPortGroupSpec) < 0 ||\n            esxVI_HostNetworkPolicy_Alloc(&hostPortGroupSpec->policy) < 0 ||\n            esxVI_Int_Alloc(&hostPortGroupSpec->vlanId) < 0) {\n            goto cleanup;\n        }\n\n        hostPortGroupSpec->name = g_strdup(def->portGroups[i].name);\n        hostPortGroupSpec->vswitchName = g_strdup(def->name);\n\n        hostPortGroupSpec->vlanId->value = 0;\n\n        if (def->portGroups[i].bandwidth) {\n            if (esxBandwidthToShapingPolicy\n                  (def->portGroups[i].bandwidth,\n                   &hostPortGroupSpec->policy->shapingPolicy) < 0) {\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_AddPortGroup\n              (priv->primary,\n               priv->primary->hostSystem->configManager->networkSystem,\n               hostPortGroupSpec) < 0) {\n            goto cleanup;\n        }\n    }\n\n    /* Lookup created HostVirtualSwitch to get the UUID */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, def->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        goto cleanup;\n\n    network = virGetNetwork(conn, hostVirtualSwitch->name, md5);\n\n cleanup:\n    virNetworkDefFree(def);\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n    esxVI_HostVirtualSwitchSpec_Free(&hostVirtualSwitchSpec);\n    esxVI_PhysicalNic_Free(&physicalNicList);\n    esxVI_HostPortGroupSpec_Free(&hostPortGroupSpec);\n\n    return network;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostPortGroupSpec_Free",
          "args": [
            "&hostPortGroupSpec"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitchSpec_Free",
          "args": [
            "&hostVirtualSwitchSpec"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostPortGroup_Free",
          "args": [
            "&hostPortGroupList"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitch"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "hostVirtualSwitch->name",
            "md5"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostVirtualSwitch->key",
            "md5"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchByName",
          "args": [
            "priv->primary",
            "def->name",
            "&hostVirtualSwitch",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4022-4066",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AddPortGroup",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->networkSystem",
            "hostPortGroupSpec"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxBandwidthToShapingPolicy",
          "args": [
            "def->portGroups[i].bandwidth",
            "&hostPortGroupSpec->policy->shapingPolicy"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "esxBandwidthToShapingPolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
          "lines": "214-272",
          "snippet": "static int\nesxBandwidthToShapingPolicy(virNetDevBandwidthPtr bandwidth,\n                            esxVI_HostNetworkTrafficShapingPolicy **shapingPolicy)\n{\n    int result = -1;\n\n    ESX_VI_CHECK_ARG_LIST(shapingPolicy);\n\n    if (!bandwidth->in || !bandwidth->out ||\n        bandwidth->in->average != bandwidth->out->average ||\n        bandwidth->in->peak != bandwidth->out->peak ||\n        bandwidth->in->burst != bandwidth->out->burst) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different inbound and outbound bandwidth is unsupported\"));\n        return -1;\n    }\n\n    if (bandwidth->in->average == 0 && bandwidth->in->peak == 0 &&\n        bandwidth->in->burst == 0) {\n        return 0;\n    }\n\n    if (esxVI_HostNetworkTrafficShapingPolicy_Alloc(shapingPolicy) < 0)\n        goto cleanup;\n\n    (*shapingPolicy)->enabled = esxVI_Boolean_True;\n\n    if (bandwidth->in->average > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->averageBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->averageBandwidth->value = bandwidth->in->average * 8 * 1000;\n    }\n\n    if (bandwidth->in->peak > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->peakBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->peakBandwidth->value = bandwidth->in->peak * 8 * 1000;\n    }\n\n    if (bandwidth->in->burst > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->burstSize) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes to bytes */\n        (*shapingPolicy)->burstSize->value = bandwidth->in->burst * 1024;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_HostNetworkTrafficShapingPolicy_Free(shapingPolicy);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_private.h\"",
            "#include \"network_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxBandwidthToShapingPolicy(virNetDevBandwidthPtr bandwidth,\n                            esxVI_HostNetworkTrafficShapingPolicy **shapingPolicy)\n{\n    int result = -1;\n\n    ESX_VI_CHECK_ARG_LIST(shapingPolicy);\n\n    if (!bandwidth->in || !bandwidth->out ||\n        bandwidth->in->average != bandwidth->out->average ||\n        bandwidth->in->peak != bandwidth->out->peak ||\n        bandwidth->in->burst != bandwidth->out->burst) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different inbound and outbound bandwidth is unsupported\"));\n        return -1;\n    }\n\n    if (bandwidth->in->average == 0 && bandwidth->in->peak == 0 &&\n        bandwidth->in->burst == 0) {\n        return 0;\n    }\n\n    if (esxVI_HostNetworkTrafficShapingPolicy_Alloc(shapingPolicy) < 0)\n        goto cleanup;\n\n    (*shapingPolicy)->enabled = esxVI_Boolean_True;\n\n    if (bandwidth->in->average > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->averageBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->averageBandwidth->value = bandwidth->in->average * 8 * 1000;\n    }\n\n    if (bandwidth->in->peak > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->peakBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->peakBandwidth->value = bandwidth->in->peak * 8 * 1000;\n    }\n\n    if (bandwidth->in->burst > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->burstSize) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes to bytes */\n        (*shapingPolicy)->burstSize->value = bandwidth->in->burst * 1024;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_HostNetworkTrafficShapingPolicy_Free(shapingPolicy);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->name"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&hostPortGroupSpec->vlanId"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostNetworkPolicy_Alloc",
          "args": [
            "&hostPortGroupSpec->policy"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostPortGroupSpec_Alloc",
          "args": [
            "&hostPortGroupSpec"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostPortGroupSpec_Free",
          "args": [
            "&hostPortGroupSpec"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AddVirtualSwitch",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->networkSystem",
            "def->name",
            "hostVirtualSwitchSpec"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostNetworkPolicy_Alloc",
          "args": [
            "&hostVirtualSwitchSpec->policy"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find PhysicalNic with name '%s'\")",
            "def->forward.ifs[i].device.dev"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find PhysicalNic with name '%s'\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&hostVirtualSwitchBondBridge->nicDevice",
            "physicalNic->key"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->forward.ifs[i].device.dev",
            "physicalNic->device"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unsupported device type in network %s \"\n                                 \"interface pool\")",
            "def->name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "priv->primary",
            "&physicalNicList"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitchBondBridge_Alloc",
          "args": [
            "&hostVirtualSwitchBondBridge"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&hostVirtualSwitchSpec->numPorts"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitchSpec_Alloc",
          "args": [
            "&hostVirtualSwitchSpec"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HostPortGroup with name '%s' exists already\")",
            "def->portGroups[i].name"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->portGroups[i].name",
            "hostPortGroup->spec->name"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostPortGroupList",
          "args": [
            "priv->primary",
            "&hostPortGroupList"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostPortGroupList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4070-4109",
          "snippet": "int\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported forward mode '%s'\")",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Cannot use predefined UUID\")"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"HostVirtualSwitch already exists, editing existing \"\n                         \"ones is not supported yet\")"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseString",
          "args": [
            "xml",
            "NULL"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2114-2119",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr\nesxNetworkDefineXML(virConnectPtr conn, const char *xml)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    virNetworkDefPtr def = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    esxVI_HostPortGroup *hostPortGroupList = NULL;\n    esxVI_HostPortGroup *hostPortGroup = NULL;\n    esxVI_HostVirtualSwitchSpec *hostVirtualSwitchSpec = NULL;\n    esxVI_HostVirtualSwitchBondBridge *hostVirtualSwitchBondBridge = NULL;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    esxVI_HostPortGroupSpec *hostPortGroupSpec = NULL;\n    size_t i;\n\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse network XML */\n    def = virNetworkDefParseString(xml, NULL);\n\n    if (!def)\n        return NULL;\n\n    /* Check if an existing HostVirtualSwitch should be edited */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, def->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (hostVirtualSwitch) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"HostVirtualSwitch already exists, editing existing \"\n                         \"ones is not supported yet\"));\n        goto cleanup;\n    }\n\n    /* UUID is derived from the HostVirtualSwitch's key and cannot be specified */\n    if (def->uuid_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Cannot use predefined UUID\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Add support for NAT */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        break;\n\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported forward mode '%s'\"),\n                       virNetworkForwardTypeToString(def->forward.type));\n        goto cleanup;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    /* Verify that specified HostPortGroups don't exist already */\n    if (def->nPortGroups > 0) {\n        if (esxVI_LookupHostPortGroupList(priv->primary, &hostPortGroupList) < 0)\n            goto cleanup;\n\n        for (i = 0; i < def->nPortGroups; ++i) {\n            for (hostPortGroup = hostPortGroupList; hostPortGroup;\n                 hostPortGroup = hostPortGroup->_next) {\n                if (STREQ(def->portGroups[i].name, hostPortGroup->spec->name)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"HostPortGroup with name '%s' exists already\"),\n                                   def->portGroups[i].name);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    /* Create HostVirtualSwitch */\n    if (esxVI_HostVirtualSwitchSpec_Alloc(&hostVirtualSwitchSpec) < 0 ||\n        esxVI_Int_Alloc(&hostVirtualSwitchSpec->numPorts) < 0) {\n        goto cleanup;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE && def->forward.nifs > 0) {\n        if (esxVI_HostVirtualSwitchBondBridge_Alloc\n              (&hostVirtualSwitchBondBridge) < 0) {\n            goto cleanup;\n        }\n\n        hostVirtualSwitchSpec->bridge =\n          (esxVI_HostVirtualSwitchBridge *)hostVirtualSwitchBondBridge;\n\n        /* Lookup PhysicalNic list and match by name to get key */\n        if (esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0)\n            goto cleanup;\n\n        for (i = 0; i < def->forward.nifs; ++i) {\n            bool found = false;\n\n            if (def->forward.ifs[i].type !=\n                VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unsupported device type in network %s \"\n                                 \"interface pool\"),\n                               def->name);\n                goto cleanup;\n            }\n\n            for (physicalNic = physicalNicList; physicalNic;\n                 physicalNic = physicalNic->_next) {\n                if (STREQ(def->forward.ifs[i].device.dev, physicalNic->device)) {\n                    if (esxVI_String_AppendValueToList\n                          (&hostVirtualSwitchBondBridge->nicDevice,\n                           physicalNic->key) < 0) {\n                        goto cleanup;\n                    }\n\n                    found = true;\n                    break;\n                }\n            }\n\n            if (! found) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find PhysicalNic with name '%s'\"),\n                               def->forward.ifs[i].device.dev);\n                goto cleanup;\n            }\n        }\n    }\n\n    hostVirtualSwitchSpec->numPorts->value = 128;\n\n    if (def->bandwidth) {\n        if (esxVI_HostNetworkPolicy_Alloc(&hostVirtualSwitchSpec->policy) < 0)\n            goto cleanup;\n\n        if (esxBandwidthToShapingPolicy\n              (def->bandwidth,\n               &hostVirtualSwitchSpec->policy->shapingPolicy) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_AddVirtualSwitch\n          (priv->primary,\n           priv->primary->hostSystem->configManager->networkSystem,\n           def->name, hostVirtualSwitchSpec) < 0) {\n        goto cleanup;\n    }\n\n    /* Create HostPortGroup(s) */\n    for (i = 0; i < def->nPortGroups; ++i) {\n        esxVI_HostPortGroupSpec_Free(&hostPortGroupSpec);\n\n        if (esxVI_HostPortGroupSpec_Alloc(&hostPortGroupSpec) < 0 ||\n            esxVI_HostNetworkPolicy_Alloc(&hostPortGroupSpec->policy) < 0 ||\n            esxVI_Int_Alloc(&hostPortGroupSpec->vlanId) < 0) {\n            goto cleanup;\n        }\n\n        hostPortGroupSpec->name = g_strdup(def->portGroups[i].name);\n        hostPortGroupSpec->vswitchName = g_strdup(def->name);\n\n        hostPortGroupSpec->vlanId->value = 0;\n\n        if (def->portGroups[i].bandwidth) {\n            if (esxBandwidthToShapingPolicy\n                  (def->portGroups[i].bandwidth,\n                   &hostPortGroupSpec->policy->shapingPolicy) < 0) {\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_AddPortGroup\n              (priv->primary,\n               priv->primary->hostSystem->configManager->networkSystem,\n               hostPortGroupSpec) < 0) {\n            goto cleanup;\n        }\n    }\n\n    /* Lookup created HostVirtualSwitch to get the UUID */\n    if (esxVI_LookupHostVirtualSwitchByName(priv->primary, def->name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        goto cleanup;\n\n    network = virGetNetwork(conn, hostVirtualSwitch->name, md5);\n\n cleanup:\n    virNetworkDefFree(def);\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n    esxVI_HostPortGroup_Free(&hostPortGroupList);\n    esxVI_HostVirtualSwitchSpec_Free(&hostVirtualSwitchSpec);\n    esxVI_PhysicalNic_Free(&physicalNicList);\n    esxVI_HostPortGroupSpec_Free(&hostPortGroupSpec);\n\n    return network;\n}"
  },
  {
    "function_name": "esxBandwidthToShapingPolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "214-272",
    "snippet": "static int\nesxBandwidthToShapingPolicy(virNetDevBandwidthPtr bandwidth,\n                            esxVI_HostNetworkTrafficShapingPolicy **shapingPolicy)\n{\n    int result = -1;\n\n    ESX_VI_CHECK_ARG_LIST(shapingPolicy);\n\n    if (!bandwidth->in || !bandwidth->out ||\n        bandwidth->in->average != bandwidth->out->average ||\n        bandwidth->in->peak != bandwidth->out->peak ||\n        bandwidth->in->burst != bandwidth->out->burst) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different inbound and outbound bandwidth is unsupported\"));\n        return -1;\n    }\n\n    if (bandwidth->in->average == 0 && bandwidth->in->peak == 0 &&\n        bandwidth->in->burst == 0) {\n        return 0;\n    }\n\n    if (esxVI_HostNetworkTrafficShapingPolicy_Alloc(shapingPolicy) < 0)\n        goto cleanup;\n\n    (*shapingPolicy)->enabled = esxVI_Boolean_True;\n\n    if (bandwidth->in->average > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->averageBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->averageBandwidth->value = bandwidth->in->average * 8 * 1000;\n    }\n\n    if (bandwidth->in->peak > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->peakBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->peakBandwidth->value = bandwidth->in->peak * 8 * 1000;\n    }\n\n    if (bandwidth->in->burst > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->burstSize) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes to bytes */\n        (*shapingPolicy)->burstSize->value = bandwidth->in->burst * 1024;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_HostNetworkTrafficShapingPolicy_Free(shapingPolicy);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostNetworkTrafficShapingPolicy_Free",
          "args": [
            "shapingPolicy"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&(*shapingPolicy)->burstSize"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&(*shapingPolicy)->peakBandwidth"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&(*shapingPolicy)->averageBandwidth"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostNetworkTrafficShapingPolicy_Alloc",
          "args": [
            "shapingPolicy"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Different inbound and outbound bandwidth is unsupported\")"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Different inbound and outbound bandwidth is unsupported\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "shapingPolicy"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxBandwidthToShapingPolicy(virNetDevBandwidthPtr bandwidth,\n                            esxVI_HostNetworkTrafficShapingPolicy **shapingPolicy)\n{\n    int result = -1;\n\n    ESX_VI_CHECK_ARG_LIST(shapingPolicy);\n\n    if (!bandwidth->in || !bandwidth->out ||\n        bandwidth->in->average != bandwidth->out->average ||\n        bandwidth->in->peak != bandwidth->out->peak ||\n        bandwidth->in->burst != bandwidth->out->burst) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different inbound and outbound bandwidth is unsupported\"));\n        return -1;\n    }\n\n    if (bandwidth->in->average == 0 && bandwidth->in->peak == 0 &&\n        bandwidth->in->burst == 0) {\n        return 0;\n    }\n\n    if (esxVI_HostNetworkTrafficShapingPolicy_Alloc(shapingPolicy) < 0)\n        goto cleanup;\n\n    (*shapingPolicy)->enabled = esxVI_Boolean_True;\n\n    if (bandwidth->in->average > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->averageBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->averageBandwidth->value = bandwidth->in->average * 8 * 1000;\n    }\n\n    if (bandwidth->in->peak > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->peakBandwidth) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes per second to bits per second */\n        (*shapingPolicy)->peakBandwidth->value = bandwidth->in->peak * 8 * 1000;\n    }\n\n    if (bandwidth->in->burst > 0) {\n        if (esxVI_Long_Alloc(&(*shapingPolicy)->burstSize) < 0)\n            goto cleanup;\n\n        /* Scale kilobytes to bytes */\n        (*shapingPolicy)->burstSize->value = bandwidth->in->burst * 1024;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_HostNetworkTrafficShapingPolicy_Free(shapingPolicy);\n\n    return result;\n}"
  },
  {
    "function_name": "esxNetworkLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "191-210",
    "snippet": "static virNetworkPtr\nesxNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchByName(priv->primary, name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    network = virtualswitchToNetwork(conn, hostVirtualSwitch);\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n\n    return network;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitch"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualswitchToNetwork",
          "args": [
            "conn",
            "hostVirtualSwitch"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virtualswitchToNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
          "lines": "169-187",
          "snippet": "static virNetworkPtr\nvirtualswitchToNetwork(virConnectPtr conn,\n                       esxVI_HostVirtualSwitch *hostVirtualSwitch)\n{\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    /*\n     * HostVirtualSwitch doesn't have a UUID, but we can use the key property\n     * as source for a UUID. The key is unique per host and cannot change\n     * during the lifetime of the HostVirtualSwitch.\n     *\n     * The MD5 sum of the key can be used as UUID, assuming MD5 is considered\n     * to be collision-free enough for this use case.\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        return NULL;\n\n    return virGetNetwork(conn, hostVirtualSwitch->name, md5);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_private.h\"",
            "#include \"network_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr\nvirtualswitchToNetwork(virConnectPtr conn,\n                       esxVI_HostVirtualSwitch *hostVirtualSwitch)\n{\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    /*\n     * HostVirtualSwitch doesn't have a UUID, but we can use the key property\n     * as source for a UUID. The key is unique per host and cannot change\n     * during the lifetime of the HostVirtualSwitch.\n     *\n     * The MD5 sum of the key can be used as UUID, assuming MD5 is considered\n     * to be collision-free enough for this use case.\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        return NULL;\n\n    return virGetNetwork(conn, hostVirtualSwitch->name, md5);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchByName",
          "args": [
            "priv->primary",
            "name",
            "&hostVirtualSwitch",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4022-4066",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr\nesxNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchByName(priv->primary, name,\n                                            &hostVirtualSwitch,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    network = virtualswitchToNetwork(conn, hostVirtualSwitch);\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitch);\n\n    return network;\n}"
  },
  {
    "function_name": "virtualswitchToNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "169-187",
    "snippet": "static virNetworkPtr\nvirtualswitchToNetwork(virConnectPtr conn,\n                       esxVI_HostVirtualSwitch *hostVirtualSwitch)\n{\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    /*\n     * HostVirtualSwitch doesn't have a UUID, but we can use the key property\n     * as source for a UUID. The key is unique per host and cannot change\n     * during the lifetime of the HostVirtualSwitch.\n     *\n     * The MD5 sum of the key can be used as UUID, assuming MD5 is considered\n     * to be collision-free enough for this use case.\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        return NULL;\n\n    return virGetNetwork(conn, hostVirtualSwitch->name, md5);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "hostVirtualSwitch->name",
            "md5"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostVirtualSwitch->key",
            "md5"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr\nvirtualswitchToNetwork(virConnectPtr conn,\n                       esxVI_HostVirtualSwitch *hostVirtualSwitch)\n{\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n\n    /*\n     * HostVirtualSwitch doesn't have a UUID, but we can use the key property\n     * as source for a UUID. The key is unique per host and cannot change\n     * during the lifetime of the HostVirtualSwitch.\n     *\n     * The MD5 sum of the key can be used as UUID, assuming MD5 is considered\n     * to be collision-free enough for this use case.\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n        return NULL;\n\n    return virGetNetwork(conn, hostVirtualSwitch->name, md5);\n}"
  },
  {
    "function_name": "esxNetworkLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "124-165",
    "snippet": "static virNetworkPtr\nesxNetworkLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return NULL;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!hostVirtualSwitch) {\n        virUUIDFormat(uuid, uuid_string);\n\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with UUID '%s'\"),\n                       uuid_string);\n\n        goto cleanup;\n    }\n\n    network = virGetNetwork(conn, hostVirtualSwitch->name, uuid);\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return network;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitchList"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "hostVirtualSwitch->name",
            "uuid"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "_(\"Could not find HostVirtualSwitch with UUID '%s'\")",
            "uuid_string"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find HostVirtualSwitch with UUID '%s'\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuid_string"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "md5",
            "VIR_UUID_BUFLEN"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostVirtualSwitch->key",
            "md5"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchList",
          "args": [
            "priv->primary",
            "&hostVirtualSwitchList"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3981-4018",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr\nesxNetworkLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    virNetworkPtr network = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5]; /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return NULL;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostVirtualSwitch->key, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!hostVirtualSwitch) {\n        virUUIDFormat(uuid, uuid_string);\n\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with UUID '%s'\"),\n                       uuid_string);\n\n        goto cleanup;\n    }\n\n    network = virGetNetwork(conn, hostVirtualSwitch->name, uuid);\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return network;\n}"
  },
  {
    "function_name": "esxConnectListDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "113-120",
    "snippet": "static int\nesxConnectListDefinedNetworks(virConnectPtr conn G_GNUC_UNUSED,\n                              char **const names G_GNUC_UNUSED,\n                              int maxnames G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListDefinedNetworks(virConnectPtr conn G_GNUC_UNUSED,\n                              char **const names G_GNUC_UNUSED,\n                              int maxnames G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectNumOfDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "104-109",
    "snippet": "static int\nesxConnectNumOfDefinedNetworks(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfDefinedNetworks(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX networks are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectListNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "73-100",
    "snippet": "static int\nesxConnectListNetworks(virConnectPtr conn, char **const names, int maxnames)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return -1;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        names[count] = g_strdup(hostVirtualSwitch->name);\n\n        ++count;\n    }\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitchList"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hostVirtualSwitch->name"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchList",
          "args": [
            "priv->primary",
            "&hostVirtualSwitchList"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3981-4018",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListNetworks(virConnectPtr conn, char **const names, int maxnames)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return -1;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        names[count] = g_strdup(hostVirtualSwitch->name);\n\n        ++count;\n    }\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxConnectNumOfNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_network_driver.c",
    "lines": "47-69",
    "snippet": "static int\nesxConnectNumOfNetworks(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return -1;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        ++count;\n    }\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"network_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitchList"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchList",
          "args": [
            "priv->primary",
            "&hostVirtualSwitchList"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3981-4018",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_private.h\"\n#include \"network_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfNetworks(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *hostVirtualSwitch = NULL;\n    int count = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupHostVirtualSwitchList(priv->primary,\n                                          &hostVirtualSwitchList) < 0) {\n        return -1;\n    }\n\n    for (hostVirtualSwitch = hostVirtualSwitchList; hostVirtualSwitch;\n         hostVirtualSwitch = hostVirtualSwitch->_next) {\n        ++count;\n    }\n\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return count;\n}"
  }
]