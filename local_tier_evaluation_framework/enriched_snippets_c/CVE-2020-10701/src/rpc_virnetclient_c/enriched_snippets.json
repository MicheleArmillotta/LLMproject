[
  {
    "function_name": "virNetClientSendStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2188-2219",
    "snippet": "int virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamCheckSendStatus",
          "args": [
            "st",
            "msg"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamCheckSendStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "219-247",
          "snippet": "int virNetClientStreamCheckSendStatus(virNetClientStreamPtr st,\n                                      virNetMessagePtr msg)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    /* We can not check if the message is dummy in a usual way\n     * by checking msg->bufferLength because at this point message payload\n     * is cleared. As caller must not call this function for messages\n     * not expecting reply we can check for dummy messages just by status.\n     */\n    if (msg->header.status == VIR_NET_CONTINUE) {\n        if (st->closed) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"stream is closed\"));\n            return -1;\n        }\n        return 0;\n    } else if (msg->header.status == VIR_NET_OK &&\n               st->closed != VIR_NET_CLIENT_STREAM_CLOSED_FINISHED) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream aborted by another thread\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckSendStatus(virNetClientStreamPtr st,\n                                      virNetMessagePtr msg)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    /* We can not check if the message is dummy in a usual way\n     * by checking msg->bufferLength because at this point message payload\n     * is cleared. As caller must not call this function for messages\n     * not expecting reply we can check for dummy messages just by status.\n     */\n    if (msg->header.status == VIR_NET_CONTINUE) {\n        if (st->closed) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"stream is closed\"));\n            return -1;\n        }\n        return 0;\n    } else if (msg->header.status == VIR_NET_OK &&\n               st->closed != VIR_NET_CLIENT_STREAM_CLOSED_FINISHED) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream aborted by another thread\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendInternal",
          "args": [
            "client",
            "msg",
            "expectReply",
            "false"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2096-2130",
          "snippet": "static int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEOF",
          "args": [
            "st"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEOF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "805-808",
          "snippet": "bool virNetClientStreamEOF(virNetClientStreamPtr st)\n{\n    return st->incomingEOF;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nbool virNetClientStreamEOF(virNetClientStreamPtr st)\n{\n    return st->incomingEOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamCheckState",
          "args": [
            "st"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamCheckState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "200-214",
          "snippet": "int virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientSendNonBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2167-2175",
    "snippet": "int virNetClientSendNonBlock(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, false, true);\n    virObjectUnlock(client);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendInternal",
          "args": [
            "client",
            "msg",
            "false",
            "true"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2096-2130",
          "snippet": "static int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendNonBlock(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, false, true);\n    virObjectUnlock(client);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientSendWithReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2143-2153",
    "snippet": "int virNetClientSendWithReply(virNetClientPtr client,\n                              virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, true, false);\n    virObjectUnlock(client);\n    if (ret < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendInternal",
          "args": [
            "client",
            "msg",
            "true",
            "false"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2096-2130",
          "snippet": "static int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendWithReply(virNetClientPtr client,\n                              virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, true, false);\n    virObjectUnlock(client);\n    if (ret < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientSendInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2096-2130",
    "snippet": "static int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&call->cond"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIO",
          "args": [
            "client",
            "call"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1867-1958",
          "snippet": "static int virNetClientIO(virNetClientPtr client,\n                          virNetClientCallPtr thiscall)\n{\n    int rv = -1;\n\n    VIR_DEBUG(\"Outgoing message prog=%u version=%u serial=%u proc=%d type=%d length=%zu dispatch=%p\",\n              thiscall->msg->header.prog,\n              thiscall->msg->header.vers,\n              thiscall->msg->header.serial,\n              thiscall->msg->header.proc,\n              thiscall->msg->header.type,\n              thiscall->msg->bufferLength,\n              client->waitDispatch);\n\n    /* Stick ourselves on the end of the wait queue */\n    virNetClientCallQueue(&client->waitDispatch, thiscall);\n\n    /* Check to see if another thread is dispatching */\n    if (client->haveTheBuck) {\n        /* Force other thread to wakeup from poll */\n        g_main_loop_quit(client->eventLoop);\n\n        /* If we are non-blocking, detach the thread and keep the call in the\n         * queue. */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            rv = 1;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Going to sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Go to sleep while other thread is working... */\n        if (virCondWait(&thiscall->cond, &client->parent.lock) < 0) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to wait on condition\"));\n            return -1;\n        }\n\n        VIR_DEBUG(\"Woken up from sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Three reasons we can be woken up\n         *  1. Other thread has got our reply ready for us\n         *  2. Other thread is all done, and it is our turn to\n         *     be the dispatcher to finish waiting for\n         *     our reply\n         */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            rv = 0;\n            /*\n             * We avoided catching the buck and our reply is ready !\n             * We've already had 'thiscall' removed from the list\n             * so just need to (maybe) handle errors & free it\n             */\n            goto cleanup;\n        }\n\n        /* Grr, someone passed the buck to us ... */\n    } else {\n        client->haveTheBuck = true;\n    }\n\n    VIR_DEBUG(\"We have the buck head=%p call=%p\",\n              client->waitDispatch, thiscall);\n\n    /*\n     * The buck stops here!\n     *\n     * At this point we're about to own the dispatch\n     * process...\n     */\n\n    /*\n     * Avoid needless wake-ups of the event loop in the\n     * case where this call is being made from a different\n     * thread than the event loop. These wake-ups would\n     * cause the event loop thread to be blocked on the\n     * mutex for the duration of the call\n     */\n    virNetClientIOUpdateCallback(client, false);\n\n    rv = virNetClientIOEventLoop(client, thiscall);\n\n    if (client->sock)\n        virNetClientIOUpdateCallback(client, true);\n\n cleanup:\n    VIR_DEBUG(\"All done with our call head=%p call=%p rv=%d\",\n              client->waitDispatch, thiscall, rv);\n    return rv;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientIO(virNetClientPtr client,\n                          virNetClientCallPtr thiscall)\n{\n    int rv = -1;\n\n    VIR_DEBUG(\"Outgoing message prog=%u version=%u serial=%u proc=%d type=%d length=%zu dispatch=%p\",\n              thiscall->msg->header.prog,\n              thiscall->msg->header.vers,\n              thiscall->msg->header.serial,\n              thiscall->msg->header.proc,\n              thiscall->msg->header.type,\n              thiscall->msg->bufferLength,\n              client->waitDispatch);\n\n    /* Stick ourselves on the end of the wait queue */\n    virNetClientCallQueue(&client->waitDispatch, thiscall);\n\n    /* Check to see if another thread is dispatching */\n    if (client->haveTheBuck) {\n        /* Force other thread to wakeup from poll */\n        g_main_loop_quit(client->eventLoop);\n\n        /* If we are non-blocking, detach the thread and keep the call in the\n         * queue. */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            rv = 1;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Going to sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Go to sleep while other thread is working... */\n        if (virCondWait(&thiscall->cond, &client->parent.lock) < 0) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to wait on condition\"));\n            return -1;\n        }\n\n        VIR_DEBUG(\"Woken up from sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Three reasons we can be woken up\n         *  1. Other thread has got our reply ready for us\n         *  2. Other thread is all done, and it is our turn to\n         *     be the dispatcher to finish waiting for\n         *     our reply\n         */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            rv = 0;\n            /*\n             * We avoided catching the buck and our reply is ready !\n             * We've already had 'thiscall' removed from the list\n             * so just need to (maybe) handle errors & free it\n             */\n            goto cleanup;\n        }\n\n        /* Grr, someone passed the buck to us ... */\n    } else {\n        client->haveTheBuck = true;\n    }\n\n    VIR_DEBUG(\"We have the buck head=%p call=%p\",\n              client->waitDispatch, thiscall);\n\n    /*\n     * The buck stops here!\n     *\n     * At this point we're about to own the dispatch\n     * process...\n     */\n\n    /*\n     * Avoid needless wake-ups of the event loop in the\n     * case where this call is being made from a different\n     * thread than the event loop. These wake-ups would\n     * cause the event loop thread to be blocked on the\n     * mutex for the duration of the call\n     */\n    virNetClientIOUpdateCallback(client, false);\n\n    rv = virNetClientIOEventLoop(client, thiscall);\n\n    if (client->sock)\n        virNetClientIOUpdateCallback(client, true);\n\n cleanup:\n    VIR_DEBUG(\"All done with our call head=%p call=%p rv=%d\",\n              client->waitDispatch, thiscall, rv);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallNew",
          "args": [
            "msg",
            "expectReply",
            "nonBlock"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2019-2068",
          "snippet": "static virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"client socket is closed\")"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"client socket is closed\""
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_CLIENT_MSG_TX_QUEUE",
            "\"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\"",
            "client",
            "msg->bufferLength",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.proc",
            "msg->header.type",
            "msg->header.status",
            "msg->header.serial"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientSendInternal(virNetClientPtr client,\n                                    virNetMessagePtr msg,\n                                    bool expectReply,\n                                    bool nonBlock)\n{\n    virNetClientCallPtr call;\n    int ret = -1;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!client->sock || client->wantClose) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"client socket is closed\"));\n        return -1;\n    }\n\n    if (!(call = virNetClientCallNew(msg, expectReply, nonBlock)))\n        return -1;\n\n    call->haveThread = true;\n    ret = virNetClientIO(client, call);\n\n    /* If queued, the call will be finished and freed later by another thread;\n     * we're done. */\n    if (ret == 1)\n        return 1;\n\n    virCondDestroy(&call->cond);\n    VIR_FREE(call);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientQueueNonBlocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2071-2089",
    "snippet": "static int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientCallQueue",
          "args": [
            "&client->waitDispatch",
            "call"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "152-163",
          "snippet": "static void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallNew",
          "args": [
            "msg",
            "false",
            "true"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2019-2068",
          "snippet": "static virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_CLIENT_MSG_TX_QUEUE",
            "\"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\"",
            "client",
            "msg->bufferLength",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.proc",
            "msg->header.type",
            "msg->header.status",
            "msg->header.serial"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientCallNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "2019-2068",
    "snippet": "static virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\"",
            "call",
            "msg",
            "expectReply",
            "nonBlock"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot initialize condition variable\")"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot initialize condition variable\""
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&call->cond"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "call"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\")"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\")"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic virNetClientCallPtr\nvirNetClientCallNew(virNetMessagePtr msg,\n                    bool expectReply,\n                    bool nonBlock)\n{\n    virNetClientCallPtr call = NULL;\n\n    if (expectReply &&\n        (msg->bufferLength != 0) &&\n        (msg->header.status == VIR_NET_CONTINUE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send an asynchronous message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (expectReply && nonBlock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to send a non-blocking message with\"\n                         \" a synchronous reply\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC(call) < 0)\n        goto error;\n\n    if (virCondInit(&call->cond) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize condition variable\"));\n        goto error;\n    }\n\n    msg->donefds = 0;\n    if (msg->bufferLength)\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_TX;\n    else\n        call->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n    call->msg = msg;\n    call->expectReply = expectReply;\n    call->nonBlock = nonBlock;\n\n    VIR_DEBUG(\"New call %p: msg=%p, expectReply=%d, nonBlock=%d\",\n              call, msg, expectReply, nonBlock);\n\n    return call;\n\n error:\n    VIR_FREE(call);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetClientIncomingEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1961-2016",
    "snippet": "void virNetClientIncomingEvent(virNetSocketPtr sock,\n                               int events,\n                               void *opaque)\n{\n    virNetClientPtr client = opaque;\n    int closeReason;\n\n    virObjectLock(client);\n\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client->sock)\n        goto done;\n\n    if (client->haveTheBuck || client->wantClose)\n        goto done;\n\n    VIR_DEBUG(\"Event fired %p %d\", sock, events);\n\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n    else\n        closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n    if (events & VIR_EVENT_HANDLE_WRITABLE) {\n        if (virNetClientIOHandleOutput(client) < 0)\n            virNetClientMarkClose(client, closeReason);\n    }\n\n    if (events & VIR_EVENT_HANDLE_READABLE) {\n        if (virNetClientIOHandleInput(client) < 0)\n            virNetClientMarkClose(client, closeReason);\n    }\n\n    if (events & (VIR_EVENT_HANDLE_HANGUP | VIR_EVENT_HANDLE_ERROR)) {\n        VIR_DEBUG(\"VIR_EVENT_HANDLE_HANGUP or \"\n                  \"VIR_EVENT_HANDLE_ERROR encountered\");\n        virNetClientMarkClose(client, closeReason);\n        goto done;\n    }\n\n    /* Remove completed calls or signal their threads. */\n    virNetClientCallRemovePredicate(&client->waitDispatch,\n                                    virNetClientIOEventLoopRemoveDone,\n                                    NULL);\n    virNetClientIOUpdateCallback(client, true);\n\n done:\n    if (client->wantClose && !client->haveTheBuck) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        NULL);\n    }\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallRemovePredicate",
          "args": [
            "&client->waitDispatch",
            "virNetClientIOEventLoopRemoveAll",
            "NULL"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallRemovePredicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "203-223",
          "snippet": "static void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCloseLocked",
          "args": [
            "client"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCloseLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "727-769",
          "snippet": "static void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOUpdateCallback",
          "args": [
            "client",
            "true"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOUpdateCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1791-1807",
          "snippet": "static void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientMarkClose",
          "args": [
            "client",
            "closeReason"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientMarkClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "708-724",
          "snippet": "static void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VIR_EVENT_HANDLE_HANGUP or \"\n                  \"VIR_EVENT_HANDLE_ERROR encountered\""
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientIOHandleInput",
          "args": [
            "client"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOHandleInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1391-1476",
          "snippet": "static ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOHandleOutput",
          "args": [
            "client"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOHandleOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1335-1362",
          "snippet": "static ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Event fired %p %d\"",
            "sock",
            "events"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p wantclose=%d\"",
            "client",
            "client ? client->wantClose : false"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nvoid virNetClientIncomingEvent(virNetSocketPtr sock,\n                               int events,\n                               void *opaque)\n{\n    virNetClientPtr client = opaque;\n    int closeReason;\n\n    virObjectLock(client);\n\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client->sock)\n        goto done;\n\n    if (client->haveTheBuck || client->wantClose)\n        goto done;\n\n    VIR_DEBUG(\"Event fired %p %d\", sock, events);\n\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n    else\n        closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n    if (events & VIR_EVENT_HANDLE_WRITABLE) {\n        if (virNetClientIOHandleOutput(client) < 0)\n            virNetClientMarkClose(client, closeReason);\n    }\n\n    if (events & VIR_EVENT_HANDLE_READABLE) {\n        if (virNetClientIOHandleInput(client) < 0)\n            virNetClientMarkClose(client, closeReason);\n    }\n\n    if (events & (VIR_EVENT_HANDLE_HANGUP | VIR_EVENT_HANDLE_ERROR)) {\n        VIR_DEBUG(\"VIR_EVENT_HANDLE_HANGUP or \"\n                  \"VIR_EVENT_HANDLE_ERROR encountered\");\n        virNetClientMarkClose(client, closeReason);\n        goto done;\n    }\n\n    /* Remove completed calls or signal their threads. */\n    virNetClientCallRemovePredicate(&client->waitDispatch,\n                                    virNetClientIOEventLoopRemoveDone,\n                                    NULL);\n    virNetClientIOUpdateCallback(client, true);\n\n done:\n    if (client->wantClose && !client->haveTheBuck) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        NULL);\n    }\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1867-1958",
    "snippet": "static int virNetClientIO(virNetClientPtr client,\n                          virNetClientCallPtr thiscall)\n{\n    int rv = -1;\n\n    VIR_DEBUG(\"Outgoing message prog=%u version=%u serial=%u proc=%d type=%d length=%zu dispatch=%p\",\n              thiscall->msg->header.prog,\n              thiscall->msg->header.vers,\n              thiscall->msg->header.serial,\n              thiscall->msg->header.proc,\n              thiscall->msg->header.type,\n              thiscall->msg->bufferLength,\n              client->waitDispatch);\n\n    /* Stick ourselves on the end of the wait queue */\n    virNetClientCallQueue(&client->waitDispatch, thiscall);\n\n    /* Check to see if another thread is dispatching */\n    if (client->haveTheBuck) {\n        /* Force other thread to wakeup from poll */\n        g_main_loop_quit(client->eventLoop);\n\n        /* If we are non-blocking, detach the thread and keep the call in the\n         * queue. */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            rv = 1;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Going to sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Go to sleep while other thread is working... */\n        if (virCondWait(&thiscall->cond, &client->parent.lock) < 0) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to wait on condition\"));\n            return -1;\n        }\n\n        VIR_DEBUG(\"Woken up from sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Three reasons we can be woken up\n         *  1. Other thread has got our reply ready for us\n         *  2. Other thread is all done, and it is our turn to\n         *     be the dispatcher to finish waiting for\n         *     our reply\n         */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            rv = 0;\n            /*\n             * We avoided catching the buck and our reply is ready !\n             * We've already had 'thiscall' removed from the list\n             * so just need to (maybe) handle errors & free it\n             */\n            goto cleanup;\n        }\n\n        /* Grr, someone passed the buck to us ... */\n    } else {\n        client->haveTheBuck = true;\n    }\n\n    VIR_DEBUG(\"We have the buck head=%p call=%p\",\n              client->waitDispatch, thiscall);\n\n    /*\n     * The buck stops here!\n     *\n     * At this point we're about to own the dispatch\n     * process...\n     */\n\n    /*\n     * Avoid needless wake-ups of the event loop in the\n     * case where this call is being made from a different\n     * thread than the event loop. These wake-ups would\n     * cause the event loop thread to be blocked on the\n     * mutex for the duration of the call\n     */\n    virNetClientIOUpdateCallback(client, false);\n\n    rv = virNetClientIOEventLoop(client, thiscall);\n\n    if (client->sock)\n        virNetClientIOUpdateCallback(client, true);\n\n cleanup:\n    VIR_DEBUG(\"All done with our call head=%p call=%p rv=%d\",\n              client->waitDispatch, thiscall, rv);\n    return rv;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"All done with our call head=%p call=%p rv=%d\"",
            "client->waitDispatch",
            "thiscall",
            "rv"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientIOUpdateCallback",
          "args": [
            "client",
            "true"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOUpdateCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1791-1807",
          "snippet": "static void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOEventLoop",
          "args": [
            "client",
            "thiscall"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOEventLoop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1608-1775",
          "snippet": "static int virNetClientIOEventLoop(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    bool error = false;\n    int closeReason;\n\n    for (;;) {\n#ifndef WIN32\n        sigset_t oldmask, blockedsigs;\n#endif /* !WIN32 */\n        int timeout = -1;\n        virNetMessagePtr msg = NULL;\n        GIOCondition ev = 0;\n        struct virNetClientIOEventData data = {\n            .client = client,\n            .rev = 0,\n        };\n\n        /* If we have existing SASL decoded data we don't want to sleep in\n         * the poll(), just check if any other FDs are also ready.\n         * If the connection is going to be closed, we don't want to sleep in\n         * poll() either.\n         */\n        if (virNetSocketHasCachedData(client->sock) || client->wantClose)\n            timeout = 0;\n\n        /* If we are non-blocking, then we don't want to sleep in poll() */\n        if (thiscall->nonBlock)\n            timeout = 0;\n\n        /* Limit timeout so that we can send keepalive request in time */\n        if (timeout == -1)\n            timeout = virKeepAliveTimeout(client->keepalive);\n\n        /* Calculate poll events for calls */\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOEventLoopPollEvents,\n                                       &ev);\n\n        /* We have to be prepared to receive stream data\n         * regardless of whether any of the calls waiting\n         * for dispatch are for streams.\n         */\n        if (client->nstreams)\n            ev |= G_IO_IN;\n\n        virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                                   ev,\n                                   client->eventCtx,\n                                   virNetClientIOEventFD, &data, NULL);\n\n        /* Release lock while poll'ing so other threads\n         * can stuff themselves on the queue */\n        virObjectUnlock(client);\n\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n        sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n        sigaddset(&blockedsigs, SIGCHLD);\n# endif\n        sigaddset(&blockedsigs, SIGPIPE);\n\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n        virObjectLock(client);\n\n        if (virKeepAliveTrigger(client->keepalive, &msg)) {\n            virNetClientMarkClose(client, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n        } else if (msg && virNetClientQueueNonBlocking(client, msg) < 0) {\n            VIR_WARN(\"Could not queue keepalive request\");\n            virNetMessageFree(msg);\n        }\n\n        /* If we have existing SASL decoded data, pretend\n         * the socket became readable so we consume it\n         */\n        if (virNetSocketHasCachedData(client->sock))\n            data.rev |= G_IO_IN;\n\n        /* If wantClose flag is set, pretend there was an error on the socket,\n         * but still read and process any data we received so far.\n         */\n        if (client->wantClose)\n            error = true;\n\n        if (data.rev & G_IO_HUP)\n            closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n        else\n            closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n        if (data.rev & G_IO_OUT) {\n            if (virNetClientIOHandleOutput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        if (data.rev & G_IO_IN) {\n            if (virNetClientIOHandleInput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        /* Iterate through waiting calls and if any are\n         * complete, remove them from the dispatch list.\n         */\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveDone,\n                                        thiscall);\n\n        /* Now see if *we* are done */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 0;\n        }\n\n        /* We're not done, but we're non-blocking; keep the call queued */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 1;\n        }\n\n        if (error)\n            goto error;\n\n        if (data.rev & G_IO_HUP) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received hangup event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n        if (data.rev & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received error event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n    }\n\n error:\n    if (client->error) {\n        VIR_DEBUG(\"error on socket: %s\", client->error->message);\n        virSetError(client->error);\n    }\n    virNetClientCallRemove(&client->waitDispatch, thiscall);\n    virNetClientIOEventLoopPassTheBuck(client, thiscall);\n    return -1;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientIOEventLoop(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    bool error = false;\n    int closeReason;\n\n    for (;;) {\n#ifndef WIN32\n        sigset_t oldmask, blockedsigs;\n#endif /* !WIN32 */\n        int timeout = -1;\n        virNetMessagePtr msg = NULL;\n        GIOCondition ev = 0;\n        struct virNetClientIOEventData data = {\n            .client = client,\n            .rev = 0,\n        };\n\n        /* If we have existing SASL decoded data we don't want to sleep in\n         * the poll(), just check if any other FDs are also ready.\n         * If the connection is going to be closed, we don't want to sleep in\n         * poll() either.\n         */\n        if (virNetSocketHasCachedData(client->sock) || client->wantClose)\n            timeout = 0;\n\n        /* If we are non-blocking, then we don't want to sleep in poll() */\n        if (thiscall->nonBlock)\n            timeout = 0;\n\n        /* Limit timeout so that we can send keepalive request in time */\n        if (timeout == -1)\n            timeout = virKeepAliveTimeout(client->keepalive);\n\n        /* Calculate poll events for calls */\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOEventLoopPollEvents,\n                                       &ev);\n\n        /* We have to be prepared to receive stream data\n         * regardless of whether any of the calls waiting\n         * for dispatch are for streams.\n         */\n        if (client->nstreams)\n            ev |= G_IO_IN;\n\n        virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                                   ev,\n                                   client->eventCtx,\n                                   virNetClientIOEventFD, &data, NULL);\n\n        /* Release lock while poll'ing so other threads\n         * can stuff themselves on the queue */\n        virObjectUnlock(client);\n\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n        sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n        sigaddset(&blockedsigs, SIGCHLD);\n# endif\n        sigaddset(&blockedsigs, SIGPIPE);\n\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n        virObjectLock(client);\n\n        if (virKeepAliveTrigger(client->keepalive, &msg)) {\n            virNetClientMarkClose(client, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n        } else if (msg && virNetClientQueueNonBlocking(client, msg) < 0) {\n            VIR_WARN(\"Could not queue keepalive request\");\n            virNetMessageFree(msg);\n        }\n\n        /* If we have existing SASL decoded data, pretend\n         * the socket became readable so we consume it\n         */\n        if (virNetSocketHasCachedData(client->sock))\n            data.rev |= G_IO_IN;\n\n        /* If wantClose flag is set, pretend there was an error on the socket,\n         * but still read and process any data we received so far.\n         */\n        if (client->wantClose)\n            error = true;\n\n        if (data.rev & G_IO_HUP)\n            closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n        else\n            closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n        if (data.rev & G_IO_OUT) {\n            if (virNetClientIOHandleOutput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        if (data.rev & G_IO_IN) {\n            if (virNetClientIOHandleInput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        /* Iterate through waiting calls and if any are\n         * complete, remove them from the dispatch list.\n         */\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveDone,\n                                        thiscall);\n\n        /* Now see if *we* are done */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 0;\n        }\n\n        /* We're not done, but we're non-blocking; keep the call queued */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 1;\n        }\n\n        if (error)\n            goto error;\n\n        if (data.rev & G_IO_HUP) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received hangup event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n        if (data.rev & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received error event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n    }\n\n error:\n    if (client->error) {\n        VIR_DEBUG(\"error on socket: %s\", client->error->message);\n        virSetError(client->error);\n    }\n    virNetClientCallRemove(&client->waitDispatch, thiscall);\n    virNetClientIOEventLoopPassTheBuck(client, thiscall);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"We have the buck head=%p call=%p\"",
            "client->waitDispatch",
            "thiscall"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Woken up from sleep head=%p call=%p\"",
            "client->waitDispatch",
            "thiscall"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to wait on condition\")"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to wait on condition\""
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallRemove",
          "args": [
            "&client->waitDispatch",
            "thiscall"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "180-197",
          "snippet": "static void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "&thiscall->cond",
            "&client->parent.lock"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Going to sleep head=%p call=%p\"",
            "client->waitDispatch",
            "thiscall"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientIODetachNonBlocking",
          "args": [
            "thiscall"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIODetachNonBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1530-1535",
          "snippet": "static void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "client->eventLoop"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientCallQueue",
          "args": [
            "&client->waitDispatch",
            "thiscall"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "152-163",
          "snippet": "static void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outgoing message prog=%u version=%u serial=%u proc=%d type=%d length=%zu dispatch=%p\"",
            "thiscall->msg->header.prog",
            "thiscall->msg->header.vers",
            "thiscall->msg->header.serial",
            "thiscall->msg->header.proc",
            "thiscall->msg->header.type",
            "thiscall->msg->bufferLength",
            "client->waitDispatch"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientIO(virNetClientPtr client,\n                          virNetClientCallPtr thiscall)\n{\n    int rv = -1;\n\n    VIR_DEBUG(\"Outgoing message prog=%u version=%u serial=%u proc=%d type=%d length=%zu dispatch=%p\",\n              thiscall->msg->header.prog,\n              thiscall->msg->header.vers,\n              thiscall->msg->header.serial,\n              thiscall->msg->header.proc,\n              thiscall->msg->header.type,\n              thiscall->msg->bufferLength,\n              client->waitDispatch);\n\n    /* Stick ourselves on the end of the wait queue */\n    virNetClientCallQueue(&client->waitDispatch, thiscall);\n\n    /* Check to see if another thread is dispatching */\n    if (client->haveTheBuck) {\n        /* Force other thread to wakeup from poll */\n        g_main_loop_quit(client->eventLoop);\n\n        /* If we are non-blocking, detach the thread and keep the call in the\n         * queue. */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            rv = 1;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Going to sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Go to sleep while other thread is working... */\n        if (virCondWait(&thiscall->cond, &client->parent.lock) < 0) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to wait on condition\"));\n            return -1;\n        }\n\n        VIR_DEBUG(\"Woken up from sleep head=%p call=%p\",\n                  client->waitDispatch, thiscall);\n        /* Three reasons we can be woken up\n         *  1. Other thread has got our reply ready for us\n         *  2. Other thread is all done, and it is our turn to\n         *     be the dispatcher to finish waiting for\n         *     our reply\n         */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            rv = 0;\n            /*\n             * We avoided catching the buck and our reply is ready !\n             * We've already had 'thiscall' removed from the list\n             * so just need to (maybe) handle errors & free it\n             */\n            goto cleanup;\n        }\n\n        /* Grr, someone passed the buck to us ... */\n    } else {\n        client->haveTheBuck = true;\n    }\n\n    VIR_DEBUG(\"We have the buck head=%p call=%p\",\n              client->waitDispatch, thiscall);\n\n    /*\n     * The buck stops here!\n     *\n     * At this point we're about to own the dispatch\n     * process...\n     */\n\n    /*\n     * Avoid needless wake-ups of the event loop in the\n     * case where this call is being made from a different\n     * thread than the event loop. These wake-ups would\n     * cause the event loop thread to be blocked on the\n     * mutex for the duration of the call\n     */\n    virNetClientIOUpdateCallback(client, false);\n\n    rv = virNetClientIOEventLoop(client, thiscall);\n\n    if (client->sock)\n        virNetClientIOUpdateCallback(client, true);\n\n cleanup:\n    VIR_DEBUG(\"All done with our call head=%p call=%p rv=%d\",\n              client->waitDispatch, thiscall, rv);\n    return rv;\n}"
  },
  {
    "function_name": "virNetClientIOUpdateCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1791-1807",
    "snippet": "static void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketUpdateIOCallback",
          "args": [
            "client->sock",
            "events"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketUpdateIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2222-2235",
          "snippet": "void virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallMatchPredicate",
          "args": [
            "client->waitDispatch",
            "virNetClientIOUpdateEvents",
            "&events"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallMatchPredicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "226-237",
          "snippet": "static bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOUpdateCallback(virNetClientPtr client,\n                                         bool enableCallback)\n{\n    int events = 0;\n\n    if (client->wantClose)\n        return;\n\n    if (enableCallback) {\n        events |= VIR_EVENT_HANDLE_READABLE;\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOUpdateEvents,\n                                       &events);\n    }\n\n    virNetSocketUpdateIOCallback(client->sock, events);\n}"
  },
  {
    "function_name": "virNetClientIOUpdateEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1778-1788",
    "snippet": "static bool\nvirNetClientIOUpdateEvents(virNetClientCallPtr call,\n                           void *opaque)\n{\n    int *events = opaque;\n\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n        *events |= VIR_EVENT_HANDLE_WRITABLE;\n\n    return false;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool\nvirNetClientIOUpdateEvents(virNetClientCallPtr call,\n                           void *opaque)\n{\n    int *events = opaque;\n\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n        *events |= VIR_EVENT_HANDLE_WRITABLE;\n\n    return false;\n}"
  },
  {
    "function_name": "virNetClientIOEventLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1608-1775",
    "snippet": "static int virNetClientIOEventLoop(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    bool error = false;\n    int closeReason;\n\n    for (;;) {\n#ifndef WIN32\n        sigset_t oldmask, blockedsigs;\n#endif /* !WIN32 */\n        int timeout = -1;\n        virNetMessagePtr msg = NULL;\n        GIOCondition ev = 0;\n        struct virNetClientIOEventData data = {\n            .client = client,\n            .rev = 0,\n        };\n\n        /* If we have existing SASL decoded data we don't want to sleep in\n         * the poll(), just check if any other FDs are also ready.\n         * If the connection is going to be closed, we don't want to sleep in\n         * poll() either.\n         */\n        if (virNetSocketHasCachedData(client->sock) || client->wantClose)\n            timeout = 0;\n\n        /* If we are non-blocking, then we don't want to sleep in poll() */\n        if (thiscall->nonBlock)\n            timeout = 0;\n\n        /* Limit timeout so that we can send keepalive request in time */\n        if (timeout == -1)\n            timeout = virKeepAliveTimeout(client->keepalive);\n\n        /* Calculate poll events for calls */\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOEventLoopPollEvents,\n                                       &ev);\n\n        /* We have to be prepared to receive stream data\n         * regardless of whether any of the calls waiting\n         * for dispatch are for streams.\n         */\n        if (client->nstreams)\n            ev |= G_IO_IN;\n\n        virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                                   ev,\n                                   client->eventCtx,\n                                   virNetClientIOEventFD, &data, NULL);\n\n        /* Release lock while poll'ing so other threads\n         * can stuff themselves on the queue */\n        virObjectUnlock(client);\n\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n        sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n        sigaddset(&blockedsigs, SIGCHLD);\n# endif\n        sigaddset(&blockedsigs, SIGPIPE);\n\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n        virObjectLock(client);\n\n        if (virKeepAliveTrigger(client->keepalive, &msg)) {\n            virNetClientMarkClose(client, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n        } else if (msg && virNetClientQueueNonBlocking(client, msg) < 0) {\n            VIR_WARN(\"Could not queue keepalive request\");\n            virNetMessageFree(msg);\n        }\n\n        /* If we have existing SASL decoded data, pretend\n         * the socket became readable so we consume it\n         */\n        if (virNetSocketHasCachedData(client->sock))\n            data.rev |= G_IO_IN;\n\n        /* If wantClose flag is set, pretend there was an error on the socket,\n         * but still read and process any data we received so far.\n         */\n        if (client->wantClose)\n            error = true;\n\n        if (data.rev & G_IO_HUP)\n            closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n        else\n            closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n        if (data.rev & G_IO_OUT) {\n            if (virNetClientIOHandleOutput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        if (data.rev & G_IO_IN) {\n            if (virNetClientIOHandleInput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        /* Iterate through waiting calls and if any are\n         * complete, remove them from the dispatch list.\n         */\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveDone,\n                                        thiscall);\n\n        /* Now see if *we* are done */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 0;\n        }\n\n        /* We're not done, but we're non-blocking; keep the call queued */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 1;\n        }\n\n        if (error)\n            goto error;\n\n        if (data.rev & G_IO_HUP) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received hangup event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n        if (data.rev & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received error event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n    }\n\n error:\n    if (client->error) {\n        VIR_DEBUG(\"error on socket: %s\", client->error->message);\n        virSetError(client->error);\n    }\n    virNetClientCallRemove(&client->waitDispatch, thiscall);\n    virNetClientIOEventLoopPassTheBuck(client, thiscall);\n    return -1;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientIOEventLoopPassTheBuck",
          "args": [
            "client",
            "thiscall"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOEventLoopPassTheBuck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1555-1580",
          "snippet": "static void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\n\nstatic void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallRemove",
          "args": [
            "&client->waitDispatch",
            "thiscall"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "180-197",
          "snippet": "static void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "client->error"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"error on socket: %s\"",
            "client->error->message"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientMarkClose",
          "args": [
            "client",
            "closeReason"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientMarkClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "708-724",
          "snippet": "static void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"received error event on socket\")"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"received error event on socket\""
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"received hangup event on socket\")"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientIODetachNonBlocking",
          "args": [
            "thiscall"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIODetachNonBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1530-1535",
          "snippet": "static void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallRemovePredicate",
          "args": [
            "&client->waitDispatch",
            "virNetClientIOEventLoopRemoveDone",
            "thiscall"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallRemovePredicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "203-223",
          "snippet": "static void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOHandleInput",
          "args": [
            "client"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOHandleInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1391-1476",
          "snippet": "static ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOHandleOutput",
          "args": [
            "client"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOHandleOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1335-1362",
          "snippet": "static ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketHasCachedData",
          "args": [
            "client->sock"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketHasCachedData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1701-1722",
          "snippet": "bool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not queue keepalive request\""
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientQueueNonBlocking",
          "args": [
            "client",
            "msg"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientQueueNonBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2071-2089",
          "snippet": "static int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveTrigger",
          "args": [
            "client->keepalive",
            "&msg"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "343-358",
          "snippet": "bool\nvirKeepAliveTrigger(virKeepAlivePtr ka,\n                    virNetMessagePtr *msg)\n{\n    bool dead;\n\n    *msg = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n    dead = virKeepAliveTimerInternal(ka, msg);\n    virObjectUnlock(ka);\n\n    return dead;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirKeepAliveTrigger(virKeepAlivePtr ka,\n                    virNetMessagePtr *msg)\n{\n    bool dead;\n\n    *msg = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n    dead = virKeepAliveTimerInternal(ka, msg);\n    virObjectUnlock(ka);\n\n    return dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_SETMASK, &oldmask, NULL)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_sigmask",
          "args": [
            "SIG_SETMASK",
            "&oldmask",
            "NULL"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_run",
          "args": [
            "client->eventLoop"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGPIPE"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGCHLD"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGWINCH"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&blockedsigs"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventGLibAddSocketWatch",
          "args": [
            "virNetSocketGetFD(client->sock)",
            "ev",
            "client->eventCtx",
            "virNetClientIOEventFD",
            "&data",
            "NULL"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibAddSocketWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglibwatch.c",
          "lines": "236-249",
          "snippet": "guint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}",
          "includes": [
            "# include <winsock2.h>",
            "#include \"vireventglibwatch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <winsock2.h>\n#include \"vireventglibwatch.h\"\n#include <config.h>\n\nguint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "client->sock"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallMatchPredicate",
          "args": [
            "client->waitDispatch",
            "virNetClientIOEventLoopPollEvents",
            "&ev"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallMatchPredicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "226-237",
          "snippet": "static bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveTimeout",
          "args": [
            "client->keepalive"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "313-340",
          "snippet": "int\nvirKeepAliveTimeout(virKeepAlivePtr ka)\n{\n    int timeout;\n\n    if (!ka)\n        return -1;\n\n    virObjectLock(ka);\n\n    if (ka->interval <= 0 || ka->intervalStart == 0) {\n        timeout = -1;\n    } else {\n        timeout = ka->interval - (time(NULL) - ka->intervalStart);\n        if (timeout < 0)\n            timeout = 0;\n        /* Guard against overflow */\n        if (timeout > INT_MAX / 1000)\n            timeout = INT_MAX / 1000;\n    }\n\n    virObjectUnlock(ka);\n\n    if (timeout < 0)\n        return -1;\n    else\n        return timeout * 1000;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirKeepAliveTimeout(virKeepAlivePtr ka)\n{\n    int timeout;\n\n    if (!ka)\n        return -1;\n\n    virObjectLock(ka);\n\n    if (ka->interval <= 0 || ka->intervalStart == 0) {\n        timeout = -1;\n    } else {\n        timeout = ka->interval - (time(NULL) - ka->intervalStart);\n        if (timeout < 0)\n            timeout = 0;\n        /* Guard against overflow */\n        if (timeout > INT_MAX / 1000)\n            timeout = INT_MAX / 1000;\n    }\n\n    virObjectUnlock(ka);\n\n    if (timeout < 0)\n        return -1;\n    else\n        return timeout * 1000;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientIOEventLoop(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    bool error = false;\n    int closeReason;\n\n    for (;;) {\n#ifndef WIN32\n        sigset_t oldmask, blockedsigs;\n#endif /* !WIN32 */\n        int timeout = -1;\n        virNetMessagePtr msg = NULL;\n        GIOCondition ev = 0;\n        struct virNetClientIOEventData data = {\n            .client = client,\n            .rev = 0,\n        };\n\n        /* If we have existing SASL decoded data we don't want to sleep in\n         * the poll(), just check if any other FDs are also ready.\n         * If the connection is going to be closed, we don't want to sleep in\n         * poll() either.\n         */\n        if (virNetSocketHasCachedData(client->sock) || client->wantClose)\n            timeout = 0;\n\n        /* If we are non-blocking, then we don't want to sleep in poll() */\n        if (thiscall->nonBlock)\n            timeout = 0;\n\n        /* Limit timeout so that we can send keepalive request in time */\n        if (timeout == -1)\n            timeout = virKeepAliveTimeout(client->keepalive);\n\n        /* Calculate poll events for calls */\n        virNetClientCallMatchPredicate(client->waitDispatch,\n                                       virNetClientIOEventLoopPollEvents,\n                                       &ev);\n\n        /* We have to be prepared to receive stream data\n         * regardless of whether any of the calls waiting\n         * for dispatch are for streams.\n         */\n        if (client->nstreams)\n            ev |= G_IO_IN;\n\n        virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                                   ev,\n                                   client->eventCtx,\n                                   virNetClientIOEventFD, &data, NULL);\n\n        /* Release lock while poll'ing so other threads\n         * can stuff themselves on the queue */\n        virObjectUnlock(client);\n\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n        sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n        sigaddset(&blockedsigs, SIGCHLD);\n# endif\n        sigaddset(&blockedsigs, SIGPIPE);\n\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n        virObjectLock(client);\n\n        if (virKeepAliveTrigger(client->keepalive, &msg)) {\n            virNetClientMarkClose(client, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n        } else if (msg && virNetClientQueueNonBlocking(client, msg) < 0) {\n            VIR_WARN(\"Could not queue keepalive request\");\n            virNetMessageFree(msg);\n        }\n\n        /* If we have existing SASL decoded data, pretend\n         * the socket became readable so we consume it\n         */\n        if (virNetSocketHasCachedData(client->sock))\n            data.rev |= G_IO_IN;\n\n        /* If wantClose flag is set, pretend there was an error on the socket,\n         * but still read and process any data we received so far.\n         */\n        if (client->wantClose)\n            error = true;\n\n        if (data.rev & G_IO_HUP)\n            closeReason = VIR_CONNECT_CLOSE_REASON_EOF;\n        else\n            closeReason = VIR_CONNECT_CLOSE_REASON_ERROR;\n\n        if (data.rev & G_IO_OUT) {\n            if (virNetClientIOHandleOutput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        if (data.rev & G_IO_IN) {\n            if (virNetClientIOHandleInput(client) < 0) {\n                virNetClientMarkClose(client, closeReason);\n                error = true;\n                /* Fall through to process any pending data. */\n            }\n        }\n\n        /* Iterate through waiting calls and if any are\n         * complete, remove them from the dispatch list.\n         */\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveDone,\n                                        thiscall);\n\n        /* Now see if *we* are done */\n        if (thiscall->mode == VIR_NET_CLIENT_MODE_COMPLETE) {\n            virNetClientCallRemove(&client->waitDispatch, thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 0;\n        }\n\n        /* We're not done, but we're non-blocking; keep the call queued */\n        if (thiscall->nonBlock) {\n            virNetClientIODetachNonBlocking(thiscall);\n            virNetClientIOEventLoopPassTheBuck(client, thiscall);\n            return 1;\n        }\n\n        if (error)\n            goto error;\n\n        if (data.rev & G_IO_HUP) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received hangup event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n        if (data.rev & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"received error event on socket\"));\n            virNetClientMarkClose(client, closeReason);\n            goto error;\n        }\n    }\n\n error:\n    if (client->error) {\n        VIR_DEBUG(\"error on socket: %s\", client->error->message);\n        virSetError(client->error);\n    }\n    virNetClientCallRemove(&client->waitDispatch, thiscall);\n    virNetClientIOEventLoopPassTheBuck(client, thiscall);\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientIOEventFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1588-1597",
    "snippet": "static gboolean\nvirNetClientIOEventFD(int fd G_GNUC_UNUSED,\n                      GIOCondition ev,\n                      gpointer opaque)\n{\n    struct virNetClientIOEventData *data = opaque;\n    data->rev = ev;\n    g_main_loop_quit(data->client->eventLoop);\n    return G_SOURCE_REMOVE;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "data->client->eventLoop"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic gboolean\nvirNetClientIOEventFD(int fd G_GNUC_UNUSED,\n                      GIOCondition ev,\n                      gpointer opaque)\n{\n    struct virNetClientIOEventData *data = opaque;\n    data->rev = ev;\n    g_main_loop_quit(data->client->eventLoop);\n    return G_SOURCE_REMOVE;\n}"
  },
  {
    "function_name": "virNetClientIOEventLoopPassTheBuck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1555-1580",
    "snippet": "static void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientCallRemovePredicate",
          "args": [
            "&client->waitDispatch",
            "virNetClientIOEventLoopRemoveAll",
            "thiscall"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallRemovePredicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "203-223",
          "snippet": "static void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCloseLocked",
          "args": [
            "client"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCloseLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "727-769",
          "snippet": "static void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No thread to pass the buck to\""
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&tmp->cond"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Passing the buck to %p\"",
            "tmp"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Giving up the buck %p\"",
            "thiscall"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\n\nstatic void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}"
  },
  {
    "function_name": "virNetClientIOEventLoopRemoveAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1538-1552",
    "snippet": "static bool\nvirNetClientIOEventLoopRemoveAll(virNetClientCallPtr call,\n                                 void *opaque)\n{\n    virNetClientCallPtr thiscall = opaque;\n\n    if (call == thiscall)\n        return false;\n\n    VIR_DEBUG(\"Removing call %p\", call);\n    virCondDestroy(&call->cond);\n    VIR_FREE(call->msg);\n    VIR_FREE(call);\n    return true;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);",
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call->msg"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&call->cond"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing call %p\"",
            "call"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool\nvirNetClientIOEventLoopRemoveAll(virNetClientCallPtr call,\n                                 void *opaque)\n{\n    virNetClientCallPtr thiscall = opaque;\n\n    if (call == thiscall)\n        return false;\n\n    VIR_DEBUG(\"Removing call %p\", call);\n    virCondDestroy(&call->cond);\n    VIR_FREE(call->msg);\n    VIR_FREE(call);\n    return true;\n}"
  },
  {
    "function_name": "virNetClientIODetachNonBlocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1530-1535",
    "snippet": "static void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Keeping unfinished non-blocking call %p in the queue\"",
            "call"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetClientIODetachNonBlocking(virNetClientCallPtr call)\n{\n    VIR_DEBUG(\"Keeping unfinished non-blocking call %p in the queue\", call);\n    call->haveThread = false;\n}"
  },
  {
    "function_name": "virNetClientIOEventLoopRemoveDone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1493-1527",
    "snippet": "static bool virNetClientIOEventLoopRemoveDone(virNetClientCallPtr call,\n                                              void *opaque)\n{\n    virNetClientCallPtr thiscall = opaque;\n\n    if (call == thiscall)\n        return false;\n\n    if (call->mode != VIR_NET_CLIENT_MODE_COMPLETE)\n        return false;\n\n    /*\n     * ...if the call being removed from the list\n     * still has a thread, then wake that thread up,\n     * otherwise free the call. The latter should\n     * only happen for calls without replies.\n     *\n     * ...the threads won't actually wakeup until\n     * we release our mutex a short while\n     * later...\n     */\n    if (call->haveThread) {\n        VIR_DEBUG(\"Waking up sleep %p\", call);\n        virCondSignal(&call->cond);\n    } else {\n        VIR_DEBUG(\"Removing completed call %p\", call);\n        if (call->expectReply)\n            VIR_WARN(\"Got a call expecting a reply but without a waiting thread\");\n        virCondDestroy(&call->cond);\n        VIR_FREE(call->msg);\n        VIR_FREE(call);\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);",
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);",
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "call->msg"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&call->cond"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Got a call expecting a reply but without a waiting thread\""
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing completed call %p\"",
            "call"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&call->cond"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waking up sleep %p\"",
            "call"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool virNetClientIOEventLoopRemoveDone(virNetClientCallPtr call,\n                                              void *opaque)\n{\n    virNetClientCallPtr thiscall = opaque;\n\n    if (call == thiscall)\n        return false;\n\n    if (call->mode != VIR_NET_CLIENT_MODE_COMPLETE)\n        return false;\n\n    /*\n     * ...if the call being removed from the list\n     * still has a thread, then wake that thread up,\n     * otherwise free the call. The latter should\n     * only happen for calls without replies.\n     *\n     * ...the threads won't actually wakeup until\n     * we release our mutex a short while\n     * later...\n     */\n    if (call->haveThread) {\n        VIR_DEBUG(\"Waking up sleep %p\", call);\n        virCondSignal(&call->cond);\n    } else {\n        VIR_DEBUG(\"Removing completed call %p\", call);\n        if (call->expectReply)\n            VIR_WARN(\"Got a call expecting a reply but without a waiting thread\");\n        virCondDestroy(&call->cond);\n        VIR_FREE(call->msg);\n        VIR_FREE(call);\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virNetClientIOEventLoopPollEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1479-1490",
    "snippet": "static bool virNetClientIOEventLoopPollEvents(virNetClientCallPtr call,\n                                              void *opaque)\n{\n    GIOCondition *ev = opaque;\n\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_RX)\n        *ev |= G_IO_IN;\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n        *ev |= G_IO_OUT;\n\n    return false;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool virNetClientIOEventLoopPollEvents(virNetClientCallPtr call,\n                                              void *opaque)\n{\n    GIOCondition *ev = opaque;\n\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_RX)\n        *ev |= G_IO_IN;\n    if (call->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n        *ev |= G_IO_OUT;\n\n    return false;\n}"
  },
  {
    "function_name": "virNetClientIOHandleInput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1391-1476",
    "snippet": "static ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketHasCachedData",
          "args": [
            "client->sock"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketHasCachedData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1701-1722",
          "snippet": "bool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "&client->msg"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallDispatch",
          "args": [
            "client"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallDispatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1254-1295",
          "snippet": "static int\nvirNetClientCallDispatch(virNetClientPtr client)\n{\n    virNetMessagePtr response = NULL;\n\n    PROBE(RPC_CLIENT_MSG_RX,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, client->msg.bufferLength,\n          client->msg.header.prog, client->msg.header.vers, client->msg.header.proc,\n          client->msg.header.type, client->msg.header.status, client->msg.header.serial);\n\n    if (virKeepAliveCheckMessage(client->keepalive, &client->msg, &response)) {\n        if (response &&\n            virNetClientQueueNonBlocking(client, response) < 0) {\n            VIR_WARN(\"Could not queue keepalive response\");\n            virNetMessageFree(response);\n        }\n        return 0;\n    }\n\n    switch (client->msg.header.type) {\n    case VIR_NET_REPLY: /* Normal RPC replies */\n    case VIR_NET_REPLY_WITH_FDS: /* Normal RPC replies with FDs */\n        return virNetClientCallDispatchReply(client);\n\n    case VIR_NET_MESSAGE: /* Async notifications */\n        return virNetClientCallDispatchMessage(client);\n\n    case VIR_NET_STREAM: /* Stream protocol */\n    case VIR_NET_STREAM_HOLE: /* Sparse stream protocol */\n        return virNetClientCallDispatchStream(client);\n\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"got unexpected RPC call prog %d vers %d proc %d type %d\"),\n                       client->msg.header.prog, client->msg.header.vers,\n                       client->msg.header.proc, client->msg.header.type);\n        return -1;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientCallDispatch(virNetClientPtr client)\n{\n    virNetMessagePtr response = NULL;\n\n    PROBE(RPC_CLIENT_MSG_RX,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, client->msg.bufferLength,\n          client->msg.header.prog, client->msg.header.vers, client->msg.header.proc,\n          client->msg.header.type, client->msg.header.status, client->msg.header.serial);\n\n    if (virKeepAliveCheckMessage(client->keepalive, &client->msg, &response)) {\n        if (response &&\n            virNetClientQueueNonBlocking(client, response) < 0) {\n            VIR_WARN(\"Could not queue keepalive response\");\n            virNetMessageFree(response);\n        }\n        return 0;\n    }\n\n    switch (client->msg.header.type) {\n    case VIR_NET_REPLY: /* Normal RPC replies */\n    case VIR_NET_REPLY_WITH_FDS: /* Normal RPC replies with FDs */\n        return virNetClientCallDispatchReply(client);\n\n    case VIR_NET_MESSAGE: /* Async notifications */\n        return virNetClientCallDispatchMessage(client);\n\n    case VIR_NET_STREAM: /* Stream protocol */\n    case VIR_NET_STREAM_HOLE: /* Sparse stream protocol */\n        return virNetClientCallDispatchStream(client);\n\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"got unexpected RPC call prog %d vers %d proc %d type %d\"),\n                       client->msg.header.prog, client->msg.header.vers,\n                       client->msg.header.proc, client->msg.header.type);\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRecvFD",
          "args": [
            "client->sock",
            "&(client->msg.fds[i])"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRecvFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2053-2081",
          "snippet": "int virNetSocketRecvFD(virNetSocketPtr sock, int *fd)\n{\n    int ret = -1;\n\n    *fd = -1;\n\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Receiving file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n\n    if ((*fd = virSocketRecvFD(sock->fd, O_CLOEXEC)) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to recv file descriptor\"));\n        goto cleanup;\n    }\n    PROBE(RPC_SOCKET_RECV_FD,\n          \"sock=%p fd=%d\", sock, *fd);\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketRecvFD(virNetSocketPtr sock, int *fd)\n{\n    int ret = -1;\n\n    *fd = -1;\n\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Receiving file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n\n    if ((*fd = virSocketRecvFD(sock->fd, O_CLOEXEC)) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to recv file descriptor\"));\n        goto cleanup;\n    }\n    PROBE(RPC_SOCKET_RECV_FD,\n          \"sock=%p fd=%d\", sock, *fd);\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodeNumFDs",
          "args": [
            "&client->msg"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodeNumFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "307-344",
          "snippet": "int virNetMessageDecodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs;\n    int ret = -1;\n    size_t i;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Received too many FDs %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (msg->nfds == 0) {\n        msg->nfds = numFDs;\n        if (VIR_ALLOC_N(msg->fds, msg->nfds) < 0)\n            goto cleanup;\n        for (i = 0; i < msg->nfds; i++)\n            msg->fds[i] = -1;\n    }\n\n    VIR_DEBUG(\"Got %zu FDs from peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs;\n    int ret = -1;\n    size_t i;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Received too many FDs %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (msg->nfds == 0) {\n        msg->nfds = numFDs;\n        if (VIR_ALLOC_N(msg->fds, msg->nfds) < 0)\n            goto cleanup;\n        for (i = 0; i < msg->nfds; i++)\n            msg->fds[i] = -1;\n    }\n\n    VIR_DEBUG(\"Got %zu FDs from peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodeHeader",
          "args": [
            "&client->msg"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "181-212",
          "snippet": "int virNetMessageDecodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n\n    if (msg->bufferLength < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to decode header until len is received\"));\n        return -1;\n    }\n\n    msg->bufferOffset = VIR_NET_MESSAGE_LEN_MAX;\n\n    /* Parse the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset,\n                  XDR_DECODE);\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message header\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n\n    if (msg->bufferLength < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to decode header until len is received\"));\n        return -1;\n    }\n\n    msg->bufferOffset = VIR_NET_MESSAGE_LEN_MAX;\n\n    /* Parse the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset,\n                  XDR_DECODE);\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message header\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodeLength",
          "args": [
            "&client->msg"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodeLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "122-167",
          "snippet": "int virNetMessageDecodeLength(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int len;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer,\n                  msg->bufferLength, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message length\"));\n        goto cleanup;\n    }\n    msg->bufferOffset = xdr_getpos(&xdr);\n\n    if (len < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too small, want %d\"),\n                       len, VIR_NET_MESSAGE_LEN_MAX);\n        goto cleanup;\n    }\n\n    /* Length includes length word - adjust to real length to read. */\n    len -= VIR_NET_MESSAGE_LEN_MAX;\n\n    if (len > VIR_NET_MESSAGE_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too large, want %d\"),\n                       len, VIR_NET_MESSAGE_MAX);\n        goto cleanup;\n    }\n\n    /* Extend our declared buffer length and carry\n       on reading the header + payload */\n    msg->bufferLength += len;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Got length, now need %zu total (%u more)\",\n              msg->bufferLength, len);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeLength(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int len;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer,\n                  msg->bufferLength, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message length\"));\n        goto cleanup;\n    }\n    msg->bufferOffset = xdr_getpos(&xdr);\n\n    if (len < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too small, want %d\"),\n                       len, VIR_NET_MESSAGE_LEN_MAX);\n        goto cleanup;\n    }\n\n    /* Length includes length word - adjust to real length to read. */\n    len -= VIR_NET_MESSAGE_LEN_MAX;\n\n    if (len > VIR_NET_MESSAGE_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too large, want %d\"),\n                       len, VIR_NET_MESSAGE_MAX);\n        goto cleanup;\n    }\n\n    /* Extend our declared buffer length and carry\n       on reading the header + payload */\n    msg->bufferLength += len;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Got length, now need %zu total (%u more)\",\n              msg->bufferLength, len);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOReadMessage",
          "args": [
            "client"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOReadMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1364-1388",
          "snippet": "static ssize_t\nvirNetClientIOReadMessage(virNetClientPtr client)\n{\n    size_t wantData;\n    ssize_t ret;\n\n    /* Start by reading length word */\n    if (client->msg.bufferLength == 0) {\n        client->msg.bufferLength = 4;\n        if (VIR_ALLOC_N(client->msg.buffer, client->msg.bufferLength) < 0)\n            return -ENOMEM;\n    }\n\n    wantData = client->msg.bufferLength - client->msg.bufferOffset;\n\n    ret = virNetSocketRead(client->sock,\n                           client->msg.buffer + client->msg.bufferOffset,\n                           wantData);\n    if (ret <= 0)\n        return ret;\n\n    client->msg.bufferOffset += ret;\n\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOReadMessage(virNetClientPtr client)\n{\n    size_t wantData;\n    ssize_t ret;\n\n    /* Start by reading length word */\n    if (client->msg.bufferLength == 0) {\n        client->msg.bufferLength = 4;\n        if (VIR_ALLOC_N(client->msg.buffer, client->msg.bufferLength) < 0)\n            return -ENOMEM;\n    }\n\n    wantData = client->msg.bufferLength - client->msg.bufferOffset;\n\n    ret = virNetSocketRead(client->sock,\n                           client->msg.buffer + client->msg.bufferOffset,\n                           wantData);\n    if (ret <= 0)\n        return ret;\n\n    client->msg.bufferOffset += ret;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOHandleInput(virNetClientPtr client)\n{\n    /* Read as much data as is available, until we get\n     * EAGAIN\n     */\n    for (;;) {\n        ssize_t ret;\n\n        if (client->msg.nfds == 0) {\n            ret = virNetClientIOReadMessage(client);\n\n            if (ret < 0)\n                return -1;\n            if (ret == 0)\n                return 0;  /* Blocking on read */\n        }\n\n        /* Check for completion of our goal */\n        if (client->msg.bufferOffset == client->msg.bufferLength) {\n            if (client->msg.bufferOffset == 4) {\n                ret = virNetMessageDecodeLength(&client->msg);\n                if (ret < 0)\n                    return -1;\n\n                /*\n                 * We'll carry on around the loop to immediately\n                 * process the message body, because it has probably\n                 * already arrived. Worst case, we'll get EAGAIN on\n                 * next iteration.\n                 */\n            } else {\n                if (virNetMessageDecodeHeader(&client->msg) < 0)\n                    return -1;\n\n                if (client->msg.header.type == VIR_NET_REPLY_WITH_FDS) {\n                    size_t i;\n\n                    if (virNetMessageDecodeNumFDs(&client->msg) < 0)\n                        return -1;\n\n                    for (i = client->msg.donefds; i < client->msg.nfds; i++) {\n                        int rv;\n                        if ((rv = virNetSocketRecvFD(client->sock, &(client->msg.fds[i]))) < 0)\n                            return -1;\n                        if (rv == 0) /* Blocking */\n                            break;\n                        client->msg.donefds++;\n                    }\n\n                    if (client->msg.donefds < client->msg.nfds) {\n                        /* Because DecodeHeader/NumFDs reset bufferOffset, we\n                         * put it back to what it was, so everything works\n                         * again next time we run this method\n                         */\n                        client->msg.bufferOffset = client->msg.bufferLength;\n                        return 0; /* Blocking on more fds */\n                    }\n                }\n\n                ret = virNetClientCallDispatch(client);\n                virNetMessageClear(&client->msg);\n                /*\n                 * We've completed one call, but we don't want to\n                 * spin around the loop forever if there are many\n                 * incoming async events, or replies for other\n                 * thread's RPC calls. We want to get out & let\n                 * any other thread take over as soon as we've\n                 * got our reply. When SASL is active though, we\n                 * may have read more data off the wire than we\n                 * initially wanted & cached it in memory. In this\n                 * case, poll() would not detect that there is more\n                 * ready todo.\n                 *\n                 * So if SASL is active *and* some SASL data is\n                 * already cached, then we'll process that now,\n                 * before returning.\n                 */\n                if (ret == 0 &&\n                    virNetSocketHasCachedData(client->sock))\n                    continue;\n                return ret;\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "virNetClientIOReadMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1364-1388",
    "snippet": "static ssize_t\nvirNetClientIOReadMessage(virNetClientPtr client)\n{\n    size_t wantData;\n    ssize_t ret;\n\n    /* Start by reading length word */\n    if (client->msg.bufferLength == 0) {\n        client->msg.bufferLength = 4;\n        if (VIR_ALLOC_N(client->msg.buffer, client->msg.bufferLength) < 0)\n            return -ENOMEM;\n    }\n\n    wantData = client->msg.bufferLength - client->msg.bufferOffset;\n\n    ret = virNetSocketRead(client->sock,\n                           client->msg.buffer + client->msg.bufferOffset,\n                           wantData);\n    if (ret <= 0)\n        return ret;\n\n    client->msg.bufferOffset += ret;\n\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketRead",
          "args": [
            "client->sock",
            "client->msg.buffer + client->msg.bufferOffset",
            "wantData"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1989-2001",
          "snippet": "ssize_t virNetSocketRead(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t ret;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketReadSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketReadWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nssize_t virNetSocketRead(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t ret;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketReadSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketReadWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "client->msg.buffer",
            "client->msg.bufferLength"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOReadMessage(virNetClientPtr client)\n{\n    size_t wantData;\n    ssize_t ret;\n\n    /* Start by reading length word */\n    if (client->msg.bufferLength == 0) {\n        client->msg.bufferLength = 4;\n        if (VIR_ALLOC_N(client->msg.buffer, client->msg.bufferLength) < 0)\n            return -ENOMEM;\n    }\n\n    wantData = client->msg.bufferLength - client->msg.bufferOffset;\n\n    ret = virNetSocketRead(client->sock,\n                           client->msg.buffer + client->msg.bufferOffset,\n                           wantData);\n    if (ret <= 0)\n        return ret;\n\n    client->msg.bufferOffset += ret;\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientIOHandleOutput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1335-1362",
    "snippet": "static ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientIOWriteMessage",
          "args": [
            "client",
            "thecall"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOWriteMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1298-1332",
          "snippet": "static ssize_t\nvirNetClientIOWriteMessage(virNetClientPtr client,\n                           virNetClientCallPtr thecall)\n{\n    ssize_t ret = 0;\n\n    if (thecall->msg->bufferOffset < thecall->msg->bufferLength) {\n        ret = virNetSocketWrite(client->sock,\n                                thecall->msg->buffer + thecall->msg->bufferOffset,\n                                thecall->msg->bufferLength - thecall->msg->bufferOffset);\n        if (ret <= 0)\n            return ret;\n\n        thecall->msg->bufferOffset += ret;\n    }\n\n    if (thecall->msg->bufferOffset == thecall->msg->bufferLength) {\n        size_t i;\n        for (i = thecall->msg->donefds; i < thecall->msg->nfds; i++) {\n            int rv;\n            if ((rv = virNetSocketSendFD(client->sock, thecall->msg->fds[i])) < 0)\n                return -1;\n            if (rv == 0) /* Blocking */\n                return 0;\n            thecall->msg->donefds++;\n        }\n        virNetMessageClearPayload(thecall->msg);\n        if (thecall->expectReply)\n            thecall->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n        else\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOWriteMessage(virNetClientPtr client,\n                           virNetClientCallPtr thecall)\n{\n    ssize_t ret = 0;\n\n    if (thecall->msg->bufferOffset < thecall->msg->bufferLength) {\n        ret = virNetSocketWrite(client->sock,\n                                thecall->msg->buffer + thecall->msg->bufferOffset,\n                                thecall->msg->bufferLength - thecall->msg->bufferOffset);\n        if (ret <= 0)\n            return ret;\n\n        thecall->msg->bufferOffset += ret;\n    }\n\n    if (thecall->msg->bufferOffset == thecall->msg->bufferLength) {\n        size_t i;\n        for (i = thecall->msg->donefds; i < thecall->msg->nfds; i++) {\n            int rv;\n            if ((rv = virNetSocketSendFD(client->sock, thecall->msg->fds[i])) < 0)\n                return -1;\n            if (rv == 0) /* Blocking */\n                return 0;\n            thecall->msg->donefds++;\n        }\n        virNetMessageClearPayload(thecall->msg);\n        if (thecall->expectReply)\n            thecall->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n        else\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic ssize_t\nvirNetClientIOHandleOutput(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall = client->waitDispatch;\n\n    while (thecall &&\n           thecall->mode != VIR_NET_CLIENT_MODE_WAIT_TX)\n        thecall = thecall->next;\n\n    if (!thecall)\n        return 0; /* This can happen if another thread raced with us and\n                   * completed the call between the time this thread woke\n                   * up from poll()ing and the time we locked the client\n                   */\n\n    while (thecall) {\n        ssize_t ret = virNetClientIOWriteMessage(client, thecall);\n        if (ret < 0)\n            return ret;\n\n        if (thecall->mode == VIR_NET_CLIENT_MODE_WAIT_TX)\n            return 0; /* Blocking write, to back to event loop */\n\n        thecall = thecall->next;\n    }\n\n    return 0; /* No more calls to send, all done */\n}"
  },
  {
    "function_name": "virNetClientIOWriteMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1298-1332",
    "snippet": "static ssize_t\nvirNetClientIOWriteMessage(virNetClientPtr client,\n                           virNetClientCallPtr thecall)\n{\n    ssize_t ret = 0;\n\n    if (thecall->msg->bufferOffset < thecall->msg->bufferLength) {\n        ret = virNetSocketWrite(client->sock,\n                                thecall->msg->buffer + thecall->msg->bufferOffset,\n                                thecall->msg->bufferLength - thecall->msg->bufferOffset);\n        if (ret <= 0)\n            return ret;\n\n        thecall->msg->bufferOffset += ret;\n    }\n\n    if (thecall->msg->bufferOffset == thecall->msg->bufferLength) {\n        size_t i;\n        for (i = thecall->msg->donefds; i < thecall->msg->nfds; i++) {\n            int rv;\n            if ((rv = virNetSocketSendFD(client->sock, thecall->msg->fds[i])) < 0)\n                return -1;\n            if (rv == 0) /* Blocking */\n                return 0;\n            thecall->msg->donefds++;\n        }\n        virNetMessageClearPayload(thecall->msg);\n        if (thecall->expectReply)\n            thecall->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n        else\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageClearPayload",
          "args": [
            "thecall->msg"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClearPayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "51-66",
          "snippet": "void\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketSendFD",
          "args": [
            "client->sock",
            "thecall->msg->fds[i]"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketSendFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2022-2047",
          "snippet": "int virNetSocketSendFD(virNetSocketPtr sock, int fd)\n{\n    int ret = -1;\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sending file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n    PROBE(RPC_SOCKET_SEND_FD,\n          \"sock=%p fd=%d\", sock, fd);\n    if (virSocketSendFD(sock->fd, fd) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno,\n                                 _(\"Failed to send file descriptor %d\"),\n                                 fd);\n        goto cleanup;\n    }\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketSendFD(virNetSocketPtr sock, int fd)\n{\n    int ret = -1;\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sending file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n    PROBE(RPC_SOCKET_SEND_FD,\n          \"sock=%p fd=%d\", sock, fd);\n    if (virSocketSendFD(sock->fd, fd) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno,\n                                 _(\"Failed to send file descriptor %d\"),\n                                 fd);\n        goto cleanup;\n    }\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketWrite",
          "args": [
            "client->sock",
            "thecall->msg->buffer + thecall->msg->bufferOffset",
            "thecall->msg->bufferLength - thecall->msg->bufferOffset"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2003-2016",
          "snippet": "ssize_t virNetSocketWrite(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketWriteSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketWriteWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nssize_t virNetSocketWrite(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketWriteSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketWriteWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic ssize_t\nvirNetClientIOWriteMessage(virNetClientPtr client,\n                           virNetClientCallPtr thecall)\n{\n    ssize_t ret = 0;\n\n    if (thecall->msg->bufferOffset < thecall->msg->bufferLength) {\n        ret = virNetSocketWrite(client->sock,\n                                thecall->msg->buffer + thecall->msg->bufferOffset,\n                                thecall->msg->bufferLength - thecall->msg->bufferOffset);\n        if (ret <= 0)\n            return ret;\n\n        thecall->msg->bufferOffset += ret;\n    }\n\n    if (thecall->msg->bufferOffset == thecall->msg->bufferLength) {\n        size_t i;\n        for (i = thecall->msg->donefds; i < thecall->msg->nfds; i++) {\n            int rv;\n            if ((rv = virNetSocketSendFD(client->sock, thecall->msg->fds[i])) < 0)\n                return -1;\n            if (rv == 0) /* Blocking */\n                return 0;\n            thecall->msg->donefds++;\n        }\n        virNetMessageClearPayload(thecall->msg);\n        if (thecall->expectReply)\n            thecall->mode = VIR_NET_CLIENT_MODE_WAIT_RX;\n        else\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientCallDispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1254-1295",
    "snippet": "static int\nvirNetClientCallDispatch(virNetClientPtr client)\n{\n    virNetMessagePtr response = NULL;\n\n    PROBE(RPC_CLIENT_MSG_RX,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, client->msg.bufferLength,\n          client->msg.header.prog, client->msg.header.vers, client->msg.header.proc,\n          client->msg.header.type, client->msg.header.status, client->msg.header.serial);\n\n    if (virKeepAliveCheckMessage(client->keepalive, &client->msg, &response)) {\n        if (response &&\n            virNetClientQueueNonBlocking(client, response) < 0) {\n            VIR_WARN(\"Could not queue keepalive response\");\n            virNetMessageFree(response);\n        }\n        return 0;\n    }\n\n    switch (client->msg.header.type) {\n    case VIR_NET_REPLY: /* Normal RPC replies */\n    case VIR_NET_REPLY_WITH_FDS: /* Normal RPC replies with FDs */\n        return virNetClientCallDispatchReply(client);\n\n    case VIR_NET_MESSAGE: /* Async notifications */\n        return virNetClientCallDispatchMessage(client);\n\n    case VIR_NET_STREAM: /* Stream protocol */\n    case VIR_NET_STREAM_HOLE: /* Sparse stream protocol */\n        return virNetClientCallDispatchStream(client);\n\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"got unexpected RPC call prog %d vers %d proc %d type %d\"),\n                       client->msg.header.prog, client->msg.header.vers,\n                       client->msg.header.proc, client->msg.header.type);\n        return -1;\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"got unexpected RPC call prog %d vers %d proc %d type %d\")",
            "client->msg.header.prog",
            "client->msg.header.vers",
            "client->msg.header.proc",
            "client->msg.header.type"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"got unexpected RPC call prog %d vers %d proc %d type %d\""
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallDispatchStream",
          "args": [
            "client"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallDispatchStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1158-1251",
          "snippet": "static int virNetClientCallDispatchStream(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientStreamPtr st = NULL;\n    virNetClientCallPtr thecall;\n\n    /* First identify what stream this packet is directed at */\n    for (i = 0; i < client->nstreams; i++) {\n        if (virNetClientStreamMatches(client->streams[i],\n                                      &client->msg)) {\n            st = client->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        VIR_DEBUG(\"No stream found for packet with prog=%d vers=%d serial=%u proc=%u\",\n                  client->msg.header.prog, client->msg.header.vers,\n                  client->msg.header.serial, client->msg.header.proc);\n        /* Don't return -1, because we expect to see further stream packets\n         * after we've shut it down sometimes */\n        return 0;\n    }\n\n\n    /* Status is either\n     *   - VIR_NET_OK - no payload for streams\n     *   - VIR_NET_ERROR - followed by a remote_error struct\n     *   - VIR_NET_CONTINUE - followed by a raw data packet\n     */\n    switch (client->msg.header.status) {\n    case VIR_NET_CONTINUE: {\n        if (virNetClientStreamQueuePacket(st, &client->msg) < 0)\n            return -1;\n\n        /* Find oldest dummy message waiting for incoming data. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status == VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (thecall) {\n            VIR_DEBUG(\"Got a new incoming stream data\");\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n        }\n        return 0;\n    }\n\n    case VIR_NET_OK:\n        /* Find oldest abort/finish message. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status != VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (!thecall) {\n            VIR_DEBUG(\"Got unexpected async stream finish confirmation\");\n            return -1;\n        }\n\n        VIR_DEBUG(\"Got a synchronous abort/finish confirm\");\n\n        virNetClientStreamSetClosed(st,\n                                    thecall->msg->header.status == VIR_NET_OK ?\n                                        VIR_NET_CLIENT_STREAM_CLOSED_FINISHED :\n                                        VIR_NET_CLIENT_STREAM_CLOSED_ABORTED);\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    case VIR_NET_ERROR:\n        /* No call, so queue the error against the stream */\n        if (virNetClientStreamSetError(st, &client->msg) < 0)\n            return -1;\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    default:\n        VIR_WARN(\"Stream with unexpected serial=%d, proc=%d, status=%d\",\n                 client->msg.header.serial, client->msg.header.proc,\n                 client->msg.header.status);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientCallDispatchStream(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientStreamPtr st = NULL;\n    virNetClientCallPtr thecall;\n\n    /* First identify what stream this packet is directed at */\n    for (i = 0; i < client->nstreams; i++) {\n        if (virNetClientStreamMatches(client->streams[i],\n                                      &client->msg)) {\n            st = client->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        VIR_DEBUG(\"No stream found for packet with prog=%d vers=%d serial=%u proc=%u\",\n                  client->msg.header.prog, client->msg.header.vers,\n                  client->msg.header.serial, client->msg.header.proc);\n        /* Don't return -1, because we expect to see further stream packets\n         * after we've shut it down sometimes */\n        return 0;\n    }\n\n\n    /* Status is either\n     *   - VIR_NET_OK - no payload for streams\n     *   - VIR_NET_ERROR - followed by a remote_error struct\n     *   - VIR_NET_CONTINUE - followed by a raw data packet\n     */\n    switch (client->msg.header.status) {\n    case VIR_NET_CONTINUE: {\n        if (virNetClientStreamQueuePacket(st, &client->msg) < 0)\n            return -1;\n\n        /* Find oldest dummy message waiting for incoming data. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status == VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (thecall) {\n            VIR_DEBUG(\"Got a new incoming stream data\");\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n        }\n        return 0;\n    }\n\n    case VIR_NET_OK:\n        /* Find oldest abort/finish message. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status != VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (!thecall) {\n            VIR_DEBUG(\"Got unexpected async stream finish confirmation\");\n            return -1;\n        }\n\n        VIR_DEBUG(\"Got a synchronous abort/finish confirm\");\n\n        virNetClientStreamSetClosed(st,\n                                    thecall->msg->header.status == VIR_NET_OK ?\n                                        VIR_NET_CLIENT_STREAM_CLOSED_FINISHED :\n                                        VIR_NET_CLIENT_STREAM_CLOSED_ABORTED);\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    case VIR_NET_ERROR:\n        /* No call, so queue the error against the stream */\n        if (virNetClientStreamSetError(st, &client->msg) < 0)\n            return -1;\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    default:\n        VIR_WARN(\"Stream with unexpected serial=%d, proc=%d, status=%d\",\n                 client->msg.header.serial, client->msg.header.proc,\n                 client->msg.header.status);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallDispatchMessage",
          "args": [
            "client"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallDispatchMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1122-1143",
          "snippet": "static int virNetClientCallDispatchMessage(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientProgramPtr prog = NULL;\n\n    for (i = 0; i < client->nprograms; i++) {\n        if (virNetClientProgramMatches(client->programs[i],\n                                       &client->msg)) {\n            prog = client->programs[i];\n            break;\n        }\n    }\n    if (!prog) {\n        VIR_DEBUG(\"No program found for event with prog=%d vers=%d\",\n                  client->msg.header.prog, client->msg.header.vers);\n        return -1;\n    }\n\n    virNetClientProgramDispatch(prog, client, &client->msg);\n\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientCallDispatchMessage(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientProgramPtr prog = NULL;\n\n    for (i = 0; i < client->nprograms; i++) {\n        if (virNetClientProgramMatches(client->programs[i],\n                                       &client->msg)) {\n            prog = client->programs[i];\n            break;\n        }\n    }\n    if (!prog) {\n        VIR_DEBUG(\"No program found for event with prog=%d vers=%d\",\n                  client->msg.header.prog, client->msg.header.vers);\n        return -1;\n    }\n\n    virNetClientProgramDispatch(prog, client, &client->msg);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientCallDispatchReply",
          "args": [
            "client"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallDispatchReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1083-1120",
          "snippet": "static int\nvirNetClientCallDispatchReply(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall;\n\n    /* Ok, definitely got an RPC reply now find\n       out which waiting call is associated with it */\n    thecall = client->waitDispatch;\n    while (thecall &&\n           !(thecall->msg->header.prog == client->msg.header.prog &&\n             thecall->msg->header.vers == client->msg.header.vers &&\n             thecall->msg->header.serial == client->msg.header.serial))\n        thecall = thecall->next;\n\n    if (!thecall) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"no call waiting for reply with prog %d vers %d serial %d\"),\n                       client->msg.header.prog, client->msg.header.vers, client->msg.header.serial);\n        return -1;\n    }\n\n    if (VIR_REALLOC_N(thecall->msg->buffer, client->msg.bufferLength) < 0)\n        return -1;\n\n    memcpy(thecall->msg->buffer, client->msg.buffer, client->msg.bufferLength);\n    memcpy(&thecall->msg->header, &client->msg.header, sizeof(client->msg.header));\n    thecall->msg->bufferLength = client->msg.bufferLength;\n    thecall->msg->bufferOffset = client->msg.bufferOffset;\n\n    thecall->msg->nfds = client->msg.nfds;\n    thecall->msg->fds = client->msg.fds;\n    client->msg.nfds = 0;\n    client->msg.fds = NULL;\n\n    thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientCallDispatchReply(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall;\n\n    /* Ok, definitely got an RPC reply now find\n       out which waiting call is associated with it */\n    thecall = client->waitDispatch;\n    while (thecall &&\n           !(thecall->msg->header.prog == client->msg.header.prog &&\n             thecall->msg->header.vers == client->msg.header.vers &&\n             thecall->msg->header.serial == client->msg.header.serial))\n        thecall = thecall->next;\n\n    if (!thecall) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"no call waiting for reply with prog %d vers %d serial %d\"),\n                       client->msg.header.prog, client->msg.header.vers, client->msg.header.serial);\n        return -1;\n    }\n\n    if (VIR_REALLOC_N(thecall->msg->buffer, client->msg.bufferLength) < 0)\n        return -1;\n\n    memcpy(thecall->msg->buffer, client->msg.buffer, client->msg.bufferLength);\n    memcpy(&thecall->msg->header, &client->msg.header, sizeof(client->msg.header));\n    thecall->msg->bufferLength = client->msg.bufferLength;\n    thecall->msg->bufferOffset = client->msg.bufferOffset;\n\n    thecall->msg->nfds = client->msg.nfds;\n    thecall->msg->fds = client->msg.fds;\n    client->msg.nfds = 0;\n    client->msg.fds = NULL;\n\n    thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "response"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not queue keepalive response\""
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientQueueNonBlocking",
          "args": [
            "client",
            "response"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientQueueNonBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2071-2089",
          "snippet": "static int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientQueueNonBlocking(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    virNetClientCallPtr call;\n\n    PROBE(RPC_CLIENT_MSG_TX_QUEUE,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u\"\n          \" type=%u status=%u serial=%u\",\n          client, msg->bufferLength,\n          msg->header.prog, msg->header.vers, msg->header.proc,\n          msg->header.type, msg->header.status, msg->header.serial);\n\n    if (!(call = virNetClientCallNew(msg, false, true)))\n        return -1;\n\n    virNetClientCallQueue(&client->waitDispatch, call);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveCheckMessage",
          "args": [
            "client->keepalive",
            "&client->msg",
            "&response"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveCheckMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "361-410",
          "snippet": "bool\nvirKeepAliveCheckMessage(virKeepAlivePtr ka,\n                         virNetMessagePtr msg,\n                         virNetMessagePtr *response)\n{\n    bool ret = false;\n\n    VIR_DEBUG(\"ka=%p, client=%p, msg=%p\",\n              ka, ka ? ka->client : \"(null)\", msg);\n\n    *response = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n\n    ka->countToDeath = ka->count;\n    ka->lastPacketReceived = ka->intervalStart = time(NULL);\n\n    if (msg->header.prog == KEEPALIVE_PROGRAM &&\n        msg->header.vers == KEEPALIVE_PROTOCOL_VERSION &&\n        msg->header.type == VIR_NET_MESSAGE) {\n        PROBE(RPC_KEEPALIVE_RECEIVED,\n              \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n              ka, ka->client, msg->header.prog,\n              msg->header.vers, msg->header.proc);\n        ret = true;\n        switch (msg->header.proc) {\n        case KEEPALIVE_PROC_PING:\n            VIR_DEBUG(\"Got keepalive request from client %p\", ka->client);\n            *response = virKeepAliveMessage(ka, KEEPALIVE_PROC_PONG);\n            break;\n\n        case KEEPALIVE_PROC_PONG:\n            VIR_DEBUG(\"Got keepalive response from client %p\", ka->client);\n            break;\n\n        default:\n            VIR_DEBUG(\"Ignoring unknown keepalive message %d from client %p\",\n                      msg->header.proc, ka->client);\n        }\n    }\n\n    if (ka->timer >= 0)\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n\n    virObjectUnlock(ka);\n\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirKeepAliveCheckMessage(virKeepAlivePtr ka,\n                         virNetMessagePtr msg,\n                         virNetMessagePtr *response)\n{\n    bool ret = false;\n\n    VIR_DEBUG(\"ka=%p, client=%p, msg=%p\",\n              ka, ka ? ka->client : \"(null)\", msg);\n\n    *response = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n\n    ka->countToDeath = ka->count;\n    ka->lastPacketReceived = ka->intervalStart = time(NULL);\n\n    if (msg->header.prog == KEEPALIVE_PROGRAM &&\n        msg->header.vers == KEEPALIVE_PROTOCOL_VERSION &&\n        msg->header.type == VIR_NET_MESSAGE) {\n        PROBE(RPC_KEEPALIVE_RECEIVED,\n              \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n              ka, ka->client, msg->header.prog,\n              msg->header.vers, msg->header.proc);\n        ret = true;\n        switch (msg->header.proc) {\n        case KEEPALIVE_PROC_PING:\n            VIR_DEBUG(\"Got keepalive request from client %p\", ka->client);\n            *response = virKeepAliveMessage(ka, KEEPALIVE_PROC_PONG);\n            break;\n\n        case KEEPALIVE_PROC_PONG:\n            VIR_DEBUG(\"Got keepalive response from client %p\", ka->client);\n            break;\n\n        default:\n            VIR_DEBUG(\"Ignoring unknown keepalive message %d from client %p\",\n                      msg->header.proc, ka->client);\n        }\n    }\n\n    if (ka->timer >= 0)\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n\n    virObjectUnlock(ka);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_CLIENT_MSG_RX",
            "\"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\"",
            "client",
            "client->msg.bufferLength",
            "client->msg.header.prog",
            "client->msg.header.vers",
            "client->msg.header.proc",
            "client->msg.header.type",
            "client->msg.header.status",
            "client->msg.header.serial"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientCallDispatch(virNetClientPtr client)\n{\n    virNetMessagePtr response = NULL;\n\n    PROBE(RPC_CLIENT_MSG_RX,\n          \"client=%p len=%zu prog=%u vers=%u proc=%u type=%u status=%u serial=%u\",\n          client, client->msg.bufferLength,\n          client->msg.header.prog, client->msg.header.vers, client->msg.header.proc,\n          client->msg.header.type, client->msg.header.status, client->msg.header.serial);\n\n    if (virKeepAliveCheckMessage(client->keepalive, &client->msg, &response)) {\n        if (response &&\n            virNetClientQueueNonBlocking(client, response) < 0) {\n            VIR_WARN(\"Could not queue keepalive response\");\n            virNetMessageFree(response);\n        }\n        return 0;\n    }\n\n    switch (client->msg.header.type) {\n    case VIR_NET_REPLY: /* Normal RPC replies */\n    case VIR_NET_REPLY_WITH_FDS: /* Normal RPC replies with FDs */\n        return virNetClientCallDispatchReply(client);\n\n    case VIR_NET_MESSAGE: /* Async notifications */\n        return virNetClientCallDispatchMessage(client);\n\n    case VIR_NET_STREAM: /* Stream protocol */\n    case VIR_NET_STREAM_HOLE: /* Sparse stream protocol */\n        return virNetClientCallDispatchStream(client);\n\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"got unexpected RPC call prog %d vers %d proc %d type %d\"),\n                       client->msg.header.prog, client->msg.header.vers,\n                       client->msg.header.proc, client->msg.header.type);\n        return -1;\n    }\n}"
  },
  {
    "function_name": "virNetClientCallDispatchStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1158-1251",
    "snippet": "static int virNetClientCallDispatchStream(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientStreamPtr st = NULL;\n    virNetClientCallPtr thecall;\n\n    /* First identify what stream this packet is directed at */\n    for (i = 0; i < client->nstreams; i++) {\n        if (virNetClientStreamMatches(client->streams[i],\n                                      &client->msg)) {\n            st = client->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        VIR_DEBUG(\"No stream found for packet with prog=%d vers=%d serial=%u proc=%u\",\n                  client->msg.header.prog, client->msg.header.vers,\n                  client->msg.header.serial, client->msg.header.proc);\n        /* Don't return -1, because we expect to see further stream packets\n         * after we've shut it down sometimes */\n        return 0;\n    }\n\n\n    /* Status is either\n     *   - VIR_NET_OK - no payload for streams\n     *   - VIR_NET_ERROR - followed by a remote_error struct\n     *   - VIR_NET_CONTINUE - followed by a raw data packet\n     */\n    switch (client->msg.header.status) {\n    case VIR_NET_CONTINUE: {\n        if (virNetClientStreamQueuePacket(st, &client->msg) < 0)\n            return -1;\n\n        /* Find oldest dummy message waiting for incoming data. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status == VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (thecall) {\n            VIR_DEBUG(\"Got a new incoming stream data\");\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n        }\n        return 0;\n    }\n\n    case VIR_NET_OK:\n        /* Find oldest abort/finish message. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status != VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (!thecall) {\n            VIR_DEBUG(\"Got unexpected async stream finish confirmation\");\n            return -1;\n        }\n\n        VIR_DEBUG(\"Got a synchronous abort/finish confirm\");\n\n        virNetClientStreamSetClosed(st,\n                                    thecall->msg->header.status == VIR_NET_OK ?\n                                        VIR_NET_CLIENT_STREAM_CLOSED_FINISHED :\n                                        VIR_NET_CLIENT_STREAM_CLOSED_ABORTED);\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    case VIR_NET_ERROR:\n        /* No call, so queue the error against the stream */\n        if (virNetClientStreamSetError(st, &client->msg) < 0)\n            return -1;\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    default:\n        VIR_WARN(\"Stream with unexpected serial=%d, proc=%d, status=%d\",\n                 client->msg.header.serial, client->msg.header.proc,\n                 client->msg.header.status);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Stream with unexpected serial=%d, proc=%d, status=%d\"",
            "client->msg.header.serial",
            "client->msg.header.proc",
            "client->msg.header.status"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientCallCompleteAllWaitingReply",
          "args": [
            "client"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCallCompleteAllWaitingReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1145-1156",
          "snippet": "static void virNetClientCallCompleteAllWaitingReply(virNetClientPtr client)\n{\n    virNetClientCallPtr call;\n\n    for (call = client->waitDispatch; call; call = call->next) {\n        if (call->msg->header.prog == client->msg.header.prog &&\n            call->msg->header.vers == client->msg.header.vers &&\n            call->msg->header.serial == client->msg.header.serial &&\n            call->expectReply)\n            call->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic void virNetClientCallCompleteAllWaitingReply(virNetClientPtr client)\n{\n    virNetClientCallPtr call;\n\n    for (call = client->waitDispatch; call; call = call->next) {\n        if (call->msg->header.prog == client->msg.header.prog &&\n            call->msg->header.vers == client->msg.header.vers &&\n            call->msg->header.serial == client->msg.header.serial &&\n            call->expectReply)\n            call->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamSetError",
          "args": [
            "st",
            "&client->msg"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamSetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "262-317",
          "snippet": "int virNetClientStreamSetError(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    virObjectLock(st);\n\n    if (st->err.code != VIR_ERR_OK)\n        VIR_DEBUG(\"Overwriting existing stream error %s\", NULLSTR(st->err.message));\n\n    virResetError(&st->err);\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    if (err.domain == VIR_FROM_REMOTE &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        st->err.code = VIR_ERR_NO_SUPPORT;\n    } else {\n        st->err.code = err.code;\n    }\n    if (err.message) {\n        st->err.message = *err.message;\n        *err.message = NULL;\n    }\n    st->err.domain = err.domain;\n    st->err.level = err.level;\n    if (err.str1) {\n        st->err.str1 = *err.str1;\n        *err.str1 = NULL;\n    }\n    if (err.str2) {\n        st->err.str2 = *err.str2;\n        *err.str2 = NULL;\n    }\n    if (err.str3) {\n        st->err.str3 = *err.str3;\n        *err.str3 = NULL;\n    }\n    st->err.int1 = err.int1;\n    st->err.int2 = err.int2;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    virObjectUnlock(st);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamSetError(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    virObjectLock(st);\n\n    if (st->err.code != VIR_ERR_OK)\n        VIR_DEBUG(\"Overwriting existing stream error %s\", NULLSTR(st->err.message));\n\n    virResetError(&st->err);\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    if (err.domain == VIR_FROM_REMOTE &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        st->err.code = VIR_ERR_NO_SUPPORT;\n    } else {\n        st->err.code = err.code;\n    }\n    if (err.message) {\n        st->err.message = *err.message;\n        *err.message = NULL;\n    }\n    st->err.domain = err.domain;\n    st->err.level = err.level;\n    if (err.str1) {\n        st->err.str1 = *err.str1;\n        *err.str1 = NULL;\n    }\n    if (err.str2) {\n        st->err.str2 = *err.str2;\n        *err.str2 = NULL;\n    }\n    if (err.str3) {\n        st->err.str3 = *err.str3;\n        *err.str3 = NULL;\n    }\n    st->err.int1 = err.int1;\n    st->err.int2 = err.int2;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    virObjectUnlock(st);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamSetClosed",
          "args": [
            "st",
            "thecall->msg->header.status == VIR_NET_OK ?\n                                        VIR_NET_CLIENT_STREAM_CLOSED_FINISHED :\n                                        VIR_NET_CLIENT_STREAM_CLOSED_ABORTED"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamSetClosed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "250-259",
          "snippet": "void virNetClientStreamSetClosed(virNetClientStreamPtr st,\n                                 virNetClientStreamClosed closed)\n{\n    virObjectLock(st);\n\n    st->closed = closed;\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nvoid virNetClientStreamSetClosed(virNetClientStreamPtr st,\n                                 virNetClientStreamClosed closed)\n{\n    virObjectLock(st);\n\n    st->closed = closed;\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got a synchronous abort/finish confirm\""
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got unexpected async stream finish confirmation\""
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got a new incoming stream data\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamQueuePacket",
          "args": [
            "st",
            "&client->msg"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamQueuePacket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "320-362",
          "snippet": "int virNetClientStreamQueuePacket(virNetClientStreamPtr st,\n                                  virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp_msg;\n\n    VIR_DEBUG(\"Incoming stream message: stream=%p message=%p\", st, msg);\n\n    if (msg->bufferLength == msg->bufferOffset) {\n        /* No payload means end of the stream. */\n        virObjectLock(st);\n        st->incomingEOF = true;\n        virNetClientStreamEventTimerUpdate(st);\n        virObjectUnlock(st);\n        return 0;\n    }\n\n    /* Unfortunately, we must allocate new message as the one we\n     * get in @msg is going to be cleared later in the process. */\n\n    if (!(tmp_msg = virNetMessageNew(false)))\n        return -1;\n\n    /* Copy header */\n    memcpy(&tmp_msg->header, &msg->header, sizeof(msg->header));\n\n    /* Steal message buffer */\n    tmp_msg->buffer = msg->buffer;\n    tmp_msg->bufferLength = msg->bufferLength;\n    tmp_msg->bufferOffset = msg->bufferOffset;\n    msg->buffer = NULL;\n    msg->bufferLength = msg->bufferOffset = 0;\n\n    virObjectLock(st);\n\n    /* Don't distinguish VIR_NET_STREAM and VIR_NET_STREAM_SKIP\n     * here just yet. We want in order processing! */\n    virNetMessageQueuePush(&st->rx, tmp_msg);\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamQueuePacket(virNetClientStreamPtr st,\n                                  virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp_msg;\n\n    VIR_DEBUG(\"Incoming stream message: stream=%p message=%p\", st, msg);\n\n    if (msg->bufferLength == msg->bufferOffset) {\n        /* No payload means end of the stream. */\n        virObjectLock(st);\n        st->incomingEOF = true;\n        virNetClientStreamEventTimerUpdate(st);\n        virObjectUnlock(st);\n        return 0;\n    }\n\n    /* Unfortunately, we must allocate new message as the one we\n     * get in @msg is going to be cleared later in the process. */\n\n    if (!(tmp_msg = virNetMessageNew(false)))\n        return -1;\n\n    /* Copy header */\n    memcpy(&tmp_msg->header, &msg->header, sizeof(msg->header));\n\n    /* Steal message buffer */\n    tmp_msg->buffer = msg->buffer;\n    tmp_msg->bufferLength = msg->bufferLength;\n    tmp_msg->bufferOffset = msg->bufferOffset;\n    msg->buffer = NULL;\n    msg->bufferLength = msg->bufferOffset = 0;\n\n    virObjectLock(st);\n\n    /* Don't distinguish VIR_NET_STREAM and VIR_NET_STREAM_SKIP\n     * here just yet. We want in order processing! */\n    virNetMessageQueuePush(&st->rx, tmp_msg);\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No stream found for packet with prog=%d vers=%d serial=%u proc=%u\"",
            "client->msg.header.prog",
            "client->msg.header.vers",
            "client->msg.header.serial",
            "client->msg.header.proc"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamMatches",
          "args": [
            "client->streams[i]",
            "&client->msg"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "169-180",
          "snippet": "bool virNetClientStreamMatches(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    bool match = false;\n    virObjectLock(st);\n    if (virNetClientProgramMatches(st->prog, msg) &&\n        st->proc == msg->header.proc &&\n        st->serial == msg->header.serial)\n        match = true;\n    virObjectUnlock(st);\n    return match;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nbool virNetClientStreamMatches(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    bool match = false;\n    virObjectLock(st);\n    if (virNetClientProgramMatches(st->prog, msg) &&\n        st->proc == msg->header.proc &&\n        st->serial == msg->header.serial)\n        match = true;\n    virObjectUnlock(st);\n    return match;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientCallDispatchStream(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientStreamPtr st = NULL;\n    virNetClientCallPtr thecall;\n\n    /* First identify what stream this packet is directed at */\n    for (i = 0; i < client->nstreams; i++) {\n        if (virNetClientStreamMatches(client->streams[i],\n                                      &client->msg)) {\n            st = client->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        VIR_DEBUG(\"No stream found for packet with prog=%d vers=%d serial=%u proc=%u\",\n                  client->msg.header.prog, client->msg.header.vers,\n                  client->msg.header.serial, client->msg.header.proc);\n        /* Don't return -1, because we expect to see further stream packets\n         * after we've shut it down sometimes */\n        return 0;\n    }\n\n\n    /* Status is either\n     *   - VIR_NET_OK - no payload for streams\n     *   - VIR_NET_ERROR - followed by a remote_error struct\n     *   - VIR_NET_CONTINUE - followed by a raw data packet\n     */\n    switch (client->msg.header.status) {\n    case VIR_NET_CONTINUE: {\n        if (virNetClientStreamQueuePacket(st, &client->msg) < 0)\n            return -1;\n\n        /* Find oldest dummy message waiting for incoming data. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status == VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (thecall) {\n            VIR_DEBUG(\"Got a new incoming stream data\");\n            thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n        }\n        return 0;\n    }\n\n    case VIR_NET_OK:\n        /* Find oldest abort/finish message. */\n        for (thecall = client->waitDispatch; thecall; thecall = thecall->next) {\n            if (thecall->msg->header.prog == client->msg.header.prog &&\n                thecall->msg->header.vers == client->msg.header.vers &&\n                thecall->msg->header.serial == client->msg.header.serial &&\n                thecall->expectReply &&\n                thecall->msg->header.status != VIR_NET_CONTINUE)\n                break;\n        }\n\n        if (!thecall) {\n            VIR_DEBUG(\"Got unexpected async stream finish confirmation\");\n            return -1;\n        }\n\n        VIR_DEBUG(\"Got a synchronous abort/finish confirm\");\n\n        virNetClientStreamSetClosed(st,\n                                    thecall->msg->header.status == VIR_NET_OK ?\n                                        VIR_NET_CLIENT_STREAM_CLOSED_FINISHED :\n                                        VIR_NET_CLIENT_STREAM_CLOSED_ABORTED);\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    case VIR_NET_ERROR:\n        /* No call, so queue the error against the stream */\n        if (virNetClientStreamSetError(st, &client->msg) < 0)\n            return -1;\n\n        virNetClientCallCompleteAllWaitingReply(client);\n        return 0;\n\n    default:\n        VIR_WARN(\"Stream with unexpected serial=%d, proc=%d, status=%d\",\n                 client->msg.header.serial, client->msg.header.proc,\n                 client->msg.header.status);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientCallCompleteAllWaitingReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1145-1156",
    "snippet": "static void virNetClientCallCompleteAllWaitingReply(virNetClientPtr client)\n{\n    virNetClientCallPtr call;\n\n    for (call = client->waitDispatch; call; call = call->next) {\n        if (call->msg->header.prog == client->msg.header.prog &&\n            call->msg->header.vers == client->msg.header.vers &&\n            call->msg->header.serial == client->msg.header.serial &&\n            call->expectReply)\n            call->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic void virNetClientCallCompleteAllWaitingReply(virNetClientPtr client)\n{\n    virNetClientCallPtr call;\n\n    for (call = client->waitDispatch; call; call = call->next) {\n        if (call->msg->header.prog == client->msg.header.prog &&\n            call->msg->header.vers == client->msg.header.vers &&\n            call->msg->header.serial == client->msg.header.serial &&\n            call->expectReply)\n            call->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n    }\n}"
  },
  {
    "function_name": "virNetClientCallDispatchMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1122-1143",
    "snippet": "static int virNetClientCallDispatchMessage(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientProgramPtr prog = NULL;\n\n    for (i = 0; i < client->nprograms; i++) {\n        if (virNetClientProgramMatches(client->programs[i],\n                                       &client->msg)) {\n            prog = client->programs[i];\n            break;\n        }\n    }\n    if (!prog) {\n        VIR_DEBUG(\"No program found for event with prog=%d vers=%d\",\n                  client->msg.header.prog, client->msg.header.vers);\n        return -1;\n    }\n\n    virNetClientProgramDispatch(prog, client, &client->msg);\n\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramDispatch",
          "args": [
            "prog",
            "client",
            "&client->msg"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramDispatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "206-263",
          "snippet": "int virNetClientProgramDispatch(virNetClientProgramPtr prog,\n                                virNetClientPtr client,\n                                virNetMessagePtr msg)\n{\n    virNetClientProgramEventPtr event;\n    char *evdata;\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        VIR_ERROR(_(\"program mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.prog, prog->program);\n        return -1;\n    }\n\n    if (msg->header.vers != prog->version) {\n        VIR_ERROR(_(\"version mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.vers, prog->version);\n        return -1;\n    }\n\n    if (msg->header.status != VIR_NET_OK) {\n        VIR_ERROR(_(\"status mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.status, VIR_NET_OK);\n        return -1;\n    }\n\n    if (msg->header.type != VIR_NET_MESSAGE) {\n        VIR_ERROR(_(\"type mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.type, VIR_NET_MESSAGE);\n        return -1;\n    }\n\n    event = virNetClientProgramGetEvent(prog, msg->header.proc);\n\n    if (!event) {\n        VIR_ERROR(_(\"No event expected with procedure 0x%x\"),\n                  msg->header.proc);\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(evdata, event->msg_len) < 0)\n        return -1;\n\n    if (virNetMessageDecodePayload(msg, event->msg_filter, evdata) < 0)\n        goto cleanup;\n\n    event->func(prog, client, evdata, prog->eventOpaque);\n\n    xdr_free(event->msg_filter, evdata);\n\n cleanup:\n    VIR_FREE(evdata);\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramDispatch(virNetClientProgramPtr prog,\n                                virNetClientPtr client,\n                                virNetMessagePtr msg)\n{\n    virNetClientProgramEventPtr event;\n    char *evdata;\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        VIR_ERROR(_(\"program mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.prog, prog->program);\n        return -1;\n    }\n\n    if (msg->header.vers != prog->version) {\n        VIR_ERROR(_(\"version mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.vers, prog->version);\n        return -1;\n    }\n\n    if (msg->header.status != VIR_NET_OK) {\n        VIR_ERROR(_(\"status mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.status, VIR_NET_OK);\n        return -1;\n    }\n\n    if (msg->header.type != VIR_NET_MESSAGE) {\n        VIR_ERROR(_(\"type mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.type, VIR_NET_MESSAGE);\n        return -1;\n    }\n\n    event = virNetClientProgramGetEvent(prog, msg->header.proc);\n\n    if (!event) {\n        VIR_ERROR(_(\"No event expected with procedure 0x%x\"),\n                  msg->header.proc);\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(evdata, event->msg_len) < 0)\n        return -1;\n\n    if (virNetMessageDecodePayload(msg, event->msg_filter, evdata) < 0)\n        goto cleanup;\n\n    event->func(prog, client, evdata, prog->eventOpaque);\n\n    xdr_free(event->msg_filter, evdata);\n\n cleanup:\n    VIR_FREE(evdata);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No program found for event with prog=%d vers=%d\"",
            "client->msg.header.prog",
            "client->msg.header.vers"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientProgramMatches",
          "args": [
            "client->programs[i]",
            "&client->msg"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "105-112",
          "snippet": "int virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int virNetClientCallDispatchMessage(virNetClientPtr client)\n{\n    size_t i;\n    virNetClientProgramPtr prog = NULL;\n\n    for (i = 0; i < client->nprograms; i++) {\n        if (virNetClientProgramMatches(client->programs[i],\n                                       &client->msg)) {\n            prog = client->programs[i];\n            break;\n        }\n    }\n    if (!prog) {\n        VIR_DEBUG(\"No program found for event with prog=%d vers=%d\",\n                  client->msg.header.prog, client->msg.header.vers);\n        return -1;\n    }\n\n    virNetClientProgramDispatch(prog, client, &client->msg);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientCallDispatchReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1083-1120",
    "snippet": "static int\nvirNetClientCallDispatchReply(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall;\n\n    /* Ok, definitely got an RPC reply now find\n       out which waiting call is associated with it */\n    thecall = client->waitDispatch;\n    while (thecall &&\n           !(thecall->msg->header.prog == client->msg.header.prog &&\n             thecall->msg->header.vers == client->msg.header.vers &&\n             thecall->msg->header.serial == client->msg.header.serial))\n        thecall = thecall->next;\n\n    if (!thecall) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"no call waiting for reply with prog %d vers %d serial %d\"),\n                       client->msg.header.prog, client->msg.header.vers, client->msg.header.serial);\n        return -1;\n    }\n\n    if (VIR_REALLOC_N(thecall->msg->buffer, client->msg.bufferLength) < 0)\n        return -1;\n\n    memcpy(thecall->msg->buffer, client->msg.buffer, client->msg.bufferLength);\n    memcpy(&thecall->msg->header, &client->msg.header, sizeof(client->msg.header));\n    thecall->msg->bufferLength = client->msg.bufferLength;\n    thecall->msg->bufferOffset = client->msg.bufferOffset;\n\n    thecall->msg->nfds = client->msg.nfds;\n    thecall->msg->fds = client->msg.fds;\n    client->msg.nfds = 0;\n    client->msg.fds = NULL;\n\n    thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&thecall->msg->header",
            "&client->msg.header",
            "sizeof(client->msg.header)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "thecall->msg->buffer",
            "client->msg.buffer",
            "client->msg.bufferLength"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "thecall->msg->buffer",
            "client->msg.bufferLength"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"no call waiting for reply with prog %d vers %d serial %d\")",
            "client->msg.header.prog",
            "client->msg.header.vers",
            "client->msg.header.serial"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no call waiting for reply with prog %d vers %d serial %d\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nstatic int\nvirNetClientCallDispatchReply(virNetClientPtr client)\n{\n    virNetClientCallPtr thecall;\n\n    /* Ok, definitely got an RPC reply now find\n       out which waiting call is associated with it */\n    thecall = client->waitDispatch;\n    while (thecall &&\n           !(thecall->msg->header.prog == client->msg.header.prog &&\n             thecall->msg->header.vers == client->msg.header.vers &&\n             thecall->msg->header.serial == client->msg.header.serial))\n        thecall = thecall->next;\n\n    if (!thecall) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"no call waiting for reply with prog %d vers %d serial %d\"),\n                       client->msg.header.prog, client->msg.header.vers, client->msg.header.serial);\n        return -1;\n    }\n\n    if (VIR_REALLOC_N(thecall->msg->buffer, client->msg.bufferLength) < 0)\n        return -1;\n\n    memcpy(thecall->msg->buffer, client->msg.buffer, client->msg.bufferLength);\n    memcpy(&thecall->msg->header, &client->msg.header, sizeof(client->msg.header));\n    thecall->msg->bufferLength = client->msg.bufferLength;\n    thecall->msg->bufferOffset = client->msg.bufferOffset;\n\n    thecall->msg->nfds = client->msg.nfds;\n    thecall->msg->fds = client->msg.fds;\n    client->msg.nfds = 0;\n    client->msg.fds = NULL;\n\n    thecall->mode = VIR_NET_CLIENT_MODE_COMPLETE;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientGetTLSKeySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1073-1081",
    "snippet": "int virNetClientGetTLSKeySize(virNetClientPtr client)\n{\n    int ret = 0;\n    virObjectLock(client);\n    if (client->tls)\n        ret = virNetTLSSessionGetKeySize(client->tls);\n    virObjectUnlock(client);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionGetKeySize",
          "args": [
            "client->tls"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionGetKeySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1385-1401",
          "snippet": "int virNetTLSSessionGetKeySize(virNetTLSSessionPtr sess)\n{\n    gnutls_cipher_algorithm_t cipher;\n    int ssf;\n    virObjectLock(sess);\n    cipher = gnutls_cipher_get(sess->session);\n    if (!(ssf = gnutls_cipher_get_key_size(cipher))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cipher size for TLS session\"));\n        ssf = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ssf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSSessionGetKeySize(virNetTLSSessionPtr sess)\n{\n    gnutls_cipher_algorithm_t cipher;\n    int ssf;\n    virObjectLock(sess);\n    cipher = gnutls_cipher_get(sess->session);\n    if (!(ssf = gnutls_cipher_get_key_size(cipher))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cipher size for TLS session\"));\n        ssf = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ssf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientGetTLSKeySize(virNetClientPtr client)\n{\n    int ret = 0;\n    virObjectLock(client);\n    if (client->tls)\n        ret = virNetTLSSessionGetKeySize(client->tls);\n    virObjectUnlock(client);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientRemoteAddrStringSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1068-1071",
    "snippet": "const char *virNetClientRemoteAddrStringSASL(virNetClientPtr client)\n{\n    return virNetSocketRemoteAddrStringSASL(client->sock);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketRemoteAddrStringSASL",
          "args": [
            "client->sock"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoteAddrStringSASL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1648-1651",
          "snippet": "const char *virNetSocketRemoteAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrSASL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nconst char *virNetSocketRemoteAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrSASL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *virNetClientRemoteAddrStringSASL(virNetClientPtr client)\n{\n    return virNetSocketRemoteAddrStringSASL(client->sock);\n}"
  },
  {
    "function_name": "virNetClientLocalAddrStringSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1063-1066",
    "snippet": "const char *virNetClientLocalAddrStringSASL(virNetClientPtr client)\n{\n    return virNetSocketLocalAddrStringSASL(client->sock);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketLocalAddrStringSASL",
          "args": [
            "client->sock"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketLocalAddrStringSASL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1643-1646",
          "snippet": "const char *virNetSocketLocalAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->localAddrStrSASL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nconst char *virNetSocketLocalAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->localAddrStrSASL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *virNetClientLocalAddrStringSASL(virNetClientPtr client)\n{\n    return virNetSocketLocalAddrStringSASL(client->sock);\n}"
  },
  {
    "function_name": "virNetClientRemoveStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1043-1060",
    "snippet": "void virNetClientRemoveStream(virNetClientPtr client,\n                              virNetClientStreamPtr st)\n{\n    virObjectLock(client);\n    size_t i;\n    for (i = 0; i < client->nstreams; i++) {\n        if (client->streams[i] == st)\n            break;\n    }\n    if (i == client->nstreams)\n        goto cleanup;\n\n    VIR_DELETE_ELEMENT(client->streams, i, client->nstreams);\n    virObjectUnref(st);\n\n cleanup:\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "client->streams",
            "i",
            "client->nstreams"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientRemoveStream(virNetClientPtr client,\n                              virNetClientStreamPtr st)\n{\n    virObjectLock(client);\n    size_t i;\n    for (i = 0; i < client->nstreams; i++) {\n        if (client->streams[i] == st)\n            break;\n    }\n    if (i == client->nstreams)\n        goto cleanup;\n\n    VIR_DELETE_ELEMENT(client->streams, i, client->nstreams);\n    virObjectUnref(st);\n\n cleanup:\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientAddStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1024-1040",
    "snippet": "int virNetClientAddStream(virNetClientPtr client,\n                          virNetClientStreamPtr st)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->streams, client->nstreams, 1) < 0)\n        goto error;\n\n    client->streams[client->nstreams-1] = virObjectRef(st);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "st"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "client->streams",
            "client->nstreams",
            "1"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientAddStream(virNetClientPtr client,\n                          virNetClientStreamPtr st)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->streams, client->nstreams, 1) < 0)\n        goto error;\n\n    client->streams[client->nstreams-1] = virObjectRef(st);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientAddProgram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "1005-1021",
    "snippet": "int virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "prog"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "client->programs",
            "client->nprograms",
            "1"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientIsOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "991-1002",
    "snippet": "bool virNetClientIsOpen(virNetClientPtr client)\n{\n    bool ret;\n\n    if (!client)\n        return false;\n\n    virObjectLock(client);\n    ret = client->sock && !client->wantClose;\n    virObjectUnlock(client);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virNetClientIsOpen(virNetClientPtr client)\n{\n    bool ret;\n\n    if (!client)\n        return false;\n\n    virObjectLock(client);\n    ret = client->sock && !client->wantClose;\n    virObjectUnlock(client);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "976-988",
    "snippet": "bool virNetClientIsEncrypted(virNetClientPtr client)\n{\n    bool ret = false;\n    virObjectLock(client);\n    if (client->tls)\n        ret = true;\n#if WITH_SASL\n    if (client->sasl)\n        ret = true;\n#endif\n    virObjectUnlock(client);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virNetClientIsEncrypted(virNetClientPtr client)\n{\n    bool ret = false;\n    virObjectLock(client);\n    if (client->tls)\n        ret = true;\n#if WITH_SASL\n    if (client->sasl)\n        ret = true;\n#endif\n    virObjectUnlock(client);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientSetTLSSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "879-974",
    "snippet": "int virNetClientSetTLSSession(virNetClientPtr client,\n                              virNetTLSContextPtr tls)\n{\n    int ret;\n    char buf[1];\n    int len;\n\n#ifndef WIN32\n    sigset_t oldmask, blockedsigs;\n\n    sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n    sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n    sigaddset(&blockedsigs, SIGCHLD);\n# endif\n    sigaddset(&blockedsigs, SIGPIPE);\n#endif /* !WIN32 */\n\n    virObjectLock(client);\n\n    if (!(client->tls = virNetTLSSessionNew(tls,\n                                            client->hostname)))\n        goto error;\n\n    virNetSocketSetTLSSession(client->sock, client->tls);\n\n    virResetLastError();\n    if (virNetClientTLSHandshake(client)) {\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n    }\n\n    if (virGetLastErrorCode() != VIR_ERR_OK)\n        goto error;\n\n    ret = virNetTLSContextCheckCertificate(tls, client->tls);\n\n    if (ret < 0)\n        goto error;\n\n    /* At this point, the server is verifying _our_ certificate, IP address,\n     * etc.  If we make the grade, it will send us a '\\1' byte.\n     */\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               G_IO_IN,\n                               client->eventCtx,\n                               virNetClientIOEventTLSConfirm, client, NULL);\n\n#ifndef WIN32\n    /* Block SIGWINCH from interrupting poll in curses programs */\n    ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n    g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n    ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n    len = virNetTLSSessionRead(client->tls, buf, 1);\n    if (len < 0 && errno != ENOMSG) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to read TLS confirmation\"));\n        goto error;\n    }\n    if (len != 1 || buf[0] != '\\1') {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"server verification (of our certificate or IP \"\n                         \"address) failed\"));\n        goto error;\n    }\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n    virObjectUnlock(client);\n    return -1;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client->tls"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"server verification (of our certificate or IP \"\n                         \"address) failed\")"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"server verification (of our certificate or IP \"\n                         \"address) failed\""
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to read TLS confirmation\")"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionRead",
          "args": [
            "client->tls",
            "buf",
            "1"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1308-1336",
          "snippet": "ssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_SETMASK, &oldmask, NULL)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_sigmask",
          "args": [
            "SIG_SETMASK",
            "&oldmask",
            "NULL"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_run",
          "args": [
            "client->eventLoop"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibAddSocketWatch",
          "args": [
            "virNetSocketGetFD(client->sock)",
            "G_IO_IN",
            "client->eventCtx",
            "virNetClientIOEventTLSConfirm",
            "client",
            "NULL"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibAddSocketWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglibwatch.c",
          "lines": "236-249",
          "snippet": "guint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}",
          "includes": [
            "# include <winsock2.h>",
            "#include \"vireventglibwatch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <winsock2.h>\n#include \"vireventglibwatch.h\"\n#include <config.h>\n\nguint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "client->sock"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertificate",
          "args": [
            "tls",
            "client->tls"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertificate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1120-1145",
          "snippet": "int virNetTLSContextCheckCertificate(virNetTLSContextPtr ctxt,\n                                     virNetTLSSessionPtr sess)\n{\n    int ret = -1;\n\n    virObjectLock(ctxt);\n    virObjectLock(sess);\n    if (virNetTLSContextValidCertificate(ctxt, sess) < 0) {\n        VIR_WARN(\"Certificate check failed %s\", virGetLastErrorMessage());\n        if (ctxt->requireValidCert) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Failed to verify peer's certificate\"));\n            goto cleanup;\n        }\n        virResetLastError();\n        VIR_INFO(\"Ignoring bad certificate at user request\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(sess);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSContextCheckCertificate(virNetTLSContextPtr ctxt,\n                                     virNetTLSSessionPtr sess)\n{\n    int ret = -1;\n\n    virObjectLock(ctxt);\n    virObjectLock(sess);\n    if (virNetTLSContextValidCertificate(ctxt, sess) < 0) {\n        VIR_WARN(\"Certificate check failed %s\", virGetLastErrorMessage());\n        if (ctxt->requireValidCert) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Failed to verify peer's certificate\"));\n            goto cleanup;\n        }\n        virResetLastError();\n        VIR_INFO(\"Ignoring bad certificate at user request\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(sess);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_SETMASK, &oldmask, NULL)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_run",
          "args": [
            "client->eventLoop"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientTLSHandshake",
          "args": [
            "client"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientTLSHandshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "826-849",
          "snippet": "static gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketSetTLSSession",
          "args": [
            "client->sock",
            "client->tls"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketSetTLSSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1676-1687",
          "snippet": "void virNetSocketSetTLSSession(virNetSocketPtr sock,\n                               virNetTLSSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->tlsSession);\n    sock->tlsSession = virObjectRef(sess);\n    virNetTLSSessionSetIOCallbacks(sess,\n                                   virNetSocketTLSSessionWrite,\n                                   virNetSocketTLSSessionRead,\n                                   sock);\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketSetTLSSession(virNetSocketPtr sock,\n                               virNetTLSSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->tlsSession);\n    sock->tlsSession = virObjectRef(sess);\n    virNetTLSSessionSetIOCallbacks(sess,\n                                   virNetSocketTLSSessionWrite,\n                                   virNetSocketTLSSessionRead,\n                                   sock);\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionNew",
          "args": [
            "tls",
            "client->hostname"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1188-1259",
          "snippet": "virNetTLSSessionPtr virNetTLSSessionNew(virNetTLSContextPtr ctxt,\n                                        const char *hostname)\n{\n    virNetTLSSessionPtr sess;\n    int err;\n    const char *priority;\n\n    VIR_DEBUG(\"ctxt=%p hostname=%s isServer=%d\",\n              ctxt, NULLSTR(hostname), ctxt->isServer);\n\n    if (!(sess = virObjectLockableNew(virNetTLSSessionClass)))\n        return NULL;\n\n    sess->hostname = g_strdup(hostname);\n\n    if ((err = gnutls_init(&sess->session,\n                           ctxt->isServer ? GNUTLS_SERVER : GNUTLS_CLIENT)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to initialize TLS session: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* avoid calling all the priority functions, since the defaults\n     * are adequate.\n     */\n    priority = ctxt->priority ? ctxt->priority : TLS_PRIORITY;\n    VIR_DEBUG(\"Setting priority string '%s'\", priority);\n    if ((err = gnutls_priority_set_direct(sess->session,\n                                          priority,\n                                          NULL)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to set TLS session priority to %s: %s\"),\n                       priority, gnutls_strerror(err));\n        goto error;\n    }\n\n    if ((err = gnutls_credentials_set(sess->session,\n                                      GNUTLS_CRD_CERTIFICATE,\n                                      ctxt->x509cred)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed set TLS x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* request client certificate if any.\n     */\n    if (ctxt->isServer) {\n        gnutls_certificate_server_set_request(sess->session, GNUTLS_CERT_REQUEST);\n\n        gnutls_dh_set_prime_bits(sess->session, DH_BITS);\n    }\n\n    gnutls_transport_set_ptr(sess->session, sess);\n    gnutls_transport_set_push_function(sess->session,\n                                       virNetTLSSessionPush);\n    gnutls_transport_set_pull_function(sess->session,\n                                       virNetTLSSessionPull);\n\n    sess->isServer = ctxt->isServer;\n\n    PROBE(RPC_TLS_SESSION_NEW,\n          \"sess=%p ctxt=%p hostname=%s isServer=%d\",\n          sess, ctxt, hostname, sess->isServer);\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DH_BITS 2048"
          ],
          "globals_used": [
            "static virClassPtr virNetTLSSessionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSSessionClass;\n\nvirNetTLSSessionPtr virNetTLSSessionNew(virNetTLSContextPtr ctxt,\n                                        const char *hostname)\n{\n    virNetTLSSessionPtr sess;\n    int err;\n    const char *priority;\n\n    VIR_DEBUG(\"ctxt=%p hostname=%s isServer=%d\",\n              ctxt, NULLSTR(hostname), ctxt->isServer);\n\n    if (!(sess = virObjectLockableNew(virNetTLSSessionClass)))\n        return NULL;\n\n    sess->hostname = g_strdup(hostname);\n\n    if ((err = gnutls_init(&sess->session,\n                           ctxt->isServer ? GNUTLS_SERVER : GNUTLS_CLIENT)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to initialize TLS session: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* avoid calling all the priority functions, since the defaults\n     * are adequate.\n     */\n    priority = ctxt->priority ? ctxt->priority : TLS_PRIORITY;\n    VIR_DEBUG(\"Setting priority string '%s'\", priority);\n    if ((err = gnutls_priority_set_direct(sess->session,\n                                          priority,\n                                          NULL)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to set TLS session priority to %s: %s\"),\n                       priority, gnutls_strerror(err));\n        goto error;\n    }\n\n    if ((err = gnutls_credentials_set(sess->session,\n                                      GNUTLS_CRD_CERTIFICATE,\n                                      ctxt->x509cred)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed set TLS x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* request client certificate if any.\n     */\n    if (ctxt->isServer) {\n        gnutls_certificate_server_set_request(sess->session, GNUTLS_CERT_REQUEST);\n\n        gnutls_dh_set_prime_bits(sess->session, DH_BITS);\n    }\n\n    gnutls_transport_set_ptr(sess->session, sess);\n    gnutls_transport_set_push_function(sess->session,\n                                       virNetTLSSessionPush);\n    gnutls_transport_set_pull_function(sess->session,\n                                       virNetTLSSessionPull);\n\n    sess->isServer = ctxt->isServer;\n\n    PROBE(RPC_TLS_SESSION_NEW,\n          \"sess=%p ctxt=%p hostname=%s isServer=%d\",\n          sess, ctxt, hostname, sess->isServer);\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGPIPE"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGCHLD"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blockedsigs",
            "SIGWINCH"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&blockedsigs"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientSetTLSSession(virNetClientPtr client,\n                              virNetTLSContextPtr tls)\n{\n    int ret;\n    char buf[1];\n    int len;\n\n#ifndef WIN32\n    sigset_t oldmask, blockedsigs;\n\n    sigemptyset(&blockedsigs);\n# ifdef SIGWINCH\n    sigaddset(&blockedsigs, SIGWINCH);\n# endif\n# ifdef SIGCHLD\n    sigaddset(&blockedsigs, SIGCHLD);\n# endif\n    sigaddset(&blockedsigs, SIGPIPE);\n#endif /* !WIN32 */\n\n    virObjectLock(client);\n\n    if (!(client->tls = virNetTLSSessionNew(tls,\n                                            client->hostname)))\n        goto error;\n\n    virNetSocketSetTLSSession(client->sock, client->tls);\n\n    virResetLastError();\n    if (virNetClientTLSHandshake(client)) {\n#ifndef WIN32\n        /* Block SIGWINCH from interrupting poll in curses programs,\n         * then restore the original signal mask again immediately\n         * after the call (RHBZ#567931).  Same for SIGCHLD and SIGPIPE\n         * at the suggestion of Paolo Bonzini and Daniel Berrange.\n         */\n        ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n        g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n    }\n\n    if (virGetLastErrorCode() != VIR_ERR_OK)\n        goto error;\n\n    ret = virNetTLSContextCheckCertificate(tls, client->tls);\n\n    if (ret < 0)\n        goto error;\n\n    /* At this point, the server is verifying _our_ certificate, IP address,\n     * etc.  If we make the grade, it will send us a '\\1' byte.\n     */\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               G_IO_IN,\n                               client->eventCtx,\n                               virNetClientIOEventTLSConfirm, client, NULL);\n\n#ifndef WIN32\n    /* Block SIGWINCH from interrupting poll in curses programs */\n    ignore_value(pthread_sigmask(SIG_BLOCK, &blockedsigs, &oldmask));\n#endif /* !WIN32 */\n\n    g_main_loop_run(client->eventLoop);\n\n#ifndef WIN32\n    ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n#endif /* !WIN32 */\n\n    len = virNetTLSSessionRead(client->tls, buf, 1);\n    if (len < 0 && errno != ENOMSG) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to read TLS confirmation\"));\n        goto error;\n    }\n    if (len != 1 || buf[0] != '\\1') {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"server verification (of our certificate or IP \"\n                         \"address) failed\"));\n        goto error;\n    }\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n    virObjectUnlock(client);\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientIOEventTLSConfirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "866-876",
    "snippet": "static gboolean\nvirNetClientIOEventTLSConfirm(int fd G_GNUC_UNUSED,\n                              GIOCondition ev G_GNUC_UNUSED,\n                              gpointer opaque)\n{\n    virNetClientPtr client = opaque;\n\n    g_main_loop_quit(client->eventLoop);\n\n    return G_SOURCE_REMOVE;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "client->eventLoop"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic gboolean\nvirNetClientIOEventTLSConfirm(int fd G_GNUC_UNUSED,\n                              GIOCondition ev G_GNUC_UNUSED,\n                              gpointer opaque)\n{\n    virNetClientPtr client = opaque;\n\n    g_main_loop_quit(client->eventLoop);\n\n    return G_SOURCE_REMOVE;\n}"
  },
  {
    "function_name": "virNetClientIOEventTLS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "852-863",
    "snippet": "static gboolean\nvirNetClientIOEventTLS(int fd G_GNUC_UNUSED,\n                       GIOCondition ev G_GNUC_UNUSED,\n                       gpointer opaque)\n{\n    virNetClientPtr client = opaque;\n\n    if (!virNetClientTLSHandshake(client))\n        g_main_loop_quit(client->eventLoop);\n\n    return G_SOURCE_REMOVE;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "client->eventLoop"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientTLSHandshake",
          "args": [
            "client"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientTLSHandshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "826-849",
          "snippet": "static gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic gboolean\nvirNetClientIOEventTLS(int fd G_GNUC_UNUSED,\n                       GIOCondition ev G_GNUC_UNUSED,\n                       gpointer opaque)\n{\n    virNetClientPtr client = opaque;\n\n    if (!virNetClientTLSHandshake(client))\n        g_main_loop_quit(client->eventLoop);\n\n    return G_SOURCE_REMOVE;\n}"
  },
  {
    "function_name": "virNetClientTLSHandshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "826-849",
    "snippet": "static gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventGLibAddSocketWatch",
          "args": [
            "virNetSocketGetFD(client->sock)",
            "ev",
            "client->eventCtx",
            "virNetClientIOEventTLS",
            "client",
            "NULL"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibAddSocketWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglibwatch.c",
          "lines": "236-249",
          "snippet": "guint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}",
          "includes": [
            "# include <winsock2.h>",
            "#include \"vireventglibwatch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <winsock2.h>\n#include \"vireventglibwatch.h\"\n#include <config.h>\n\nguint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "client->sock"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionGetHandshakeStatus",
          "args": [
            "client->tls"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionGetHandshakeStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1370-1383",
          "snippet": "virNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionHandshake",
          "args": [
            "client->tls"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionHandshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1338-1368",
          "snippet": "int virNetTLSSessionHandshake(virNetTLSSessionPtr sess)\n{\n    int ret;\n    VIR_DEBUG(\"sess=%p\", sess);\n    virObjectLock(sess);\n    ret = gnutls_handshake(sess->session);\n    VIR_DEBUG(\"Ret=%d\", ret);\n    if (ret == 0) {\n        sess->handshakeComplete = true;\n        VIR_DEBUG(\"Handshake is complete\");\n        goto cleanup;\n    }\n    if (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN) {\n        ret = 1;\n        goto cleanup;\n    }\n\n#if 0\n    PROBE(CLIENT_TLS_FAIL, \"fd=%d\",\n          virNetServerClientGetFD(client));\n#endif\n\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"TLS handshake failed %s\"),\n                   gnutls_strerror(ret));\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSSessionHandshake(virNetTLSSessionPtr sess)\n{\n    int ret;\n    VIR_DEBUG(\"sess=%p\", sess);\n    virObjectLock(sess);\n    ret = gnutls_handshake(sess->session);\n    VIR_DEBUG(\"Ret=%d\", ret);\n    if (ret == 0) {\n        sess->handshakeComplete = true;\n        VIR_DEBUG(\"Handshake is complete\");\n        goto cleanup;\n    }\n    if (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN) {\n        ret = 1;\n        goto cleanup;\n    }\n\n#if 0\n    PROBE(CLIENT_TLS_FAIL, \"fd=%d\",\n          virNetServerClientGetFD(client));\n#endif\n\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"TLS handshake failed %s\"),\n                   gnutls_strerror(ret));\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic gboolean\nvirNetClientTLSHandshake(virNetClientPtr client)\n{\n    GIOCondition ev;\n    int ret;\n\n    ret = virNetTLSSessionHandshake(client->tls);\n\n    if (ret <= 0)\n        return FALSE;\n\n    if (virNetTLSSessionGetHandshakeStatus(client->tls) ==\n        VIR_NET_TLS_HANDSHAKE_RECVING)\n        ev = G_IO_IN;\n    else\n        ev = G_IO_OUT;\n\n    virEventGLibAddSocketWatch(virNetSocketGetFD(client->sock),\n                               ev,\n                               client->eventCtx,\n                               virNetClientIOEventTLS, client, NULL);\n\n    return TRUE;\n}"
  },
  {
    "function_name": "virNetClientSetSASLSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "810-817",
    "snippet": "void virNetClientSetSASLSession(virNetClientPtr client,\n                                virNetSASLSessionPtr sasl)\n{\n    virObjectLock(client);\n    client->sasl = virObjectRef(sasl);\n    virNetSocketSetSASLSession(client->sock, client->sasl);\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketSetSASLSession",
          "args": [
            "client->sock",
            "client->sasl"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketSetSASLSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1690-1697",
          "snippet": "void virNetSocketSetSASLSession(virNetSocketPtr sock,\n                                virNetSASLSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->saslSession);\n    sock->saslSession = virObjectRef(sess);\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketSetSASLSession(virNetSocketPtr sock,\n                                virNetSASLSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->saslSession);\n    sock->saslSession = virObjectRef(sess);\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "sasl"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientSetSASLSession(virNetClientPtr client,\n                                virNetSASLSessionPtr sasl)\n{\n    virObjectLock(client);\n    client->sasl = virObjectRef(sasl);\n    virNetSocketSetSASLSession(client->sock, client->sasl);\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "803-806",
    "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientCloseInternal",
          "args": [
            "client",
            "VIR_CONNECT_CLOSE_REASON_CLIENT"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCloseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "772-800",
          "snippet": "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
  },
  {
    "function_name": "virNetClientCloseInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "772-800",
    "snippet": "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientIOEventLoopPassTheBuck",
          "args": [
            "client",
            "NULL"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientIOEventLoopPassTheBuck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1555-1580",
          "snippet": "static void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                               virNetClientCallPtr thiscall);\n\nstatic void\nvirNetClientIOEventLoopPassTheBuck(virNetClientPtr client,\n                                   virNetClientCallPtr thiscall)\n{\n    VIR_DEBUG(\"Giving up the buck %p\", thiscall);\n    virNetClientCallPtr tmp = client->waitDispatch;\n    /* See if someone else is still waiting\n     * and if so, then pass the buck ! */\n    while (tmp) {\n        if (tmp != thiscall && tmp->haveThread) {\n            VIR_DEBUG(\"Passing the buck to %p\", tmp);\n            virCondSignal(&tmp->cond);\n            return;\n        }\n        tmp = tmp->next;\n    }\n    client->haveTheBuck = false;\n\n    VIR_DEBUG(\"No thread to pass the buck to\");\n    if (client->wantClose) {\n        virNetClientCloseLocked(client);\n        virNetClientCallRemovePredicate(&client->waitDispatch,\n                                        virNetClientIOEventLoopRemoveAll,\n                                        thiscall);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "client->eventLoop"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientMarkClose",
          "args": [
            "client",
            "reason"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientMarkClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "708-724",
          "snippet": "static void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p wantclose=%d\"",
            "client",
            "client ? client->wantClose : false"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientCloseLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "727-769",
    "snippet": "static void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closeCb",
          "args": [
            "client",
            "closeReason",
            "closeOpaque"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKeepAliveStop",
          "args": [
            "ka"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "295-310",
          "snippet": "void\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "client->error"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, sock=%p, reason=%d\"",
            "client",
            "client->sock",
            "client->closeReason"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientCloseLocked(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, sock=%p, reason=%d\", client, client->sock, client->closeReason);\n\n    if (!client->sock)\n        return;\n\n    virObjectUnref(client->sock);\n    client->sock = NULL;\n    virObjectUnref(client->tls);\n    client->tls = NULL;\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n    client->sasl = NULL;\n#endif\n    ka = client->keepalive;\n    client->keepalive = NULL;\n    client->wantClose = false;\n\n    virFreeError(client->error);\n    client->error = NULL;\n\n    if (ka || client->closeCb) {\n        virNetClientCloseFunc closeCb = client->closeCb;\n        void *closeOpaque = client->closeOpaque;\n        int closeReason = client->closeReason;\n        virObjectRef(client);\n        virObjectUnlock(client);\n\n        if (ka) {\n            virKeepAliveStop(ka);\n            virObjectUnref(ka);\n        }\n        if (closeCb)\n            closeCb(client, closeReason, closeOpaque);\n\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n}"
  },
  {
    "function_name": "virNetClientMarkClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "708-724",
    "snippet": "static void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSaveLastError",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virSaveLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "401-413",
          "snippet": "virErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRemoveIOCallback",
          "args": [
            "client->sock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoveIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2237-2252",
          "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, reason=%d\"",
            "client",
            "reason"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void\nvirNetClientMarkClose(virNetClientPtr client,\n                      int reason)\n{\n    VIR_DEBUG(\"client=%p, reason=%d\", client, reason);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    /* Don't override reason that's already set. */\n    if (!client->wantClose) {\n        if (!client->error)\n            client->error = virSaveLastError();\n        client->wantClose = true;\n        client->closeReason = reason;\n    }\n}"
  },
  {
    "function_name": "virNetClientDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "676-705",
    "snippet": "void virNetClientDispose(void *obj)\n{\n    virNetClientPtr client = obj;\n    size_t i;\n\n    PROBE(RPC_CLIENT_DISPOSE,\n          \"client=%p\", client);\n\n    if (client->closeFf)\n        client->closeFf(client->closeOpaque);\n\n    for (i = 0; i < client->nprograms; i++)\n        virObjectUnref(client->programs[i]);\n    VIR_FREE(client->programs);\n\n    g_main_loop_unref(client->eventLoop);\n    g_main_context_unref(client->eventCtx);\n\n    VIR_FREE(client->hostname);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n    virObjectUnref(client->sock);\n    virObjectUnref(client->tls);\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n#endif\n\n    virNetMessageClear(&client->msg);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientDispose(void *obj);",
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "&client->msg"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client->sasl"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRemoveIOCallback",
          "args": [
            "client->sock"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoveIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2237-2252",
          "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "client->hostname"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_unref",
          "args": [
            "client->eventCtx"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_unref",
          "args": [
            "client->eventLoop"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "client->programs"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client->closeFf",
          "args": [
            "client->closeOpaque"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_CLIENT_DISPOSE",
            "\"client=%p\"",
            "client"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientDispose(void *obj);\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nvoid virNetClientDispose(void *obj)\n{\n    virNetClientPtr client = obj;\n    size_t i;\n\n    PROBE(RPC_CLIENT_DISPOSE,\n          \"client=%p\", client);\n\n    if (client->closeFf)\n        client->closeFf(client->closeOpaque);\n\n    for (i = 0; i < client->nprograms; i++)\n        virObjectUnref(client->programs[i]);\n    VIR_FREE(client->programs);\n\n    g_main_loop_unref(client->eventLoop);\n    g_main_context_unref(client->eventCtx);\n\n    VIR_FREE(client->hostname);\n\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n    virObjectUnref(client->sock);\n    virObjectUnref(client->tls);\n#if WITH_SASL\n    virObjectUnref(client->sasl);\n#endif\n\n    virNetMessageClear(&client->msg);\n}"
  },
  {
    "function_name": "virNetClientHasPassFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "666-673",
    "snippet": "bool virNetClientHasPassFD(virNetClientPtr client)\n{\n    bool hasPassFD;\n    virObjectLock(client);\n    hasPassFD = virNetSocketHasPassFD(client->sock);\n    virObjectUnlock(client);\n    return hasPassFD;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketHasPassFD",
          "args": [
            "client->sock"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketHasPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1426-1434",
          "snippet": "bool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virNetClientHasPassFD(virNetClientPtr client)\n{\n    bool hasPassFD;\n    virObjectLock(client);\n    hasPassFD = virNetSocketHasPassFD(client->sock);\n    virObjectUnlock(client);\n    return hasPassFD;\n}"
  },
  {
    "function_name": "virNetClientDupFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "656-663",
    "snippet": "int virNetClientDupFD(virNetClientPtr client, bool cloexec)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketDupFD(client->sock, cloexec);\n    virObjectUnlock(client);\n    return fd;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketDupFD",
          "args": [
            "client->sock",
            "cloexec"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketDupFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1386-1412",
          "snippet": "int virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientDupFD(virNetClientPtr client, bool cloexec)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketDupFD(client->sock, cloexec);\n    virObjectUnlock(client);\n    return fd;\n}"
  },
  {
    "function_name": "virNetClientGetFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "646-653",
    "snippet": "int virNetClientGetFD(virNetClientPtr client)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketGetFD(client->sock);\n    virObjectUnlock(client);\n    return fd;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "client->sock"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientGetFD(virNetClientPtr client)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketGetFD(client->sock);\n    virObjectUnlock(client);\n    return fd;\n}"
  },
  {
    "function_name": "virNetClientRegisterKeepAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "617-643",
    "snippet": "int virNetClientRegisterKeepAlive(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    if (client->keepalive)\n        return 0;\n\n    if (!client->asyncIO) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to enable keepalives without async IO support\"));\n        return -1;\n    }\n\n    /* Keepalive protocol consists of async messages so it can only be used\n     * if the client supports them */\n    if (!(ka = virKeepAliveNew(-1, 0, client,\n                               virNetClientKeepAliveSendCB,\n                               virNetClientKeepAliveDeadCB,\n                               virObjectFreeCallback)))\n        return -1;\n\n    /* keepalive object has a reference to client */\n    virObjectRef(client);\n\n    client->keepalive = ka;\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveNew",
          "args": [
            "-1",
            "0",
            "client",
            "virNetClientKeepAliveSendCB",
            "virNetClientKeepAliveDeadCB",
            "virObjectFreeCallback"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "181-213",
          "snippet": "virKeepAlivePtr\nvirKeepAliveNew(int interval,\n                unsigned int count,\n                void *client,\n                virKeepAliveSendFunc sendCB,\n                virKeepAliveDeadFunc deadCB,\n                virKeepAliveFreeFunc freeCB)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, interval=%d, count=%u\", client, interval, count);\n\n    if (virKeepAliveInitialize() < 0)\n        return NULL;\n\n    if (!(ka = virObjectLockableNew(virKeepAliveClass)))\n        return NULL;\n\n    ka->interval = interval;\n    ka->count = count;\n    ka->countToDeath = count;\n    ka->timer = -1;\n    ka->client = client;\n    ka->sendCB = sendCB;\n    ka->deadCB = deadCB;\n    ka->freeCB = freeCB;\n\n    PROBE(RPC_KEEPALIVE_NEW,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    return ka;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virKeepAliveClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virClassPtr virKeepAliveClass;\n\nvirKeepAlivePtr\nvirKeepAliveNew(int interval,\n                unsigned int count,\n                void *client,\n                virKeepAliveSendFunc sendCB,\n                virKeepAliveDeadFunc deadCB,\n                virKeepAliveFreeFunc freeCB)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, interval=%d, count=%u\", client, interval, count);\n\n    if (virKeepAliveInitialize() < 0)\n        return NULL;\n\n    if (!(ka = virObjectLockableNew(virKeepAliveClass)))\n        return NULL;\n\n    ka->interval = interval;\n    ka->count = count;\n    ka->countToDeath = count;\n    ka->timer = -1;\n    ka->client = client;\n    ka->sendCB = sendCB;\n    ka->deadCB = deadCB;\n    ka->freeCB = freeCB;\n\n    PROBE(RPC_KEEPALIVE_NEW,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    return ka;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Unable to enable keepalives without async IO support\")"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to enable keepalives without async IO support\""
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientRegisterKeepAlive(virNetClientPtr client)\n{\n    virKeepAlivePtr ka;\n\n    if (client->keepalive)\n        return 0;\n\n    if (!client->asyncIO) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to enable keepalives without async IO support\"));\n        return -1;\n    }\n\n    /* Keepalive protocol consists of async messages so it can only be used\n     * if the client supports them */\n    if (!(ka = virKeepAliveNew(-1, 0, client,\n                               virNetClientKeepAliveSendCB,\n                               virNetClientKeepAliveDeadCB,\n                               virObjectFreeCallback)))\n        return -1;\n\n    /* keepalive object has a reference to client */\n    virObjectRef(client);\n\n    client->keepalive = ka;\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientRegisterAsyncIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "594-614",
    "snippet": "int virNetClientRegisterAsyncIO(virNetClientPtr client)\n{\n    if (client->asyncIO)\n        return 0;\n\n    /* Set up a callback to listen on the socket data */\n    virObjectRef(client);\n    if (virNetSocketAddIOCallback(client->sock,\n                                  VIR_EVENT_HANDLE_READABLE,\n                                  virNetClientIncomingEvent,\n                                  client,\n                                  virObjectFreeCallback) < 0) {\n        virObjectUnref(client);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to register async IO callback\"));\n        return -1;\n    }\n\n    client->asyncIO = true;\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to register async IO callback\")"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to register async IO callback\""
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketAddIOCallback",
          "args": [
            "client->sock",
            "VIR_EVENT_HANDLE_READABLE",
            "virNetClientIncomingEvent",
            "client",
            "virObjectFreeCallback"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAddIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2186-2220",
          "snippet": "int virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientRegisterAsyncIO(virNetClientPtr client)\n{\n    if (client->asyncIO)\n        return 0;\n\n    /* Set up a callback to listen on the socket data */\n    virObjectRef(client);\n    if (virNetSocketAddIOCallback(client->sock,\n                                  VIR_EVENT_HANDLE_READABLE,\n                                  virNetClientIncomingEvent,\n                                  client,\n                                  virObjectFreeCallback) < 0) {\n        virObjectUnref(client);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to register async IO callback\"));\n        return -1;\n    }\n\n    client->asyncIO = true;\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientNewExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "583-591",
    "snippet": "virNetClientPtr virNetClientNewExternal(const char **cmdargv)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectExternal(cmdargv, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectExternal",
          "args": [
            "cmdargv",
            "&sock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectExternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1179-1191",
          "snippet": "int virNetSocketNewConnectExternal(const char **cmdargv,\n                                   virNetSocketPtr *retsock)\n{\n    virCommandPtr cmd;\n\n    *retsock = NULL;\n\n    cmd = virCommandNewArgs(cmdargv);\n    virCommandAddEnvPassCommon(cmd);\n    virCommandClearCaps(cmd);\n\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectExternal(const char **cmdargv,\n                                   virNetSocketPtr *retsock)\n{\n    virCommandPtr cmd;\n\n    *retsock = NULL;\n\n    cmd = virCommandNewArgs(cmdargv);\n    virCommandAddEnvPassCommon(cmd);\n    virCommandClearCaps(cmd);\n\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewExternal(const char **cmdargv)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectExternal(cmdargv, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
  },
  {
    "function_name": "virNetClientNewLibssh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "506-580",
    "snippet": "virNetClientPtr virNetClientNewLibssh(const char *host,\n                                      const char *port,\n                                      int family,\n                                      const char *username,\n                                      const char *privkeyPath,\n                                      const char *knownHostsPath,\n                                      const char *knownHostsVerify,\n                                      const char *authMethods,\n                                      const char *netcatPath,\n                                      const char *socketPath,\n                                      virConnectAuthPtr authPtr,\n                                      virURIPtr uri)\n{\n    virNetSocketPtr sock = NULL;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *nc = NULL;\n    g_autofree char *command = NULL;\n\n    g_autofree char *homedir = NULL;\n    g_autofree char *confdir = NULL;\n    g_autofree char *knownhosts = NULL;\n    g_autofree char *privkey = NULL;\n\n    /* Use default paths for known hosts an public keys if not provided */\n    if (knownHostsPath) {\n        knownhosts = g_strdup(knownHostsPath);\n    } else {\n        confdir = virGetUserConfigDirectory();\n        knownhosts = g_strdup_printf(\"%s/known_hosts\", confdir);\n    }\n\n    if (privkeyPath) {\n        privkey = g_strdup(privkeyPath);\n    } else {\n        homedir = virGetUserDirectory();\n        if (virNetClientFindDefaultSshKey(homedir, &privkey) < 0)\n            return NULL;\n    }\n\n    if (!authMethods) {\n        if (privkey)\n            authMethods = \"agent,privkey,password,keyboard-interactive\";\n        else\n            authMethods = \"agent,password,keyboard-interactive\";\n    }\n\n    DEFAULT_VALUE(host, \"localhost\");\n    DEFAULT_VALUE(port, \"22\");\n    DEFAULT_VALUE(username, \"root\");\n    DEFAULT_VALUE(netcatPath, \"nc\");\n    DEFAULT_VALUE(knownHostsVerify, \"normal\");\n\n    virBufferEscapeShell(&buf, netcatPath);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n    virBufferEscapeShell(&buf, nc);\n    VIR_FREE(nc);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    command = g_strdup_printf(\"sh -c \"\n                              \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n                              \"ARG=-q0;\" \"else \" \"ARG=;\" \"fi;\" \"'%s' $ARG -U %s'\", nc, nc,\n                              socketPath);\n\n    if (virNetSocketNewConnectLibssh(host, port,\n                                     family,\n                                     username, privkey,\n                                     knownhosts, knownHostsVerify, authMethods,\n                                     command, authPtr, uri, &sock) != 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectLibssh",
          "args": [
            "host",
            "port",
            "family",
            "username",
            "privkey",
            "knownhosts",
            "knownHostsVerify",
            "authMethods",
            "command",
            "authPtr",
            "uri",
            "&sock"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectLibssh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1159-1176",
          "snippet": "int\nvirNetSocketNewConnectLibssh(const char *host G_GNUC_UNUSED,\n                             const char *port G_GNUC_UNUSED,\n                             int family G_GNUC_UNUSED,\n                             const char *username G_GNUC_UNUSED,\n                             const char *privkey G_GNUC_UNUSED,\n                             const char *knownHosts G_GNUC_UNUSED,\n                             const char *knownHostsVerify G_GNUC_UNUSED,\n                             const char *authMethods G_GNUC_UNUSED,\n                             const char *command G_GNUC_UNUSED,\n                             virConnectAuthPtr auth G_GNUC_UNUSED,\n                             virURIPtr uri G_GNUC_UNUSED,\n                             virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh transport support was not enabled\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibssh(const char *host G_GNUC_UNUSED,\n                             const char *port G_GNUC_UNUSED,\n                             int family G_GNUC_UNUSED,\n                             const char *username G_GNUC_UNUSED,\n                             const char *privkey G_GNUC_UNUSED,\n                             const char *knownHosts G_GNUC_UNUSED,\n                             const char *knownHostsVerify G_GNUC_UNUSED,\n                             const char *authMethods G_GNUC_UNUSED,\n                             const char *command G_GNUC_UNUSED,\n                             virConnectAuthPtr auth G_GNUC_UNUSED,\n                             virURIPtr uri G_GNUC_UNUSED,\n                             virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh transport support was not enabled\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"sh -c \"\n                              \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n                              \"ARG=-q0;\" \"else \" \"ARG=;\" \"fi;\" \"'%s' $ARG -U %s'\"",
            "nc",
            "nc",
            "socketPath"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nc"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeShell",
          "args": [
            "&buf",
            "nc"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeShell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "554-597",
          "snippet": "void\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "knownHostsVerify",
            "\"normal\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "netcatPath",
            "\"nc\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "username",
            "\"root\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "port",
            "\"22\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "host",
            "\"localhost\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientFindDefaultSshKey",
          "args": [
            "homedir",
            "&privkey"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientFindDefaultSshKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "350-364",
          "snippet": "static int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserDirectory",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "567-571",
          "snippet": "char *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserConfigDirectory",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserConfigDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "574-581",
          "snippet": "char *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewLibssh(const char *host,\n                                      const char *port,\n                                      int family,\n                                      const char *username,\n                                      const char *privkeyPath,\n                                      const char *knownHostsPath,\n                                      const char *knownHostsVerify,\n                                      const char *authMethods,\n                                      const char *netcatPath,\n                                      const char *socketPath,\n                                      virConnectAuthPtr authPtr,\n                                      virURIPtr uri)\n{\n    virNetSocketPtr sock = NULL;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *nc = NULL;\n    g_autofree char *command = NULL;\n\n    g_autofree char *homedir = NULL;\n    g_autofree char *confdir = NULL;\n    g_autofree char *knownhosts = NULL;\n    g_autofree char *privkey = NULL;\n\n    /* Use default paths for known hosts an public keys if not provided */\n    if (knownHostsPath) {\n        knownhosts = g_strdup(knownHostsPath);\n    } else {\n        confdir = virGetUserConfigDirectory();\n        knownhosts = g_strdup_printf(\"%s/known_hosts\", confdir);\n    }\n\n    if (privkeyPath) {\n        privkey = g_strdup(privkeyPath);\n    } else {\n        homedir = virGetUserDirectory();\n        if (virNetClientFindDefaultSshKey(homedir, &privkey) < 0)\n            return NULL;\n    }\n\n    if (!authMethods) {\n        if (privkey)\n            authMethods = \"agent,privkey,password,keyboard-interactive\";\n        else\n            authMethods = \"agent,password,keyboard-interactive\";\n    }\n\n    DEFAULT_VALUE(host, \"localhost\");\n    DEFAULT_VALUE(port, \"22\");\n    DEFAULT_VALUE(username, \"root\");\n    DEFAULT_VALUE(netcatPath, \"nc\");\n    DEFAULT_VALUE(knownHostsVerify, \"normal\");\n\n    virBufferEscapeShell(&buf, netcatPath);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n    virBufferEscapeShell(&buf, nc);\n    VIR_FREE(nc);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    command = g_strdup_printf(\"sh -c \"\n                              \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n                              \"ARG=-q0;\" \"else \" \"ARG=;\" \"fi;\" \"'%s' $ARG -U %s'\", nc, nc,\n                              socketPath);\n\n    if (virNetSocketNewConnectLibssh(host, port,\n                                     family,\n                                     username, privkey,\n                                     knownhosts, knownHostsVerify, authMethods,\n                                     command, authPtr, uri, &sock) != 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
  },
  {
    "function_name": "virNetClientNewLibSSH2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "416-500",
    "snippet": "virNetClientPtr virNetClientNewLibSSH2(const char *host,\n                                       const char *port,\n                                       int family,\n                                       const char *username,\n                                       const char *privkeyPath,\n                                       const char *knownHostsPath,\n                                       const char *knownHostsVerify,\n                                       const char *authMethods,\n                                       const char *netcatPath,\n                                       const char *socketPath,\n                                       virConnectAuthPtr authPtr,\n                                       virURIPtr uri)\n{\n    virNetSocketPtr sock = NULL;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *nc = NULL;\n    g_autofree char *command = NULL;\n\n    g_autofree char *homedir = NULL;\n    g_autofree char *confdir = NULL;\n    g_autofree char *knownhosts = NULL;\n    g_autofree char *privkey = NULL;\n\n    /* Use default paths for known hosts an public keys if not provided */\n    if (knownHostsPath) {\n        knownhosts = g_strdup(knownHostsPath);\n    } else {\n        confdir = virGetUserConfigDirectory();\n        virBufferAsprintf(&buf, \"%s/known_hosts\", confdir);\n        if (!(knownhosts = virBufferContentAndReset(&buf)))\n            return NULL;\n    }\n\n    if (privkeyPath) {\n        privkey = g_strdup(privkeyPath);\n    } else {\n        homedir = virGetUserDirectory();\n        if (virNetClientFindDefaultSshKey(homedir, &privkey) < 0)\n            return NULL;\n    }\n\n    if (!authMethods) {\n        if (privkey)\n            authMethods = \"agent,privkey,password,keyboard-interactive\";\n        else\n            authMethods = \"agent,password,keyboard-interactive\";\n    }\n\n    DEFAULT_VALUE(host, \"localhost\");\n    DEFAULT_VALUE(port, \"22\");\n    DEFAULT_VALUE(username, \"root\");\n    DEFAULT_VALUE(netcatPath, \"nc\");\n    DEFAULT_VALUE(knownHostsVerify, \"normal\");\n\n    virBufferEscapeShell(&buf, netcatPath);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n    virBufferEscapeShell(&buf, nc);\n    VIR_FREE(nc);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    virBufferAsprintf(&buf,\n         \"sh -c \"\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         nc, nc, socketPath);\n\n    if (!(command = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    if (virNetSocketNewConnectLibSSH2(host, port,\n                                      family,\n                                      username, privkey,\n                                      knownhosts, knownHostsVerify, authMethods,\n                                      command, authPtr, uri, &sock) != 0)\n        return NULL;\n\n   return virNetClientNew(sock, NULL);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectLibSSH2",
          "args": [
            "host",
            "port",
            "family",
            "username",
            "privkey",
            "knownhosts",
            "knownHostsVerify",
            "authMethods",
            "command",
            "authPtr",
            "uri",
            "&sock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectLibSSH2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1025-1042",
          "snippet": "int\nvirNetSocketNewConnectLibSSH2(const char *host G_GNUC_UNUSED,\n                              const char *port G_GNUC_UNUSED,\n                              int family G_GNUC_UNUSED,\n                              const char *username G_GNUC_UNUSED,\n                              const char *privkey G_GNUC_UNUSED,\n                              const char *knownHosts G_GNUC_UNUSED,\n                              const char *knownHostsVerify G_GNUC_UNUSED,\n                              const char *authMethods G_GNUC_UNUSED,\n                              const char *command G_GNUC_UNUSED,\n                              virConnectAuthPtr auth G_GNUC_UNUSED,\n                              virURIPtr uri G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh2 transport support was not enabled\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibSSH2(const char *host G_GNUC_UNUSED,\n                              const char *port G_GNUC_UNUSED,\n                              int family G_GNUC_UNUSED,\n                              const char *username G_GNUC_UNUSED,\n                              const char *privkey G_GNUC_UNUSED,\n                              const char *knownHosts G_GNUC_UNUSED,\n                              const char *knownHostsVerify G_GNUC_UNUSED,\n                              const char *authMethods G_GNUC_UNUSED,\n                              const char *command G_GNUC_UNUSED,\n                              virConnectAuthPtr auth G_GNUC_UNUSED,\n                              virURIPtr uri G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh2 transport support was not enabled\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"sh -c \"\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\"",
            "nc",
            "nc",
            "socketPath"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nc"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeShell",
          "args": [
            "&buf",
            "nc"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeShell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "554-597",
          "snippet": "void\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "knownHostsVerify",
            "\"normal\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "netcatPath",
            "\"nc\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "username",
            "\"root\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "port",
            "\"22\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_VALUE",
          "args": [
            "host",
            "\"localhost\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientFindDefaultSshKey",
          "args": [
            "homedir",
            "&privkey"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientFindDefaultSshKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "350-364",
          "snippet": "static int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserDirectory",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "567-571",
          "snippet": "char *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "privkeyPath"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserConfigDirectory",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserConfigDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "574-581",
          "snippet": "char *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewLibSSH2(const char *host,\n                                       const char *port,\n                                       int family,\n                                       const char *username,\n                                       const char *privkeyPath,\n                                       const char *knownHostsPath,\n                                       const char *knownHostsVerify,\n                                       const char *authMethods,\n                                       const char *netcatPath,\n                                       const char *socketPath,\n                                       virConnectAuthPtr authPtr,\n                                       virURIPtr uri)\n{\n    virNetSocketPtr sock = NULL;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *nc = NULL;\n    g_autofree char *command = NULL;\n\n    g_autofree char *homedir = NULL;\n    g_autofree char *confdir = NULL;\n    g_autofree char *knownhosts = NULL;\n    g_autofree char *privkey = NULL;\n\n    /* Use default paths for known hosts an public keys if not provided */\n    if (knownHostsPath) {\n        knownhosts = g_strdup(knownHostsPath);\n    } else {\n        confdir = virGetUserConfigDirectory();\n        virBufferAsprintf(&buf, \"%s/known_hosts\", confdir);\n        if (!(knownhosts = virBufferContentAndReset(&buf)))\n            return NULL;\n    }\n\n    if (privkeyPath) {\n        privkey = g_strdup(privkeyPath);\n    } else {\n        homedir = virGetUserDirectory();\n        if (virNetClientFindDefaultSshKey(homedir, &privkey) < 0)\n            return NULL;\n    }\n\n    if (!authMethods) {\n        if (privkey)\n            authMethods = \"agent,privkey,password,keyboard-interactive\";\n        else\n            authMethods = \"agent,password,keyboard-interactive\";\n    }\n\n    DEFAULT_VALUE(host, \"localhost\");\n    DEFAULT_VALUE(port, \"22\");\n    DEFAULT_VALUE(username, \"root\");\n    DEFAULT_VALUE(netcatPath, \"nc\");\n    DEFAULT_VALUE(knownHostsVerify, \"normal\");\n\n    virBufferEscapeShell(&buf, netcatPath);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n    virBufferEscapeShell(&buf, nc);\n    VIR_FREE(nc);\n    if (!(nc = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    virBufferAsprintf(&buf,\n         \"sh -c \"\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         nc, nc, socketPath);\n\n    if (!(command = virBufferContentAndReset(&buf)))\n        return NULL;\n\n    if (virNetSocketNewConnectLibSSH2(host, port,\n                                      family,\n                                      username, privkey,\n                                      knownhosts, knownHostsVerify, authMethods,\n                                      command, authPtr, uri, &sock) != 0)\n        return NULL;\n\n   return virNetClientNew(sock, NULL);\n}"
  },
  {
    "function_name": "virNetClientNewSSH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "394-411",
    "snippet": "virNetClientPtr virNetClientNewSSH(const char *nodename,\n                                   const char *service,\n                                   const char *binary,\n                                   const char *username,\n                                   bool noTTY,\n                                   bool noVerify,\n                                   const char *netcat,\n                                   const char *keyfile,\n                                   const char *path)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectSSH(nodename, service, binary, username, noTTY,\n                                  noVerify, netcat, keyfile, path, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectSSH",
          "args": [
            "nodename",
            "service",
            "binary",
            "username",
            "noTTY",
            "noVerify",
            "netcat",
            "keyfile",
            "path",
            "&sock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectSSH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "839-910",
          "snippet": "int virNetSocketNewConnectSSH(const char *nodename,\n                              const char *service,\n                              const char *binary,\n                              const char *username,\n                              bool noTTY,\n                              bool noVerify,\n                              const char *netcat,\n                              const char *keyfile,\n                              const char *path,\n                              virNetSocketPtr *retsock)\n{\n    char *quoted;\n    virCommandPtr cmd;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    *retsock = NULL;\n\n    cmd = virCommandNew(binary ? binary : \"ssh\");\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"KRB5CCNAME\");\n    virCommandAddEnvPass(cmd, \"SSH_AUTH_SOCK\");\n    virCommandAddEnvPass(cmd, \"SSH_ASKPASS\");\n    virCommandAddEnvPass(cmd, \"DISPLAY\");\n    virCommandAddEnvPass(cmd, \"XAUTHORITY\");\n    virCommandClearCaps(cmd);\n\n    if (service)\n        virCommandAddArgList(cmd, \"-p\", service, NULL);\n    if (username)\n        virCommandAddArgList(cmd, \"-l\", username, NULL);\n    if (keyfile)\n        virCommandAddArgList(cmd, \"-i\", keyfile, NULL);\n    virCommandAddArgList(cmd, \"-T\", \"-e\", \"none\", NULL);\n    if (noTTY)\n        virCommandAddArgList(cmd, \"-o\", \"BatchMode=yes\", NULL);\n    if (noVerify)\n        virCommandAddArgList(cmd, \"-o\", \"StrictHostKeyChecking=no\", NULL);\n\n    if (!netcat)\n        netcat = \"nc\";\n\n    virCommandAddArgList(cmd, \"--\", nodename, \"sh\", \"-c\", NULL);\n\n    virBufferEscapeShell(&buf, netcat);\n    quoted = virBufferContentAndReset(&buf);\n\n    virBufferEscapeShell(&buf, quoted);\n    VIR_FREE(quoted);\n    quoted = virBufferContentAndReset(&buf);\n\n    /*\n     * This ugly thing is a shell script to detect availability of\n     * the -q option for 'nc': debian and suse based distros need this\n     * flag to ensure the remote nc will exit on EOF, so it will go away\n     * when we close the connection tunnel. If it doesn't go away, subsequent\n     * connection attempts will hang.\n     *\n     * Fedora's 'nc' doesn't have this option, and defaults to the desired\n     * behavior.\n     */\n    virCommandAddArgFormat(cmd,\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         quoted, quoted, path);\n\n    VIR_FREE(quoted);\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectSSH(const char *nodename,\n                              const char *service,\n                              const char *binary,\n                              const char *username,\n                              bool noTTY,\n                              bool noVerify,\n                              const char *netcat,\n                              const char *keyfile,\n                              const char *path,\n                              virNetSocketPtr *retsock)\n{\n    char *quoted;\n    virCommandPtr cmd;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    *retsock = NULL;\n\n    cmd = virCommandNew(binary ? binary : \"ssh\");\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"KRB5CCNAME\");\n    virCommandAddEnvPass(cmd, \"SSH_AUTH_SOCK\");\n    virCommandAddEnvPass(cmd, \"SSH_ASKPASS\");\n    virCommandAddEnvPass(cmd, \"DISPLAY\");\n    virCommandAddEnvPass(cmd, \"XAUTHORITY\");\n    virCommandClearCaps(cmd);\n\n    if (service)\n        virCommandAddArgList(cmd, \"-p\", service, NULL);\n    if (username)\n        virCommandAddArgList(cmd, \"-l\", username, NULL);\n    if (keyfile)\n        virCommandAddArgList(cmd, \"-i\", keyfile, NULL);\n    virCommandAddArgList(cmd, \"-T\", \"-e\", \"none\", NULL);\n    if (noTTY)\n        virCommandAddArgList(cmd, \"-o\", \"BatchMode=yes\", NULL);\n    if (noVerify)\n        virCommandAddArgList(cmd, \"-o\", \"StrictHostKeyChecking=no\", NULL);\n\n    if (!netcat)\n        netcat = \"nc\";\n\n    virCommandAddArgList(cmd, \"--\", nodename, \"sh\", \"-c\", NULL);\n\n    virBufferEscapeShell(&buf, netcat);\n    quoted = virBufferContentAndReset(&buf);\n\n    virBufferEscapeShell(&buf, quoted);\n    VIR_FREE(quoted);\n    quoted = virBufferContentAndReset(&buf);\n\n    /*\n     * This ugly thing is a shell script to detect availability of\n     * the -q option for 'nc': debian and suse based distros need this\n     * flag to ensure the remote nc will exit on EOF, so it will go away\n     * when we close the connection tunnel. If it doesn't go away, subsequent\n     * connection attempts will hang.\n     *\n     * Fedora's 'nc' doesn't have this option, and defaults to the desired\n     * behavior.\n     */\n    virCommandAddArgFormat(cmd,\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         quoted, quoted, path);\n\n    VIR_FREE(quoted);\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewSSH(const char *nodename,\n                                   const char *service,\n                                   const char *binary,\n                                   const char *username,\n                                   bool noTTY,\n                                   bool noVerify,\n                                   const char *netcat,\n                                   const char *keyfile,\n                                   const char *path)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectSSH(nodename, service, binary, username, noTTY,\n                                  noVerify, netcat, keyfile, path, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
  },
  {
    "function_name": "virNetClientNewTCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "380-392",
    "snippet": "virNetClientPtr virNetClientNewTCP(const char *nodename,\n                                   const char *service,\n                                   int family)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectTCP(nodename, service,\n                                  family,\n                                  &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, nodename);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "nodename"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectTCP",
          "args": [
            "nodename",
            "service",
            "family",
            "&sock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "558-640",
          "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewTCP(const char *nodename,\n                                   const char *service,\n                                   int family)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectTCP(nodename, service,\n                                  family,\n                                  &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, nodename);\n}"
  },
  {
    "function_name": "virNetClientNewUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "367-377",
    "snippet": "virNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientNew",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "292-320",
          "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectUNIX",
          "args": [
            "path",
            "spawnDaemon",
            "binary",
            "&sock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "765-773",
          "snippet": "int virNetSocketNewConnectUNIX(const char *path G_GNUC_UNUSED,\n                               bool spawnDaemon G_GNUC_UNUSED,\n                               const char *binary G_GNUC_UNUSED,\n                               virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectUNIX(const char *path G_GNUC_UNUSED,\n                               bool spawnDaemon G_GNUC_UNUSED,\n                               const char *binary G_GNUC_UNUSED,\n                               virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
  },
  {
    "function_name": "virNetClientFindDefaultSshKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "350-364",
    "snippet": "static int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientCheckKeyExists",
          "args": [
            "homedir",
            "keys[i]",
            "retPath"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCheckKeyExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "327-343",
          "snippet": "static int\nvirNetClientCheckKeyExists(const char *homedir,\n                           const char *name,\n                           char **retPath)\n{\n    char *path;\n\n    path = g_strdup_printf(\"%s/.ssh/%s\", homedir, name);\n\n    if (!(virFileExists(path))) {\n        VIR_FREE(path);\n        return 0;\n    }\n\n    *retPath = path;\n    return 1;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientCheckKeyExists(const char *homedir,\n                           const char *name,\n                           char **retPath)\n{\n    char *path;\n\n    path = g_strdup_printf(\"%s/.ssh/%s\", homedir, name);\n\n    if (!(virFileExists(path))) {\n        VIR_FREE(path);\n        return 0;\n    }\n\n    *retPath = path;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "keys"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientFindDefaultSshKey(const char *homedir, char **retPath)\n{\n    size_t i;\n\n    const char *keys[] = { \"identity\", \"id_dsa\", \"id_ecdsa\", \"id_ed25519\", \"id_rsa\" };\n\n    for (i = 0; i < G_N_ELEMENTS(keys); ++i) {\n        int ret = virNetClientCheckKeyExists(homedir, keys[i], retPath);\n        if (ret != 0)\n            return ret;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientCheckKeyExists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "327-343",
    "snippet": "static int\nvirNetClientCheckKeyExists(const char *homedir,\n                           const char *name,\n                           char **retPath)\n{\n    char *path;\n\n    path = g_strdup_printf(\"%s/.ssh/%s\", homedir, name);\n\n    if (!(virFileExists(path))) {\n        VIR_FREE(path);\n        return 0;\n    }\n\n    *retPath = path;\n    return 1;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/.ssh/%s\"",
            "homedir",
            "name"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientCheckKeyExists(const char *homedir,\n                           const char *name,\n                           char **retPath)\n{\n    char *path;\n\n    path = g_strdup_printf(\"%s/.ssh/%s\", homedir, name);\n\n    if (!(virFileExists(path))) {\n        VIR_FREE(path);\n        return 0;\n    }\n\n    *retPath = path;\n    return 1;\n}"
  },
  {
    "function_name": "virNetClientNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "292-320",
    "snippet": "static virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetClientClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_CLIENT_NEW",
            "\"client=%p sock=%p\"",
            "client",
            "client->sock"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hostname"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_new",
          "args": [
            "client->eventCtx",
            "FALSE"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_new",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetClientClass"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientInitialize",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientClass;\n\nstatic virNetClientPtr virNetClientNew(virNetSocketPtr sock,\n                                       const char *hostname)\n{\n    virNetClientPtr client = NULL;\n\n    if (virNetClientInitialize() < 0)\n        goto error;\n\n    if (!(client = virObjectLockableNew(virNetClientClass)))\n        goto error;\n\n    client->sock = sock;\n    sock = NULL;\n\n    client->eventCtx = g_main_context_new();\n    client->eventLoop = g_main_loop_new(client->eventCtx, FALSE);\n\n    client->hostname = g_strdup(hostname);\n\n    PROBE(RPC_CLIENT_NEW,\n          \"client=%p sock=%p\",\n          client, client->sock);\n    return client;\n\n error:\n    virObjectUnref(client);\n    virObjectUnref(sock);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetClientKeepAliveSendCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "280-290",
    "snippet": "static int\nvirNetClientKeepAliveSendCB(void *opaque,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    ret = virNetClientSendNonBlock(opaque, msg);\n    if (ret != -1 && ret != 1)\n        virNetMessageFree(msg);\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);",
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendNonBlock",
          "args": [
            "opaque",
            "msg"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2167-2175",
          "snippet": "int virNetClientSendNonBlock(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, false, true);\n    virObjectUnlock(client);\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendNonBlock(virNetClientPtr client,\n                             virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, false, true);\n    virObjectUnlock(client);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic int\nvirNetClientKeepAliveSendCB(void *opaque,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    ret = virNetClientSendNonBlock(opaque, msg);\n    if (ret != -1 && ret != 1)\n        virNetMessageFree(msg);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientKeepAliveDeadCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "274-278",
    "snippet": "static void\nvirNetClientKeepAliveDeadCB(void *opaque)\n{\n    virNetClientCloseInternal(opaque, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientCloseInternal",
          "args": [
            "opaque",
            "VIR_CONNECT_CLOSE_REASON_KEEPALIVE"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientCloseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "772-800",
          "snippet": "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason);\n\nstatic void virNetClientCloseInternal(virNetClientPtr client,\n                                      int reason)\n{\n    VIR_DEBUG(\"client=%p wantclose=%d\", client, client ? client->wantClose : false);\n\n    if (!client)\n        return;\n\n    if (!client->sock ||\n        client->wantClose)\n        return;\n\n    virObjectLock(client);\n\n    virNetClientMarkClose(client, reason);\n\n    /* If there is a thread polling for data on the socket, wake the thread up\n     * otherwise try to pass the buck to a possibly waiting thread. If no\n     * thread is waiting, virNetClientIOEventLoopPassTheBuck will clean the\n     * queue and close the client because we set client->wantClose.\n     */\n    if (client->haveTheBuck) {\n        g_main_loop_quit(client->eventLoop);\n    } else {\n        virNetClientIOEventLoopPassTheBuck(client, NULL);\n    }\n\n    virObjectUnlock(client);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic void\nvirNetClientKeepAliveDeadCB(void *opaque)\n{\n    virNetClientCloseInternal(opaque, VIR_CONNECT_CLOSE_REASON_KEEPALIVE);\n}"
  },
  {
    "function_name": "virNetClientKeepAliveStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "266-272",
    "snippet": "void\nvirNetClientKeepAliveStop(virNetClientPtr client)\n{\n    virObjectLock(client);\n    virKeepAliveStop(client->keepalive);\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveStop",
          "args": [
            "client->keepalive"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "295-310",
          "snippet": "void\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetClientKeepAliveStop(virNetClientPtr client)\n{\n    virObjectLock(client);\n    virKeepAliveStop(client->keepalive);\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientKeepAliveStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "252-264",
    "snippet": "int\nvirNetClientKeepAliveStart(virNetClientPtr client,\n                           int interval,\n                           unsigned int count)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virKeepAliveStart(client->keepalive, interval, count);\n    virObjectUnlock(client);\n\n    return ret;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveStart",
          "args": [
            "client->keepalive",
            "interval",
            "count"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "228-292",
          "snippet": "int\nvirKeepAliveStart(virKeepAlivePtr ka,\n                  int interval,\n                  unsigned int count)\n{\n    int ret = -1;\n    time_t delay;\n    int timeout;\n    time_t now;\n\n    virObjectLock(ka);\n\n    if (ka->timer >= 0) {\n        VIR_DEBUG(\"Keepalive messages already enabled\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (interval > 0) {\n        if (ka->interval > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"keepalive interval already set\"));\n            goto cleanup;\n        }\n        /* Guard against overflow */\n        if (interval > INT_MAX / 1000) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"keepalive interval %d too large\"), interval);\n            goto cleanup;\n        }\n        ka->interval = interval;\n        ka->count = count;\n        ka->countToDeath = count;\n    }\n\n    if (ka->interval <= 0) {\n        VIR_DEBUG(\"Keepalive messages disabled by configuration\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    PROBE(RPC_KEEPALIVE_START,\n          \"ka=%p client=%p interval=%d count=%u\",\n          ka, ka->client, interval, count);\n\n    now = time(NULL);\n    delay = now - ka->lastPacketReceived;\n    if (delay > ka->interval)\n        timeout = 0;\n    else\n        timeout = ka->interval - delay;\n    ka->intervalStart = now - (ka->interval - timeout);\n    ka->timer = virEventAddTimeout(timeout * 1000, virKeepAliveTimer,\n                                   ka, virObjectFreeCallback);\n    if (ka->timer < 0)\n        goto cleanup;\n\n    /* the timer now has another reference to this object */\n    virObjectRef(ka);\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ka);\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirKeepAliveStart(virKeepAlivePtr ka,\n                  int interval,\n                  unsigned int count)\n{\n    int ret = -1;\n    time_t delay;\n    int timeout;\n    time_t now;\n\n    virObjectLock(ka);\n\n    if (ka->timer >= 0) {\n        VIR_DEBUG(\"Keepalive messages already enabled\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (interval > 0) {\n        if (ka->interval > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"keepalive interval already set\"));\n            goto cleanup;\n        }\n        /* Guard against overflow */\n        if (interval > INT_MAX / 1000) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"keepalive interval %d too large\"), interval);\n            goto cleanup;\n        }\n        ka->interval = interval;\n        ka->count = count;\n        ka->countToDeath = count;\n    }\n\n    if (ka->interval <= 0) {\n        VIR_DEBUG(\"Keepalive messages disabled by configuration\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    PROBE(RPC_KEEPALIVE_START,\n          \"ka=%p client=%p interval=%d count=%u\",\n          ka, ka->client, interval, count);\n\n    now = time(NULL);\n    delay = now - ka->lastPacketReceived;\n    if (delay > ka->interval)\n        timeout = 0;\n    else\n        timeout = ka->interval - delay;\n    ka->intervalStart = now - (ka->interval - timeout);\n    ka->timer = virEventAddTimeout(timeout * 1000, virKeepAliveTimer,\n                                   ka, virObjectFreeCallback);\n    if (ka->timer < 0)\n        goto cleanup;\n\n    /* the timer now has another reference to this object */\n    virObjectRef(ka);\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ka);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetClientKeepAliveStart(virNetClientPtr client,\n                           int interval,\n                           unsigned int count)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virKeepAliveStart(client->keepalive, interval, count);\n    virObjectUnlock(client);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientKeepAliveIsSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "240-250",
    "snippet": "bool\nvirNetClientKeepAliveIsSupported(virNetClientPtr client)\n{\n    bool supported;\n\n    virObjectLock(client);\n    supported = !!client->keepalive;\n    virObjectUnlock(client);\n\n    return supported;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirNetClientKeepAliveIsSupported(virNetClientPtr client)\n{\n    bool supported;\n\n    virObjectLock(client);\n    supported = !!client->keepalive;\n    virObjectUnlock(client);\n\n    return supported;\n}"
  },
  {
    "function_name": "virNetClientCallMatchPredicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "226-237",
    "snippet": "static bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred",
          "args": [
            "tmp",
            "opaque"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic bool virNetClientCallMatchPredicate(virNetClientCallPtr head,\n                                           virNetClientCallPredicate pred,\n                                           void *opaque)\n{\n    virNetClientCallPtr tmp = head;\n    while (tmp) {\n        if (pred(tmp, opaque))\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}"
  },
  {
    "function_name": "virNetClientCallRemovePredicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "203-223",
    "snippet": "static void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred",
          "args": [
            "tmp",
            "opaque"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nstatic void virNetClientCallRemovePredicate(virNetClientCallPtr *head,\n                                            virNetClientCallPredicate pred,\n                                            void *opaque)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        virNetClientCallPtr next = tmp->next;\n        tmp->next = NULL; /* Temp unlink */\n        if (pred(tmp, opaque)) {\n            if (prev)\n                prev->next = next;\n            else\n                *head = next;\n        } else {\n            tmp->next = next; /* Reverse temp unlink */\n            prev = tmp;\n        }\n        tmp = next;\n    }\n}"
  },
  {
    "function_name": "virNetClientCallRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "180-197",
    "snippet": "static void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallRemove(virNetClientCallPtr *head,\n                                   virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    virNetClientCallPtr prev = NULL;\n    while (tmp) {\n        if (tmp == call) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                *head = tmp->next;\n            tmp->next = NULL;\n            return;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}"
  },
  {
    "function_name": "virNetClientCallServe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "167-176",
    "snippet": "static virNetClientCallPtr virNetClientCallServe(virNetClientCallPtr *head)\n{\n    virNetClientCallPtr tmp = *head;\n    if (tmp)\n        *head = tmp->next;\n    else\n        *head = NULL;\n    tmp->next = NULL;\n    return tmp;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetClientCallPtr virNetClientCallServe(virNetClientCallPtr *head)\n{\n    virNetClientCallPtr tmp = *head;\n    if (tmp)\n        *head = tmp->next;\n    else\n        *head = NULL;\n    tmp->next = NULL;\n    return tmp;\n}"
  },
  {
    "function_name": "virNetClientCallQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "152-163",
    "snippet": "static void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientCallQueue(virNetClientCallPtr *head,\n                                  virNetClientCallPtr call)\n{\n    virNetClientCallPtr tmp = *head;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = call;\n    else\n        *head = call;\n    call->next = NULL;\n}"
  },
  {
    "function_name": "virNetClientSetCloseCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "134-144",
    "snippet": "void virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
      "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nvoid virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}"
  },
  {
    "function_name": "virNetClientOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
    "lines": "116-122",
    "snippet": "static int virNetClientOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClient, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vireventglibwatch.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virerror.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virnetclient.h\"",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetClient",
            "virClassForObjectLockable()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClient, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]