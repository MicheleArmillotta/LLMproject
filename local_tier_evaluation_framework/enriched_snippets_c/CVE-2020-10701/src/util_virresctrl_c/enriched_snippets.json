[
  {
    "function_name": "virResctrlMonitorStatsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2773-2782",
    "snippet": "void\nvirResctrlMonitorStatsFree(virResctrlMonitorStatsPtr stat)\n{\n    if (!stat)\n        return;\n\n    virStringListFree(stat->features);\n    VIR_FREE(stat->vals);\n    VIR_FREE(stat);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stat"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stat->vals"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "stat->features"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlMonitorStatsFree(virResctrlMonitorStatsPtr stat)\n{\n    if (!stat)\n        return;\n\n    virStringListFree(stat->features);\n    VIR_FREE(stat->vals);\n    VIR_FREE(stat);\n}"
  },
  {
    "function_name": "virResctrlMonitorGetStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2673-2770",
    "snippet": "int\nvirResctrlMonitorGetStats(virResctrlMonitorPtr monitor,\n                          const char **resources,\n                          virResctrlMonitorStatsPtr **stats,\n                          size_t *nstats)\n{\n    int rv = -1;\n    int ret = -1;\n    size_t i = 0;\n    unsigned long long val = 0;\n    DIR *dirp = NULL;\n    char *datapath = NULL;\n    char *filepath = NULL;\n    struct dirent *ent = NULL;\n    virResctrlMonitorStatsPtr stat = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    datapath = g_strdup_printf(\"%s/mon_data\", monitor->path);\n\n    if (virDirOpen(&dirp, datapath) < 0)\n        goto cleanup;\n\n    *nstats = 0;\n    while (virDirRead(dirp, &ent, datapath) > 0) {\n        char *node_id = NULL;\n\n        VIR_FREE(filepath);\n\n        /* Looking for directory that contains resource utilization\n         * information file. The directory name is arranged in format\n         * \"mon_<node_name>_<node_id>\". For example, \"mon_L3_00\" and\n         * \"mon_L3_01\" are two target directories for a two nodes system\n         * with resource utilization data file for each node respectively.\n         */\n        filepath = g_strdup_printf(\"%s/%s\", datapath, ent->d_name);\n\n        if (!virFileIsDir(filepath))\n            continue;\n\n        /* Looking for directory has a prefix 'mon_L' */\n        if (!(node_id = STRSKIP(ent->d_name, \"mon_L\")))\n            continue;\n\n        /* Looking for directory has another '_' */\n        node_id = strchr(node_id, '_');\n        if (!node_id)\n            continue;\n\n        /* Skip the character '_' */\n        if (!(node_id = STRSKIP(node_id, \"_\")))\n            continue;\n\n        if (VIR_ALLOC(stat) < 0)\n            goto cleanup;\n\n        /* The node ID number should be here, parsing it. */\n        if (virStrToLong_uip(node_id, NULL, 0, &stat->id) < 0)\n            goto cleanup;\n\n        for (i = 0; resources[i]; i++) {\n            rv = virFileReadValueUllong(&val, \"%s/%s/%s\", datapath,\n                                        ent->d_name, resources[i]);\n            if (rv == -2) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File '%s/%s/%s' does not exist.\"),\n                               datapath, ent->d_name, resources[i]);\n            }\n            if (rv < 0)\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(stat->vals, stat->nvals, val) < 0)\n                goto cleanup;\n\n            if (virStringListAdd(&stat->features, resources[i]) < 0)\n                goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(*stats, *nstats, stat) < 0)\n            goto cleanup;\n    }\n\n    /* Sort in id's ascending order */\n    if (*nstats)\n        qsort(*stats, *nstats, sizeof(**stats), virResctrlMonitorStatsSorter);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(datapath);\n    VIR_FREE(filepath);\n    virResctrlMonitorStatsFree(stat);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dirp"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlMonitorStatsFree",
          "args": [
            "stat"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlMonitorStatsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2773-2782",
          "snippet": "void\nvirResctrlMonitorStatsFree(virResctrlMonitorStatsPtr stat)\n{\n    if (!stat)\n        return;\n\n    virStringListFree(stat->features);\n    VIR_FREE(stat->vals);\n    VIR_FREE(stat);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlMonitorStatsFree(virResctrlMonitorStatsPtr stat)\n{\n    if (!stat)\n        return;\n\n    virStringListFree(stat->features);\n    VIR_FREE(stat->vals);\n    VIR_FREE(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filepath"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datapath"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "*stats",
            "*nstats",
            "sizeof(**stats)",
            "virResctrlMonitorStatsSorter"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*stats",
            "*nstats",
            "stat"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListAdd",
          "args": [
            "&stat->features",
            "resources[i]"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "176-188",
          "snippet": "int\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "stat->vals",
            "stat->nvals",
            "val"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"File '%s/%s/%s' does not exist.\")",
            "datapath",
            "ent->d_name",
            "resources[i]"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File '%s/%s/%s' does not exist.\""
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueUllong",
          "args": [
            "&val",
            "\"%s/%s/%s\"",
            "datapath",
            "ent->d_name",
            "resources[i]"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUllong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4157-4184",
          "snippet": "int\nvirFileReadValueUllong(unsigned long long *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_ullp(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned long long value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUllong(unsigned long long *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_ullp(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned long long value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "node_id",
            "NULL",
            "0",
            "&stat->id"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "stat"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "node_id",
            "\"_\""
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "node_id",
            "'_'"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "ent->d_name",
            "\"mon_L\""
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsDir",
          "args": [
            "filepath"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1850-1855",
          "snippet": "bool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filepath"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dirp",
            "&ent",
            "datapath"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dirp",
            "datapath"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid resctrl monitor\")"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorGetStats(virResctrlMonitorPtr monitor,\n                          const char **resources,\n                          virResctrlMonitorStatsPtr **stats,\n                          size_t *nstats)\n{\n    int rv = -1;\n    int ret = -1;\n    size_t i = 0;\n    unsigned long long val = 0;\n    DIR *dirp = NULL;\n    char *datapath = NULL;\n    char *filepath = NULL;\n    struct dirent *ent = NULL;\n    virResctrlMonitorStatsPtr stat = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    datapath = g_strdup_printf(\"%s/mon_data\", monitor->path);\n\n    if (virDirOpen(&dirp, datapath) < 0)\n        goto cleanup;\n\n    *nstats = 0;\n    while (virDirRead(dirp, &ent, datapath) > 0) {\n        char *node_id = NULL;\n\n        VIR_FREE(filepath);\n\n        /* Looking for directory that contains resource utilization\n         * information file. The directory name is arranged in format\n         * \"mon_<node_name>_<node_id>\". For example, \"mon_L3_00\" and\n         * \"mon_L3_01\" are two target directories for a two nodes system\n         * with resource utilization data file for each node respectively.\n         */\n        filepath = g_strdup_printf(\"%s/%s\", datapath, ent->d_name);\n\n        if (!virFileIsDir(filepath))\n            continue;\n\n        /* Looking for directory has a prefix 'mon_L' */\n        if (!(node_id = STRSKIP(ent->d_name, \"mon_L\")))\n            continue;\n\n        /* Looking for directory has another '_' */\n        node_id = strchr(node_id, '_');\n        if (!node_id)\n            continue;\n\n        /* Skip the character '_' */\n        if (!(node_id = STRSKIP(node_id, \"_\")))\n            continue;\n\n        if (VIR_ALLOC(stat) < 0)\n            goto cleanup;\n\n        /* The node ID number should be here, parsing it. */\n        if (virStrToLong_uip(node_id, NULL, 0, &stat->id) < 0)\n            goto cleanup;\n\n        for (i = 0; resources[i]; i++) {\n            rv = virFileReadValueUllong(&val, \"%s/%s/%s\", datapath,\n                                        ent->d_name, resources[i]);\n            if (rv == -2) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File '%s/%s/%s' does not exist.\"),\n                               datapath, ent->d_name, resources[i]);\n            }\n            if (rv < 0)\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(stat->vals, stat->nvals, val) < 0)\n                goto cleanup;\n\n            if (virStringListAdd(&stat->features, resources[i]) < 0)\n                goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(*stats, *nstats, stat) < 0)\n            goto cleanup;\n    }\n\n    /* Sort in id's ascending order */\n    if (*nstats)\n        qsort(*stats, *nstats, sizeof(**stats), virResctrlMonitorStatsSorter);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(datapath);\n    VIR_FREE(filepath);\n    virResctrlMonitorStatsFree(stat);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlMonitorStatsSorter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2651-2657",
    "snippet": "static int\nvirResctrlMonitorStatsSorter(const void *a,\n                             const void *b)\n{\n    return (*(virResctrlMonitorStatsPtr *)a)->id\n        - (*(virResctrlMonitorStatsPtr *)b)->id;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlMonitorStatsSorter(const void *a,\n                             const void *b)\n{\n    return (*(virResctrlMonitorStatsPtr *)a)->id\n        - (*(virResctrlMonitorStatsPtr *)b)->id;\n}"
  },
  {
    "function_name": "virResctrlMonitorRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2630-2648",
    "snippet": "int\nvirResctrlMonitorRemove(virResctrlMonitorPtr monitor)\n{\n    int ret = 0;\n\n    if (!monitor->path)\n        return 0;\n\n    if (STREQ(monitor->path, monitor->alloc->path))\n        return 0;\n\n    VIR_DEBUG(\"Removing resctrl monitor path=%s\", monitor->path);\n    if (rmdir(monitor->path) != 0 && errno != ENOENT) {\n        ret = -errno;\n        VIR_ERROR(_(\"Unable to remove %s (%d)\"), monitor->path, errno);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Unable to remove %s (%d)\")",
            "monitor->path",
            "errno"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to remove %s (%d)\""
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "monitor->path"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing resctrl monitor path=%s\"",
            "monitor->path"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "monitor->path",
            "monitor->alloc->path"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorRemove(virResctrlMonitorPtr monitor)\n{\n    int ret = 0;\n\n    if (!monitor->path)\n        return 0;\n\n    if (STREQ(monitor->path, monitor->alloc->path))\n        return 0;\n\n    VIR_DEBUG(\"Removing resctrl monitor path=%s\", monitor->path);\n    if (rmdir(monitor->path) != 0 && errno != ENOENT) {\n        ret = -errno;\n        VIR_ERROR(_(\"Unable to remove %s (%d)\"), monitor->path, errno);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlMonitorSetAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2622-2627",
    "snippet": "void\nvirResctrlMonitorSetAlloc(virResctrlMonitorPtr monitor,\n                          virResctrlAllocPtr alloc)\n{\n    monitor->alloc = virObjectRef(alloc);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "alloc"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlMonitorSetAlloc(virResctrlMonitorPtr monitor,\n                          virResctrlAllocPtr alloc)\n{\n    monitor->alloc = virObjectRef(alloc);\n}"
  },
  {
    "function_name": "virResctrlMonitorGetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2615-2619",
    "snippet": "const char *\nvirResctrlMonitorGetID(virResctrlMonitorPtr monitor)\n{\n    return monitor->id;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nconst char *\nvirResctrlMonitorGetID(virResctrlMonitorPtr monitor)\n{\n    return monitor->id;\n}"
  },
  {
    "function_name": "virResctrlMonitorSetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2606-2612",
    "snippet": "int\nvirResctrlMonitorSetID(virResctrlMonitorPtr monitor,\n                       const char *id)\n\n{\n    return virResctrlSetID(&monitor->id, id);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlSetID",
          "args": [
            "&monitor->id",
            "id"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlSetID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1372-1391",
          "snippet": "static int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorSetID(virResctrlMonitorPtr monitor,\n                       const char *id)\n\n{\n    return virResctrlSetID(&monitor->id, id);\n}"
  },
  {
    "function_name": "virResctrlMonitorCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2582-2603",
    "snippet": "int\nvirResctrlMonitorCreate(virResctrlMonitorPtr monitor,\n                        const char *machinename)\n{\n    int lockfd = -1;\n    int ret = -1;\n\n    if (!monitor)\n        return 0;\n\n    if (virResctrlMonitorDeterminePath(monitor, machinename) < 0)\n        return -1;\n\n    lockfd = virResctrlLockWrite();\n    if (lockfd < 0)\n        return -1;\n\n    ret = virResctrlCreateGroupPath(monitor->path);\n\n    virResctrlUnlock(lockfd);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlUnlock",
          "args": [
            "lockfd"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "476-495",
          "snippet": "static int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlCreateGroupPath",
          "args": [
            "monitor->path"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlCreateGroupPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2356-2371",
          "snippet": "static int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlLockWrite",
          "args": [],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlLockWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "456-473",
          "snippet": "static int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlMonitorDeterminePath",
          "args": [
            "monitor",
            "machinename"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlMonitorDeterminePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2532-2571",
          "snippet": "int\nvirResctrlMonitorDeterminePath(virResctrlMonitorPtr monitor,\n                               const char *machinename)\n{\n    g_autofree char *parentpath = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    if (!monitor->alloc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resctrl monitor alloc\"));\n        return -1;\n    }\n\n    if (monitor->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl monitor path is already set to '%s'\"),\n                       monitor->path);\n        return -1;\n    }\n\n    if (!virResctrlAllocIsEmpty(monitor->alloc) &&\n        STREQ_NULLABLE(monitor->id, monitor->alloc->id)) {\n        monitor->path = g_strdup(monitor->alloc->path);\n        return 0;\n    }\n\n    parentpath = g_strdup_printf(\"%s/mon_groups\", monitor->alloc->path);\n\n    monitor->path = virResctrlDeterminePath(parentpath, machinename,\n                                            monitor->id);\n    if (!monitor->path)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorDeterminePath(virResctrlMonitorPtr monitor,\n                               const char *machinename)\n{\n    g_autofree char *parentpath = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    if (!monitor->alloc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resctrl monitor alloc\"));\n        return -1;\n    }\n\n    if (monitor->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl monitor path is already set to '%s'\"),\n                       monitor->path);\n        return -1;\n    }\n\n    if (!virResctrlAllocIsEmpty(monitor->alloc) &&\n        STREQ_NULLABLE(monitor->id, monitor->alloc->id)) {\n        monitor->path = g_strdup(monitor->alloc->path);\n        return 0;\n    }\n\n    parentpath = g_strdup_printf(\"%s/mon_groups\", monitor->alloc->path);\n\n    monitor->path = virResctrlDeterminePath(parentpath, machinename,\n                                            monitor->id);\n    if (!monitor->path)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorCreate(virResctrlMonitorPtr monitor,\n                        const char *machinename)\n{\n    int lockfd = -1;\n    int ret = -1;\n\n    if (!monitor)\n        return 0;\n\n    if (virResctrlMonitorDeterminePath(monitor, machinename) < 0)\n        return -1;\n\n    lockfd = virResctrlLockWrite();\n    if (lockfd < 0)\n        return -1;\n\n    ret = virResctrlCreateGroupPath(monitor->path);\n\n    virResctrlUnlock(lockfd);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlMonitorAddPID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2574-2579",
    "snippet": "int\nvirResctrlMonitorAddPID(virResctrlMonitorPtr monitor,\n                        pid_t pid)\n{\n    return virResctrlAddPID(monitor->path, pid);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlAddPID",
          "args": [
            "monitor->path",
            "pid"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAddPID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2436-2466",
          "snippet": "static int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorAddPID(virResctrlMonitorPtr monitor,\n                        pid_t pid)\n{\n    return virResctrlAddPID(monitor->path, pid);\n}"
  },
  {
    "function_name": "virResctrlMonitorDeterminePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2532-2571",
    "snippet": "int\nvirResctrlMonitorDeterminePath(virResctrlMonitorPtr monitor,\n                               const char *machinename)\n{\n    g_autofree char *parentpath = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    if (!monitor->alloc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resctrl monitor alloc\"));\n        return -1;\n    }\n\n    if (monitor->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl monitor path is already set to '%s'\"),\n                       monitor->path);\n        return -1;\n    }\n\n    if (!virResctrlAllocIsEmpty(monitor->alloc) &&\n        STREQ_NULLABLE(monitor->id, monitor->alloc->id)) {\n        monitor->path = g_strdup(monitor->alloc->path);\n        return 0;\n    }\n\n    parentpath = g_strdup_printf(\"%s/mon_groups\", monitor->alloc->path);\n\n    monitor->path = virResctrlDeterminePath(parentpath, machinename,\n                                            monitor->id);\n    if (!monitor->path)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlDeterminePath",
          "args": [
            "parentpath",
            "machinename",
            "monitor->id"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlDeterminePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2306-2323",
          "snippet": "static char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/mon_groups\"",
            "monitor->alloc->path"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "monitor->id",
            "monitor->alloc->id"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocIsEmpty",
          "args": [
            "monitor->alloc"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1044-1082",
          "snippet": "bool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nbool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resctrl monitor path is already set to '%s'\")",
            "monitor->path"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing resctrl monitor alloc\")"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid resctrl monitor\")"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlMonitorDeterminePath(virResctrlMonitorPtr monitor,\n                               const char *machinename)\n{\n    g_autofree char *parentpath = NULL;\n\n    if (!monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid resctrl monitor\"));\n        return -1;\n    }\n\n    if (!monitor->alloc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resctrl monitor alloc\"));\n        return -1;\n    }\n\n    if (monitor->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl monitor path is already set to '%s'\"),\n                       monitor->path);\n        return -1;\n    }\n\n    if (!virResctrlAllocIsEmpty(monitor->alloc) &&\n        STREQ_NULLABLE(monitor->id, monitor->alloc->id)) {\n        monitor->path = g_strdup(monitor->alloc->path);\n        return 0;\n    }\n\n    parentpath = g_strdup_printf(\"%s/mon_groups\", monitor->alloc->path);\n\n    monitor->path = virResctrlDeterminePath(parentpath, machinename,\n                                            monitor->id);\n    if (!monitor->path)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlMonitorNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2506-2513",
    "snippet": "virResctrlMonitorPtr\nvirResctrlMonitorNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlMonitorClass);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virResctrlMonitorClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virResctrlMonitorClass"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInitialize",
          "args": [],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlMonitorClass;\n\nvirResctrlMonitorPtr\nvirResctrlMonitorNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlMonitorClass);\n}"
  },
  {
    "function_name": "virResctrlAllocRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2482-2501",
    "snippet": "int\nvirResctrlAllocRemove(virResctrlAllocPtr alloc)\n{\n    int ret = 0;\n\n    if (!alloc->path)\n        return 0;\n\n    /* Do not destroy if path is the system/default path for the allocation */\n    if (STREQ(alloc->path, SYSFS_RESCTRL_PATH))\n        return 0;\n\n    VIR_DEBUG(\"Removing resctrl allocation %s\", alloc->path);\n    if (rmdir(alloc->path) != 0 && errno != ENOENT) {\n        ret = -errno;\n        VIR_ERROR(_(\"Unable to remove %s (%d)\"), alloc->path, errno);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Unable to remove %s (%d)\")",
            "alloc->path",
            "errno"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to remove %s (%d)\""
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "alloc->path"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing resctrl allocation %s\"",
            "alloc->path"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "alloc->path",
            "SYSFS_RESCTRL_PATH"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nint\nvirResctrlAllocRemove(virResctrlAllocPtr alloc)\n{\n    int ret = 0;\n\n    if (!alloc->path)\n        return 0;\n\n    /* Do not destroy if path is the system/default path for the allocation */\n    if (STREQ(alloc->path, SYSFS_RESCTRL_PATH))\n        return 0;\n\n    VIR_DEBUG(\"Removing resctrl allocation %s\", alloc->path);\n    if (rmdir(alloc->path) != 0 && errno != ENOENT) {\n        ret = -errno;\n        VIR_ERROR(_(\"Unable to remove %s (%d)\"), alloc->path, errno);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocAddPID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2469-2479",
    "snippet": "int\nvirResctrlAllocAddPID(virResctrlAllocPtr alloc,\n                      pid_t pid)\n{\n    /* If the allocation is empty, then it is impossible to add a PID to\n     * allocation due to lacking of its 'tasks' file so just return */\n    if (virResctrlAllocIsEmpty(alloc))\n        return 0;\n\n    return virResctrlAddPID(alloc->path, pid);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlAddPID",
          "args": [
            "alloc->path",
            "pid"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAddPID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2436-2466",
          "snippet": "static int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocIsEmpty",
          "args": [
            "alloc"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1044-1082",
          "snippet": "bool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nbool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocAddPID(virResctrlAllocPtr alloc,\n                      pid_t pid)\n{\n    /* If the allocation is empty, then it is impossible to add a PID to\n     * allocation due to lacking of its 'tasks' file so just return */\n    if (virResctrlAllocIsEmpty(alloc))\n        return 0;\n\n    return virResctrlAddPID(alloc->path, pid);\n}"
  },
  {
    "function_name": "virResctrlAddPID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2436-2466",
    "snippet": "static int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pidstr"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tasks"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot write pid in tasks file '%s'\")",
            "tasks"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot write pid in tasks file '%s'\""
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "tasks",
            "pidstr",
            "0"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot add pid to non-existing resctrl group\")"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAddPID(const char *path,\n                 pid_t pid)\n{\n    char *tasks = NULL;\n    char *pidstr = NULL;\n    int ret = 0;\n\n    if (!path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add pid to non-existing resctrl group\"));\n        return -1;\n    }\n\n    tasks = g_strdup_printf(\"%s/tasks\", path);\n\n    pidstr = g_strdup_printf(\"%lld\", (long long int)pid);\n\n    if (virFileWriteStr(tasks, pidstr, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot write pid in tasks file '%s'\"),\n                             tasks);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tasks);\n    VIR_FREE(pidstr);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2376-2433",
    "snippet": "int\nvirResctrlAllocCreate(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc,\n                      const char *machinename)\n{\n    char *schemata_path = NULL;\n    char *alloc_str = NULL;\n    int ret = -1;\n    int lockfd = -1;\n\n    if (!alloc)\n        return 0;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return -1;\n    }\n\n    if (virResctrlAllocDeterminePath(alloc, machinename) < 0)\n        return -1;\n\n    /* If using the system/default path for the allocation, then we're done */\n    if (STREQ(alloc->path, SYSFS_RESCTRL_PATH))\n        return 0;\n\n    lockfd = virResctrlLockWrite();\n    if (lockfd < 0)\n        goto cleanup;\n\n    if (virResctrlAllocAssign(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlCreateGroupPath(alloc->path) < 0)\n        goto cleanup;\n\n    alloc_str = virResctrlAllocFormat(alloc);\n    if (!alloc_str)\n        goto cleanup;\n\n    schemata_path = g_strdup_printf(\"%s/schemata\", alloc->path);\n\n    VIR_DEBUG(\"Writing resctrl schemata '%s' into '%s'\", alloc_str, schemata_path);\n    if (virFileWriteStr(schemata_path, alloc_str, 0) < 0) {\n        rmdir(alloc->path);\n        virReportSystemError(errno,\n                             _(\"Cannot write into schemata file '%s'\"),\n                             schemata_path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virResctrlUnlock(lockfd);\n    VIR_FREE(alloc_str);\n    VIR_FREE(schemata_path);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "schemata_path"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc_str"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlUnlock",
          "args": [
            "lockfd"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "476-495",
          "snippet": "static int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot write into schemata file '%s'\")",
            "schemata_path"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot write into schemata file '%s'\""
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "alloc->path"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "schemata_path",
            "alloc_str",
            "0"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Writing resctrl schemata '%s' into '%s'\"",
            "alloc_str",
            "schemata_path"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocFormat",
          "args": [
            "alloc"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1587-1606",
          "snippet": "char *\nvirResctrlAllocFormat(virResctrlAllocPtr alloc)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (!alloc)\n        return NULL;\n\n    if (virResctrlAllocFormatCache(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    if (virResctrlAllocMemoryBandwidthFormat(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nchar *\nvirResctrlAllocFormat(virResctrlAllocPtr alloc)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (!alloc)\n        return NULL;\n\n    if (virResctrlAllocFormatCache(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    if (virResctrlAllocMemoryBandwidthFormat(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlCreateGroupPath",
          "args": [
            "alloc->path"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlCreateGroupPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2356-2371",
          "snippet": "static int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocAssign",
          "args": [
            "resctrl",
            "alloc"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2228-2303",
          "snippet": "static int\nvirResctrlAllocAssign(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc)\n{\n    int ret = -1;\n    unsigned int level = 0;\n    virResctrlAllocPtr alloc_free = NULL;\n    virResctrlAllocPtr alloc_default = NULL;\n\n    alloc_free = virResctrlAllocGetUnused(resctrl);\n    if (!alloc_free)\n        return -1;\n\n    alloc_default = virResctrlAllocGetDefault(resctrl);\n    if (!alloc_default)\n        goto cleanup;\n\n    if (virResctrlAllocMemoryBandwidth(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMasks(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMemBW(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n        virResctrlAllocPerLevelPtr f_level = NULL;\n        unsigned int type = 0;\n\n        if (!a_level)\n            continue;\n\n        if (level < alloc_free->nlevels)\n            f_level = alloc_free->levels[level];\n\n        if (!f_level) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cache level %d does not support tuning\"),\n                           level);\n            goto cleanup;\n        }\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n            virResctrlAllocPerTypePtr f_type = f_level->types[type];\n            unsigned int cache = 0;\n\n            if (!a_type)\n                continue;\n\n            if (!f_type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\"),\n                               level, virCacheTypeToString(type));\n                goto cleanup;\n            }\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                virResctrlInfoPerLevelPtr i_level = resctrl->levels[level];\n                virResctrlInfoPerTypePtr i_type = i_level->types[type];\n\n                if (virResctrlAllocFindUnused(alloc, i_type, f_type, level, type, cache) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(alloc_free);\n    virObjectUnref(alloc_default);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocAssign(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc)\n{\n    int ret = -1;\n    unsigned int level = 0;\n    virResctrlAllocPtr alloc_free = NULL;\n    virResctrlAllocPtr alloc_default = NULL;\n\n    alloc_free = virResctrlAllocGetUnused(resctrl);\n    if (!alloc_free)\n        return -1;\n\n    alloc_default = virResctrlAllocGetDefault(resctrl);\n    if (!alloc_default)\n        goto cleanup;\n\n    if (virResctrlAllocMemoryBandwidth(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMasks(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMemBW(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n        virResctrlAllocPerLevelPtr f_level = NULL;\n        unsigned int type = 0;\n\n        if (!a_level)\n            continue;\n\n        if (level < alloc_free->nlevels)\n            f_level = alloc_free->levels[level];\n\n        if (!f_level) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cache level %d does not support tuning\"),\n                           level);\n            goto cleanup;\n        }\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n            virResctrlAllocPerTypePtr f_type = f_level->types[type];\n            unsigned int cache = 0;\n\n            if (!a_type)\n                continue;\n\n            if (!f_type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\"),\n                               level, virCacheTypeToString(type));\n                goto cleanup;\n            }\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                virResctrlInfoPerLevelPtr i_level = resctrl->levels[level];\n                virResctrlInfoPerTypePtr i_type = i_level->types[type];\n\n                if (virResctrlAllocFindUnused(alloc, i_type, f_type, level, type, cache) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(alloc_free);\n    virObjectUnref(alloc_default);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlLockWrite",
          "args": [],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlLockWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "456-473",
          "snippet": "static int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "alloc->path",
            "SYSFS_RESCTRL_PATH"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocDeterminePath",
          "args": [
            "alloc",
            "machinename"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocDeterminePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2326-2351",
          "snippet": "int\nvirResctrlAllocDeterminePath(virResctrlAllocPtr alloc,\n                             const char *machinename)\n{\n    if (alloc->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl allocation path is already set to '%s'\"),\n                       alloc->path);\n        return -1;\n    }\n\n    /* If the allocation is empty, then the path will be SYSFS_RESCTRL_PATH */\n    if (virResctrlAllocIsEmpty(alloc)) {\n        alloc->path = g_strdup(SYSFS_RESCTRL_PATH);\n\n        return 0;\n    }\n\n    alloc->path = virResctrlDeterminePath(SYSFS_RESCTRL_PATH,\n                                          machinename, alloc->id);\n\n    if (!alloc->path)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nint\nvirResctrlAllocDeterminePath(virResctrlAllocPtr alloc,\n                             const char *machinename)\n{\n    if (alloc->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl allocation path is already set to '%s'\"),\n                       alloc->path);\n        return -1;\n    }\n\n    /* If the allocation is empty, then the path will be SYSFS_RESCTRL_PATH */\n    if (virResctrlAllocIsEmpty(alloc)) {\n        alloc->path = g_strdup(SYSFS_RESCTRL_PATH);\n\n        return 0;\n    }\n\n    alloc->path = virResctrlDeterminePath(SYSFS_RESCTRL_PATH,\n                                          machinename, alloc->id);\n\n    if (!alloc->path)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Resource control is not supported on this host\")"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoIsEmpty",
          "args": [
            "resctrl"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "814-842",
          "snippet": "static bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nint\nvirResctrlAllocCreate(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc,\n                      const char *machinename)\n{\n    char *schemata_path = NULL;\n    char *alloc_str = NULL;\n    int ret = -1;\n    int lockfd = -1;\n\n    if (!alloc)\n        return 0;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return -1;\n    }\n\n    if (virResctrlAllocDeterminePath(alloc, machinename) < 0)\n        return -1;\n\n    /* If using the system/default path for the allocation, then we're done */\n    if (STREQ(alloc->path, SYSFS_RESCTRL_PATH))\n        return 0;\n\n    lockfd = virResctrlLockWrite();\n    if (lockfd < 0)\n        goto cleanup;\n\n    if (virResctrlAllocAssign(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlCreateGroupPath(alloc->path) < 0)\n        goto cleanup;\n\n    alloc_str = virResctrlAllocFormat(alloc);\n    if (!alloc_str)\n        goto cleanup;\n\n    schemata_path = g_strdup_printf(\"%s/schemata\", alloc->path);\n\n    VIR_DEBUG(\"Writing resctrl schemata '%s' into '%s'\", alloc_str, schemata_path);\n    if (virFileWriteStr(schemata_path, alloc_str, 0) < 0) {\n        rmdir(alloc->path);\n        virReportSystemError(errno,\n                             _(\"Cannot write into schemata file '%s'\"),\n                             schemata_path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virResctrlUnlock(lockfd);\n    VIR_FREE(alloc_str);\n    VIR_FREE(schemata_path);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlCreateGroupPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2356-2371",
    "snippet": "static int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot create resctrl directory '%s'\")",
            "path"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot create resctrl directory '%s'\""
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "path"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlCreateGroupPath(const char *path)\n{\n    /* Directory exists, return */\n    if (virFileExists(path))\n        return 0;\n\n    if (virFileMakePath(path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create resctrl directory '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocDeterminePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2326-2351",
    "snippet": "int\nvirResctrlAllocDeterminePath(virResctrlAllocPtr alloc,\n                             const char *machinename)\n{\n    if (alloc->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl allocation path is already set to '%s'\"),\n                       alloc->path);\n        return -1;\n    }\n\n    /* If the allocation is empty, then the path will be SYSFS_RESCTRL_PATH */\n    if (virResctrlAllocIsEmpty(alloc)) {\n        alloc->path = g_strdup(SYSFS_RESCTRL_PATH);\n\n        return 0;\n    }\n\n    alloc->path = virResctrlDeterminePath(SYSFS_RESCTRL_PATH,\n                                          machinename, alloc->id);\n\n    if (!alloc->path)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlDeterminePath",
          "args": [
            "SYSFS_RESCTRL_PATH",
            "machinename",
            "alloc->id"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlDeterminePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2306-2323",
          "snippet": "static char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "SYSFS_RESCTRL_PATH"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocIsEmpty",
          "args": [
            "alloc"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1044-1082",
          "snippet": "bool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nbool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resctrl allocation path is already set to '%s'\")",
            "alloc->path"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nint\nvirResctrlAllocDeterminePath(virResctrlAllocPtr alloc,\n                             const char *machinename)\n{\n    if (alloc->path) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl allocation path is already set to '%s'\"),\n                       alloc->path);\n        return -1;\n    }\n\n    /* If the allocation is empty, then the path will be SYSFS_RESCTRL_PATH */\n    if (virResctrlAllocIsEmpty(alloc)) {\n        alloc->path = g_strdup(SYSFS_RESCTRL_PATH);\n\n        return 0;\n    }\n\n    alloc->path = virResctrlDeterminePath(SYSFS_RESCTRL_PATH,\n                                          machinename, alloc->id);\n\n    if (!alloc->path)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlDeterminePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2306-2323",
    "snippet": "static char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-%s\"",
            "parentpath",
            "prefix",
            "id"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\")",
            "parentpath",
            "prefix"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic char *\nvirResctrlDeterminePath(const char *parentpath,\n                        const char *prefix,\n                        const char *id)\n{\n    char *path = NULL;\n\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resctrl ID must be set before determining resctrl \"\n                         \"parentpath='%s' prefix='%s'\"), parentpath, prefix);\n        return NULL;\n    }\n\n    path = g_strdup_printf(\"%s/%s-%s\", parentpath, prefix, id);\n\n    return path;\n}"
  },
  {
    "function_name": "virResctrlAllocAssign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2228-2303",
    "snippet": "static int\nvirResctrlAllocAssign(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc)\n{\n    int ret = -1;\n    unsigned int level = 0;\n    virResctrlAllocPtr alloc_free = NULL;\n    virResctrlAllocPtr alloc_default = NULL;\n\n    alloc_free = virResctrlAllocGetUnused(resctrl);\n    if (!alloc_free)\n        return -1;\n\n    alloc_default = virResctrlAllocGetDefault(resctrl);\n    if (!alloc_default)\n        goto cleanup;\n\n    if (virResctrlAllocMemoryBandwidth(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMasks(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMemBW(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n        virResctrlAllocPerLevelPtr f_level = NULL;\n        unsigned int type = 0;\n\n        if (!a_level)\n            continue;\n\n        if (level < alloc_free->nlevels)\n            f_level = alloc_free->levels[level];\n\n        if (!f_level) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cache level %d does not support tuning\"),\n                           level);\n            goto cleanup;\n        }\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n            virResctrlAllocPerTypePtr f_type = f_level->types[type];\n            unsigned int cache = 0;\n\n            if (!a_type)\n                continue;\n\n            if (!f_type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\"),\n                               level, virCacheTypeToString(type));\n                goto cleanup;\n            }\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                virResctrlInfoPerLevelPtr i_level = resctrl->levels[level];\n                virResctrlInfoPerTypePtr i_type = i_level->types[type];\n\n                if (virResctrlAllocFindUnused(alloc, i_type, f_type, level, type, cache) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(alloc_free);\n    virObjectUnref(alloc_default);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "alloc_default"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocFindUnused",
          "args": [
            "alloc",
            "i_type",
            "f_type",
            "level",
            "type",
            "cache"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocFindUnused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1979-2097",
          "snippet": "static int\nvirResctrlAllocFindUnused(virResctrlAllocPtr alloc,\n                          virResctrlInfoPerTypePtr i_type,\n                          virResctrlAllocPerTypePtr f_type,\n                          unsigned int level,\n                          unsigned int type,\n                          unsigned int cache)\n{\n    unsigned long long *size = alloc->levels[level]->types[type]->sizes[cache];\n    virBitmapPtr a_mask = NULL;\n    virBitmapPtr f_mask = NULL;\n    unsigned long long need_bits;\n    size_t i = 0;\n    ssize_t pos = -1;\n    ssize_t last_bits = 0;\n    ssize_t last_pos = -1;\n    int ret = -1;\n\n    if (!size)\n        return 0;\n\n    if (cache >= f_type->nmasks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache with id %u does not exists for level %d\"),\n                       cache, level);\n        return -1;\n    }\n\n    f_mask = f_type->masks[cache];\n    if (!f_mask) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache level %d id %u does not support tuning for \"\n                         \"scope type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    if (*size == i_type->size) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation for the whole cache is not \"\n                         \"possible, specify size smaller than %llu\"),\n                       i_type->size);\n        return -1;\n    }\n\n    need_bits = *size / i_type->control.granularity;\n\n    if (*size % i_type->control.granularity) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is not \"\n                         \"divisible by granularity %llu\"),\n                       *size, i_type->control.granularity);\n        return -1;\n    }\n\n    if (need_bits < i_type->min_cbm_bits) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is smaller \"\n                         \"than the minimum allowed allocation %llu\"),\n                       *size,\n                       i_type->control.granularity * i_type->min_cbm_bits);\n        return -1;\n    }\n\n    while ((pos = virBitmapNextSetBit(f_mask, pos)) >= 0) {\n        ssize_t pos_clear = virBitmapNextClearBit(f_mask, pos);\n        ssize_t bits;\n\n        if (pos_clear < 0)\n            pos_clear = virBitmapSize(f_mask);\n\n        bits = pos_clear - pos;\n\n        /* Not enough bits, move on and skip all of them */\n        if (bits < need_bits) {\n            pos = pos_clear;\n            continue;\n        }\n\n        /* This fits perfectly */\n        if (bits == need_bits) {\n            last_pos = pos;\n            break;\n        }\n\n        /* Remember the smaller region if we already found on before */\n        if (last_pos < 0 || (last_bits && bits < last_bits)) {\n            last_bits = bits;\n            last_pos = pos;\n        }\n\n        pos = pos_clear;\n    }\n\n    if (last_pos < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\"),\n                       *size, level, cache,\n                       virCacheTypeToString(type));\n        return -1;\n    }\n\n    a_mask = virBitmapNew(i_type->bits);\n    if (!a_mask)\n        return -1;\n\n    for (i = last_pos; i < last_pos + need_bits; i++)\n        ignore_value(virBitmapSetBit(a_mask, i));\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache, a_mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(a_mask);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocFindUnused(virResctrlAllocPtr alloc,\n                          virResctrlInfoPerTypePtr i_type,\n                          virResctrlAllocPerTypePtr f_type,\n                          unsigned int level,\n                          unsigned int type,\n                          unsigned int cache)\n{\n    unsigned long long *size = alloc->levels[level]->types[type]->sizes[cache];\n    virBitmapPtr a_mask = NULL;\n    virBitmapPtr f_mask = NULL;\n    unsigned long long need_bits;\n    size_t i = 0;\n    ssize_t pos = -1;\n    ssize_t last_bits = 0;\n    ssize_t last_pos = -1;\n    int ret = -1;\n\n    if (!size)\n        return 0;\n\n    if (cache >= f_type->nmasks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache with id %u does not exists for level %d\"),\n                       cache, level);\n        return -1;\n    }\n\n    f_mask = f_type->masks[cache];\n    if (!f_mask) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache level %d id %u does not support tuning for \"\n                         \"scope type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    if (*size == i_type->size) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation for the whole cache is not \"\n                         \"possible, specify size smaller than %llu\"),\n                       i_type->size);\n        return -1;\n    }\n\n    need_bits = *size / i_type->control.granularity;\n\n    if (*size % i_type->control.granularity) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is not \"\n                         \"divisible by granularity %llu\"),\n                       *size, i_type->control.granularity);\n        return -1;\n    }\n\n    if (need_bits < i_type->min_cbm_bits) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is smaller \"\n                         \"than the minimum allowed allocation %llu\"),\n                       *size,\n                       i_type->control.granularity * i_type->min_cbm_bits);\n        return -1;\n    }\n\n    while ((pos = virBitmapNextSetBit(f_mask, pos)) >= 0) {\n        ssize_t pos_clear = virBitmapNextClearBit(f_mask, pos);\n        ssize_t bits;\n\n        if (pos_clear < 0)\n            pos_clear = virBitmapSize(f_mask);\n\n        bits = pos_clear - pos;\n\n        /* Not enough bits, move on and skip all of them */\n        if (bits < need_bits) {\n            pos = pos_clear;\n            continue;\n        }\n\n        /* This fits perfectly */\n        if (bits == need_bits) {\n            last_pos = pos;\n            break;\n        }\n\n        /* Remember the smaller region if we already found on before */\n        if (last_pos < 0 || (last_bits && bits < last_bits)) {\n            last_bits = bits;\n            last_pos = pos;\n        }\n\n        pos = pos_clear;\n    }\n\n    if (last_pos < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\"),\n                       *size, level, cache,\n                       virCacheTypeToString(type));\n        return -1;\n    }\n\n    a_mask = virBitmapNew(i_type->bits);\n    if (!a_mask)\n        return -1;\n\n    for (i = last_pos; i < last_pos + need_bits; i++)\n        ignore_value(virBitmapSetBit(a_mask, i));\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache, a_mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(a_mask);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\")",
            "level",
            "virCacheTypeToString(type)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "type"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\""
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache level %d does not support tuning\")",
            "level"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocCopyMemBW",
          "args": [
            "alloc",
            "alloc_default"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocCopyMemBW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2150-2181",
          "snippet": "static int\nvirResctrlAllocCopyMemBW(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr dst_bw = NULL;\n    virResctrlAllocMemBWPtr src_bw = src->mem_bw;\n\n    if (!src->mem_bw)\n        return 0;\n\n    if (!dst->mem_bw &&\n        VIR_ALLOC(dst->mem_bw) < 0)\n        return -1;\n\n    dst_bw = dst->mem_bw;\n\n    if (src_bw->nbandwidths > dst_bw->nbandwidths &&\n        VIR_EXPAND_N(dst_bw->bandwidths, dst_bw->nbandwidths,\n                     src_bw->nbandwidths - dst_bw->nbandwidths) < 0)\n        return -1;\n\n    for (i = 0; i < src_bw->nbandwidths; i++) {\n        if (dst_bw->bandwidths[i])\n            continue;\n        if (VIR_ALLOC(dst_bw->bandwidths[i]) < 0)\n            return -1;\n        *dst_bw->bandwidths[i] = *src_bw->bandwidths[i];\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocCopyMemBW(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr dst_bw = NULL;\n    virResctrlAllocMemBWPtr src_bw = src->mem_bw;\n\n    if (!src->mem_bw)\n        return 0;\n\n    if (!dst->mem_bw &&\n        VIR_ALLOC(dst->mem_bw) < 0)\n        return -1;\n\n    dst_bw = dst->mem_bw;\n\n    if (src_bw->nbandwidths > dst_bw->nbandwidths &&\n        VIR_EXPAND_N(dst_bw->bandwidths, dst_bw->nbandwidths,\n                     src_bw->nbandwidths - dst_bw->nbandwidths) < 0)\n        return -1;\n\n    for (i = 0; i < src_bw->nbandwidths; i++) {\n        if (dst_bw->bandwidths[i])\n            continue;\n        if (VIR_ALLOC(dst_bw->bandwidths[i]) < 0)\n            return -1;\n        *dst_bw->bandwidths[i] = *src_bw->bandwidths[i];\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocCopyMasks",
          "args": [
            "alloc",
            "alloc_default"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocCopyMasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2184-2219",
          "snippet": "static int\nvirResctrlAllocCopyMasks(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    unsigned int level = 0;\n\n    for (level = 0; level < src->nlevels; level++) {\n        virResctrlAllocPerLevelPtr s_level = src->levels[level];\n        unsigned int type = 0;\n\n        if (!s_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr s_type = s_level->types[type];\n            virResctrlAllocPerTypePtr d_type = NULL;\n            unsigned int cache = 0;\n\n            if (!s_type)\n                continue;\n\n            d_type = virResctrlAllocGetType(dst, level, type);\n            if (!d_type)\n                return -1;\n\n            for (cache = 0; cache < s_type->nmasks; cache++) {\n                virBitmapPtr mask = s_type->masks[cache];\n\n                if (mask && virResctrlAllocUpdateMask(dst, level, type, cache, mask) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocCopyMasks(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    unsigned int level = 0;\n\n    for (level = 0; level < src->nlevels; level++) {\n        virResctrlAllocPerLevelPtr s_level = src->levels[level];\n        unsigned int type = 0;\n\n        if (!s_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr s_type = s_level->types[type];\n            virResctrlAllocPerTypePtr d_type = NULL;\n            unsigned int cache = 0;\n\n            if (!s_type)\n                continue;\n\n            d_type = virResctrlAllocGetType(dst, level, type);\n            if (!d_type)\n                return -1;\n\n            for (cache = 0; cache < s_type->nmasks; cache++) {\n                virBitmapPtr mask = s_type->masks[cache];\n\n                if (mask && virResctrlAllocUpdateMask(dst, level, type, cache, mask) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocMemoryBandwidth",
          "args": [
            "resctrl",
            "alloc"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocMemoryBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "2100-2147",
          "snippet": "static int\nvirResctrlAllocMemoryBandwidth(virResctrlInfoPtr resctrl,\n                               virResctrlAllocPtr alloc)\n{\n    size_t i;\n    virResctrlAllocMemBWPtr mem_bw_alloc = alloc->mem_bw;\n    virResctrlInfoMemBWPtr mem_bw_info = resctrl->membw_info;\n\n    if (!mem_bw_alloc)\n        return 0;\n\n    if (!mem_bw_info) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"RDT Memory Bandwidth allocation unsupported\"));\n        return -1;\n    }\n\n    for (i = 0; i < mem_bw_alloc->nbandwidths; i++) {\n        if (!mem_bw_alloc->bandwidths[i])\n            continue;\n\n        if (*(mem_bw_alloc->bandwidths[i]) % mem_bw_info->bandwidth_granularity) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is not divisible by granularity %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->bandwidth_granularity);\n            return -1;\n        }\n        if (*(mem_bw_alloc->bandwidths[i]) < mem_bw_info->min_bandwidth) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is smaller than the minimum \"\n                             \"allowed allocation %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->min_bandwidth);\n            return -1;\n        }\n        if (i > mem_bw_info->max_id) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\"),\n                           i, mem_bw_info->max_id);\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocMemoryBandwidth(virResctrlInfoPtr resctrl,\n                               virResctrlAllocPtr alloc)\n{\n    size_t i;\n    virResctrlAllocMemBWPtr mem_bw_alloc = alloc->mem_bw;\n    virResctrlInfoMemBWPtr mem_bw_info = resctrl->membw_info;\n\n    if (!mem_bw_alloc)\n        return 0;\n\n    if (!mem_bw_info) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"RDT Memory Bandwidth allocation unsupported\"));\n        return -1;\n    }\n\n    for (i = 0; i < mem_bw_alloc->nbandwidths; i++) {\n        if (!mem_bw_alloc->bandwidths[i])\n            continue;\n\n        if (*(mem_bw_alloc->bandwidths[i]) % mem_bw_info->bandwidth_granularity) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is not divisible by granularity %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->bandwidth_granularity);\n            return -1;\n        }\n        if (*(mem_bw_alloc->bandwidths[i]) < mem_bw_info->min_bandwidth) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is smaller than the minimum \"\n                             \"allowed allocation %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->min_bandwidth);\n            return -1;\n        }\n        if (i > mem_bw_info->max_id) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\"),\n                           i, mem_bw_info->max_id);\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetDefault",
          "args": [
            "resctrl"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1778-1790",
          "snippet": "static virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetUnused",
          "args": [
            "resctrl"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetUnused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1906-1966",
          "snippet": "virResctrlAllocPtr\nvirResctrlAllocGetUnused(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    virResctrlAllocPtr alloc = NULL;\n    struct dirent *ent = NULL;\n    DIR *dirp = NULL;\n    int rv = -1;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return NULL;\n    }\n\n    ret = virResctrlAllocNewFromInfo(resctrl);\n    if (!ret)\n        return NULL;\n\n    alloc = virResctrlAllocGetDefault(resctrl);\n    if (!alloc)\n        goto error;\n\n    virResctrlAllocSubtract(ret, alloc);\n    virObjectUnref(alloc);\n\n    if (virDirOpen(&dirp, SYSFS_RESCTRL_PATH) < 0)\n        goto error;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH)) > 0) {\n        if (STREQ(ent->d_name, \"info\"))\n            continue;\n\n        rv = virResctrlAllocGetGroup(resctrl, ent->d_name, &alloc);\n        if (rv == -2)\n            continue;\n\n        if (rv < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not read schemata file for group %s\"),\n                           ent->d_name);\n            goto error;\n        }\n\n        virResctrlAllocSubtract(ret, alloc);\n        virObjectUnref(alloc);\n        alloc = NULL;\n    }\n    if (rv < 0)\n        goto error;\n\n cleanup:\n    virObjectUnref(alloc);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nvirResctrlAllocPtr\nvirResctrlAllocGetUnused(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    virResctrlAllocPtr alloc = NULL;\n    struct dirent *ent = NULL;\n    DIR *dirp = NULL;\n    int rv = -1;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return NULL;\n    }\n\n    ret = virResctrlAllocNewFromInfo(resctrl);\n    if (!ret)\n        return NULL;\n\n    alloc = virResctrlAllocGetDefault(resctrl);\n    if (!alloc)\n        goto error;\n\n    virResctrlAllocSubtract(ret, alloc);\n    virObjectUnref(alloc);\n\n    if (virDirOpen(&dirp, SYSFS_RESCTRL_PATH) < 0)\n        goto error;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH)) > 0) {\n        if (STREQ(ent->d_name, \"info\"))\n            continue;\n\n        rv = virResctrlAllocGetGroup(resctrl, ent->d_name, &alloc);\n        if (rv == -2)\n            continue;\n\n        if (rv < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not read schemata file for group %s\"),\n                           ent->d_name);\n            goto error;\n        }\n\n        virResctrlAllocSubtract(ret, alloc);\n        virObjectUnref(alloc);\n        alloc = NULL;\n    }\n    if (rv < 0)\n        goto error;\n\n cleanup:\n    virObjectUnref(alloc);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocAssign(virResctrlInfoPtr resctrl,\n                      virResctrlAllocPtr alloc)\n{\n    int ret = -1;\n    unsigned int level = 0;\n    virResctrlAllocPtr alloc_free = NULL;\n    virResctrlAllocPtr alloc_default = NULL;\n\n    alloc_free = virResctrlAllocGetUnused(resctrl);\n    if (!alloc_free)\n        return -1;\n\n    alloc_default = virResctrlAllocGetDefault(resctrl);\n    if (!alloc_default)\n        goto cleanup;\n\n    if (virResctrlAllocMemoryBandwidth(resctrl, alloc) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMasks(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    if (virResctrlAllocCopyMemBW(alloc, alloc_default) < 0)\n        goto cleanup;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n        virResctrlAllocPerLevelPtr f_level = NULL;\n        unsigned int type = 0;\n\n        if (!a_level)\n            continue;\n\n        if (level < alloc_free->nlevels)\n            f_level = alloc_free->levels[level];\n\n        if (!f_level) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cache level %d does not support tuning\"),\n                           level);\n            goto cleanup;\n        }\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n            virResctrlAllocPerTypePtr f_type = f_level->types[type];\n            unsigned int cache = 0;\n\n            if (!a_type)\n                continue;\n\n            if (!f_type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Cache level %d does not support tuning for \"\n                                 \"scope type '%s'\"),\n                               level, virCacheTypeToString(type));\n                goto cleanup;\n            }\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                virResctrlInfoPerLevelPtr i_level = resctrl->levels[level];\n                virResctrlInfoPerTypePtr i_type = i_level->types[type];\n\n                if (virResctrlAllocFindUnused(alloc, i_type, f_type, level, type, cache) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(alloc_free);\n    virObjectUnref(alloc_default);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocCopyMasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2184-2219",
    "snippet": "static int\nvirResctrlAllocCopyMasks(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    unsigned int level = 0;\n\n    for (level = 0; level < src->nlevels; level++) {\n        virResctrlAllocPerLevelPtr s_level = src->levels[level];\n        unsigned int type = 0;\n\n        if (!s_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr s_type = s_level->types[type];\n            virResctrlAllocPerTypePtr d_type = NULL;\n            unsigned int cache = 0;\n\n            if (!s_type)\n                continue;\n\n            d_type = virResctrlAllocGetType(dst, level, type);\n            if (!d_type)\n                return -1;\n\n            for (cache = 0; cache < s_type->nmasks; cache++) {\n                virBitmapPtr mask = s_type->masks[cache];\n\n                if (mask && virResctrlAllocUpdateMask(dst, level, type, cache, mask) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlAllocUpdateMask",
          "args": [
            "dst",
            "level",
            "type",
            "cache",
            "mask"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocUpdateMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1118-1143",
          "snippet": "static int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetType",
          "args": [
            "dst",
            "level",
            "type"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1085-1115",
          "snippet": "static virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocCopyMasks(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    unsigned int level = 0;\n\n    for (level = 0; level < src->nlevels; level++) {\n        virResctrlAllocPerLevelPtr s_level = src->levels[level];\n        unsigned int type = 0;\n\n        if (!s_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr s_type = s_level->types[type];\n            virResctrlAllocPerTypePtr d_type = NULL;\n            unsigned int cache = 0;\n\n            if (!s_type)\n                continue;\n\n            d_type = virResctrlAllocGetType(dst, level, type);\n            if (!d_type)\n                return -1;\n\n            for (cache = 0; cache < s_type->nmasks; cache++) {\n                virBitmapPtr mask = s_type->masks[cache];\n\n                if (mask && virResctrlAllocUpdateMask(dst, level, type, cache, mask) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocCopyMemBW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2150-2181",
    "snippet": "static int\nvirResctrlAllocCopyMemBW(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr dst_bw = NULL;\n    virResctrlAllocMemBWPtr src_bw = src->mem_bw;\n\n    if (!src->mem_bw)\n        return 0;\n\n    if (!dst->mem_bw &&\n        VIR_ALLOC(dst->mem_bw) < 0)\n        return -1;\n\n    dst_bw = dst->mem_bw;\n\n    if (src_bw->nbandwidths > dst_bw->nbandwidths &&\n        VIR_EXPAND_N(dst_bw->bandwidths, dst_bw->nbandwidths,\n                     src_bw->nbandwidths - dst_bw->nbandwidths) < 0)\n        return -1;\n\n    for (i = 0; i < src_bw->nbandwidths; i++) {\n        if (dst_bw->bandwidths[i])\n            continue;\n        if (VIR_ALLOC(dst_bw->bandwidths[i]) < 0)\n            return -1;\n        *dst_bw->bandwidths[i] = *src_bw->bandwidths[i];\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "dst_bw->bandwidths[i]"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "dst_bw->bandwidths",
            "dst_bw->nbandwidths",
            "src_bw->nbandwidths - dst_bw->nbandwidths"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "dst->mem_bw"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocCopyMemBW(virResctrlAllocPtr dst,\n                         virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr dst_bw = NULL;\n    virResctrlAllocMemBWPtr src_bw = src->mem_bw;\n\n    if (!src->mem_bw)\n        return 0;\n\n    if (!dst->mem_bw &&\n        VIR_ALLOC(dst->mem_bw) < 0)\n        return -1;\n\n    dst_bw = dst->mem_bw;\n\n    if (src_bw->nbandwidths > dst_bw->nbandwidths &&\n        VIR_EXPAND_N(dst_bw->bandwidths, dst_bw->nbandwidths,\n                     src_bw->nbandwidths - dst_bw->nbandwidths) < 0)\n        return -1;\n\n    for (i = 0; i < src_bw->nbandwidths; i++) {\n        if (dst_bw->bandwidths[i])\n            continue;\n        if (VIR_ALLOC(dst_bw->bandwidths[i]) < 0)\n            return -1;\n        *dst_bw->bandwidths[i] = *src_bw->bandwidths[i];\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocMemoryBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "2100-2147",
    "snippet": "static int\nvirResctrlAllocMemoryBandwidth(virResctrlInfoPtr resctrl,\n                               virResctrlAllocPtr alloc)\n{\n    size_t i;\n    virResctrlAllocMemBWPtr mem_bw_alloc = alloc->mem_bw;\n    virResctrlInfoMemBWPtr mem_bw_info = resctrl->membw_info;\n\n    if (!mem_bw_alloc)\n        return 0;\n\n    if (!mem_bw_info) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"RDT Memory Bandwidth allocation unsupported\"));\n        return -1;\n    }\n\n    for (i = 0; i < mem_bw_alloc->nbandwidths; i++) {\n        if (!mem_bw_alloc->bandwidths[i])\n            continue;\n\n        if (*(mem_bw_alloc->bandwidths[i]) % mem_bw_info->bandwidth_granularity) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is not divisible by granularity %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->bandwidth_granularity);\n            return -1;\n        }\n        if (*(mem_bw_alloc->bandwidths[i]) < mem_bw_info->min_bandwidth) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is smaller than the minimum \"\n                             \"allowed allocation %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->min_bandwidth);\n            return -1;\n        }\n        if (i > mem_bw_info->max_id) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\"),\n                           i, mem_bw_info->max_id);\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\")",
            "i",
            "mem_bw_info->max_id"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\""
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Memory Bandwidth allocation of size \"\n                             \"%u is smaller than the minimum \"\n                             \"allowed allocation %u\")",
            "*(mem_bw_alloc->bandwidths[i])",
            "mem_bw_info->min_bandwidth"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Memory Bandwidth allocation of size \"\n                             \"%u is not divisible by granularity %u\")",
            "*(mem_bw_alloc->bandwidths[i])",
            "mem_bw_info->bandwidth_granularity"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"RDT Memory Bandwidth allocation unsupported\")"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocMemoryBandwidth(virResctrlInfoPtr resctrl,\n                               virResctrlAllocPtr alloc)\n{\n    size_t i;\n    virResctrlAllocMemBWPtr mem_bw_alloc = alloc->mem_bw;\n    virResctrlInfoMemBWPtr mem_bw_info = resctrl->membw_info;\n\n    if (!mem_bw_alloc)\n        return 0;\n\n    if (!mem_bw_info) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"RDT Memory Bandwidth allocation unsupported\"));\n        return -1;\n    }\n\n    for (i = 0; i < mem_bw_alloc->nbandwidths; i++) {\n        if (!mem_bw_alloc->bandwidths[i])\n            continue;\n\n        if (*(mem_bw_alloc->bandwidths[i]) % mem_bw_info->bandwidth_granularity) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is not divisible by granularity %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->bandwidth_granularity);\n            return -1;\n        }\n        if (*(mem_bw_alloc->bandwidths[i]) < mem_bw_info->min_bandwidth) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Memory Bandwidth allocation of size \"\n                             \"%u is smaller than the minimum \"\n                             \"allowed allocation %u\"),\n                           *(mem_bw_alloc->bandwidths[i]),\n                           mem_bw_info->min_bandwidth);\n            return -1;\n        }\n        if (i > mem_bw_info->max_id) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"bandwidth controller id %zd does not \"\n                             \"exist, max controller id %u\"),\n                           i, mem_bw_info->max_id);\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocFindUnused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1979-2097",
    "snippet": "static int\nvirResctrlAllocFindUnused(virResctrlAllocPtr alloc,\n                          virResctrlInfoPerTypePtr i_type,\n                          virResctrlAllocPerTypePtr f_type,\n                          unsigned int level,\n                          unsigned int type,\n                          unsigned int cache)\n{\n    unsigned long long *size = alloc->levels[level]->types[type]->sizes[cache];\n    virBitmapPtr a_mask = NULL;\n    virBitmapPtr f_mask = NULL;\n    unsigned long long need_bits;\n    size_t i = 0;\n    ssize_t pos = -1;\n    ssize_t last_bits = 0;\n    ssize_t last_pos = -1;\n    int ret = -1;\n\n    if (!size)\n        return 0;\n\n    if (cache >= f_type->nmasks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache with id %u does not exists for level %d\"),\n                       cache, level);\n        return -1;\n    }\n\n    f_mask = f_type->masks[cache];\n    if (!f_mask) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache level %d id %u does not support tuning for \"\n                         \"scope type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    if (*size == i_type->size) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation for the whole cache is not \"\n                         \"possible, specify size smaller than %llu\"),\n                       i_type->size);\n        return -1;\n    }\n\n    need_bits = *size / i_type->control.granularity;\n\n    if (*size % i_type->control.granularity) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is not \"\n                         \"divisible by granularity %llu\"),\n                       *size, i_type->control.granularity);\n        return -1;\n    }\n\n    if (need_bits < i_type->min_cbm_bits) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is smaller \"\n                         \"than the minimum allowed allocation %llu\"),\n                       *size,\n                       i_type->control.granularity * i_type->min_cbm_bits);\n        return -1;\n    }\n\n    while ((pos = virBitmapNextSetBit(f_mask, pos)) >= 0) {\n        ssize_t pos_clear = virBitmapNextClearBit(f_mask, pos);\n        ssize_t bits;\n\n        if (pos_clear < 0)\n            pos_clear = virBitmapSize(f_mask);\n\n        bits = pos_clear - pos;\n\n        /* Not enough bits, move on and skip all of them */\n        if (bits < need_bits) {\n            pos = pos_clear;\n            continue;\n        }\n\n        /* This fits perfectly */\n        if (bits == need_bits) {\n            last_pos = pos;\n            break;\n        }\n\n        /* Remember the smaller region if we already found on before */\n        if (last_pos < 0 || (last_bits && bits < last_bits)) {\n            last_bits = bits;\n            last_pos = pos;\n        }\n\n        pos = pos_clear;\n    }\n\n    if (last_pos < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\"),\n                       *size, level, cache,\n                       virCacheTypeToString(type));\n        return -1;\n    }\n\n    a_mask = virBitmapNew(i_type->bits);\n    if (!a_mask)\n        return -1;\n\n    for (i = last_pos; i < last_pos + need_bits; i++)\n        ignore_value(virBitmapSetBit(a_mask, i));\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache, a_mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(a_mask);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "a_mask"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocUpdateMask",
          "args": [
            "alloc",
            "level",
            "type",
            "cache",
            "a_mask"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocUpdateMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1118-1143",
          "snippet": "static int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(a_mask, i)"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "a_mask",
            "i"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "i_type->bits"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\")",
            "*size",
            "level",
            "cache",
            "virCacheTypeToString(type)"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "type"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\""
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "f_mask"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "f_mask",
            "pos"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "f_mask",
            "pos"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache allocation of size %llu is smaller \"\n                         \"than the minimum allowed allocation %llu\")",
            "*size",
            "i_type->control.granularity * i_type->min_cbm_bits"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache allocation of size %llu is not \"\n                         \"divisible by granularity %llu\")",
            "*size",
            "i_type->control.granularity"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache allocation for the whole cache is not \"\n                         \"possible, specify size smaller than %llu\")",
            "i_type->size"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache level %d id %u does not support tuning for \"\n                         \"scope type '%s'\")",
            "level",
            "cache",
            "virCacheTypeToString(type)"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "type"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cache with id %u does not exists for level %d\")",
            "cache",
            "level"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocFindUnused(virResctrlAllocPtr alloc,\n                          virResctrlInfoPerTypePtr i_type,\n                          virResctrlAllocPerTypePtr f_type,\n                          unsigned int level,\n                          unsigned int type,\n                          unsigned int cache)\n{\n    unsigned long long *size = alloc->levels[level]->types[type]->sizes[cache];\n    virBitmapPtr a_mask = NULL;\n    virBitmapPtr f_mask = NULL;\n    unsigned long long need_bits;\n    size_t i = 0;\n    ssize_t pos = -1;\n    ssize_t last_bits = 0;\n    ssize_t last_pos = -1;\n    int ret = -1;\n\n    if (!size)\n        return 0;\n\n    if (cache >= f_type->nmasks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache with id %u does not exists for level %d\"),\n                       cache, level);\n        return -1;\n    }\n\n    f_mask = f_type->masks[cache];\n    if (!f_mask) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache level %d id %u does not support tuning for \"\n                         \"scope type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    if (*size == i_type->size) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation for the whole cache is not \"\n                         \"possible, specify size smaller than %llu\"),\n                       i_type->size);\n        return -1;\n    }\n\n    need_bits = *size / i_type->control.granularity;\n\n    if (*size % i_type->control.granularity) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is not \"\n                         \"divisible by granularity %llu\"),\n                       *size, i_type->control.granularity);\n        return -1;\n    }\n\n    if (need_bits < i_type->min_cbm_bits) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Cache allocation of size %llu is smaller \"\n                         \"than the minimum allowed allocation %llu\"),\n                       *size,\n                       i_type->control.granularity * i_type->min_cbm_bits);\n        return -1;\n    }\n\n    while ((pos = virBitmapNextSetBit(f_mask, pos)) >= 0) {\n        ssize_t pos_clear = virBitmapNextClearBit(f_mask, pos);\n        ssize_t bits;\n\n        if (pos_clear < 0)\n            pos_clear = virBitmapSize(f_mask);\n\n        bits = pos_clear - pos;\n\n        /* Not enough bits, move on and skip all of them */\n        if (bits < need_bits) {\n            pos = pos_clear;\n            continue;\n        }\n\n        /* This fits perfectly */\n        if (bits == need_bits) {\n            last_pos = pos;\n            break;\n        }\n\n        /* Remember the smaller region if we already found on before */\n        if (last_pos < 0 || (last_bits && bits < last_bits)) {\n            last_bits = bits;\n            last_pos = pos;\n        }\n\n        pos = pos_clear;\n    }\n\n    if (last_pos < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Not enough room for allocation of \"\n                         \"%llu bytes for level %u cache %u \"\n                         \"scope type '%s'\"),\n                       *size, level, cache,\n                       virCacheTypeToString(type));\n        return -1;\n    }\n\n    a_mask = virBitmapNew(i_type->bits);\n    if (!a_mask)\n        return -1;\n\n    for (i = last_pos; i < last_pos + need_bits; i++)\n        ignore_value(virBitmapSetBit(a_mask, i));\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache, a_mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(a_mask);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocGetUnused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1906-1966",
    "snippet": "virResctrlAllocPtr\nvirResctrlAllocGetUnused(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    virResctrlAllocPtr alloc = NULL;\n    struct dirent *ent = NULL;\n    DIR *dirp = NULL;\n    int rv = -1;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return NULL;\n    }\n\n    ret = virResctrlAllocNewFromInfo(resctrl);\n    if (!ret)\n        return NULL;\n\n    alloc = virResctrlAllocGetDefault(resctrl);\n    if (!alloc)\n        goto error;\n\n    virResctrlAllocSubtract(ret, alloc);\n    virObjectUnref(alloc);\n\n    if (virDirOpen(&dirp, SYSFS_RESCTRL_PATH) < 0)\n        goto error;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH)) > 0) {\n        if (STREQ(ent->d_name, \"info\"))\n            continue;\n\n        rv = virResctrlAllocGetGroup(resctrl, ent->d_name, &alloc);\n        if (rv == -2)\n            continue;\n\n        if (rv < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not read schemata file for group %s\"),\n                           ent->d_name);\n            goto error;\n        }\n\n        virResctrlAllocSubtract(ret, alloc);\n        virObjectUnref(alloc);\n        alloc = NULL;\n    }\n    if (rv < 0)\n        goto error;\n\n cleanup:\n    virObjectUnref(alloc);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dirp"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocSubtract",
          "args": [
            "ret",
            "alloc"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1809-1827",
          "snippet": "static void\nvirResctrlAllocSubtract(virResctrlAllocPtr dst,\n                        virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!src)\n        return;\n\n    for (i = 0; i < dst->nlevels && i < src->nlevels; i++) {\n        if (dst->levels[i] && src->levels[i]) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n                virResctrlAllocSubtractPerType(dst->levels[i]->types[j],\n                                               src->levels[i]->types[j]);\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlAllocSubtract(virResctrlAllocPtr dst,\n                        virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!src)\n        return;\n\n    for (i = 0; i < dst->nlevels && i < src->nlevels; i++) {\n        if (dst->levels[i] && src->levels[i]) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n                virResctrlAllocSubtractPerType(dst->levels[i]->types[j],\n                                               src->levels[i]->types[j]);\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not read schemata file for group %s\")",
            "ent->d_name"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not read schemata file for group %s\""
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetGroup",
          "args": [
            "resctrl",
            "ent->d_name",
            "&alloc"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1745-1775",
          "snippet": "static int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"info\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dirp",
            "&ent",
            "SYSFS_RESCTRL_PATH"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dirp",
            "SYSFS_RESCTRL_PATH"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetDefault",
          "args": [
            "resctrl"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1778-1790",
          "snippet": "static virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocNewFromInfo",
          "args": [
            "resctrl"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocNewFromInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1830-1890",
          "snippet": "static virResctrlAllocPtr\nvirResctrlAllocNewFromInfo(virResctrlInfoPtr info)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n    virResctrlAllocPtr ret = virResctrlAllocNew();\n    virBitmapPtr mask = NULL;\n\n    if (!ret)\n        return NULL;\n\n    for (i = 0; i < info->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = info->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlInfoPerTypePtr i_type = i_level->types[j];\n\n            if (!i_type)\n                continue;\n\n            virBitmapFree(mask);\n            mask = virBitmapNew(i_type->bits);\n            if (!mask)\n                goto error;\n            virBitmapSetAll(mask);\n\n            for (k = 0; k <= i_type->max_cache_id; k++) {\n                if (virResctrlAllocUpdateMask(ret, i, j, k, mask) < 0)\n                    goto error;\n            }\n        }\n    }\n\n    /* set default free memory bandwidth to 100%*/\n    if (info->membw_info) {\n        if (VIR_ALLOC(ret->mem_bw) < 0)\n            goto error;\n\n        if (VIR_EXPAND_N(ret->mem_bw->bandwidths, ret->mem_bw->nbandwidths,\n                         info->membw_info->max_id + 1) < 0)\n            goto error;\n\n        for (i = 0; i < ret->mem_bw->nbandwidths; i++) {\n            if (VIR_ALLOC(ret->mem_bw->bandwidths[i]) < 0)\n                goto error;\n            *(ret->mem_bw->bandwidths[i]) = 100;\n        }\n    }\n\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPtr\nvirResctrlAllocNewFromInfo(virResctrlInfoPtr info)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n    virResctrlAllocPtr ret = virResctrlAllocNew();\n    virBitmapPtr mask = NULL;\n\n    if (!ret)\n        return NULL;\n\n    for (i = 0; i < info->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = info->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlInfoPerTypePtr i_type = i_level->types[j];\n\n            if (!i_type)\n                continue;\n\n            virBitmapFree(mask);\n            mask = virBitmapNew(i_type->bits);\n            if (!mask)\n                goto error;\n            virBitmapSetAll(mask);\n\n            for (k = 0; k <= i_type->max_cache_id; k++) {\n                if (virResctrlAllocUpdateMask(ret, i, j, k, mask) < 0)\n                    goto error;\n            }\n        }\n    }\n\n    /* set default free memory bandwidth to 100%*/\n    if (info->membw_info) {\n        if (VIR_ALLOC(ret->mem_bw) < 0)\n            goto error;\n\n        if (VIR_EXPAND_N(ret->mem_bw->bandwidths, ret->mem_bw->nbandwidths,\n                         info->membw_info->max_id + 1) < 0)\n            goto error;\n\n        for (i = 0; i < ret->mem_bw->nbandwidths; i++) {\n            if (VIR_ALLOC(ret->mem_bw->bandwidths[i]) < 0)\n                goto error;\n            *(ret->mem_bw->bandwidths[i]) = 100;\n        }\n    }\n\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Resource control is not supported on this host\")"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoIsEmpty",
          "args": [
            "resctrl"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "814-842",
          "snippet": "static bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nvirResctrlAllocPtr\nvirResctrlAllocGetUnused(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    virResctrlAllocPtr alloc = NULL;\n    struct dirent *ent = NULL;\n    DIR *dirp = NULL;\n    int rv = -1;\n\n    if (virResctrlInfoIsEmpty(resctrl)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Resource control is not supported on this host\"));\n        return NULL;\n    }\n\n    ret = virResctrlAllocNewFromInfo(resctrl);\n    if (!ret)\n        return NULL;\n\n    alloc = virResctrlAllocGetDefault(resctrl);\n    if (!alloc)\n        goto error;\n\n    virResctrlAllocSubtract(ret, alloc);\n    virObjectUnref(alloc);\n\n    if (virDirOpen(&dirp, SYSFS_RESCTRL_PATH) < 0)\n        goto error;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH)) > 0) {\n        if (STREQ(ent->d_name, \"info\"))\n            continue;\n\n        rv = virResctrlAllocGetGroup(resctrl, ent->d_name, &alloc);\n        if (rv == -2)\n            continue;\n\n        if (rv < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not read schemata file for group %s\"),\n                           ent->d_name);\n            goto error;\n        }\n\n        virResctrlAllocSubtract(ret, alloc);\n        virObjectUnref(alloc);\n        alloc = NULL;\n    }\n    if (rv < 0)\n        goto error;\n\n cleanup:\n    virObjectUnref(alloc);\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virResctrlAllocNewFromInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1830-1890",
    "snippet": "static virResctrlAllocPtr\nvirResctrlAllocNewFromInfo(virResctrlInfoPtr info)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n    virResctrlAllocPtr ret = virResctrlAllocNew();\n    virBitmapPtr mask = NULL;\n\n    if (!ret)\n        return NULL;\n\n    for (i = 0; i < info->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = info->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlInfoPerTypePtr i_type = i_level->types[j];\n\n            if (!i_type)\n                continue;\n\n            virBitmapFree(mask);\n            mask = virBitmapNew(i_type->bits);\n            if (!mask)\n                goto error;\n            virBitmapSetAll(mask);\n\n            for (k = 0; k <= i_type->max_cache_id; k++) {\n                if (virResctrlAllocUpdateMask(ret, i, j, k, mask) < 0)\n                    goto error;\n            }\n        }\n    }\n\n    /* set default free memory bandwidth to 100%*/\n    if (info->membw_info) {\n        if (VIR_ALLOC(ret->mem_bw) < 0)\n            goto error;\n\n        if (VIR_EXPAND_N(ret->mem_bw->bandwidths, ret->mem_bw->nbandwidths,\n                         info->membw_info->max_id + 1) < 0)\n            goto error;\n\n        for (i = 0; i < ret->mem_bw->nbandwidths; i++) {\n            if (VIR_ALLOC(ret->mem_bw->bandwidths[i]) < 0)\n                goto error;\n            *(ret->mem_bw->bandwidths[i]) = 100;\n        }\n    }\n\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "mask"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret->mem_bw->bandwidths[i]"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "ret->mem_bw->bandwidths",
            "ret->mem_bw->nbandwidths",
            "info->membw_info->max_id + 1"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret->mem_bw"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocUpdateMask",
          "args": [
            "ret",
            "i",
            "j",
            "k",
            "mask"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocUpdateMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1118-1143",
          "snippet": "static int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSetAll",
          "args": [
            "mask"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "895-906",
          "snippet": "void virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "i_type->bits"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocNew",
          "args": [],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1034-1041",
          "snippet": "virResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virResctrlAllocClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlAllocClass;\n\nvirResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPtr\nvirResctrlAllocNewFromInfo(virResctrlInfoPtr info)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n    virResctrlAllocPtr ret = virResctrlAllocNew();\n    virBitmapPtr mask = NULL;\n\n    if (!ret)\n        return NULL;\n\n    for (i = 0; i < info->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = info->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlInfoPerTypePtr i_type = i_level->types[j];\n\n            if (!i_type)\n                continue;\n\n            virBitmapFree(mask);\n            mask = virBitmapNew(i_type->bits);\n            if (!mask)\n                goto error;\n            virBitmapSetAll(mask);\n\n            for (k = 0; k <= i_type->max_cache_id; k++) {\n                if (virResctrlAllocUpdateMask(ret, i, j, k, mask) < 0)\n                    goto error;\n            }\n        }\n    }\n\n    /* set default free memory bandwidth to 100%*/\n    if (info->membw_info) {\n        if (VIR_ALLOC(ret->mem_bw) < 0)\n            goto error;\n\n        if (VIR_EXPAND_N(ret->mem_bw->bandwidths, ret->mem_bw->nbandwidths,\n                         info->membw_info->max_id + 1) < 0)\n            goto error;\n\n        for (i = 0; i < ret->mem_bw->nbandwidths; i++) {\n            if (VIR_ALLOC(ret->mem_bw->bandwidths[i]) < 0)\n                goto error;\n            *(ret->mem_bw->bandwidths[i]) = 100;\n        }\n    }\n\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n error:\n    virObjectUnref(ret);\n    ret = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virResctrlAllocSubtract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1809-1827",
    "snippet": "static void\nvirResctrlAllocSubtract(virResctrlAllocPtr dst,\n                        virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!src)\n        return;\n\n    for (i = 0; i < dst->nlevels && i < src->nlevels; i++) {\n        if (dst->levels[i] && src->levels[i]) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n                virResctrlAllocSubtractPerType(dst->levels[i]->types[j],\n                                               src->levels[i]->types[j]);\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlAllocSubtractPerType",
          "args": [
            "dst->levels[i]->types[j]",
            "src->levels[i]->types[j]"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocSubtractPerType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1793-1806",
          "snippet": "static void\nvirResctrlAllocSubtractPerType(virResctrlAllocPerTypePtr dst,\n                               virResctrlAllocPerTypePtr src)\n{\n    size_t i = 0;\n\n    if (!dst || !src)\n        return;\n\n    for (i = 0; i < dst->nmasks && i < src->nmasks; i++) {\n        if (dst->masks[i] && src->masks[i])\n            virBitmapSubtract(dst->masks[i], src->masks[i]);\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlAllocSubtractPerType(virResctrlAllocPerTypePtr dst,\n                               virResctrlAllocPerTypePtr src)\n{\n    size_t i = 0;\n\n    if (!dst || !src)\n        return;\n\n    for (i = 0; i < dst->nmasks && i < src->nmasks; i++) {\n        if (dst->masks[i] && src->masks[i])\n            virBitmapSubtract(dst->masks[i], src->masks[i]);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlAllocSubtract(virResctrlAllocPtr dst,\n                        virResctrlAllocPtr src)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!src)\n        return;\n\n    for (i = 0; i < dst->nlevels && i < src->nlevels; i++) {\n        if (dst->levels[i] && src->levels[i]) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n                virResctrlAllocSubtractPerType(dst->levels[i]->types[j],\n                                               src->levels[i]->types[j]);\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "virResctrlAllocSubtractPerType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1793-1806",
    "snippet": "static void\nvirResctrlAllocSubtractPerType(virResctrlAllocPerTypePtr dst,\n                               virResctrlAllocPerTypePtr src)\n{\n    size_t i = 0;\n\n    if (!dst || !src)\n        return;\n\n    for (i = 0; i < dst->nmasks && i < src->nmasks; i++) {\n        if (dst->masks[i] && src->masks[i])\n            virBitmapSubtract(dst->masks[i], src->masks[i]);\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapSubtract",
          "args": [
            "dst->masks[i]",
            "src->masks[i]"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1279-1291",
          "snippet": "void\nvirBitmapSubtract(virBitmapPtr a,\n                  virBitmapPtr b)\n{\n    size_t i;\n    size_t max = a->map_len;\n\n    if (max > b->map_len)\n        max = b->map_len;\n\n    for (i = 0; i < max; i++)\n        a->map[i] &= ~b->map[i];\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapSubtract(virBitmapPtr a,\n                  virBitmapPtr b)\n{\n    size_t i;\n    size_t max = a->map_len;\n\n    if (max > b->map_len)\n        max = b->map_len;\n\n    for (i = 0; i < max; i++)\n        a->map[i] &= ~b->map[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlAllocSubtractPerType(virResctrlAllocPerTypePtr dst,\n                               virResctrlAllocPerTypePtr src)\n{\n    size_t i = 0;\n\n    if (!dst || !src)\n        return;\n\n    for (i = 0; i < dst->nmasks && i < src->nmasks; i++) {\n        if (dst->masks[i] && src->masks[i])\n            virBitmapSubtract(dst->masks[i], src->masks[i]);\n    }\n}"
  },
  {
    "function_name": "virResctrlAllocGetDefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1778-1790",
    "snippet": "static virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not read schemata file for the default group\")"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not read schemata file for the default group\""
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetGroup",
          "args": [
            "resctrl",
            "\".\"",
            "&ret"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1745-1775",
          "snippet": "static int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPtr\nvirResctrlAllocGetDefault(virResctrlInfoPtr resctrl)\n{\n    virResctrlAllocPtr ret = NULL;\n    int rv = virResctrlAllocGetGroup(resctrl, \".\", &ret);\n\n    if (rv == -2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not read schemata file for the default group\"));\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocGetGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1745-1775",
    "snippet": "static int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "*alloc"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "schemata"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "schemata"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocParse",
          "args": [
            "resctrl",
            "*alloc",
            "schemata"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1719-1742",
          "snippet": "static int\nvirResctrlAllocParse(virResctrlInfoPtr resctrl,\n                     virResctrlAllocPtr alloc,\n                     const char *schemata)\n{\n    char **lines = NULL;\n    size_t nlines = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    lines = virStringSplitCount(schemata, \"\\n\", 0, &nlines);\n    for (i = 0; i < nlines; i++) {\n        if (virResctrlAllocParseCacheLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n        if (virResctrlAllocParseMemoryBandwidthLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(lines);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParse(virResctrlInfoPtr resctrl,\n                     virResctrlAllocPtr alloc,\n                     const char *schemata)\n{\n    char **lines = NULL;\n    size_t nlines = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    lines = virStringSplitCount(schemata, \"\\n\", 0, &nlines);\n    for (i = 0; i < nlines; i++) {\n        if (virResctrlAllocParseCacheLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n        if (virResctrlAllocParseMemoryBandwidthLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(lines);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocNew",
          "args": [],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1034-1041",
          "snippet": "virResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virResctrlAllocClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlAllocClass;\n\nvirResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&schemata",
            "SYSFS_RESCTRL_PATH \"/%s/schemata\"",
            "groupname"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlAllocGetGroup(virResctrlInfoPtr resctrl,\n                        const char *groupname,\n                        virResctrlAllocPtr *alloc)\n{\n    char *schemata = NULL;\n    int rv = virFileReadValueString(&schemata,\n                                    SYSFS_RESCTRL_PATH \"/%s/schemata\",\n                                    groupname);\n\n    *alloc = NULL;\n\n    if (rv < 0)\n        return rv;\n\n    *alloc = virResctrlAllocNew();\n    if (!*alloc)\n        goto error;\n\n    if (virResctrlAllocParse(resctrl, *alloc, schemata) < 0)\n        goto error;\n\n    VIR_FREE(schemata);\n    return 0;\n\n error:\n    VIR_FREE(schemata);\n    virObjectUnref(*alloc);\n    *alloc = NULL;\n    return -1;\n}"
  },
  {
    "function_name": "virResctrlAllocParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1719-1742",
    "snippet": "static int\nvirResctrlAllocParse(virResctrlInfoPtr resctrl,\n                     virResctrlAllocPtr alloc,\n                     const char *schemata)\n{\n    char **lines = NULL;\n    size_t nlines = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    lines = virStringSplitCount(schemata, \"\\n\", 0, &nlines);\n    for (i = 0; i < nlines; i++) {\n        if (virResctrlAllocParseCacheLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n        if (virResctrlAllocParseMemoryBandwidthLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(lines);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "lines"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocParseMemoryBandwidthLine",
          "args": [
            "resctrl",
            "alloc",
            "lines[i]"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocParseMemoryBandwidthLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1492-1538",
          "snippet": "static int\nvirResctrlAllocParseMemoryBandwidthLine(virResctrlInfoPtr resctrl,\n                                        virResctrlAllocPtr alloc,\n                                        char *line)\n{\n    char **mbs = NULL;\n    char *tmp = NULL;\n    size_t nmbs = 0;\n    size_t i;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    if (STRNEQLEN(line, \"MB\", 2))\n        return 0;\n\n    if (!resctrl || !resctrl->membw_info ||\n        !resctrl->membw_info->min_bandwidth ||\n        !resctrl->membw_info->bandwidth_granularity) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\"));\n        return -1;\n    }\n\n    if (!alloc->mem_bw) {\n        if (VIR_ALLOC(alloc->mem_bw) < 0)\n            return -1;\n    }\n\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n    tmp++;\n\n    mbs = virStringSplitCount(tmp, \";\", 0, &nmbs);\n    for (i = 0; i < nmbs; i++) {\n        if (virResctrlAllocParseProcessMemoryBandwidth(resctrl, alloc, mbs[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(mbs);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseMemoryBandwidthLine(virResctrlInfoPtr resctrl,\n                                        virResctrlAllocPtr alloc,\n                                        char *line)\n{\n    char **mbs = NULL;\n    char *tmp = NULL;\n    size_t nmbs = 0;\n    size_t i;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    if (STRNEQLEN(line, \"MB\", 2))\n        return 0;\n\n    if (!resctrl || !resctrl->membw_info ||\n        !resctrl->membw_info->min_bandwidth ||\n        !resctrl->membw_info->bandwidth_granularity) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\"));\n        return -1;\n    }\n\n    if (!alloc->mem_bw) {\n        if (VIR_ALLOC(alloc->mem_bw) < 0)\n            return -1;\n    }\n\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n    tmp++;\n\n    mbs = virStringSplitCount(tmp, \";\", 0, &nmbs);\n    for (i = 0; i < nmbs; i++) {\n        if (virResctrlAllocParseProcessMemoryBandwidth(resctrl, alloc, mbs[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(mbs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocParseCacheLine",
          "args": [
            "resctrl",
            "alloc",
            "lines[i]"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocParseCacheLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1660-1716",
          "snippet": "static int\nvirResctrlAllocParseCacheLine(virResctrlInfoPtr resctrl,\n                              virResctrlAllocPtr alloc,\n                              char *line)\n{\n    char **caches = NULL;\n    char *tmp = NULL;\n    unsigned int level = 0;\n    int type = -1;\n    size_t ncaches = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    /* Skip lines that don't concern caches, e.g. MB: etc. */\n    if (line[0] != 'L')\n        return 0;\n\n    /* And lines that we can't parse too */\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(line + 1, &line, 10, &level) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    type = virResctrlTypeFromString(line);\n    if (type < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    caches = virStringSplitCount(tmp, \";\", 0, &ncaches);\n    if (!caches)\n        return 0;\n\n    for (i = 0; i < ncaches; i++) {\n        if (virResctrlAllocParseProcessCache(resctrl, alloc, level, type, caches[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(caches);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseCacheLine(virResctrlInfoPtr resctrl,\n                              virResctrlAllocPtr alloc,\n                              char *line)\n{\n    char **caches = NULL;\n    char *tmp = NULL;\n    unsigned int level = 0;\n    int type = -1;\n    size_t ncaches = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    /* Skip lines that don't concern caches, e.g. MB: etc. */\n    if (line[0] != 'L')\n        return 0;\n\n    /* And lines that we can't parse too */\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(line + 1, &line, 10, &level) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    type = virResctrlTypeFromString(line);\n    if (type < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    caches = virStringSplitCount(tmp, \";\", 0, &ncaches);\n    if (!caches)\n        return 0;\n\n    for (i = 0; i < ncaches; i++) {\n        if (virResctrlAllocParseProcessCache(resctrl, alloc, level, type, caches[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(caches);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "schemata",
            "\"\\n\"",
            "0",
            "&nlines"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParse(virResctrlInfoPtr resctrl,\n                     virResctrlAllocPtr alloc,\n                     const char *schemata)\n{\n    char **lines = NULL;\n    size_t nlines = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    lines = virStringSplitCount(schemata, \"\\n\", 0, &nlines);\n    for (i = 0; i < nlines; i++) {\n        if (virResctrlAllocParseCacheLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n        if (virResctrlAllocParseMemoryBandwidthLine(resctrl, alloc, lines[i]) < 0)\n            goto cleanup;\n\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(lines);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocParseCacheLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1660-1716",
    "snippet": "static int\nvirResctrlAllocParseCacheLine(virResctrlInfoPtr resctrl,\n                              virResctrlAllocPtr alloc,\n                              char *line)\n{\n    char **caches = NULL;\n    char *tmp = NULL;\n    unsigned int level = 0;\n    int type = -1;\n    size_t ncaches = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    /* Skip lines that don't concern caches, e.g. MB: etc. */\n    if (line[0] != 'L')\n        return 0;\n\n    /* And lines that we can't parse too */\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(line + 1, &line, 10, &level) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    type = virResctrlTypeFromString(line);\n    if (type < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    caches = virStringSplitCount(tmp, \";\", 0, &ncaches);\n    if (!caches)\n        return 0;\n\n    for (i = 0; i < ncaches; i++) {\n        if (virResctrlAllocParseProcessCache(resctrl, alloc, level, type, caches[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(caches);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "caches"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocParseProcessCache",
          "args": [
            "resctrl",
            "alloc",
            "level",
            "type",
            "caches[i]"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocParseProcessCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1609-1657",
          "snippet": "static int\nvirResctrlAllocParseProcessCache(virResctrlInfoPtr resctrl,\n                                 virResctrlAllocPtr alloc,\n                                 unsigned int level,\n                                 virCacheType type,\n                                 char *cache)\n{\n    char *tmp = strchr(cache, '=');\n    unsigned int cache_id = 0;\n    virBitmapPtr mask = NULL;\n    int ret = -1;\n\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(cache, NULL, 10, &cache_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid cache id '%s'\"), cache);\n        return -1;\n    }\n\n    mask = virBitmapNewString(tmp);\n    if (!mask)\n        return -1;\n\n    if (!resctrl ||\n        level >= resctrl->nlevels ||\n        !resctrl->levels[level] ||\n        !resctrl->levels[level]->types[type]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\"),\n                       level, virCacheTypeToString(type));\n        goto cleanup;\n    }\n\n    virBitmapShrink(mask, resctrl->levels[level]->types[type]->bits);\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache_id, mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseProcessCache(virResctrlInfoPtr resctrl,\n                                 virResctrlAllocPtr alloc,\n                                 unsigned int level,\n                                 virCacheType type,\n                                 char *cache)\n{\n    char *tmp = strchr(cache, '=');\n    unsigned int cache_id = 0;\n    virBitmapPtr mask = NULL;\n    int ret = -1;\n\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(cache, NULL, 10, &cache_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid cache id '%s'\"), cache);\n        return -1;\n    }\n\n    mask = virBitmapNewString(tmp);\n    if (!mask)\n        return -1;\n\n    if (!resctrl ||\n        level >= resctrl->nlevels ||\n        !resctrl->levels[level] ||\n        !resctrl->levels[level]->types[type]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\"),\n                       level, virCacheTypeToString(type));\n        goto cleanup;\n    }\n\n    virBitmapShrink(mask, resctrl->levels[level]->types[type]->bits);\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache_id, mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "tmp",
            "\";\"",
            "0",
            "&ncaches"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse resctrl schema level '%s'\")",
            "line + 1"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot parse resctrl schema level '%s'\""
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlTypeFromString",
          "args": [
            "line"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse resctrl schema level '%s'\")",
            "line + 1"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "line + 1",
            "&line",
            "10",
            "&level"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSkipSpaces",
          "args": [
            "(const char **) &line"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "virSkipSpacesAndBackslash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "810-818",
          "snippet": "void\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseCacheLine(virResctrlInfoPtr resctrl,\n                              virResctrlAllocPtr alloc,\n                              char *line)\n{\n    char **caches = NULL;\n    char *tmp = NULL;\n    unsigned int level = 0;\n    int type = -1;\n    size_t ncaches = 0;\n    size_t i = 0;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    /* Skip lines that don't concern caches, e.g. MB: etc. */\n    if (line[0] != 'L')\n        return 0;\n\n    /* And lines that we can't parse too */\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(line + 1, &line, 10, &level) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    type = virResctrlTypeFromString(line);\n    if (type < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse resctrl schema level '%s'\"),\n                       line + 1);\n        return -1;\n    }\n\n    caches = virStringSplitCount(tmp, \";\", 0, &ncaches);\n    if (!caches)\n        return 0;\n\n    for (i = 0; i < ncaches; i++) {\n        if (virResctrlAllocParseProcessCache(resctrl, alloc, level, type, caches[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(caches);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocParseProcessCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1609-1657",
    "snippet": "static int\nvirResctrlAllocParseProcessCache(virResctrlInfoPtr resctrl,\n                                 virResctrlAllocPtr alloc,\n                                 unsigned int level,\n                                 virCacheType type,\n                                 char *cache)\n{\n    char *tmp = strchr(cache, '=');\n    unsigned int cache_id = 0;\n    virBitmapPtr mask = NULL;\n    int ret = -1;\n\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(cache, NULL, 10, &cache_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid cache id '%s'\"), cache);\n        return -1;\n    }\n\n    mask = virBitmapNewString(tmp);\n    if (!mask)\n        return -1;\n\n    if (!resctrl ||\n        level >= resctrl->nlevels ||\n        !resctrl->levels[level] ||\n        !resctrl->levels[level]->types[type]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\"),\n                       level, virCacheTypeToString(type));\n        goto cleanup;\n    }\n\n    virBitmapShrink(mask, resctrl->levels[level]->types[type]->bits);\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache_id, mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "mask"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocUpdateMask",
          "args": [
            "alloc",
            "level",
            "type",
            "cache_id",
            "mask"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocUpdateMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1118-1143",
          "snippet": "static int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapShrink",
          "args": [
            "mask",
            "resctrl->levels[level]->types[type]->bits"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapShrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1302-1329",
          "snippet": "void\nvirBitmapShrink(virBitmapPtr map,\n                size_t b)\n{\n    size_t toremove;\n    size_t nl = 0;\n    size_t nb = 0;\n\n    if (!map)\n        return;\n\n    if (map->nbits >= b)\n        map->nbits = b;\n\n    nl = map->nbits / VIR_BITMAP_BITS_PER_UNIT;\n    nb = map->nbits % VIR_BITMAP_BITS_PER_UNIT;\n    map->map[nl] &= ((1UL << nb) - 1);\n\n    toremove = map->map_alloc - (nl + 1);\n\n    if (toremove == 0)\n        return;\n\n    VIR_SHRINK_N(map->map, map->map_alloc, toremove);\n\n    /* length needs to be fixed as well */\n    map->map_len = map->map_alloc;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid\nvirBitmapShrink(virBitmapPtr map,\n                size_t b)\n{\n    size_t toremove;\n    size_t nl = 0;\n    size_t nb = 0;\n\n    if (!map)\n        return;\n\n    if (map->nbits >= b)\n        map->nbits = b;\n\n    nl = map->nbits / VIR_BITMAP_BITS_PER_UNIT;\n    nb = map->nbits % VIR_BITMAP_BITS_PER_UNIT;\n    map->map[nl] &= ((1UL << nb) - 1);\n\n    toremove = map->map_alloc - (nl + 1);\n\n    if (toremove == 0)\n        return;\n\n    VIR_SHRINK_N(map->map, map->map_alloc, toremove);\n\n    /* length needs to be fixed as well */\n    map->map_len = map->map_alloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\")",
            "level",
            "virCacheTypeToString(type)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "type"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\""
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewString",
          "args": [
            "tmp"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid cache id '%s'\")",
            "cache"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "cache",
            "NULL",
            "10",
            "&cache_id"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cache",
            "'='"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseProcessCache(virResctrlInfoPtr resctrl,\n                                 virResctrlAllocPtr alloc,\n                                 unsigned int level,\n                                 virCacheType type,\n                                 char *cache)\n{\n    char *tmp = strchr(cache, '=');\n    unsigned int cache_id = 0;\n    virBitmapPtr mask = NULL;\n    int ret = -1;\n\n    if (!tmp)\n        return 0;\n\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(cache, NULL, 10, &cache_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid cache id '%s'\"), cache);\n        return -1;\n    }\n\n    mask = virBitmapNewString(tmp);\n    if (!mask)\n        return -1;\n\n    if (!resctrl ||\n        level >= resctrl->nlevels ||\n        !resctrl->levels[level] ||\n        !resctrl->levels[level]->types[type]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"level '%u' type '%s'\"),\n                       level, virCacheTypeToString(type));\n        goto cleanup;\n    }\n\n    virBitmapShrink(mask, resctrl->levels[level]->types[type]->bits);\n\n    if (virResctrlAllocUpdateMask(alloc, level, type, cache_id, mask) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(mask);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1587-1606",
    "snippet": "char *\nvirResctrlAllocFormat(virResctrlAllocPtr alloc)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (!alloc)\n        return NULL;\n\n    if (virResctrlAllocFormatCache(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    if (virResctrlAllocMemoryBandwidthFormat(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocMemoryBandwidthFormat",
          "args": [
            "alloc",
            "&buf"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocMemoryBandwidthFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1418-1439",
          "snippet": "static int\nvirResctrlAllocMemoryBandwidthFormat(virResctrlAllocPtr alloc,\n                                     virBufferPtr buf)\n{\n    size_t i;\n\n    if (!alloc->mem_bw)\n        return 0;\n\n    virBufferAddLit(buf, \"MB:\");\n\n    for (i = 0; i < alloc->mem_bw->nbandwidths; i++) {\n        if (alloc->mem_bw->bandwidths[i]) {\n            virBufferAsprintf(buf, \"%zd=%u;\", i,\n                              *(alloc->mem_bw->bandwidths[i]));\n        }\n    }\n\n    virBufferTrim(buf, \";\");\n    virBufferAddChar(buf, '\\n');\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocMemoryBandwidthFormat(virResctrlAllocPtr alloc,\n                                     virBufferPtr buf)\n{\n    size_t i;\n\n    if (!alloc->mem_bw)\n        return 0;\n\n    virBufferAddLit(buf, \"MB:\");\n\n    for (i = 0; i < alloc->mem_bw->nbandwidths; i++) {\n        if (alloc->mem_bw->bandwidths[i]) {\n            virBufferAsprintf(buf, \"%zd=%u;\", i,\n                              *(alloc->mem_bw->bandwidths[i]));\n        }\n    }\n\n    virBufferTrim(buf, \";\");\n    virBufferAddChar(buf, '\\n');\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocFormatCache",
          "args": [
            "alloc",
            "&buf"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocFormatCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1541-1584",
          "snippet": "static int\nvirResctrlAllocFormatCache(virResctrlAllocPtr alloc,\n                           virBufferPtr buf)\n{\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            virBufferAsprintf(buf, \"L%u%s:\", level, virResctrlTypeToString(type));\n\n            for (cache = 0; cache < a_type->nmasks; cache++) {\n                virBitmapPtr mask = a_type->masks[cache];\n                char *mask_str = NULL;\n\n                if (!mask)\n                    continue;\n\n                mask_str = virBitmapToString(mask, false, true);\n                if (!mask_str)\n                    return -1;\n\n                virBufferAsprintf(buf, \"%u=%s;\", cache, mask_str);\n                VIR_FREE(mask_str);\n            }\n\n            virBufferTrim(buf, \";\");\n            virBufferAddChar(buf, '\\n');\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocFormatCache(virResctrlAllocPtr alloc,\n                           virBufferPtr buf)\n{\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            virBufferAsprintf(buf, \"L%u%s:\", level, virResctrlTypeToString(type));\n\n            for (cache = 0; cache < a_type->nmasks; cache++) {\n                virBitmapPtr mask = a_type->masks[cache];\n                char *mask_str = NULL;\n\n                if (!mask)\n                    continue;\n\n                mask_str = virBitmapToString(mask, false, true);\n                if (!mask_str)\n                    return -1;\n\n                virBufferAsprintf(buf, \"%u=%s;\", cache, mask_str);\n                VIR_FREE(mask_str);\n            }\n\n            virBufferTrim(buf, \";\");\n            virBufferAddChar(buf, '\\n');\n        }\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nchar *\nvirResctrlAllocFormat(virResctrlAllocPtr alloc)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (!alloc)\n        return NULL;\n\n    if (virResctrlAllocFormatCache(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    if (virResctrlAllocMemoryBandwidthFormat(alloc, &buf) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virResctrlAllocFormatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1541-1584",
    "snippet": "static int\nvirResctrlAllocFormatCache(virResctrlAllocPtr alloc,\n                           virBufferPtr buf)\n{\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            virBufferAsprintf(buf, \"L%u%s:\", level, virResctrlTypeToString(type));\n\n            for (cache = 0; cache < a_type->nmasks; cache++) {\n                virBitmapPtr mask = a_type->masks[cache];\n                char *mask_str = NULL;\n\n                if (!mask)\n                    continue;\n\n                mask_str = virBitmapToString(mask, false, true);\n                if (!mask_str)\n                    return -1;\n\n                virBufferAsprintf(buf, \"%u=%s;\", cache, mask_str);\n                VIR_FREE(mask_str);\n            }\n\n            virBufferTrim(buf, \";\");\n            virBufferAddChar(buf, '\\n');\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "buf",
            "\";\""
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mask_str"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%u=%s;\"",
            "cache",
            "mask_str"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapToString",
          "args": [
            "mask",
            "false",
            "true"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "343-387",
          "snippet": "char *\nvirBitmapToString(virBitmapPtr bitmap,\n                  bool prefix,\n                  bool trim)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t sz;\n    size_t len;\n    size_t diff;\n    char *ret = NULL;\n\n    if (prefix)\n        virBufferAddLit(&buf, \"0x\");\n\n    sz = bitmap->map_len;\n\n    while (sz--) {\n        virBufferAsprintf(&buf, \"%0*lx\",\n                          VIR_BITMAP_BITS_PER_UNIT / 4,\n                          bitmap->map[sz]);\n    }\n\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        return NULL;\n\n    if (!trim)\n        return ret;\n\n    if (bitmap->nbits != bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT) {\n        char *tmp = ret;\n\n        if (prefix)\n            tmp += 2;\n\n        len = strlen(tmp);\n        sz = VIR_DIV_UP(bitmap->nbits, 4);\n        diff = len - sz;\n\n        if (diff)\n            memmove(tmp, tmp + diff, sz + 1);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nchar *\nvirBitmapToString(virBitmapPtr bitmap,\n                  bool prefix,\n                  bool trim)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t sz;\n    size_t len;\n    size_t diff;\n    char *ret = NULL;\n\n    if (prefix)\n        virBufferAddLit(&buf, \"0x\");\n\n    sz = bitmap->map_len;\n\n    while (sz--) {\n        virBufferAsprintf(&buf, \"%0*lx\",\n                          VIR_BITMAP_BITS_PER_UNIT / 4,\n                          bitmap->map[sz]);\n    }\n\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        return NULL;\n\n    if (!trim)\n        return ret;\n\n    if (bitmap->nbits != bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT) {\n        char *tmp = ret;\n\n        if (prefix)\n            tmp += 2;\n\n        len = strlen(tmp);\n        sz = VIR_DIV_UP(bitmap->nbits, 4);\n        diff = len - sz;\n\n        if (diff)\n            memmove(tmp, tmp + diff, sz + 1);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlTypeToString",
          "args": [
            "type"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocFormatCache(virResctrlAllocPtr alloc,\n                           virBufferPtr buf)\n{\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            virBufferAsprintf(buf, \"L%u%s:\", level, virResctrlTypeToString(type));\n\n            for (cache = 0; cache < a_type->nmasks; cache++) {\n                virBitmapPtr mask = a_type->masks[cache];\n                char *mask_str = NULL;\n\n                if (!mask)\n                    continue;\n\n                mask_str = virBitmapToString(mask, false, true);\n                if (!mask_str)\n                    return -1;\n\n                virBufferAsprintf(buf, \"%u=%s;\", cache, mask_str);\n                VIR_FREE(mask_str);\n            }\n\n            virBufferTrim(buf, \";\");\n            virBufferAddChar(buf, '\\n');\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocParseMemoryBandwidthLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1492-1538",
    "snippet": "static int\nvirResctrlAllocParseMemoryBandwidthLine(virResctrlInfoPtr resctrl,\n                                        virResctrlAllocPtr alloc,\n                                        char *line)\n{\n    char **mbs = NULL;\n    char *tmp = NULL;\n    size_t nmbs = 0;\n    size_t i;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    if (STRNEQLEN(line, \"MB\", 2))\n        return 0;\n\n    if (!resctrl || !resctrl->membw_info ||\n        !resctrl->membw_info->min_bandwidth ||\n        !resctrl->membw_info->bandwidth_granularity) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\"));\n        return -1;\n    }\n\n    if (!alloc->mem_bw) {\n        if (VIR_ALLOC(alloc->mem_bw) < 0)\n            return -1;\n    }\n\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n    tmp++;\n\n    mbs = virStringSplitCount(tmp, \";\", 0, &nmbs);\n    for (i = 0; i < nmbs; i++) {\n        if (virResctrlAllocParseProcessMemoryBandwidth(resctrl, alloc, mbs[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(mbs);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "mbs"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocParseProcessMemoryBandwidth",
          "args": [
            "resctrl",
            "alloc",
            "mbs[i]"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocParseProcessMemoryBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1442-1486",
          "snippet": "static int\nvirResctrlAllocParseProcessMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                           virResctrlAllocPtr alloc,\n                                           char *mem_bw)\n{\n    unsigned int bandwidth;\n    unsigned int id;\n    char *tmp = NULL;\n\n    tmp = strchr(mem_bw, '=');\n    if (!tmp)\n        return 0;\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(mem_bw, NULL, 10, &id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid node id %u \"), id);\n        return -1;\n    }\n    if (virStrToLong_uip(tmp, NULL, 10, &bandwidth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid bandwidth %u\"), bandwidth);\n        return -1;\n    }\n    if (bandwidth < resctrl->membw_info->min_bandwidth ||\n        id > resctrl->membw_info->max_id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\"), id);\n        return -1;\n    }\n    if (alloc->mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(alloc->mem_bw->bandwidths, alloc->mem_bw->nbandwidths,\n                     id - alloc->mem_bw->nbandwidths + 1) < 0) {\n        return -1;\n    }\n    if (!alloc->mem_bw->bandwidths[id]) {\n        if (VIR_ALLOC(alloc->mem_bw->bandwidths[id]) < 0)\n            return -1;\n    }\n\n    *(alloc->mem_bw->bandwidths[id]) = bandwidth;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseProcessMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                           virResctrlAllocPtr alloc,\n                                           char *mem_bw)\n{\n    unsigned int bandwidth;\n    unsigned int id;\n    char *tmp = NULL;\n\n    tmp = strchr(mem_bw, '=');\n    if (!tmp)\n        return 0;\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(mem_bw, NULL, 10, &id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid node id %u \"), id);\n        return -1;\n    }\n    if (virStrToLong_uip(tmp, NULL, 10, &bandwidth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid bandwidth %u\"), bandwidth);\n        return -1;\n    }\n    if (bandwidth < resctrl->membw_info->min_bandwidth ||\n        id > resctrl->membw_info->max_id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\"), id);\n        return -1;\n    }\n    if (alloc->mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(alloc->mem_bw->bandwidths, alloc->mem_bw->nbandwidths,\n                     id - alloc->mem_bw->nbandwidths + 1) < 0) {\n        return -1;\n    }\n    if (!alloc->mem_bw->bandwidths[id]) {\n        if (VIR_ALLOC(alloc->mem_bw->bandwidths[id]) < 0)\n            return -1;\n    }\n\n    *(alloc->mem_bw->bandwidths[id]) = bandwidth;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "tmp",
            "\";\"",
            "0",
            "&nmbs"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "alloc->mem_bw"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\")"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\""
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQLEN",
          "args": [
            "line",
            "\"MB\"",
            "2"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSkipSpaces",
          "args": [
            "(const char **) &line"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "virSkipSpacesAndBackslash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "810-818",
          "snippet": "void\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseMemoryBandwidthLine(virResctrlInfoPtr resctrl,\n                                        virResctrlAllocPtr alloc,\n                                        char *line)\n{\n    char **mbs = NULL;\n    char *tmp = NULL;\n    size_t nmbs = 0;\n    size_t i;\n    int ret = -1;\n\n    /* For no reason there can be spaces */\n    virSkipSpaces((const char **) &line);\n\n    if (STRNEQLEN(line, \"MB\", 2))\n        return 0;\n\n    if (!resctrl || !resctrl->membw_info ||\n        !resctrl->membw_info->min_bandwidth ||\n        !resctrl->membw_info->bandwidth_granularity) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth allocation\"));\n        return -1;\n    }\n\n    if (!alloc->mem_bw) {\n        if (VIR_ALLOC(alloc->mem_bw) < 0)\n            return -1;\n    }\n\n    tmp = strchr(line, ':');\n    if (!tmp)\n        return 0;\n    tmp++;\n\n    mbs = virStringSplitCount(tmp, \";\", 0, &nmbs);\n    for (i = 0; i < nmbs; i++) {\n        if (virResctrlAllocParseProcessMemoryBandwidth(resctrl, alloc, mbs[i]) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(mbs);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlAllocParseProcessMemoryBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1442-1486",
    "snippet": "static int\nvirResctrlAllocParseProcessMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                           virResctrlAllocPtr alloc,\n                                           char *mem_bw)\n{\n    unsigned int bandwidth;\n    unsigned int id;\n    char *tmp = NULL;\n\n    tmp = strchr(mem_bw, '=');\n    if (!tmp)\n        return 0;\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(mem_bw, NULL, 10, &id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid node id %u \"), id);\n        return -1;\n    }\n    if (virStrToLong_uip(tmp, NULL, 10, &bandwidth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid bandwidth %u\"), bandwidth);\n        return -1;\n    }\n    if (bandwidth < resctrl->membw_info->min_bandwidth ||\n        id > resctrl->membw_info->max_id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\"), id);\n        return -1;\n    }\n    if (alloc->mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(alloc->mem_bw->bandwidths, alloc->mem_bw->nbandwidths,\n                     id - alloc->mem_bw->nbandwidths + 1) < 0) {\n        return -1;\n    }\n    if (!alloc->mem_bw->bandwidths[id]) {\n        if (VIR_ALLOC(alloc->mem_bw->bandwidths[id]) < 0)\n            return -1;\n    }\n\n    *(alloc->mem_bw->bandwidths[id]) = bandwidth;\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "alloc->mem_bw->bandwidths[id]"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "alloc->mem_bw->bandwidths",
            "alloc->mem_bw->nbandwidths",
            "id - alloc->mem_bw->nbandwidths + 1"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\")",
            "id"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\""
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid bandwidth %u\")",
            "bandwidth"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&bandwidth"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid node id %u \")",
            "id"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "mem_bw",
            "'='"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocParseProcessMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                           virResctrlAllocPtr alloc,\n                                           char *mem_bw)\n{\n    unsigned int bandwidth;\n    unsigned int id;\n    char *tmp = NULL;\n\n    tmp = strchr(mem_bw, '=');\n    if (!tmp)\n        return 0;\n    *tmp = '\\0';\n    tmp++;\n\n    if (virStrToLong_uip(mem_bw, NULL, 10, &id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid node id %u \"), id);\n        return -1;\n    }\n    if (virStrToLong_uip(tmp, NULL, 10, &bandwidth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid bandwidth %u\"), bandwidth);\n        return -1;\n    }\n    if (bandwidth < resctrl->membw_info->min_bandwidth ||\n        id > resctrl->membw_info->max_id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing or inconsistent resctrl info for \"\n                         \"memory bandwidth node '%u'\"), id);\n        return -1;\n    }\n    if (alloc->mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(alloc->mem_bw->bandwidths, alloc->mem_bw->nbandwidths,\n                     id - alloc->mem_bw->nbandwidths + 1) < 0) {\n        return -1;\n    }\n    if (!alloc->mem_bw->bandwidths[id]) {\n        if (VIR_ALLOC(alloc->mem_bw->bandwidths[id]) < 0)\n            return -1;\n    }\n\n    *(alloc->mem_bw->bandwidths[id]) = bandwidth;\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocMemoryBandwidthFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1418-1439",
    "snippet": "static int\nvirResctrlAllocMemoryBandwidthFormat(virResctrlAllocPtr alloc,\n                                     virBufferPtr buf)\n{\n    size_t i;\n\n    if (!alloc->mem_bw)\n        return 0;\n\n    virBufferAddLit(buf, \"MB:\");\n\n    for (i = 0; i < alloc->mem_bw->nbandwidths; i++) {\n        if (alloc->mem_bw->bandwidths[i]) {\n            virBufferAsprintf(buf, \"%zd=%u;\", i,\n                              *(alloc->mem_bw->bandwidths[i]));\n        }\n    }\n\n    virBufferTrim(buf, \";\");\n    virBufferAddChar(buf, '\\n');\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "buf",
            "\";\""
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%zd=%u;\"",
            "i",
            "*(alloc->mem_bw->bandwidths[i])"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"MB:\""
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocMemoryBandwidthFormat(virResctrlAllocPtr alloc,\n                                     virBufferPtr buf)\n{\n    size_t i;\n\n    if (!alloc->mem_bw)\n        return 0;\n\n    virBufferAddLit(buf, \"MB:\");\n\n    for (i = 0; i < alloc->mem_bw->nbandwidths; i++) {\n        if (alloc->mem_bw->bandwidths[i]) {\n            virBufferAsprintf(buf, \"%zd=%u;\", i,\n                              *(alloc->mem_bw->bandwidths[i]));\n        }\n    }\n\n    virBufferTrim(buf, \";\");\n    virBufferAddChar(buf, '\\n');\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocGetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1402-1406",
    "snippet": "const char *\nvirResctrlAllocGetID(virResctrlAllocPtr alloc)\n{\n    return alloc->id;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nconst char *\nvirResctrlAllocGetID(virResctrlAllocPtr alloc)\n{\n    return alloc->id;\n}"
  },
  {
    "function_name": "virResctrlAllocSetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1394-1399",
    "snippet": "int\nvirResctrlAllocSetID(virResctrlAllocPtr alloc,\n                     const char *id)\n{\n    return virResctrlSetID(&alloc->id, id);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlSetID",
          "args": [
            "&alloc->id",
            "id"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlSetID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1372-1391",
          "snippet": "static int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocSetID(virResctrlAllocPtr alloc,\n                     const char *id)\n{\n    return virResctrlSetID(&alloc->id, id);\n}"
  },
  {
    "function_name": "virResctrlSetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1372-1391",
    "snippet": "static int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "id"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Attempt to overwrite resctrlid='%s' with id='%s'\")",
            "*resctrlid",
            "id"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"New resctrl 'id' cannot be NULL\")"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlSetID(char **resctrlid,\n                const char *id)\n{\n    if (!id) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"New resctrl 'id' cannot be NULL\"));\n        return -1;\n    }\n\n    if (*resctrlid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to overwrite resctrlid='%s' with id='%s'\"),\n                       *resctrlid, id);\n        return -1;\n    }\n\n    *resctrlid = g_strdup(id);\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocForeachMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1349-1369",
    "snippet": "int\nvirResctrlAllocForeachMemory(virResctrlAllocPtr alloc,\n                             virResctrlAllocForeachMemoryCallback cb,\n                             void *opaque)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr mem_bw;\n\n    if (!alloc || !alloc->mem_bw)\n        return 0;\n\n    mem_bw = alloc->mem_bw;\n    for (i = 0; i < mem_bw->nbandwidths; i++) {\n        if (mem_bw->bandwidths[i]) {\n            if (cb(i, *mem_bw->bandwidths[i], opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "i",
            "*mem_bw->bandwidths[i]",
            "opaque"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "file_iterate_pci_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "855-861",
          "snippet": "static int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocForeachMemory(virResctrlAllocPtr alloc,\n                             virResctrlAllocForeachMemoryCallback cb,\n                             void *opaque)\n{\n    size_t i = 0;\n    virResctrlAllocMemBWPtr mem_bw;\n\n    if (!alloc || !alloc->mem_bw)\n        return 0;\n\n    mem_bw = alloc->mem_bw;\n    for (i = 0; i < mem_bw->nbandwidths; i++) {\n        if (mem_bw->bandwidths[i]) {\n            if (cb(i, *mem_bw->bandwidths[i], opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocSetMemoryBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1300-1336",
    "snippet": "int\nvirResctrlAllocSetMemoryBandwidth(virResctrlAllocPtr alloc,\n                                  unsigned int id,\n                                  unsigned int memory_bandwidth)\n{\n    virResctrlAllocMemBWPtr mem_bw = alloc->mem_bw;\n\n    if (memory_bandwidth > 100) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Memory Bandwidth value exceeding 100 is invalid.\"));\n        return -1;\n    }\n\n    if (!mem_bw) {\n        if (VIR_ALLOC(mem_bw) < 0)\n            return -1;\n        alloc->mem_bw = mem_bw;\n    }\n\n    if (mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(mem_bw->bandwidths, mem_bw->nbandwidths,\n                     id - mem_bw->nbandwidths + 1) < 0)\n        return -1;\n\n    if (mem_bw->bandwidths[id]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Memory Bandwidth already defined for node %u\"),\n                       id);\n        return -1;\n    }\n\n    if (VIR_ALLOC(mem_bw->bandwidths[id]) < 0)\n        return -1;\n\n    *(mem_bw->bandwidths[id]) = memory_bandwidth;\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mem_bw->bandwidths[id]"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Memory Bandwidth already defined for node %u\")",
            "id"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Memory Bandwidth already defined for node %u\""
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "mem_bw->bandwidths",
            "mem_bw->nbandwidths",
            "id - mem_bw->nbandwidths + 1"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mem_bw"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Memory Bandwidth value exceeding 100 is invalid.\")"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocSetMemoryBandwidth(virResctrlAllocPtr alloc,\n                                  unsigned int id,\n                                  unsigned int memory_bandwidth)\n{\n    virResctrlAllocMemBWPtr mem_bw = alloc->mem_bw;\n\n    if (memory_bandwidth > 100) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Memory Bandwidth value exceeding 100 is invalid.\"));\n        return -1;\n    }\n\n    if (!mem_bw) {\n        if (VIR_ALLOC(mem_bw) < 0)\n            return -1;\n        alloc->mem_bw = mem_bw;\n    }\n\n    if (mem_bw->nbandwidths <= id &&\n        VIR_EXPAND_N(mem_bw->bandwidths, mem_bw->nbandwidths,\n                     id - mem_bw->nbandwidths + 1) < 0)\n        return -1;\n\n    if (mem_bw->bandwidths[id]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Memory Bandwidth already defined for node %u\"),\n                       id);\n        return -1;\n    }\n\n    if (VIR_ALLOC(mem_bw->bandwidths[id]) < 0)\n        return -1;\n\n    *(mem_bw->bandwidths[id]) = memory_bandwidth;\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocForeachCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1249-1288",
    "snippet": "int\nvirResctrlAllocForeachCache(virResctrlAllocPtr alloc,\n                            virResctrlAllocForeachCacheCallback cb,\n                            void *opaque)\n{\n    int ret = 0;\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    if (!alloc)\n        return 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                unsigned long long *size = a_type->sizes[cache];\n\n                if (!size)\n                    continue;\n\n                ret = cb(level, type, cache, *size, opaque);\n                if (ret < 0)\n                    return ret;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "level",
            "type",
            "cache",
            "*size",
            "opaque"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocForeachCache(virResctrlAllocPtr alloc,\n                            virResctrlAllocForeachCacheCallback cb,\n                            void *opaque)\n{\n    int ret = 0;\n    unsigned int level = 0;\n    unsigned int type = 0;\n    unsigned int cache = 0;\n\n    if (!alloc)\n        return 0;\n\n    for (level = 0; level < alloc->nlevels; level++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[level];\n\n        if (!a_level)\n            continue;\n\n        for (type = 0; type < VIR_CACHE_TYPE_LAST; type++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[type];\n\n            if (!a_type)\n                continue;\n\n            for (cache = 0; cache < a_type->nsizes; cache++) {\n                unsigned long long *size = a_type->sizes[cache];\n\n                if (!size)\n                    continue;\n\n                ret = cb(level, type, cache, *size, opaque);\n                if (ret < 0)\n                    return ret;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocSetCacheSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1230-1246",
    "snippet": "int\nvirResctrlAllocSetCacheSize(virResctrlAllocPtr alloc,\n                            unsigned int level,\n                            virCacheType type,\n                            unsigned int cache,\n                            unsigned long long size)\n{\n    if (virResctrlAllocCheckCollision(alloc, level, type, cache)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Colliding cache allocations for cache \"\n                         \"level '%u' id '%u', type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    return virResctrlAllocUpdateSize(alloc, level, type, cache, size);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlAllocUpdateSize",
          "args": [
            "alloc",
            "level",
            "type",
            "cache",
            "size"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocUpdateSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1146-1169",
          "snippet": "static int\nvirResctrlAllocUpdateSize(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          unsigned long long size)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nsizes <= cache &&\n        VIR_EXPAND_N(a_type->sizes, a_type->nsizes,\n                     cache - a_type->nsizes + 1) < 0)\n        return -1;\n\n    if (!a_type->sizes[cache] && VIR_ALLOC(a_type->sizes[cache]) < 0)\n        return -1;\n\n    *(a_type->sizes[cache]) = size;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateSize(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          unsigned long long size)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nsizes <= cache &&\n        VIR_EXPAND_N(a_type->sizes, a_type->nsizes,\n                     cache - a_type->nsizes + 1) < 0)\n        return -1;\n\n    if (!a_type->sizes[cache] && VIR_ALLOC(a_type->sizes[cache]) < 0)\n        return -1;\n\n    *(a_type->sizes[cache]) = size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Colliding cache allocations for cache \"\n                         \"level '%u' id '%u', type '%s'\")",
            "level",
            "cache",
            "virCacheTypeToString(type)"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "type"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Colliding cache allocations for cache \"\n                         \"level '%u' id '%u', type '%s'\""
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlAllocCheckCollision",
          "args": [
            "alloc",
            "level",
            "type",
            "cache"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocCheckCollision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1182-1227",
          "snippet": "static bool\nvirResctrlAllocCheckCollision(virResctrlAllocPtr alloc,\n                              unsigned int level,\n                              virCacheType type,\n                              unsigned int cache)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n    virResctrlAllocPerTypePtr a_type = NULL;\n\n    if (!alloc)\n        return false;\n\n    if (alloc->nlevels <= level)\n        return false;\n\n    a_level = alloc->levels[level];\n\n    if (!a_level)\n        return false;\n\n    a_type = a_level->types[VIR_CACHE_TYPE_BOTH];\n\n    /* If there is an allocation for type 'both', there can be no other\n     * allocation for the same cache */\n    if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n        return true;\n\n    if (type == VIR_CACHE_TYPE_BOTH) {\n        a_type = a_level->types[VIR_CACHE_TYPE_CODE];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n\n        a_type = a_level->types[VIR_CACHE_TYPE_DATA];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    } else {\n        a_type = a_level->types[type];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlAllocCheckCollision(virResctrlAllocPtr alloc,\n                              unsigned int level,\n                              virCacheType type,\n                              unsigned int cache)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n    virResctrlAllocPerTypePtr a_type = NULL;\n\n    if (!alloc)\n        return false;\n\n    if (alloc->nlevels <= level)\n        return false;\n\n    a_level = alloc->levels[level];\n\n    if (!a_level)\n        return false;\n\n    a_type = a_level->types[VIR_CACHE_TYPE_BOTH];\n\n    /* If there is an allocation for type 'both', there can be no other\n     * allocation for the same cache */\n    if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n        return true;\n\n    if (type == VIR_CACHE_TYPE_BOTH) {\n        a_type = a_level->types[VIR_CACHE_TYPE_CODE];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n\n        a_type = a_level->types[VIR_CACHE_TYPE_DATA];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    } else {\n        a_type = a_level->types[type];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlAllocSetCacheSize(virResctrlAllocPtr alloc,\n                            unsigned int level,\n                            virCacheType type,\n                            unsigned int cache,\n                            unsigned long long size)\n{\n    if (virResctrlAllocCheckCollision(alloc, level, type, cache)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Colliding cache allocations for cache \"\n                         \"level '%u' id '%u', type '%s'\"),\n                       level, cache, virCacheTypeToString(type));\n        return -1;\n    }\n\n    return virResctrlAllocUpdateSize(alloc, level, type, cache, size);\n}"
  },
  {
    "function_name": "virResctrlAllocCheckCollision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1182-1227",
    "snippet": "static bool\nvirResctrlAllocCheckCollision(virResctrlAllocPtr alloc,\n                              unsigned int level,\n                              virCacheType type,\n                              unsigned int cache)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n    virResctrlAllocPerTypePtr a_type = NULL;\n\n    if (!alloc)\n        return false;\n\n    if (alloc->nlevels <= level)\n        return false;\n\n    a_level = alloc->levels[level];\n\n    if (!a_level)\n        return false;\n\n    a_type = a_level->types[VIR_CACHE_TYPE_BOTH];\n\n    /* If there is an allocation for type 'both', there can be no other\n     * allocation for the same cache */\n    if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n        return true;\n\n    if (type == VIR_CACHE_TYPE_BOTH) {\n        a_type = a_level->types[VIR_CACHE_TYPE_CODE];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n\n        a_type = a_level->types[VIR_CACHE_TYPE_DATA];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    } else {\n        a_type = a_level->types[type];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlAllocCheckCollision(virResctrlAllocPtr alloc,\n                              unsigned int level,\n                              virCacheType type,\n                              unsigned int cache)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n    virResctrlAllocPerTypePtr a_type = NULL;\n\n    if (!alloc)\n        return false;\n\n    if (alloc->nlevels <= level)\n        return false;\n\n    a_level = alloc->levels[level];\n\n    if (!a_level)\n        return false;\n\n    a_type = a_level->types[VIR_CACHE_TYPE_BOTH];\n\n    /* If there is an allocation for type 'both', there can be no other\n     * allocation for the same cache */\n    if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n        return true;\n\n    if (type == VIR_CACHE_TYPE_BOTH) {\n        a_type = a_level->types[VIR_CACHE_TYPE_CODE];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n\n        a_type = a_level->types[VIR_CACHE_TYPE_DATA];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    } else {\n        a_type = a_level->types[type];\n\n        if (a_type && a_type->nsizes > cache && a_type->sizes[cache])\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virResctrlAllocUpdateSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1146-1169",
    "snippet": "static int\nvirResctrlAllocUpdateSize(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          unsigned long long size)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nsizes <= cache &&\n        VIR_EXPAND_N(a_type->sizes, a_type->nsizes,\n                     cache - a_type->nsizes + 1) < 0)\n        return -1;\n\n    if (!a_type->sizes[cache] && VIR_ALLOC(a_type->sizes[cache]) < 0)\n        return -1;\n\n    *(a_type->sizes[cache]) = size;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "a_type->sizes[cache]"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "a_type->sizes",
            "a_type->nsizes",
            "cache - a_type->nsizes + 1"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetType",
          "args": [
            "alloc",
            "level",
            "type"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1085-1115",
          "snippet": "static virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateSize(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          unsigned long long size)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nsizes <= cache &&\n        VIR_EXPAND_N(a_type->sizes, a_type->nsizes,\n                     cache - a_type->nsizes + 1) < 0)\n        return -1;\n\n    if (!a_type->sizes[cache] && VIR_ALLOC(a_type->sizes[cache]) < 0)\n        return -1;\n\n    *(a_type->sizes[cache]) = size;\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlAllocUpdateMask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1118-1143",
    "snippet": "static int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapCopy",
          "args": [
            "a_type->masks[cache]",
            "mask"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "146-158",
          "snippet": "int\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "virBitmapSize(mask)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "mask"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "a_type->masks",
            "a_type->nmasks",
            "cache - a_type->nmasks + 1"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlAllocGetType",
          "args": [
            "alloc",
            "level",
            "type"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlAllocGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "1085-1115",
          "snippet": "static virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlAllocUpdateMask(virResctrlAllocPtr alloc,\n                          unsigned int level,\n                          virCacheType type,\n                          unsigned int cache,\n                          virBitmapPtr mask)\n{\n    virResctrlAllocPerTypePtr a_type = virResctrlAllocGetType(alloc, level, type);\n\n    if (!a_type)\n        return -1;\n\n    if (a_type->nmasks <= cache &&\n        VIR_EXPAND_N(a_type->masks, a_type->nmasks,\n                     cache - a_type->nmasks + 1) < 0)\n        return -1;\n\n    if (!a_type->masks[cache]) {\n        a_type->masks[cache] = virBitmapNew(virBitmapSize(mask));\n\n        if (!a_type->masks[cache])\n            return -1;\n    }\n\n    return virBitmapCopy(a_type->masks[cache], mask);\n}"
  },
  {
    "function_name": "virResctrlAllocGetType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1085-1115",
    "snippet": "static virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "a_level->types[type]"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "types"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "alloc->levels[level]"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "types",
            "VIR_CACHE_TYPE_LAST"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "alloc->levels",
            "alloc->nlevels",
            "level - alloc->nlevels + 1"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virResctrlAllocPerTypePtr\nvirResctrlAllocGetType(virResctrlAllocPtr alloc,\n                       unsigned int level,\n                       virCacheType type)\n{\n    virResctrlAllocPerLevelPtr a_level = NULL;\n\n    if (alloc->nlevels <= level &&\n        VIR_EXPAND_N(alloc->levels, alloc->nlevels, level - alloc->nlevels + 1) < 0)\n        return NULL;\n\n    if (!alloc->levels[level]) {\n        virResctrlAllocPerTypePtr *types = NULL;\n\n        if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n            return NULL;\n\n        if (VIR_ALLOC(alloc->levels[level]) < 0) {\n            VIR_FREE(types);\n            return NULL;\n        }\n        alloc->levels[level]->types = types;\n    }\n\n    a_level = alloc->levels[level];\n\n    if (!a_level->types[type] && VIR_ALLOC(a_level->types[type]) < 0)\n        return NULL;\n\n    return a_level->types[type];\n}"
  },
  {
    "function_name": "virResctrlAllocIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1044-1082",
    "snippet": "bool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nbool\nvirResctrlAllocIsEmpty(virResctrlAllocPtr alloc)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    if (!alloc)\n        return true;\n\n    if (alloc->mem_bw)\n        return false;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr a_level = alloc->levels[i];\n\n        if (!a_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr a_type = a_level->types[j];\n\n            if (!a_type)\n                continue;\n\n            for (k = 0; k < a_type->nsizes; k++) {\n                if (a_type->sizes[k])\n                    return false;\n            }\n\n            for (k = 0; k < a_type->nmasks; k++) {\n                if (a_type->masks[k])\n                    return false;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virResctrlAllocNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "1034-1041",
    "snippet": "virResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virResctrlAllocClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virResctrlAllocClass"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInitialize",
          "args": [],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlAllocClass;\n\nvirResctrlAllocPtr\nvirResctrlAllocNew(void)\n{\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virResctrlAllocClass);\n}"
  },
  {
    "function_name": "virResctrlInfoGetMonitorPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "954-1030",
    "snippet": "int\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlInfoMonFree",
          "args": [
            "mon"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoMonFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "227-235",
          "snippet": "void\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&mon"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"No resctrl monitor features using prefix '%s' found\"",
            "prefix"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListAdd",
          "args": [
            "&mon->features",
            "mongrp_info->features[i]"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "176-188",
          "snippet": "int\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "mongrp_info->features[i]",
            "prefix"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Bad prefix name '%s' for resctrl monitor\")",
            "prefix"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bad prefix name '%s' for resctrl monitor\""
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mon"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "prefix",
            "virResctrlMonitorPrefixTypeToString(i)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlMonitorPrefixTypeToString",
          "args": [
            "i"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Monitor is not supported in host\""
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoIsEmpty",
          "args": [
            "resctrl"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "814-842",
          "snippet": "static bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Empty prefix name for resctrl monitor\")"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlInfoGetCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "865-937",
    "snippet": "int\nvirResctrlInfoGetCache(virResctrlInfoPtr resctrl,\n                       unsigned int level,\n                       unsigned long long size,\n                       size_t *ncontrols,\n                       virResctrlInfoPerCachePtr **controls)\n{\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n    size_t i = 0;\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    /* Let's take the opportunity to update the number of last level\n     * cache. This number of memory bandwidth controller is same with\n     * last level cache */\n    if (resctrl->membw_info) {\n        virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n        if (level > membw_info->last_level_cache) {\n            membw_info->last_level_cache = level;\n            membw_info->max_id = 0;\n        } else if (membw_info->last_level_cache == level) {\n            membw_info->max_id++;\n        }\n    }\n\n    if (level >= resctrl->nlevels)\n        return 0;\n\n    i_level = resctrl->levels[level];\n    if (!i_level)\n        return 0;\n\n    for (i = 0; i < VIR_CACHE_TYPE_LAST; i++) {\n        i_type = i_level->types[i];\n        if (!i_type)\n            continue;\n\n        /* Let's take the opportunity to update our internal information about\n         * the cache size */\n        if (!i_type->size) {\n            i_type->size = size;\n            i_type->control.granularity = size / i_type->bits;\n            if (i_type->min_cbm_bits != 1)\n                i_type->control.min = i_type->min_cbm_bits * i_type->control.granularity;\n        } else {\n            if (i_type->size != size) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\"),\n                               level, i_type->size, size);\n                goto error;\n            }\n            i_type->max_cache_id++;\n        }\n\n        if (VIR_EXPAND_N(*controls, *ncontrols, 1) < 0)\n            goto error;\n        if (VIR_ALLOC((*controls)[*ncontrols - 1]) < 0)\n            goto error;\n\n        memcpy((*controls)[*ncontrols - 1], &i_type->control, sizeof(i_type->control));\n    }\n\n    return 0;\n error:\n    while (*ncontrols)\n        VIR_FREE((*controls)[--*ncontrols]);\n    VIR_FREE(*controls);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*controls"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*controls)[--*ncontrols]"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*controls)[*ncontrols - 1]",
            "&i_type->control",
            "sizeof(i_type->control)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "(*controls)[*ncontrols - 1]"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "*controls",
            "*ncontrols",
            "1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\")",
            "level",
            "i_type->size",
            "size"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\""
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInfoIsEmpty",
          "args": [
            "resctrl"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "814-842",
          "snippet": "static bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetCache(virResctrlInfoPtr resctrl,\n                       unsigned int level,\n                       unsigned long long size,\n                       size_t *ncontrols,\n                       virResctrlInfoPerCachePtr **controls)\n{\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n    size_t i = 0;\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    /* Let's take the opportunity to update the number of last level\n     * cache. This number of memory bandwidth controller is same with\n     * last level cache */\n    if (resctrl->membw_info) {\n        virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n        if (level > membw_info->last_level_cache) {\n            membw_info->last_level_cache = level;\n            membw_info->max_id = 0;\n        } else if (membw_info->last_level_cache == level) {\n            membw_info->max_id++;\n        }\n    }\n\n    if (level >= resctrl->nlevels)\n        return 0;\n\n    i_level = resctrl->levels[level];\n    if (!i_level)\n        return 0;\n\n    for (i = 0; i < VIR_CACHE_TYPE_LAST; i++) {\n        i_type = i_level->types[i];\n        if (!i_type)\n            continue;\n\n        /* Let's take the opportunity to update our internal information about\n         * the cache size */\n        if (!i_type->size) {\n            i_type->size = size;\n            i_type->control.granularity = size / i_type->bits;\n            if (i_type->min_cbm_bits != 1)\n                i_type->control.min = i_type->min_cbm_bits * i_type->control.granularity;\n        } else {\n            if (i_type->size != size) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\"),\n                               level, i_type->size, size);\n                goto error;\n            }\n            i_type->max_cache_id++;\n        }\n\n        if (VIR_EXPAND_N(*controls, *ncontrols, 1) < 0)\n            goto error;\n        if (VIR_ALLOC((*controls)[*ncontrols - 1]) < 0)\n            goto error;\n\n        memcpy((*controls)[*ncontrols - 1], &i_type->control, sizeof(i_type->control));\n    }\n\n    return 0;\n error:\n    while (*ncontrols)\n        VIR_FREE((*controls)[--*ncontrols]);\n    VIR_FREE(*controls);\n    return -1;\n}"
  },
  {
    "function_name": "virResctrlInfoGetMemoryBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "845-862",
    "snippet": "int\nvirResctrlInfoGetMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                 unsigned int level,\n                                 virResctrlInfoMemBWPerNodePtr control)\n{\n    virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n    if (!membw_info)\n        return 0;\n\n    if (membw_info->last_level_cache != level)\n        return 0;\n\n    control->granularity = membw_info->bandwidth_granularity;\n    control->min = membw_info->min_bandwidth;\n    control->max_allocation = membw_info->max_allocation;\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                 unsigned int level,\n                                 virResctrlInfoMemBWPerNodePtr control)\n{\n    virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n    if (!membw_info)\n        return 0;\n\n    if (membw_info->last_level_cache != level)\n        return 0;\n\n    control->granularity = membw_info->bandwidth_granularity;\n    control->min = membw_info->min_bandwidth;\n    control->max_allocation = membw_info->max_allocation;\n    return 1;\n}"
  },
  {
    "function_name": "virResctrlInfoIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "814-842",
    "snippet": "static bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic bool\nvirResctrlInfoIsEmpty(virResctrlInfoPtr resctrl)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!resctrl)\n        return true;\n\n    if (resctrl->membw_info)\n        return false;\n\n    if (resctrl->monitor_info)\n        return false;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr i_level = resctrl->levels[i];\n\n        if (!i_level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            if (i_level->types[j])\n                return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virResctrlInfoNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "793-811",
    "snippet": "virResctrlInfoPtr\nvirResctrlInfoNew(void)\n{\n    virResctrlInfoPtr ret = NULL;\n\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    ret = virObjectNew(virResctrlInfoClass);\n    if (!ret)\n        return NULL;\n\n    if (virResctrlGetInfo(ret) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virResctrlInfoClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlGetInfo",
          "args": [
            "ret"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "764-790",
          "snippet": "static int\nvirResctrlGetInfo(virResctrlInfoPtr resctrl)\n{\n    DIR *dirp = NULL;\n    int ret = -1;\n\n    ret = virDirOpenIfExists(&dirp, SYSFS_RESCTRL_PATH \"/info\");\n    if (ret <= 0)\n        goto cleanup;\n\n    ret = virResctrlGetMemoryBandwidthInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetCacheInfo(resctrl, dirp);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetMonitorInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetInfo(virResctrlInfoPtr resctrl)\n{\n    DIR *dirp = NULL;\n    int ret = -1;\n\n    ret = virDirOpenIfExists(&dirp, SYSFS_RESCTRL_PATH \"/info\");\n    if (ret <= 0)\n        goto cleanup;\n\n    ret = virResctrlGetMemoryBandwidthInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetCacheInfo(resctrl, dirp);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetMonitorInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virResctrlInfoClass"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInitialize",
          "args": [],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlInfoClass;\n\nvirResctrlInfoPtr\nvirResctrlInfoNew(void)\n{\n    virResctrlInfoPtr ret = NULL;\n\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    ret = virObjectNew(virResctrlInfoClass);\n    if (!ret)\n        return NULL;\n\n    if (virResctrlGetInfo(ret) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "764-790",
    "snippet": "static int\nvirResctrlGetInfo(virResctrlInfoPtr resctrl)\n{\n    DIR *dirp = NULL;\n    int ret = -1;\n\n    ret = virDirOpenIfExists(&dirp, SYSFS_RESCTRL_PATH \"/info\");\n    if (ret <= 0)\n        goto cleanup;\n\n    ret = virResctrlGetMemoryBandwidthInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetCacheInfo(resctrl, dirp);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetMonitorInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dirp"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlGetMonitorInfo",
          "args": [
            "resctrl"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlGetMonitorInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "689-761",
          "snippet": "static int\nvirResctrlGetMonitorInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    char *featurestr = NULL;\n    char **features = NULL;\n    size_t nfeatures = 0;\n    virResctrlInfoMongrpPtr info_monitor = NULL;\n\n    if (VIR_ALLOC(info_monitor) < 0)\n        return -1;\n\n    /* For now, monitor only exists in level 3 cache */\n    info_monitor->cache_level = 3;\n\n    rv = virFileReadValueUint(&info_monitor->max_monitor,\n                              SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us, probably resource\n         * monitor unsupported */\n        VIR_INFO(\"The file '\" SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids' \"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&info_monitor->cache_reuse_threshold,\n                              SYSFS_RESCTRL_PATH\n                              \"/info/L3_MON/max_threshold_occupancy\");\n    if (rv == -2) {\n        /* If CMT is not supported, then 'max_threshold_occupancy' file\n         * will not exist. */\n        VIR_DEBUG(\"File '\" SYSFS_RESCTRL_PATH\n                  \"/info/L3_MON/max_threshold_occupancy' does not exist\");\n    } else if (rv < 0) {\n        goto cleanup;\n    }\n\n    rv = virFileReadValueString(&featurestr,\n                                SYSFS_RESCTRL_PATH\n                                \"/info/L3_MON/mon_features\");\n    if (rv == -2)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get mon_features from resctrl\"));\n    if (rv < 0)\n        goto cleanup;\n\n    if (!*featurestr) {\n        /* If no feature found in \"/info/L3_MON/mon_features\",\n         * some error happens */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Got empty feature list from resctrl\"));\n        goto cleanup;\n    }\n\n    features = virStringSplitCount(featurestr, \"\\n\", 0, &nfeatures);\n    VIR_DEBUG(\"Resctrl supported %zd monitoring features\", nfeatures);\n\n    info_monitor->nfeatures = nfeatures;\n    info_monitor->features = g_steal_pointer(&features);\n    resctrl->monitor_info = g_steal_pointer(&info_monitor);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(featurestr);\n    virStringListFree(features);\n    VIR_FREE(info_monitor);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetMonitorInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    char *featurestr = NULL;\n    char **features = NULL;\n    size_t nfeatures = 0;\n    virResctrlInfoMongrpPtr info_monitor = NULL;\n\n    if (VIR_ALLOC(info_monitor) < 0)\n        return -1;\n\n    /* For now, monitor only exists in level 3 cache */\n    info_monitor->cache_level = 3;\n\n    rv = virFileReadValueUint(&info_monitor->max_monitor,\n                              SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us, probably resource\n         * monitor unsupported */\n        VIR_INFO(\"The file '\" SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids' \"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&info_monitor->cache_reuse_threshold,\n                              SYSFS_RESCTRL_PATH\n                              \"/info/L3_MON/max_threshold_occupancy\");\n    if (rv == -2) {\n        /* If CMT is not supported, then 'max_threshold_occupancy' file\n         * will not exist. */\n        VIR_DEBUG(\"File '\" SYSFS_RESCTRL_PATH\n                  \"/info/L3_MON/max_threshold_occupancy' does not exist\");\n    } else if (rv < 0) {\n        goto cleanup;\n    }\n\n    rv = virFileReadValueString(&featurestr,\n                                SYSFS_RESCTRL_PATH\n                                \"/info/L3_MON/mon_features\");\n    if (rv == -2)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get mon_features from resctrl\"));\n    if (rv < 0)\n        goto cleanup;\n\n    if (!*featurestr) {\n        /* If no feature found in \"/info/L3_MON/mon_features\",\n         * some error happens */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Got empty feature list from resctrl\"));\n        goto cleanup;\n    }\n\n    features = virStringSplitCount(featurestr, \"\\n\", 0, &nfeatures);\n    VIR_DEBUG(\"Resctrl supported %zd monitoring features\", nfeatures);\n\n    info_monitor->nfeatures = nfeatures;\n    info_monitor->features = g_steal_pointer(&features);\n    resctrl->monitor_info = g_steal_pointer(&info_monitor);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(featurestr);\n    virStringListFree(features);\n    VIR_FREE(info_monitor);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlGetCacheInfo",
          "args": [
            "resctrl",
            "dirp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlGetCacheInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "499-621",
          "snippet": "static int\nvirResctrlGetCacheInfo(virResctrlInfoPtr resctrl,\n                       DIR *dirp)\n{\n    char *endptr = NULL;\n    char *tmp_str = NULL;\n    int ret = -1;\n    int rv = -1;\n    int type = 0;\n    struct dirent *ent = NULL;\n    unsigned int level = 0;\n    virBitmapPtr tmp_map = NULL;\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH \"/info\")) > 0) {\n        VIR_DEBUG(\"Parsing info type '%s'\", ent->d_name);\n        if (ent->d_name[0] != 'L')\n            continue;\n\n        if (virStrToLong_uip(ent->d_name + 1, &endptr, 10, &level) < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info level '%s'\", ent->d_name + 1);\n            continue;\n        }\n\n        type = virResctrlTypeFromString(endptr);\n        if (type < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info type '%s'\", endptr);\n            continue;\n        }\n\n        if (VIR_ALLOC(i_type) < 0)\n            goto cleanup;\n\n        i_type->control.scope = type;\n\n        rv = virFileReadValueUint(&i_type->control.max_allocation,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/num_closids\",\n                                  ent->d_name);\n        if (rv == -2) {\n            /* The file doesn't exist, so it's unusable for us,\n             *  but we can scan further */\n            VIR_WARN(\"The path '\" SYSFS_RESCTRL_PATH \"/info/%s/num_closids' \"\n                     \"does not exist\",\n                     ent->d_name);\n        } else if (rv < 0) {\n            /* Other failures are fatal, so just quit */\n            goto cleanup;\n        }\n\n        rv = virFileReadValueString(&tmp_str,\n                                    SYSFS_RESCTRL_PATH\n                                    \"/info/%s/cbm_mask\",\n                                    ent->d_name);\n        if (rv == -2) {\n            /* If the previous file exists, so should this one.  Hence -2 is\n             * fatal in this case as well (errors out in next condition) - the\n             * kernel interface might've changed too much or something else is\n             * wrong. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get cbm_mask from resctrl cache info\"));\n        }\n        if (rv < 0)\n            goto cleanup;\n\n        virStringTrimOptionalNewline(tmp_str);\n\n        tmp_map = virBitmapNewString(tmp_str);\n        VIR_FREE(tmp_str);\n        if (!tmp_map) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot parse cbm_mask from resctrl cache info\"));\n            goto cleanup;\n        }\n\n        i_type->bits = virBitmapCountBits(tmp_map);\n        virBitmapFree(tmp_map);\n        tmp_map = NULL;\n\n        rv = virFileReadValueUint(&i_type->min_cbm_bits,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/min_cbm_bits\",\n                                  ent->d_name);\n        if (rv == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get min_cbm_bits from resctrl cache info\"));\n        if (rv < 0)\n            goto cleanup;\n\n        if (resctrl->nlevels <= level &&\n            VIR_EXPAND_N(resctrl->levels, resctrl->nlevels,\n                         level - resctrl->nlevels + 1) < 0)\n            goto cleanup;\n\n        if (!resctrl->levels[level]) {\n            virResctrlInfoPerTypePtr *types = NULL;\n\n            if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n                goto cleanup;\n\n            if (VIR_ALLOC(resctrl->levels[level]) < 0) {\n                VIR_FREE(types);\n                goto cleanup;\n            }\n            resctrl->levels[level]->types = types;\n        }\n\n        i_level = resctrl->levels[level];\n\n        if (i_level->types[type]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Duplicate cache type in resctrl for level %u\"),\n                           level);\n            goto cleanup;\n        }\n\n        i_level->types[type] = g_steal_pointer(&i_type);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(i_type);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetCacheInfo(virResctrlInfoPtr resctrl,\n                       DIR *dirp)\n{\n    char *endptr = NULL;\n    char *tmp_str = NULL;\n    int ret = -1;\n    int rv = -1;\n    int type = 0;\n    struct dirent *ent = NULL;\n    unsigned int level = 0;\n    virBitmapPtr tmp_map = NULL;\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH \"/info\")) > 0) {\n        VIR_DEBUG(\"Parsing info type '%s'\", ent->d_name);\n        if (ent->d_name[0] != 'L')\n            continue;\n\n        if (virStrToLong_uip(ent->d_name + 1, &endptr, 10, &level) < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info level '%s'\", ent->d_name + 1);\n            continue;\n        }\n\n        type = virResctrlTypeFromString(endptr);\n        if (type < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info type '%s'\", endptr);\n            continue;\n        }\n\n        if (VIR_ALLOC(i_type) < 0)\n            goto cleanup;\n\n        i_type->control.scope = type;\n\n        rv = virFileReadValueUint(&i_type->control.max_allocation,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/num_closids\",\n                                  ent->d_name);\n        if (rv == -2) {\n            /* The file doesn't exist, so it's unusable for us,\n             *  but we can scan further */\n            VIR_WARN(\"The path '\" SYSFS_RESCTRL_PATH \"/info/%s/num_closids' \"\n                     \"does not exist\",\n                     ent->d_name);\n        } else if (rv < 0) {\n            /* Other failures are fatal, so just quit */\n            goto cleanup;\n        }\n\n        rv = virFileReadValueString(&tmp_str,\n                                    SYSFS_RESCTRL_PATH\n                                    \"/info/%s/cbm_mask\",\n                                    ent->d_name);\n        if (rv == -2) {\n            /* If the previous file exists, so should this one.  Hence -2 is\n             * fatal in this case as well (errors out in next condition) - the\n             * kernel interface might've changed too much or something else is\n             * wrong. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get cbm_mask from resctrl cache info\"));\n        }\n        if (rv < 0)\n            goto cleanup;\n\n        virStringTrimOptionalNewline(tmp_str);\n\n        tmp_map = virBitmapNewString(tmp_str);\n        VIR_FREE(tmp_str);\n        if (!tmp_map) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot parse cbm_mask from resctrl cache info\"));\n            goto cleanup;\n        }\n\n        i_type->bits = virBitmapCountBits(tmp_map);\n        virBitmapFree(tmp_map);\n        tmp_map = NULL;\n\n        rv = virFileReadValueUint(&i_type->min_cbm_bits,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/min_cbm_bits\",\n                                  ent->d_name);\n        if (rv == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get min_cbm_bits from resctrl cache info\"));\n        if (rv < 0)\n            goto cleanup;\n\n        if (resctrl->nlevels <= level &&\n            VIR_EXPAND_N(resctrl->levels, resctrl->nlevels,\n                         level - resctrl->nlevels + 1) < 0)\n            goto cleanup;\n\n        if (!resctrl->levels[level]) {\n            virResctrlInfoPerTypePtr *types = NULL;\n\n            if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n                goto cleanup;\n\n            if (VIR_ALLOC(resctrl->levels[level]) < 0) {\n                VIR_FREE(types);\n                goto cleanup;\n            }\n            resctrl->levels[level]->types = types;\n        }\n\n        i_level = resctrl->levels[level];\n\n        if (i_level->types[type]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Duplicate cache type in resctrl for level %u\"),\n                           level);\n            goto cleanup;\n        }\n\n        i_level->types[type] = g_steal_pointer(&i_type);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(i_type);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlGetMemoryBandwidthInfo",
          "args": [
            "resctrl"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlGetMemoryBandwidthInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "624-675",
          "snippet": "static int\nvirResctrlGetMemoryBandwidthInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    virResctrlInfoMemBWPtr i_membw = NULL;\n\n    /* query memory bandwidth allocation info */\n    if (VIR_ALLOC(i_membw) < 0)\n        goto cleanup;\n    rv = virFileReadValueUint(&i_membw->bandwidth_granularity,\n                              SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us,\n         * probably memory bandwidth allocation unsupported */\n        VIR_INFO(\"The path '\" SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran'\"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&i_membw->min_bandwidth,\n                              SYSFS_RESCTRL_PATH \"/info/MB/min_bandwidth\");\n    if (rv == -2) {\n        /* If the previous file exists, so should this one. Hence -2 is\n         * fatal in this case (errors out in next condition) - the kernel\n         * interface might've changed too much or something else is wrong. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get min bandwidth from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    rv = virFileReadValueUint(&i_membw->max_allocation,\n                              SYSFS_RESCTRL_PATH \"/info/MB/num_closids\");\n    if (rv == -2) {\n         /* Similar reasoning to min_bandwidth above. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get max allocation from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    resctrl->membw_info = g_steal_pointer(&i_membw);\n    ret = 0;\n cleanup:\n    VIR_FREE(i_membw);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetMemoryBandwidthInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    virResctrlInfoMemBWPtr i_membw = NULL;\n\n    /* query memory bandwidth allocation info */\n    if (VIR_ALLOC(i_membw) < 0)\n        goto cleanup;\n    rv = virFileReadValueUint(&i_membw->bandwidth_granularity,\n                              SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us,\n         * probably memory bandwidth allocation unsupported */\n        VIR_INFO(\"The path '\" SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran'\"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&i_membw->min_bandwidth,\n                              SYSFS_RESCTRL_PATH \"/info/MB/min_bandwidth\");\n    if (rv == -2) {\n        /* If the previous file exists, so should this one. Hence -2 is\n         * fatal in this case (errors out in next condition) - the kernel\n         * interface might've changed too much or something else is wrong. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get min bandwidth from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    rv = virFileReadValueUint(&i_membw->max_allocation,\n                              SYSFS_RESCTRL_PATH \"/info/MB/num_closids\");\n    if (rv == -2) {\n         /* Similar reasoning to min_bandwidth above. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get max allocation from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    resctrl->membw_info = g_steal_pointer(&i_membw);\n    ret = 0;\n cleanup:\n    VIR_FREE(i_membw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenIfExists",
          "args": [
            "&dirp",
            "SYSFS_RESCTRL_PATH \"/info\""
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2898-2902",
          "snippet": "int\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetInfo(virResctrlInfoPtr resctrl)\n{\n    DIR *dirp = NULL;\n    int ret = -1;\n\n    ret = virDirOpenIfExists(&dirp, SYSFS_RESCTRL_PATH \"/info\");\n    if (ret <= 0)\n        goto cleanup;\n\n    ret = virResctrlGetMemoryBandwidthInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetCacheInfo(resctrl, dirp);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virResctrlGetMonitorInfo(resctrl);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dirp);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlGetMonitorInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "689-761",
    "snippet": "static int\nvirResctrlGetMonitorInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    char *featurestr = NULL;\n    char **features = NULL;\n    size_t nfeatures = 0;\n    virResctrlInfoMongrpPtr info_monitor = NULL;\n\n    if (VIR_ALLOC(info_monitor) < 0)\n        return -1;\n\n    /* For now, monitor only exists in level 3 cache */\n    info_monitor->cache_level = 3;\n\n    rv = virFileReadValueUint(&info_monitor->max_monitor,\n                              SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us, probably resource\n         * monitor unsupported */\n        VIR_INFO(\"The file '\" SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids' \"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&info_monitor->cache_reuse_threshold,\n                              SYSFS_RESCTRL_PATH\n                              \"/info/L3_MON/max_threshold_occupancy\");\n    if (rv == -2) {\n        /* If CMT is not supported, then 'max_threshold_occupancy' file\n         * will not exist. */\n        VIR_DEBUG(\"File '\" SYSFS_RESCTRL_PATH\n                  \"/info/L3_MON/max_threshold_occupancy' does not exist\");\n    } else if (rv < 0) {\n        goto cleanup;\n    }\n\n    rv = virFileReadValueString(&featurestr,\n                                SYSFS_RESCTRL_PATH\n                                \"/info/L3_MON/mon_features\");\n    if (rv == -2)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get mon_features from resctrl\"));\n    if (rv < 0)\n        goto cleanup;\n\n    if (!*featurestr) {\n        /* If no feature found in \"/info/L3_MON/mon_features\",\n         * some error happens */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Got empty feature list from resctrl\"));\n        goto cleanup;\n    }\n\n    features = virStringSplitCount(featurestr, \"\\n\", 0, &nfeatures);\n    VIR_DEBUG(\"Resctrl supported %zd monitoring features\", nfeatures);\n\n    info_monitor->nfeatures = nfeatures;\n    info_monitor->features = g_steal_pointer(&features);\n    resctrl->monitor_info = g_steal_pointer(&info_monitor);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(featurestr);\n    virStringListFree(features);\n    VIR_FREE(info_monitor);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info_monitor"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "features"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "featurestr"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&info_monitor"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&features"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Resctrl supported %zd monitoring features\"",
            "nfeatures"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "featurestr",
            "\"\\n\"",
            "0",
            "&nfeatures"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Got empty feature list from resctrl\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Got empty feature list from resctrl\""
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get mon_features from resctrl\")"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&featurestr",
            "SYSFS_RESCTRL_PATH\n                                \"/info/L3_MON/mon_features\""
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"File '\" SYSFS_RESCTRL_PATH\n                  \"/info/L3_MON/max_threshold_occupancy' does not exist\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "&info_monitor->cache_reuse_threshold",
            "SYSFS_RESCTRL_PATH\n                              \"/info/L3_MON/max_threshold_occupancy\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"The file '\" SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids' \"\n                 \"does not exist\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "info_monitor"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetMonitorInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    char *featurestr = NULL;\n    char **features = NULL;\n    size_t nfeatures = 0;\n    virResctrlInfoMongrpPtr info_monitor = NULL;\n\n    if (VIR_ALLOC(info_monitor) < 0)\n        return -1;\n\n    /* For now, monitor only exists in level 3 cache */\n    info_monitor->cache_level = 3;\n\n    rv = virFileReadValueUint(&info_monitor->max_monitor,\n                              SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us, probably resource\n         * monitor unsupported */\n        VIR_INFO(\"The file '\" SYSFS_RESCTRL_PATH \"/info/L3_MON/num_rmids' \"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&info_monitor->cache_reuse_threshold,\n                              SYSFS_RESCTRL_PATH\n                              \"/info/L3_MON/max_threshold_occupancy\");\n    if (rv == -2) {\n        /* If CMT is not supported, then 'max_threshold_occupancy' file\n         * will not exist. */\n        VIR_DEBUG(\"File '\" SYSFS_RESCTRL_PATH\n                  \"/info/L3_MON/max_threshold_occupancy' does not exist\");\n    } else if (rv < 0) {\n        goto cleanup;\n    }\n\n    rv = virFileReadValueString(&featurestr,\n                                SYSFS_RESCTRL_PATH\n                                \"/info/L3_MON/mon_features\");\n    if (rv == -2)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get mon_features from resctrl\"));\n    if (rv < 0)\n        goto cleanup;\n\n    if (!*featurestr) {\n        /* If no feature found in \"/info/L3_MON/mon_features\",\n         * some error happens */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Got empty feature list from resctrl\"));\n        goto cleanup;\n    }\n\n    features = virStringSplitCount(featurestr, \"\\n\", 0, &nfeatures);\n    VIR_DEBUG(\"Resctrl supported %zd monitoring features\", nfeatures);\n\n    info_monitor->nfeatures = nfeatures;\n    info_monitor->features = g_steal_pointer(&features);\n    resctrl->monitor_info = g_steal_pointer(&info_monitor);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(featurestr);\n    virStringListFree(features);\n    VIR_FREE(info_monitor);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlGetMemoryBandwidthInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "624-675",
    "snippet": "static int\nvirResctrlGetMemoryBandwidthInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    virResctrlInfoMemBWPtr i_membw = NULL;\n\n    /* query memory bandwidth allocation info */\n    if (VIR_ALLOC(i_membw) < 0)\n        goto cleanup;\n    rv = virFileReadValueUint(&i_membw->bandwidth_granularity,\n                              SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us,\n         * probably memory bandwidth allocation unsupported */\n        VIR_INFO(\"The path '\" SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran'\"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&i_membw->min_bandwidth,\n                              SYSFS_RESCTRL_PATH \"/info/MB/min_bandwidth\");\n    if (rv == -2) {\n        /* If the previous file exists, so should this one. Hence -2 is\n         * fatal in this case (errors out in next condition) - the kernel\n         * interface might've changed too much or something else is wrong. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get min bandwidth from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    rv = virFileReadValueUint(&i_membw->max_allocation,\n                              SYSFS_RESCTRL_PATH \"/info/MB/num_closids\");\n    if (rv == -2) {\n         /* Similar reasoning to min_bandwidth above. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get max allocation from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    resctrl->membw_info = g_steal_pointer(&i_membw);\n    ret = 0;\n cleanup:\n    VIR_FREE(i_membw);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "i_membw"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&i_membw"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get max allocation from resctrl memory info\")"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot get max allocation from resctrl memory info\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "&i_membw->max_allocation",
            "SYSFS_RESCTRL_PATH \"/info/MB/num_closids\""
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get min bandwidth from resctrl memory info\")"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"The path '\" SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran'\"\n                 \"does not exist\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "i_membw"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetMemoryBandwidthInfo(virResctrlInfoPtr resctrl)\n{\n    int ret = -1;\n    int rv = -1;\n    virResctrlInfoMemBWPtr i_membw = NULL;\n\n    /* query memory bandwidth allocation info */\n    if (VIR_ALLOC(i_membw) < 0)\n        goto cleanup;\n    rv = virFileReadValueUint(&i_membw->bandwidth_granularity,\n                              SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran\");\n    if (rv == -2) {\n        /* The file doesn't exist, so it's unusable for us,\n         * probably memory bandwidth allocation unsupported */\n        VIR_INFO(\"The path '\" SYSFS_RESCTRL_PATH \"/info/MB/bandwidth_gran'\"\n                 \"does not exist\");\n        ret = 0;\n        goto cleanup;\n    } else if (rv < 0) {\n        /* Other failures are fatal, so just quit */\n        goto cleanup;\n    }\n\n    rv = virFileReadValueUint(&i_membw->min_bandwidth,\n                              SYSFS_RESCTRL_PATH \"/info/MB/min_bandwidth\");\n    if (rv == -2) {\n        /* If the previous file exists, so should this one. Hence -2 is\n         * fatal in this case (errors out in next condition) - the kernel\n         * interface might've changed too much or something else is wrong. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get min bandwidth from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    rv = virFileReadValueUint(&i_membw->max_allocation,\n                              SYSFS_RESCTRL_PATH \"/info/MB/num_closids\");\n    if (rv == -2) {\n         /* Similar reasoning to min_bandwidth above. */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get max allocation from resctrl memory info\"));\n    }\n    if (rv < 0)\n        goto cleanup;\n\n    resctrl->membw_info = g_steal_pointer(&i_membw);\n    ret = 0;\n cleanup:\n    VIR_FREE(i_membw);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlGetCacheInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "499-621",
    "snippet": "static int\nvirResctrlGetCacheInfo(virResctrlInfoPtr resctrl,\n                       DIR *dirp)\n{\n    char *endptr = NULL;\n    char *tmp_str = NULL;\n    int ret = -1;\n    int rv = -1;\n    int type = 0;\n    struct dirent *ent = NULL;\n    unsigned int level = 0;\n    virBitmapPtr tmp_map = NULL;\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH \"/info\")) > 0) {\n        VIR_DEBUG(\"Parsing info type '%s'\", ent->d_name);\n        if (ent->d_name[0] != 'L')\n            continue;\n\n        if (virStrToLong_uip(ent->d_name + 1, &endptr, 10, &level) < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info level '%s'\", ent->d_name + 1);\n            continue;\n        }\n\n        type = virResctrlTypeFromString(endptr);\n        if (type < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info type '%s'\", endptr);\n            continue;\n        }\n\n        if (VIR_ALLOC(i_type) < 0)\n            goto cleanup;\n\n        i_type->control.scope = type;\n\n        rv = virFileReadValueUint(&i_type->control.max_allocation,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/num_closids\",\n                                  ent->d_name);\n        if (rv == -2) {\n            /* The file doesn't exist, so it's unusable for us,\n             *  but we can scan further */\n            VIR_WARN(\"The path '\" SYSFS_RESCTRL_PATH \"/info/%s/num_closids' \"\n                     \"does not exist\",\n                     ent->d_name);\n        } else if (rv < 0) {\n            /* Other failures are fatal, so just quit */\n            goto cleanup;\n        }\n\n        rv = virFileReadValueString(&tmp_str,\n                                    SYSFS_RESCTRL_PATH\n                                    \"/info/%s/cbm_mask\",\n                                    ent->d_name);\n        if (rv == -2) {\n            /* If the previous file exists, so should this one.  Hence -2 is\n             * fatal in this case as well (errors out in next condition) - the\n             * kernel interface might've changed too much or something else is\n             * wrong. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get cbm_mask from resctrl cache info\"));\n        }\n        if (rv < 0)\n            goto cleanup;\n\n        virStringTrimOptionalNewline(tmp_str);\n\n        tmp_map = virBitmapNewString(tmp_str);\n        VIR_FREE(tmp_str);\n        if (!tmp_map) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot parse cbm_mask from resctrl cache info\"));\n            goto cleanup;\n        }\n\n        i_type->bits = virBitmapCountBits(tmp_map);\n        virBitmapFree(tmp_map);\n        tmp_map = NULL;\n\n        rv = virFileReadValueUint(&i_type->min_cbm_bits,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/min_cbm_bits\",\n                                  ent->d_name);\n        if (rv == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get min_cbm_bits from resctrl cache info\"));\n        if (rv < 0)\n            goto cleanup;\n\n        if (resctrl->nlevels <= level &&\n            VIR_EXPAND_N(resctrl->levels, resctrl->nlevels,\n                         level - resctrl->nlevels + 1) < 0)\n            goto cleanup;\n\n        if (!resctrl->levels[level]) {\n            virResctrlInfoPerTypePtr *types = NULL;\n\n            if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n                goto cleanup;\n\n            if (VIR_ALLOC(resctrl->levels[level]) < 0) {\n                VIR_FREE(types);\n                goto cleanup;\n            }\n            resctrl->levels[level]->types = types;\n        }\n\n        i_level = resctrl->levels[level];\n\n        if (i_level->types[type]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Duplicate cache type in resctrl for level %u\"),\n                           level);\n            goto cleanup;\n        }\n\n        i_level->types[type] = g_steal_pointer(&i_type);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(i_type);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "i_type"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&i_type"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Duplicate cache type in resctrl for level %u\")",
            "level"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate cache type in resctrl for level %u\""
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "types"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "resctrl->levels[level]"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "types",
            "VIR_CACHE_TYPE_LAST"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "resctrl->levels",
            "resctrl->nlevels",
            "level - resctrl->nlevels + 1"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get min_cbm_bits from resctrl cache info\")"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "&i_type->min_cbm_bits",
            "SYSFS_RESCTRL_PATH \"/info/%s/min_cbm_bits\"",
            "ent->d_name"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "tmp_map"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "tmp_map"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot parse cbm_mask from resctrl cache info\")"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp_str"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNewString",
          "args": [
            "tmp_str"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringTrimOptionalNewline",
          "args": [
            "tmp_str"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virStringTrimOptionalNewline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1338-1347",
          "snippet": "void virStringTrimOptionalNewline(char *str)\n{\n    size_t len = strlen(str);\n\n    if (!len)\n        return;\n\n    if (str[len - 1] == '\\n')\n        str[len - 1] = '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringTrimOptionalNewline(char *str)\n{\n    size_t len = strlen(str);\n\n    if (!len)\n        return;\n\n    if (str[len - 1] == '\\n')\n        str[len - 1] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get cbm_mask from resctrl cache info\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&tmp_str",
            "SYSFS_RESCTRL_PATH\n                                    \"/info/%s/cbm_mask\"",
            "ent->d_name"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"The path '\" SYSFS_RESCTRL_PATH \"/info/%s/num_closids' \"\n                     \"does not exist\"",
            "ent->d_name"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "i_type"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cannot parse resctrl cache info type '%s'\"",
            "endptr"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlTypeFromString",
          "args": [
            "endptr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cannot parse resctrl cache info level '%s'\"",
            "ent->d_name + 1"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "ent->d_name + 1",
            "&endptr",
            "10",
            "&level"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Parsing info type '%s'\"",
            "ent->d_name"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dirp",
            "&ent",
            "SYSFS_RESCTRL_PATH \"/info\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlGetCacheInfo(virResctrlInfoPtr resctrl,\n                       DIR *dirp)\n{\n    char *endptr = NULL;\n    char *tmp_str = NULL;\n    int ret = -1;\n    int rv = -1;\n    int type = 0;\n    struct dirent *ent = NULL;\n    unsigned int level = 0;\n    virBitmapPtr tmp_map = NULL;\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n\n    while ((rv = virDirRead(dirp, &ent, SYSFS_RESCTRL_PATH \"/info\")) > 0) {\n        VIR_DEBUG(\"Parsing info type '%s'\", ent->d_name);\n        if (ent->d_name[0] != 'L')\n            continue;\n\n        if (virStrToLong_uip(ent->d_name + 1, &endptr, 10, &level) < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info level '%s'\", ent->d_name + 1);\n            continue;\n        }\n\n        type = virResctrlTypeFromString(endptr);\n        if (type < 0) {\n            VIR_DEBUG(\"Cannot parse resctrl cache info type '%s'\", endptr);\n            continue;\n        }\n\n        if (VIR_ALLOC(i_type) < 0)\n            goto cleanup;\n\n        i_type->control.scope = type;\n\n        rv = virFileReadValueUint(&i_type->control.max_allocation,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/num_closids\",\n                                  ent->d_name);\n        if (rv == -2) {\n            /* The file doesn't exist, so it's unusable for us,\n             *  but we can scan further */\n            VIR_WARN(\"The path '\" SYSFS_RESCTRL_PATH \"/info/%s/num_closids' \"\n                     \"does not exist\",\n                     ent->d_name);\n        } else if (rv < 0) {\n            /* Other failures are fatal, so just quit */\n            goto cleanup;\n        }\n\n        rv = virFileReadValueString(&tmp_str,\n                                    SYSFS_RESCTRL_PATH\n                                    \"/info/%s/cbm_mask\",\n                                    ent->d_name);\n        if (rv == -2) {\n            /* If the previous file exists, so should this one.  Hence -2 is\n             * fatal in this case as well (errors out in next condition) - the\n             * kernel interface might've changed too much or something else is\n             * wrong. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get cbm_mask from resctrl cache info\"));\n        }\n        if (rv < 0)\n            goto cleanup;\n\n        virStringTrimOptionalNewline(tmp_str);\n\n        tmp_map = virBitmapNewString(tmp_str);\n        VIR_FREE(tmp_str);\n        if (!tmp_map) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot parse cbm_mask from resctrl cache info\"));\n            goto cleanup;\n        }\n\n        i_type->bits = virBitmapCountBits(tmp_map);\n        virBitmapFree(tmp_map);\n        tmp_map = NULL;\n\n        rv = virFileReadValueUint(&i_type->min_cbm_bits,\n                                  SYSFS_RESCTRL_PATH \"/info/%s/min_cbm_bits\",\n                                  ent->d_name);\n        if (rv == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get min_cbm_bits from resctrl cache info\"));\n        if (rv < 0)\n            goto cleanup;\n\n        if (resctrl->nlevels <= level &&\n            VIR_EXPAND_N(resctrl->levels, resctrl->nlevels,\n                         level - resctrl->nlevels + 1) < 0)\n            goto cleanup;\n\n        if (!resctrl->levels[level]) {\n            virResctrlInfoPerTypePtr *types = NULL;\n\n            if (VIR_ALLOC_N(types, VIR_CACHE_TYPE_LAST) < 0)\n                goto cleanup;\n\n            if (VIR_ALLOC(resctrl->levels[level]) < 0) {\n                VIR_FREE(types);\n                goto cleanup;\n            }\n            resctrl->levels[level]->types = types;\n        }\n\n        i_level = resctrl->levels[level];\n\n        if (i_level->types[type]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Duplicate cache type in resctrl for level %u\"),\n                           level);\n            goto cleanup;\n        }\n\n        i_level->types[type] = g_steal_pointer(&i_type);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(i_type);\n    return ret;\n}"
  },
  {
    "function_name": "virResctrlUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "476-495",
    "snippet": "static int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot unlock resctrl\")"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot unlock resctrl\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFlock",
          "args": [
            "fd",
            "false",
            "false"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "507-513",
          "snippet": "int virFileFlock(int fd G_GNUC_UNUSED,\n                 bool lock G_GNUC_UNUSED,\n                 bool shared G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileFlock(int fd G_GNUC_UNUSED,\n                 bool lock G_GNUC_UNUSED,\n                 bool shared G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot close resctrl\")"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlUnlock(int fd)\n{\n    if (fd == -1)\n        return 0;\n\n    /* The lock gets unlocked by closing the fd, which we need to do anyway in\n     * order to clean up properly */\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot close resctrl\"));\n\n        /* Trying to save the already broken */\n        if (virFileFlock(fd, false, false) < 0)\n            virReportSystemError(errno, \"%s\", _(\"Cannot unlock resctrl\"));\n\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlLockWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "456-473",
    "snippet": "static int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot lock resctrl\")"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot lock resctrl\""
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFlock",
          "args": [
            "fd",
            "true",
            "true"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "507-513",
          "snippet": "int virFileFlock(int fd G_GNUC_UNUSED,\n                 bool lock G_GNUC_UNUSED,\n                 bool shared G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileFlock(int fd G_GNUC_UNUSED,\n                 bool lock G_GNUC_UNUSED,\n                 bool shared G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot open resctrl\")"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "SYSFS_RESCTRL_PATH",
            "O_RDWR | O_CLOEXEC"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\n#define SYSFS_RESCTRL_PATH \"/sys/fs/resctrl\"\n\nstatic int\nvirResctrlLockWrite(void)\n{\n    int fd = open(SYSFS_RESCTRL_PATH, O_RDWR | O_CLOEXEC);\n\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot open resctrl\"));\n        return -1;\n    }\n\n    if (virFileFlock(fd, true, true) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot lock resctrl\"));\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return fd;\n}"
  },
  {
    "function_name": "virResctrlOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "437-450",
    "snippet": "static int\nvirResctrlOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virResctrlInfo, virClassForObject()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virResctrlAlloc, virClassForObject()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virResctrlMonitor, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virResctrlMonitor",
            "virClassForObject()"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virResctrlAlloc",
            "virClassForObject()"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virResctrlInfo",
            "virClassForObject()"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic int\nvirResctrlOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virResctrlInfo, virClassForObject()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virResctrlAlloc, virClassForObject()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virResctrlMonitor, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virResctrlMonitorDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "425-433",
    "snippet": "static void\nvirResctrlMonitorDispose(void *obj)\n{\n    virResctrlMonitorPtr monitor = obj;\n\n    virObjectUnref(monitor->alloc);\n    VIR_FREE(monitor->id);\n    VIR_FREE(monitor->path);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "monitor->path"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "monitor->id"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "monitor->alloc"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlMonitorDispose(void *obj)\n{\n    virResctrlMonitorPtr monitor = obj;\n\n    virObjectUnref(monitor->alloc);\n    VIR_FREE(monitor->id);\n    VIR_FREE(monitor->path);\n}"
  },
  {
    "function_name": "virResctrlAllocDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "376-422",
    "snippet": "static void\nvirResctrlAllocDispose(void *obj)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    virResctrlAllocPtr alloc = obj;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr level = alloc->levels[i];\n\n        if (!level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr type = level->types[j];\n\n            if (!type)\n                continue;\n\n            for (k = 0; k < type->nsizes; k++)\n                VIR_FREE(type->sizes[k]);\n\n            for (k = 0; k < type->nmasks; k++)\n                virBitmapFree(type->masks[k]);\n\n            VIR_FREE(type->sizes);\n            VIR_FREE(type->masks);\n            VIR_FREE(type);\n        }\n        VIR_FREE(level->types);\n        VIR_FREE(level);\n    }\n\n    if (alloc->mem_bw) {\n        virResctrlAllocMemBWPtr mem_bw = alloc->mem_bw;\n        for (i = 0; i < mem_bw->nbandwidths; i++)\n            VIR_FREE(mem_bw->bandwidths[i]);\n        VIR_FREE(alloc->mem_bw->bandwidths);\n        VIR_FREE(alloc->mem_bw);\n    }\n\n    VIR_FREE(alloc->id);\n    VIR_FREE(alloc->path);\n    VIR_FREE(alloc->levels);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc->levels"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc->path"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc->id"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc->mem_bw"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alloc->mem_bw->bandwidths"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mem_bw->bandwidths[i]"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "level"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "level->types"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type->masks"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type->sizes"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "type->masks[k]"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type->sizes[k]"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlAllocDispose(void *obj)\n{\n    size_t i = 0;\n    size_t j = 0;\n    size_t k = 0;\n\n    virResctrlAllocPtr alloc = obj;\n\n    for (i = 0; i < alloc->nlevels; i++) {\n        virResctrlAllocPerLevelPtr level = alloc->levels[i];\n\n        if (!level)\n            continue;\n\n        for (j = 0; j < VIR_CACHE_TYPE_LAST; j++) {\n            virResctrlAllocPerTypePtr type = level->types[j];\n\n            if (!type)\n                continue;\n\n            for (k = 0; k < type->nsizes; k++)\n                VIR_FREE(type->sizes[k]);\n\n            for (k = 0; k < type->nmasks; k++)\n                virBitmapFree(type->masks[k]);\n\n            VIR_FREE(type->sizes);\n            VIR_FREE(type->masks);\n            VIR_FREE(type);\n        }\n        VIR_FREE(level->types);\n        VIR_FREE(level);\n    }\n\n    if (alloc->mem_bw) {\n        virResctrlAllocMemBWPtr mem_bw = alloc->mem_bw;\n        for (i = 0; i < mem_bw->nbandwidths; i++)\n            VIR_FREE(mem_bw->bandwidths[i]);\n        VIR_FREE(alloc->mem_bw->bandwidths);\n        VIR_FREE(alloc->mem_bw);\n    }\n\n    VIR_FREE(alloc->id);\n    VIR_FREE(alloc->path);\n    VIR_FREE(alloc->levels);\n}"
  },
  {
    "function_name": "virResctrlInfoMonFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "227-235",
    "snippet": "void\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mon"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "mon->features"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}"
  },
  {
    "function_name": "virResctrlInfoDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
    "lines": "196-224",
    "snippet": "static void\nvirResctrlInfoDispose(void *obj)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    virResctrlInfoPtr resctrl = obj;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr level = resctrl->levels[i];\n\n        if (!level)\n            continue;\n\n        if (level->types) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++)\n                VIR_FREE(level->types[j]);\n        }\n        VIR_FREE(level->types);\n        VIR_FREE(level);\n    }\n\n    if (resctrl->monitor_info)\n        virStringListFree(resctrl->monitor_info->features);\n\n    VIR_FREE(resctrl->membw_info);\n    VIR_FREE(resctrl->levels);\n    VIR_FREE(resctrl->monitor_info);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virresctrlpriv.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "resctrl->monitor_info"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "resctrl->levels"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "resctrl->membw_info"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "resctrl->monitor_info->features"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "level"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "level->types"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "level->types[j]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic void\nvirResctrlInfoDispose(void *obj)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    virResctrlInfoPtr resctrl = obj;\n\n    for (i = 0; i < resctrl->nlevels; i++) {\n        virResctrlInfoPerLevelPtr level = resctrl->levels[i];\n\n        if (!level)\n            continue;\n\n        if (level->types) {\n            for (j = 0; j < VIR_CACHE_TYPE_LAST; j++)\n                VIR_FREE(level->types[j]);\n        }\n        VIR_FREE(level->types);\n        VIR_FREE(level);\n    }\n\n    if (resctrl->monitor_info)\n        virStringListFree(resctrl->monitor_info->features);\n\n    VIR_FREE(resctrl->membw_info);\n    VIR_FREE(resctrl->levels);\n    VIR_FREE(resctrl->monitor_info);\n}"
  }
]