[
  {
    "function_name": "virBhyveProcessReconnectAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "476-497",
    "snippet": "void\nvirBhyveProcessReconnectAll(bhyveConnPtr driver)\n{\n    kvm_t *kd;\n    struct bhyveProcessReconnectData data;\n    char errbuf[_POSIX2_LINE_MAX];\n\n    if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to get kvm descriptor: %s\"),\n                       errbuf);\n        return;\n\n    }\n\n    data.driver = driver;\n    data.kd = kd;\n\n    virDomainObjListForEach(driver->domains, false, virBhyveProcessReconnect, &data);\n\n    kvm_close(kd);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_close",
          "args": [
            "kd"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListForEach",
          "args": [
            "driver->domains",
            "false",
            "virBhyveProcessReconnect",
            "&data"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "827-844",
          "snippet": "int\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to get kvm descriptor: %s\")",
            "errbuf"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get kvm descriptor: %s\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_openfiles",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "O_RDONLY",
            "errbuf"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirBhyveProcessReconnectAll(bhyveConnPtr driver)\n{\n    kvm_t *kd;\n    struct bhyveProcessReconnectData data;\n    char errbuf[_POSIX2_LINE_MAX];\n\n    if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to get kvm descriptor: %s\"),\n                       errbuf);\n        return;\n\n    }\n\n    data.driver = driver;\n    data.kd = kd;\n\n    virDomainObjListForEach(driver->domains, false, virBhyveProcessReconnect, &data);\n\n    kvm_close(kd);\n}"
  },
  {
    "function_name": "virBhyveProcessReconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "415-474",
    "snippet": "static int\nvirBhyveProcessReconnect(virDomainObjPtr vm,\n                         void *opaque)\n{\n    struct bhyveProcessReconnectData *data = opaque;\n    struct kinfo_proc *kp;\n    int nprocs;\n    char **proc_argv;\n    char *expected_proctitle = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    if (!virDomainObjIsActive(vm))\n        return 0;\n\n    if (!vm->pid)\n        return 0;\n\n    virObjectLock(vm);\n\n    kp = kvm_getprocs(data->kd, KERN_PROC_PID, vm->pid, &nprocs);\n    if (kp == NULL || nprocs != 1)\n        goto cleanup;\n\n    expected_proctitle = g_strdup_printf(\"bhyve: %s\", vm->def->name);\n\n    proc_argv = kvm_getargv(data->kd, kp, 0);\n    if (proc_argv && proc_argv[0]) {\n         if (STREQ(expected_proctitle, proc_argv[0])) {\n             ret = 0;\n             priv->mon = bhyveMonitorOpen(vm, data->driver);\n             if (vm->def->ngraphics == 1 &&\n                 vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                 int vnc_port = vm->def->graphics[0]->data.vnc.port;\n                 if (virPortAllocatorSetUsed(vnc_port) < 0) {\n                     VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                              vnc_port, vm->def->name);\n                 }\n             }\n         }\n    }\n\n cleanup:\n    if (ret < 0) {\n        /* If VM is reported to be in active state, but we cannot find\n         * its PID, then we clear information about the PID and\n         * set state to 'shutdown' */\n        vm->pid = 0;\n        vm->def->id = -1;\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_UNKNOWN);\n        ignore_value(virDomainObjSave(vm, data->driver->xmlopt,\n                                      BHYVE_STATE_DIR));\n    }\n\n    virObjectUnlock(vm);\n    VIR_FREE(expected_proctitle);\n\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "expected_proctitle"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainObjSave(vm, data->driver->xmlopt,\n                                      BHYVE_STATE_DIR)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "data->driver->xmlopt",
            "BHYVE_STATE_DIR"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_UNKNOWN"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to mark VNC port '%d' as used by '%s'\"",
            "vnc_port",
            "vm->def->name"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortAllocatorSetUsed",
          "args": [
            "vnc_port"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorSetUsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "283-308",
          "snippet": "int\nvirPortAllocatorSetUsed(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapIsBitSet(pa->bitmap, port) ||\n        virBitmapSetBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve port %d\"), port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorSetUsed(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapIsBitSet(pa->bitmap, port) ||\n        virBitmapSetBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve port %d\"), port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorOpen",
          "args": [
            "vm",
            "data->driver"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "220-230",
          "snippet": "bhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nbhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "expected_proctitle",
            "proc_argv[0]"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_getargv",
          "args": [
            "data->kd",
            "kp",
            "0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"bhyve: %s\"",
            "vm->def->name"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_getprocs",
          "args": [
            "data->kd",
            "KERN_PROC_PID",
            "vm->pid",
            "&nprocs"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirBhyveProcessReconnect(virDomainObjPtr vm,\n                         void *opaque)\n{\n    struct bhyveProcessReconnectData *data = opaque;\n    struct kinfo_proc *kp;\n    int nprocs;\n    char **proc_argv;\n    char *expected_proctitle = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    if (!virDomainObjIsActive(vm))\n        return 0;\n\n    if (!vm->pid)\n        return 0;\n\n    virObjectLock(vm);\n\n    kp = kvm_getprocs(data->kd, KERN_PROC_PID, vm->pid, &nprocs);\n    if (kp == NULL || nprocs != 1)\n        goto cleanup;\n\n    expected_proctitle = g_strdup_printf(\"bhyve: %s\", vm->def->name);\n\n    proc_argv = kvm_getargv(data->kd, kp, 0);\n    if (proc_argv && proc_argv[0]) {\n         if (STREQ(expected_proctitle, proc_argv[0])) {\n             ret = 0;\n             priv->mon = bhyveMonitorOpen(vm, data->driver);\n             if (vm->def->ngraphics == 1 &&\n                 vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                 int vnc_port = vm->def->graphics[0]->data.vnc.port;\n                 if (virPortAllocatorSetUsed(vnc_port) < 0) {\n                     VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                              vnc_port, vm->def->name);\n                 }\n             }\n         }\n    }\n\n cleanup:\n    if (ret < 0) {\n        /* If VM is reported to be in active state, but we cannot find\n         * its PID, then we clear information about the PID and\n         * set state to 'shutdown' */\n        vm->pid = 0;\n        vm->def->id = -1;\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_UNKNOWN);\n        ignore_value(virDomainObjSave(vm, data->driver->xmlopt,\n                                      BHYVE_STATE_DIR));\n    }\n\n    virObjectUnlock(vm);\n    VIR_FREE(expected_proctitle);\n\n    return ret;\n}"
  },
  {
    "function_name": "virBhyveGetDomainTotalCpuStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "374-408",
    "snippet": "int\nvirBhyveGetDomainTotalCpuStats(virDomainObjPtr vm,\n                               unsigned long long *cpustats)\n{\n    struct kinfo_proc *kp;\n    kvm_t *kd;\n    char errbuf[_POSIX2_LINE_MAX];\n    int nprocs;\n    int ret = -1;\n\n    if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to get kvm descriptor: %s\"),\n                       errbuf);\n        return -1;\n\n    }\n\n    kp = kvm_getprocs(kd, KERN_PROC_PID, vm->pid, &nprocs);\n    if (kp == NULL || nprocs != 1) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to obtain information about pid: %d\"),\n                       (int)vm->pid);\n        goto cleanup;\n    }\n\n    *cpustats = kp->ki_runtime * 1000ull;\n\n    ret = 0;\n\n cleanup:\n    kvm_close(kd);\n\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_close",
          "args": [
            "kd"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to obtain information about pid: %d\")",
            "(int)vm->pid"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to obtain information about pid: %d\""
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_getprocs",
          "args": [
            "kd",
            "KERN_PROC_PID",
            "vm->pid",
            "&nprocs"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to get kvm descriptor: %s\")",
            "errbuf"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_openfiles",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "O_RDONLY",
            "errbuf"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveGetDomainTotalCpuStats(virDomainObjPtr vm,\n                               unsigned long long *cpustats)\n{\n    struct kinfo_proc *kp;\n    kvm_t *kd;\n    char errbuf[_POSIX2_LINE_MAX];\n    int nprocs;\n    int ret = -1;\n\n    if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to get kvm descriptor: %s\"),\n                       errbuf);\n        return -1;\n\n    }\n\n    kp = kvm_getprocs(kd, KERN_PROC_PID, vm->pid, &nprocs);\n    if (kp == NULL || nprocs != 1) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to obtain information about pid: %d\"),\n                       (int)vm->pid);\n        goto cleanup;\n    }\n\n    *cpustats = kp->ki_runtime * 1000ull;\n\n    ret = 0;\n\n cleanup:\n    kvm_close(kd);\n\n    return ret;\n}"
  },
  {
    "function_name": "virBhyveProcessRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "361-372",
    "snippet": "int\nvirBhyveProcessRestart(bhyveConnPtr driver,\n                       virDomainObjPtr vm)\n{\n    if (virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        return -1;\n\n    if (virBhyveProcessStartImpl(driver, vm, VIR_DOMAIN_RUNNING_BOOTED) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBhyveProcessStartImpl",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_RUNNING_BOOTED"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessStartImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "113-252",
          "snippet": "static int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_SHUTDOWN"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "274-336",
          "snippet": "int\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessRestart(bhyveConnPtr driver,\n                       virDomainObjPtr vm)\n{\n    if (virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        return -1;\n\n    if (virBhyveProcessStartImpl(driver, vm, VIR_DOMAIN_RUNNING_BOOTED) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virBhyveProcessShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "338-359",
    "snippet": "int\nvirBhyveProcessShutdown(virDomainObjPtr vm)\n{\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    /* Bhyve tries to perform ACPI shutdown when it receives\n     * SIGTERM signal. So we just issue SIGTERM here and rely\n     * on the bhyve monitor to clean things up if process disappears.\n     */\n    if (virProcessKill(vm->pid, SIGTERM) != 0) {\n        VIR_WARN(\"Failed to terminate bhyve process for VM '%s': %s\",\n                 vm->def->name, virGetLastErrorMessage());\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to terminate bhyve process for VM '%s': %s\"",
            "vm->def->name",
            "virGetLastErrorMessage()"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessKill",
          "args": [
            "vm->pid",
            "SIGTERM"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid PID %d for VM\")",
            "(int)vm->pid"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid PID %d for VM\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessShutdown(virDomainObjPtr vm)\n{\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    /* Bhyve tries to perform ACPI shutdown when it receives\n     * SIGTERM signal. So we just issue SIGTERM here and rely\n     * on the bhyve monitor to clean things up if process disappears.\n     */\n    if (virProcessKill(vm->pid, SIGTERM) != 0) {\n        VIR_WARN(\"Failed to terminate bhyve process for VM '%s': %s\",\n                 vm->def->name, virGetLastErrorMessage());\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virBhyveProcessStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "274-336",
    "snippet": "int\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeleteConfig",
          "args": [
            "BHYVE_STATE_DIR",
            "NULL",
            "vm"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeleteConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29726-29753",
          "snippet": "int\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "BHYVE_STATE_DIR",
            "vm->def->name"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveProcessStopHook",
          "args": [
            "vm",
            "VIR_HOOK_BHYVE_OP_RELEASE"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveProcessStopHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "105-111",
          "snippet": "static void\nbhyveProcessStopHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                    VIR_HOOK_SUBOP_END, NULL, NULL, NULL);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveProcessStopHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                    VIR_HOOK_SUBOP_END, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "reason"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksUnset",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "bhyveProcessAutoDestroy"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksUnset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "142-178",
          "snippet": "int\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to release VNC port for '%s'\"",
            "vm->def->name"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "vm->def->graphics[0]->data.vnc.port"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveNetCleanup",
          "args": [
            "vm"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveNetCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "69-87",
          "snippet": "static void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorClose",
          "args": [
            "priv->mon"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "232-242",
          "snippet": "void\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildDestroyCmd",
          "args": [
            "driver",
            "vm->def"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildDestroyCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "656-666",
          "snippet": "virCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid PID %d for VM\")",
            "(int)vm->pid"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid PID %d for VM\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VM '%s' not active\"",
            "vm->def->name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "virBhyveProcessStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "254-272",
    "snippet": "int\nvirBhyveProcessStart(virConnectPtr conn,\n                     virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     unsigned int flags)\n{\n    bhyveConnPtr driver = conn->privateData;\n\n    /* Run an early hook to setup missing devices. */\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_PREPARE) < 0)\n        return -1;\n\n    if (flags & VIR_BHYVE_PROCESS_START_AUTODESTROY &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, bhyveProcessAutoDestroy) < 0)\n        return -1;\n\n    return virBhyveProcessStartImpl(driver, vm, reason);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBhyveProcessStartImpl",
          "args": [
            "driver",
            "vm",
            "reason"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessStartImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "113-252",
          "snippet": "static int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksSet",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "conn",
            "bhyveProcessAutoDestroy"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "89-140",
          "snippet": "int\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveProcessStartHook",
          "args": [
            "vm",
            "VIR_HOOK_BHYVE_OP_PREPARE"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveProcessStartHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "95-103",
          "snippet": "static int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessStart(virConnectPtr conn,\n                     virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     unsigned int flags)\n{\n    bhyveConnPtr driver = conn->privateData;\n\n    /* Run an early hook to setup missing devices. */\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_PREPARE) < 0)\n        return -1;\n\n    if (flags & VIR_BHYVE_PROCESS_START_AUTODESTROY &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, bhyveProcessAutoDestroy) < 0)\n        return -1;\n\n    return virBhyveProcessStartImpl(driver, vm, reason);\n}"
  },
  {
    "function_name": "virBhyveProcessStartImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "113-252",
    "snippet": "static int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "logfd"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "logfile"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveNetCleanup",
          "args": [
            "vm"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveNetCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "69-87",
          "snippet": "static void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virCommandRun(destroy_cmd, &exitstatus)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "destroy_cmd",
            "&exitstatus"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorFD",
          "args": [
            "load_cmd",
            "&logfd"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1984-1997",
          "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "load_cmd",
            "&logfd"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildDestroyCmd",
          "args": [
            "driver",
            "vm->def"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildDestroyCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "656-666",
          "snippet": "virCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devmap_file"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devicemap"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot unlink file '%s'\")",
            "devmap_file"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot unlink file '%s'\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "devmap_file"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveProcessStartHook",
          "args": [
            "vm",
            "VIR_HOOK_BHYVE_OP_STARTED"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveProcessStartHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "95-103",
          "snippet": "static int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "BHYVE_STATE_DIR"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorOpen",
          "args": [
            "vm",
            "driver"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "220-230",
          "snippet": "bhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nbhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "reason"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Domain %s didn't show up\")",
            "vm->def->name"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "driver->pidfile",
            "&vm->pid"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Starting domain '%s'\"",
            "vm->def->name"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loading domain '%s'\"",
            "vm->def->name"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandWriteArgLog",
          "args": [
            "load_cmd",
            "logfd"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandWriteArgLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2039-2067",
          "snippet": "void\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot write device.map '%s'\")",
            "devmap_file"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "devmap_file",
            "devicemap",
            "0644"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildLoadCmd",
          "args": [
            "driver",
            "vm->def",
            "devmap_file",
            "&devicemap"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildLoadCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "954-973",
          "snippet": "virCommandPtr\nvirBhyveProcessBuildLoadCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                            const char *devmap_file, char **devicesmap_out)\n{\n    virDomainDiskDefPtr disk = NULL;\n\n    if (def->os.bootloader == NULL) {\n        disk = virBhyveGetBootDisk(def);\n\n        if (disk == NULL)\n            return NULL;\n\n        return virBhyveProcessBuildBhyveloadCmd(def, disk);\n    } else if (strstr(def->os.bootloader, \"grub-bhyve\") != NULL) {\n        return virBhyveProcessBuildGrubbhyveCmd(def, driver, devmap_file,\n                                                devicesmap_out);\n    } else {\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n    }\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildLoadCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                            const char *devmap_file, char **devicesmap_out)\n{\n    virDomainDiskDefPtr disk = NULL;\n\n    if (def->os.bootloader == NULL) {\n        disk = virBhyveGetBootDisk(def);\n\n        if (disk == NULL)\n            return NULL;\n\n        return virBhyveProcessBuildBhyveloadCmd(def, disk);\n    } else if (strstr(def->os.bootloader, \"grub-bhyve\") != NULL) {\n        return virBhyveProcessBuildGrubbhyveCmd(def, driver, devmap_file,\n                                                devicesmap_out);\n    } else {\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveFormatDevMapFile",
          "args": [
            "vm->def->name",
            "&devmap_file"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveFormatDevMapFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "89-93",
          "snippet": "static void\nvirBhyveFormatDevMapFile(const char *vm_name, char **fn_out)\n{\n    *fn_out = g_strdup_printf(\"%s/grub_bhyve-%s-device.map\", BHYVE_STATE_DIR, vm_name);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirBhyveFormatDevMapFile(const char *vm_name, char **fn_out)\n{\n    *fn_out = g_strdup_printf(\"%s/grub_bhyve-%s-device.map\", BHYVE_STATE_DIR, vm_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "driver->pidfile"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildBhyveCmd",
          "args": [
            "driver",
            "vm->def",
            "false"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildBhyveCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "485-654",
          "snippet": "virCommandPtr\nvirBhyveProcessBuildBhyveCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                             bool dryRun)\n{\n    /*\n     * /usr/sbin/bhyve -c 2 -m 256 -AI -H -P \\\n     *            -s 0:0,hostbridge \\\n     *            -s 1:0,virtio-net,tap0 \\\n     *            -s 2:0,ahci-hd,${IMG} \\\n     *            -S 31,uart,stdio \\\n     *            vm0\n     */\n    virCommandPtr cmd = virCommandNew(BHYVE);\n    size_t i;\n    unsigned nusbcontrollers = 0;\n    unsigned nvcpus = virDomainDefGetVcpus(def);\n\n    /* CPUs */\n    virCommandAddArg(cmd, \"-c\");\n    if (def->cpu && def->cpu->sockets) {\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto error;\n        }\n        if (nvcpus != def->cpu->sockets * def->cpu->cores * def->cpu->threads) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Invalid CPU topology: total number of vCPUs \"\n                             \"must equal the product of sockets, cores, \"\n                             \"and threads\"));\n            goto error;\n        }\n\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_CPUTOPOLOGY) != 0) {\n            virCommandAddArgFormat(cmd, \"cpus=%d,sockets=%d,cores=%d,threads=%d\",\n                                   nvcpus,\n                                   def->cpu->sockets,\n                                   def->cpu->cores,\n                                   def->cpu->threads);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"defining CPU topology\"));\n            goto error;\n        }\n    } else {\n        virCommandAddArgFormat(cmd, \"%d\", nvcpus);\n    }\n\n    /* Memory */\n    virCommandAddArg(cmd, \"-m\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if (def->mem.locked)\n        virCommandAddArg(cmd, \"-S\"); /* Wire guest memory */\n\n    /* Options */\n    if (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-A\"); /* Create an ACPI table */\n    if (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-I\"); /* Present ioapic to the guest */\n    if (def->features[VIR_DOMAIN_FEATURE_MSRS] == VIR_TRISTATE_SWITCH_ON) {\n        if (def->msrs_features[VIR_DOMAIN_MSRS_UNKNOWN] == VIR_DOMAIN_MSRS_UNKNOWN_IGNORE)\n            virCommandAddArg(cmd, \"-w\");\n    }\n\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        /* used by default in bhyve */\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_RTC_UTC) != 0) {\n            virCommandAddArg(cmd, \"-u\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                          \"UTC clock\"));\n            goto error;\n        }\n        break;\n    default:\n         virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported clock offset '%s'\"),\n                        virDomainClockOffsetTypeToString(def->clock.offset));\n         goto error;\n    }\n\n    /* Clarification about -H and -P flags from Peter Grehan:\n     * -H and -P flags force the guest to exit when it executes IA32 HLT and PAUSE\n     * instructions respectively.\n     *\n     * For the HLT exit, bhyve uses that to infer that the guest is idling and can\n     * be put to sleep until an external event arrives. If this option is not used,\n     * the guest will always use 100% of CPU on the host.\n     *\n     * The PAUSE exit is most useful when there are large numbers of guest VMs running,\n     * since it forces the guest to exit when it spins on a lock acquisition.\n     */\n    virCommandAddArg(cmd, \"-H\"); /* vmexit from guest on hlt */\n    virCommandAddArg(cmd, \"-P\"); /* vmexit from guest on pause */\n\n    virCommandAddArgList(cmd, \"-s\", \"0:0,hostbridge\", NULL);\n\n    if (def->os.bootloader == NULL &&\n        def->os.loader) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM)) {\n            virCommandAddArg(cmd, \"-l\");\n            virCommandAddArgFormat(cmd, \"bootrom,%s\", def->os.loader->path);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"UEFI loader\"));\n            goto error;\n        }\n    }\n\n    /* Devices */\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (bhyveBuildControllerArgStr(def, def->controllers[i], driver, cmd,\n                                       &nusbcontrollers) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->nnets; i++) {\n        if (bhyveBuildNetArgStr(def, def->nets[i], driver, cmd, dryRun) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->ndisks; i++) {\n        if (bhyveBuildDiskArgStr(def, def->disks[i], cmd) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics && def->nvideos) {\n        if (def->ngraphics == 1 && def->nvideos == 1) {\n            if (bhyveBuildGraphicsArgStr(def, def->graphics[0], def->videos[0],\n                                         driver, cmd, dryRun) < 0)\n                goto error;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Multiple graphics devices are not supported\"));\n             goto error;\n        }\n    }\n\n    if (bhyveDomainDefNeedsISAController(def))\n        bhyveBuildLPCArgStr(def, cmd);\n\n    if (bhyveBuildConsoleArgStr(def, cmd) < 0)\n        goto error;\n\n    if (def->namespaceData) {\n        bhyveDomainCmdlineDefPtr bhyvecmd;\n\n        VIR_WARN(\"Booting the guest using command line pass-through feature, \"\n                 \"which could potentially cause inconsistent state and \"\n                 \"upgrade issues\");\n\n        bhyvecmd = def->namespaceData;\n        for (i = 0; i < bhyvecmd->num_args; i++)\n            virCommandAddArg(cmd, bhyvecmd->args[i]);\n    }\n\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n\n error:\n    virCommandFree(cmd);\n    return NULL;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildBhyveCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                             bool dryRun)\n{\n    /*\n     * /usr/sbin/bhyve -c 2 -m 256 -AI -H -P \\\n     *            -s 0:0,hostbridge \\\n     *            -s 1:0,virtio-net,tap0 \\\n     *            -s 2:0,ahci-hd,${IMG} \\\n     *            -S 31,uart,stdio \\\n     *            vm0\n     */\n    virCommandPtr cmd = virCommandNew(BHYVE);\n    size_t i;\n    unsigned nusbcontrollers = 0;\n    unsigned nvcpus = virDomainDefGetVcpus(def);\n\n    /* CPUs */\n    virCommandAddArg(cmd, \"-c\");\n    if (def->cpu && def->cpu->sockets) {\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto error;\n        }\n        if (nvcpus != def->cpu->sockets * def->cpu->cores * def->cpu->threads) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Invalid CPU topology: total number of vCPUs \"\n                             \"must equal the product of sockets, cores, \"\n                             \"and threads\"));\n            goto error;\n        }\n\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_CPUTOPOLOGY) != 0) {\n            virCommandAddArgFormat(cmd, \"cpus=%d,sockets=%d,cores=%d,threads=%d\",\n                                   nvcpus,\n                                   def->cpu->sockets,\n                                   def->cpu->cores,\n                                   def->cpu->threads);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"defining CPU topology\"));\n            goto error;\n        }\n    } else {\n        virCommandAddArgFormat(cmd, \"%d\", nvcpus);\n    }\n\n    /* Memory */\n    virCommandAddArg(cmd, \"-m\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if (def->mem.locked)\n        virCommandAddArg(cmd, \"-S\"); /* Wire guest memory */\n\n    /* Options */\n    if (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-A\"); /* Create an ACPI table */\n    if (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-I\"); /* Present ioapic to the guest */\n    if (def->features[VIR_DOMAIN_FEATURE_MSRS] == VIR_TRISTATE_SWITCH_ON) {\n        if (def->msrs_features[VIR_DOMAIN_MSRS_UNKNOWN] == VIR_DOMAIN_MSRS_UNKNOWN_IGNORE)\n            virCommandAddArg(cmd, \"-w\");\n    }\n\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        /* used by default in bhyve */\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_RTC_UTC) != 0) {\n            virCommandAddArg(cmd, \"-u\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                          \"UTC clock\"));\n            goto error;\n        }\n        break;\n    default:\n         virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported clock offset '%s'\"),\n                        virDomainClockOffsetTypeToString(def->clock.offset));\n         goto error;\n    }\n\n    /* Clarification about -H and -P flags from Peter Grehan:\n     * -H and -P flags force the guest to exit when it executes IA32 HLT and PAUSE\n     * instructions respectively.\n     *\n     * For the HLT exit, bhyve uses that to infer that the guest is idling and can\n     * be put to sleep until an external event arrives. If this option is not used,\n     * the guest will always use 100% of CPU on the host.\n     *\n     * The PAUSE exit is most useful when there are large numbers of guest VMs running,\n     * since it forces the guest to exit when it spins on a lock acquisition.\n     */\n    virCommandAddArg(cmd, \"-H\"); /* vmexit from guest on hlt */\n    virCommandAddArg(cmd, \"-P\"); /* vmexit from guest on pause */\n\n    virCommandAddArgList(cmd, \"-s\", \"0:0,hostbridge\", NULL);\n\n    if (def->os.bootloader == NULL &&\n        def->os.loader) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM)) {\n            virCommandAddArg(cmd, \"-l\");\n            virCommandAddArgFormat(cmd, \"bootrom,%s\", def->os.loader->path);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"UEFI loader\"));\n            goto error;\n        }\n    }\n\n    /* Devices */\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (bhyveBuildControllerArgStr(def, def->controllers[i], driver, cmd,\n                                       &nusbcontrollers) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->nnets; i++) {\n        if (bhyveBuildNetArgStr(def, def->nets[i], driver, cmd, dryRun) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->ndisks; i++) {\n        if (bhyveBuildDiskArgStr(def, def->disks[i], cmd) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics && def->nvideos) {\n        if (def->ngraphics == 1 && def->nvideos == 1) {\n            if (bhyveBuildGraphicsArgStr(def, def->graphics[0], def->videos[0],\n                                         driver, cmd, dryRun) < 0)\n                goto error;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Multiple graphics devices are not supported\"));\n             goto error;\n        }\n    }\n\n    if (bhyveDomainDefNeedsISAController(def))\n        bhyveBuildLPCArgStr(def, cmd);\n\n    if (bhyveBuildConsoleArgStr(def, cmd) < 0)\n        goto error;\n\n    if (def->namespaceData) {\n        bhyveDomainCmdlineDefPtr bhyvecmd;\n\n        VIR_WARN(\"Booting the guest using command line pass-through feature, \"\n                 \"which could potentially cause inconsistent state and \"\n                 \"upgrade issues\");\n\n        bhyvecmd = def->namespaceData;\n        for (i = 0; i < bhyvecmd->num_args; i++)\n            virCommandAddArg(cmd, bhyvecmd->args[i]);\n    }\n\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n\n error:\n    virCommandFree(cmd);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDomainAssignAddresses",
          "args": [
            "vm->def",
            "NULL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDomainAssignAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
          "lines": "186-189",
          "snippet": "int bhyveDomainAssignAddresses(virDomainDefPtr def, virDomainObjPtr obj)\n{\n    return bhyveDomainAssignPCIAddresses(def, obj);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_addr.h\"",
            "#include \"bhyve_device.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nint bhyveDomainAssignAddresses(virDomainDefPtr def, virDomainObjPtr obj)\n{\n    return bhyveDomainAssignPCIAddresses(def, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot remove state PID file %s\")",
            "driver->pidfile"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "driver->pidfile"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to build pidfile path\")"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "BHYVE_STATE_DIR",
            "vm->def->name"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->pidfile"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open '%s'\")",
            "logfile"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "logfile",
            "O_WRONLY | O_APPEND | O_CREAT",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirBhyveProcessStartImpl(bhyveConnPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainRunningReason reason)\n{\n    char *devmap_file = NULL;\n    char *devicemap = NULL;\n    char *logfile = NULL;\n    int logfd = -1;\n    virCommandPtr cmd = NULL;\n    virCommandPtr load_cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1, rc;\n\n    logfile = g_strdup_printf(\"%s/%s.log\", BHYVE_LOG_DIR, vm->def->name);\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n                      S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    VIR_FREE(driver->pidfile);\n    if (!(driver->pidfile = virPidFileBuildPath(BHYVE_STATE_DIR,\n                                                vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path\"));\n        goto cleanup;\n    }\n\n    if (unlink(driver->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove state PID file %s\"),\n                             driver->pidfile);\n        goto cleanup;\n    }\n\n    if (bhyveDomainAssignAddresses(vm->def, NULL) < 0)\n        goto cleanup;\n\n    /* Call bhyve to start the VM */\n    if (!(cmd = virBhyveProcessBuildBhyveCmd(driver, vm->def, false)))\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandWriteArgLog(cmd, logfd);\n    virCommandSetPidFile(cmd, driver->pidfile);\n    virCommandDaemonize(cmd);\n\n    if (vm->def->os.loader == NULL) {\n        /* Now bhyve command is constructed, meaning the\n         * domain is ready to be started, so we can build\n         * and execute bhyveload command */\n\n        virBhyveFormatDevMapFile(vm->def->name, &devmap_file);\n\n        if (!(load_cmd = virBhyveProcessBuildLoadCmd(driver, vm->def,\n                                                     devmap_file, &devicemap)))\n            goto cleanup;\n        virCommandSetOutputFD(load_cmd, &logfd);\n        virCommandSetErrorFD(load_cmd, &logfd);\n\n        if (devicemap != NULL) {\n            rc = virFileWriteStr(devmap_file, devicemap, 0644);\n            if (rc) {\n                virReportSystemError(errno,\n                                     _(\"Cannot write device.map '%s'\"),\n                                     devmap_file);\n                goto cleanup;\n            }\n        }\n\n        /* Log generated command line */\n        virCommandWriteArgLog(load_cmd, logfd);\n\n        VIR_DEBUG(\"Loading domain '%s'\", vm->def->name);\n        if (virCommandRun(load_cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_START) < 0)\n        goto cleanup;\n\n    /* Now we can start the domain */\n    VIR_DEBUG(\"Starting domain '%s'\", vm->def->name);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(driver->pidfile, &vm->pid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s didn't show up\"), vm->def->name);\n        goto cleanup;\n    }\n\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->mon = bhyveMonitorOpen(vm, driver);\n\n    if (virDomainObjSave(vm, driver->xmlopt,\n                         BHYVE_STATE_DIR) < 0)\n        goto cleanup;\n\n    if (bhyveProcessStartHook(vm, VIR_HOOK_BHYVE_OP_STARTED) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (devicemap != NULL) {\n        rc = unlink(devmap_file);\n        if (rc < 0 && errno != ENOENT)\n            virReportSystemError(errno, _(\"cannot unlink file '%s'\"),\n                                 devmap_file);\n        VIR_FREE(devicemap);\n    }\n    VIR_FREE(devmap_file);\n\n    if (ret < 0) {\n        int exitstatus; /* Needed to avoid logging non-zero status */\n        virCommandPtr destroy_cmd;\n        if ((destroy_cmd = virBhyveProcessBuildDestroyCmd(driver,\n                                                          vm->def)) != NULL) {\n            virCommandSetOutputFD(load_cmd, &logfd);\n            virCommandSetErrorFD(load_cmd, &logfd);\n            ignore_value(virCommandRun(destroy_cmd, &exitstatus));\n            virCommandFree(destroy_cmd);\n        }\n\n        bhyveNetCleanup(vm);\n    }\n\n    virCommandFree(load_cmd);\n    virCommandFree(cmd);\n    VIR_FREE(logfile);\n    VIR_FORCE_CLOSE(logfd);\n    return ret;\n}"
  },
  {
    "function_name": "bhyveProcessStopHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "105-111",
    "snippet": "static void\nbhyveProcessStopHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                    VIR_HOOK_SUBOP_END, NULL, NULL, NULL);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_BHYVE",
            "vm->def->name",
            "op",
            "VIR_HOOK_SUBOP_END",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_BHYVE"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveProcessStopHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                    VIR_HOOK_SUBOP_END, NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "bhyveProcessStartHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "95-103",
    "snippet": "static int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_BHYVE",
            "vm->def->name",
            "op",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_BHYVE"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nbhyveProcessStartHook(virDomainObjPtr vm, virHookBhyveOpType op)\n{\n    if (!virHookPresent(VIR_HOOK_DRIVER_BHYVE))\n        return 0;\n\n    return virHookCall(VIR_HOOK_DRIVER_BHYVE, vm->def->name, op,\n                       VIR_HOOK_SUBOP_BEGIN, NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "virBhyveFormatDevMapFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "89-93",
    "snippet": "static void\nvirBhyveFormatDevMapFile(const char *vm_name, char **fn_out)\n{\n    *fn_out = g_strdup_printf(\"%s/grub_bhyve-%s-device.map\", BHYVE_STATE_DIR, vm_name);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/grub_bhyve-%s-device.map\"",
            "BHYVE_STATE_DIR",
            "vm_name"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirBhyveFormatDevMapFile(const char *vm_name, char **fn_out)\n{\n    *fn_out = g_strdup_printf(\"%s/grub_bhyve-%s-device.map\", BHYVE_STATE_DIR, vm_name);\n}"
  },
  {
    "function_name": "bhyveNetCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "69-87",
    "snippet": "static void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevTapDelete(net->ifname, NULL)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevTapDelete",
          "args": [
            "net->ifname",
            "NULL"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "476-482",
          "snippet": "int virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeRemovePort",
          "args": [
            "virDomainNetGetActualBridgeName(net)",
            "net->ifname"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeRemovePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "727-733",
          "snippet": "int virNetDevBridgeRemovePort(const char *brname,\n                              const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to remove bridge %s port %s\"), brname, ifname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeRemovePort(const char *brname,\n                              const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to remove bridge %s port %s\"), brname, ifname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBridgeName",
          "args": [
            "net"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30164-30175",
          "snippet": "const char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveNetCleanup(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainNetType actualType = virDomainNetGetActualType(net);\n\n        if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            if (net->ifname) {\n                ignore_value(virNetDevBridgeRemovePort(\n                                virDomainNetGetActualBridgeName(net),\n                                net->ifname));\n                ignore_value(virNetDevTapDelete(net->ifname, NULL));\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "bhyveProcessAutoDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
    "lines": "56-67",
    "snippet": "static void\nbhyveProcessAutoDestroy(virDomainObjPtr vm,\n                        virConnectPtr conn G_GNUC_UNUSED,\n                        void *opaque)\n{\n    bhyveConnPtr driver = opaque;\n\n    virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_DESTROYED);\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_device.h\"",
      "#include <net/if_tap.h>",
      "#include <net/if.h>",
      "#include <sys/user.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <kvm.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_DESTROYED"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "274-336",
          "snippet": "int\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nbhyveProcessAutoDestroy(virDomainObjPtr vm,\n                        virConnectPtr conn G_GNUC_UNUSED,\n                        void *opaque)\n{\n    bhyveConnPtr driver = opaque;\n\n    virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_DESTROYED);\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}"
  }
]