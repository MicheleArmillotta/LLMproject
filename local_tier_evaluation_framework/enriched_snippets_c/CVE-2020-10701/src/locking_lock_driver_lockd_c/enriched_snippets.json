[
  {
    "function_name": "virLockManagerLockDaemonInquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "722-732",
    "snippet": "static int virLockManagerLockDaemonInquire(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           char **state,\n                                           unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    if (state)\n        *state = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int virLockManagerLockDaemonInquire(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           char **state,\n                                           unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    if (state)\n        *state = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "668-719",
    "snippet": "static int virLockManagerLockDaemonRelease(virLockManagerPtr lock,\n                                           char **state,\n                                           unsigned int flags)\n{\n    virNetClientPtr client = NULL;\n    virNetClientProgramPtr program = NULL;\n    int counter = 0;\n    int rv = -1;\n    size_t i;\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(0, -1);\n\n    if (state)\n        *state = NULL;\n\n    if (!(client = virLockManagerLockDaemonConnect(lock, &program, &counter)))\n        goto cleanup;\n\n    for (i = 0; i < priv->nresources; i++) {\n        virLockSpaceProtocolReleaseResourceArgs args;\n\n        memset(&args, 0, sizeof(args));\n\n        if (priv->resources[i].lockspace)\n            args.path = priv->resources[i].lockspace;\n        args.name = priv->resources[i].name;\n        args.flags = priv->resources[i].flags;\n\n        args.flags &=\n            ~(VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED |\n              VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE);\n\n        if (virNetClientProgramCall(program,\n                                    client,\n                                    counter++,\n                                    VIR_LOCK_SPACE_PROTOCOL_PROC_RELEASE_RESOURCE,\n                                    0, NULL, NULL, NULL,\n                                    (xdrproc_t)xdr_virLockSpaceProtocolReleaseResourceArgs, &args,\n                                    (xdrproc_t)xdr_void, NULL) < 0)\n            goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(program);\n\n    return rv;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "program"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "program",
            "client",
            "counter++",
            "VIR_LOCK_SPACE_PROTOCOL_PROC_RELEASE_RESOURCE",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLockSpaceProtocolReleaseResourceArgs",
            "&args",
            "(xdrproc_t)xdr_void",
            "NULL"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnect",
          "args": [
            "lock",
            "&program",
            "&counter"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "241-263",
          "snippet": "static virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int virLockManagerLockDaemonRelease(virLockManagerPtr lock,\n                                           char **state,\n                                           unsigned int flags)\n{\n    virNetClientPtr client = NULL;\n    virNetClientProgramPtr program = NULL;\n    int counter = 0;\n    int rv = -1;\n    size_t i;\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(0, -1);\n\n    if (state)\n        *state = NULL;\n\n    if (!(client = virLockManagerLockDaemonConnect(lock, &program, &counter)))\n        goto cleanup;\n\n    for (i = 0; i < priv->nresources; i++) {\n        virLockSpaceProtocolReleaseResourceArgs args;\n\n        memset(&args, 0, sizeof(args));\n\n        if (priv->resources[i].lockspace)\n            args.path = priv->resources[i].lockspace;\n        args.name = priv->resources[i].name;\n        args.flags = priv->resources[i].flags;\n\n        args.flags &=\n            ~(VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED |\n              VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE);\n\n        if (virNetClientProgramCall(program,\n                                    client,\n                                    counter++,\n                                    VIR_LOCK_SPACE_PROTOCOL_PROC_RELEASE_RESOURCE,\n                                    0, NULL, NULL, NULL,\n                                    (xdrproc_t)xdr_virLockSpaceProtocolReleaseResourceArgs, &args,\n                                    (xdrproc_t)xdr_void, NULL) < 0)\n            goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(program);\n\n    return rv;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonAcquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "600-666",
    "snippet": "static int virLockManagerLockDaemonAcquire(virLockManagerPtr lock,\n                                           const char *state G_GNUC_UNUSED,\n                                           unsigned int flags,\n                                           virDomainLockFailureAction action G_GNUC_UNUSED,\n                                           int *fd)\n{\n    virNetClientPtr client = NULL;\n    virNetClientProgramPtr program = NULL;\n    int counter = 0;\n    int rv = -1;\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY |\n                  VIR_LOCK_MANAGER_ACQUIRE_RESTRICT, -1);\n\n    if (priv->nresources == 0 &&\n        priv->hasRWDisks &&\n        driver->requireLeaseForDisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Read/write, exclusive access, disks were present, but no leases specified\"));\n        return -1;\n    }\n\n    if (!(client = virLockManagerLockDaemonConnect(lock, &program, &counter)))\n        goto cleanup;\n\n    if (fd &&\n        (*fd = virNetClientDupFD(client, false)) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY)) {\n        size_t i;\n        for (i = 0; i < priv->nresources; i++) {\n            virLockSpaceProtocolAcquireResourceArgs args;\n\n            memset(&args, 0, sizeof(args));\n\n            args.path = priv->resources[i].lockspace;\n            args.name = priv->resources[i].name;\n            args.flags = priv->resources[i].flags;\n\n            if (virNetClientProgramCall(program,\n                                        client,\n                                        counter++,\n                                        VIR_LOCK_SPACE_PROTOCOL_PROC_ACQUIRE_RESOURCE,\n                                        0, NULL, NULL, NULL,\n                                        (xdrproc_t)xdr_virLockSpaceProtocolAcquireResourceArgs, &args,\n                                        (xdrproc_t)xdr_void, NULL) < 0)\n                goto cleanup;\n        }\n    }\n\n    if ((flags & VIR_LOCK_MANAGER_ACQUIRE_RESTRICT) &&\n        virLockManagerLockDaemonConnectionRestrict(lock, client, program, &counter) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv != 0 && fd)\n        VIR_FORCE_CLOSE(*fd);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(program);\n\n    return rv;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerLockDaemonDriverPtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "program"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "*fd"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnectionRestrict",
          "args": [
            "lock",
            "client",
            "program",
            "&counter"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnectionRestrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "166-188",
          "snippet": "static int\nvirLockManagerLockDaemonConnectionRestrict(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockSpaceProtocolRestrictArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_RESTRICT,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRestrictArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int\nvirLockManagerLockDaemonConnectionRestrict(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockSpaceProtocolRestrictArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_RESTRICT,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRestrictArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "program",
            "client",
            "counter++",
            "VIR_LOCK_SPACE_PROTOCOL_PROC_ACQUIRE_RESOURCE",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLockSpaceProtocolAcquireResourceArgs",
            "&args",
            "(xdrproc_t)xdr_void",
            "NULL"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientDupFD",
          "args": [
            "client",
            "false"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientDupFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "656-663",
          "snippet": "int virNetClientDupFD(virNetClientPtr client, bool cloexec)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketDupFD(client->sock, cloexec);\n    virObjectUnlock(client);\n    return fd;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientDupFD(virNetClientPtr client, bool cloexec)\n{\n    int fd;\n    virObjectLock(client);\n    fd = virNetSocketDupFD(client->sock, cloexec);\n    virObjectUnlock(client);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnect",
          "args": [
            "lock",
            "&program",
            "&counter"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "241-263",
          "snippet": "static virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Read/write, exclusive access, disks were present, but no leases specified\")"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Read/write, exclusive access, disks were present, but no leases specified\""
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY |\n                  VIR_LOCK_MANAGER_ACQUIRE_RESTRICT",
            "-1"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\n\nstatic int virLockManagerLockDaemonAcquire(virLockManagerPtr lock,\n                                           const char *state G_GNUC_UNUSED,\n                                           unsigned int flags,\n                                           virDomainLockFailureAction action G_GNUC_UNUSED,\n                                           int *fd)\n{\n    virNetClientPtr client = NULL;\n    virNetClientProgramPtr program = NULL;\n    int counter = 0;\n    int rv = -1;\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY |\n                  VIR_LOCK_MANAGER_ACQUIRE_RESTRICT, -1);\n\n    if (priv->nresources == 0 &&\n        priv->hasRWDisks &&\n        driver->requireLeaseForDisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Read/write, exclusive access, disks were present, but no leases specified\"));\n        return -1;\n    }\n\n    if (!(client = virLockManagerLockDaemonConnect(lock, &program, &counter)))\n        goto cleanup;\n\n    if (fd &&\n        (*fd = virNetClientDupFD(client, false)) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY)) {\n        size_t i;\n        for (i = 0; i < priv->nresources; i++) {\n            virLockSpaceProtocolAcquireResourceArgs args;\n\n            memset(&args, 0, sizeof(args));\n\n            args.path = priv->resources[i].lockspace;\n            args.name = priv->resources[i].name;\n            args.flags = priv->resources[i].flags;\n\n            if (virNetClientProgramCall(program,\n                                        client,\n                                        counter++,\n                                        VIR_LOCK_SPACE_PROTOCOL_PROC_ACQUIRE_RESOURCE,\n                                        0, NULL, NULL, NULL,\n                                        (xdrproc_t)xdr_virLockSpaceProtocolAcquireResourceArgs, &args,\n                                        (xdrproc_t)xdr_void, NULL) < 0)\n                goto cleanup;\n        }\n    }\n\n    if ((flags & VIR_LOCK_MANAGER_ACQUIRE_RESTRICT) &&\n        virLockManagerLockDaemonConnectionRestrict(lock, client, program, &counter) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv != 0 && fd)\n        VIR_FORCE_CLOSE(*fd);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(program);\n\n    return rv;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonAddResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "459-597",
    "snippet": "static int virLockManagerLockDaemonAddResource(virLockManagerPtr lock,\n                                               unsigned int type,\n                                               const char *name,\n                                               size_t nparams,\n                                               virLockManagerParamPtr params,\n                                               unsigned int flags)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    char *newName = NULL;\n    char *newLockspace = NULL;\n    bool autoCreate = false;\n    int ret = -1;\n\n    virCheckFlags(VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED, -1);\n\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_READONLY)\n        return 0;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_DISK:\n        if (params || nparams) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpected parameters for disk resource\"));\n            goto cleanup;\n        }\n        if (!driver->autoDiskLease) {\n            if (!(flags & (VIR_LOCK_MANAGER_RESOURCE_SHARED |\n                           VIR_LOCK_MANAGER_RESOURCE_READONLY)))\n                priv->hasRWDisks = true;\n            return 0;\n        }\n\n        /* XXX we should somehow pass in TYPE=BLOCK info\n         * from the domain_lock code, instead of assuming /dev\n         */\n        if (STRPREFIX(name, \"/dev\") &&\n            driver->lvmLockSpaceDir) {\n            VIR_DEBUG(\"Trying to find an LVM UUID for %s\", name);\n            if (virStorageFileGetLVMKey(name, &newName) < 0)\n                goto cleanup;\n\n            if (newName) {\n                VIR_DEBUG(\"Got an LVM UUID %s for %s\", newName, name);\n                newLockspace = g_strdup(driver->lvmLockSpaceDir);\n                autoCreate = true;\n                break;\n            }\n            virResetLastError();\n            /* Fallback to generic non-block code */\n        }\n\n        if (STRPREFIX(name, \"/dev\") &&\n            driver->scsiLockSpaceDir) {\n            VIR_DEBUG(\"Trying to find an SCSI ID for %s\", name);\n            if (virStorageFileGetSCSIKey(name, &newName, false) < 0)\n                goto cleanup;\n\n            if (newName) {\n                VIR_DEBUG(\"Got an SCSI ID %s for %s\", newName, name);\n                newLockspace = g_strdup(driver->scsiLockSpaceDir);\n                autoCreate = true;\n                break;\n            }\n            virResetLastError();\n            /* Fallback to generic non-block code */\n        }\n\n        if (driver->fileLockSpaceDir) {\n            newLockspace = g_strdup(driver->fileLockSpaceDir);\n            if (virCryptoHashString(VIR_CRYPTO_HASH_SHA256, name, &newName) < 0)\n                goto cleanup;\n            autoCreate = true;\n            VIR_DEBUG(\"Using indirect lease %s for %s\", newName, name);\n        } else {\n            newLockspace = g_strdup(\"\");\n            newName = g_strdup(name);\n            VIR_DEBUG(\"Using direct lease for %s\", name);\n        }\n\n        break;\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_LEASE: {\n        size_t i;\n        char *path = NULL;\n        char *lockspace = NULL;\n        for (i = 0; i < nparams; i++) {\n            if (STREQ(params[i].key, \"offset\")) {\n                if (params[i].value.ul != 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Offset must be zero for this lock manager\"));\n                    goto cleanup;\n                }\n            } else if (STREQ(params[i].key, \"lockspace\")) {\n                lockspace = params[i].value.str;\n            } else if (STREQ(params[i].key, \"path\")) {\n                path = params[i].value.str;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected parameter %s for lease resource\"),\n                               params[i].key);\n                goto cleanup;\n            }\n        }\n        if (!path || !lockspace) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing path or lockspace for lease resource\"));\n            goto cleanup;\n        }\n        newLockspace = g_strdup_printf(\"%s/%s\", path, lockspace);\n        newName = g_strdup(name);\n\n    }   break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d\"),\n                       type);\n        goto cleanup;\n    }\n\n    if (VIR_EXPAND_N(priv->resources, priv->nresources, 1) < 0)\n        goto cleanup;\n\n    priv->resources[priv->nresources-1].lockspace = g_steal_pointer(&newLockspace);\n    priv->resources[priv->nresources-1].name = g_steal_pointer(&newName);\n\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)\n        priv->resources[priv->nresources-1].flags |=\n            VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED;\n\n    if (autoCreate)\n        priv->resources[priv->nresources-1].flags |=\n            VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(newLockspace);\n    VIR_FREE(newName);\n    return ret;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerLockDaemonDriverPtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newName"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newLockspace"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newName"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newLockspace"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "priv->resources",
            "priv->nresources",
            "1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown lock manager object type %d\")",
            "type"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown lock manager object type %d\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing path or lockspace for lease resource\")"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected parameter %s for lease resource\")",
            "params[i].key"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"path\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"lockspace\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Offset must be zero for this lock manager\")"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"offset\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using direct lease for %s\"",
            "name"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using indirect lease %s for %s\"",
            "newName",
            "name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashString",
          "args": [
            "VIR_CRYPTO_HASH_SHA256",
            "name",
            "&newName"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "76-100",
          "snippet": "int\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256"
          ],
          "globals_used": [
            "static const char hex[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\n#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256\n\nstatic const char hex[] = \"0123456789abcdef\";\n\nint\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got an SCSI ID %s for %s\"",
            "newName",
            "name"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetSCSIKey",
          "args": [
            "name",
            "&newName",
            "false"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetSCSIKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1416-1423",
          "snippet": "int virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Trying to find an SCSI ID for %s\"",
            "name"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "name",
            "\"/dev\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got an LVM UUID %s for %s\"",
            "newName",
            "name"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileGetLVMKey",
          "args": [
            "name",
            "&newName"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetLVMKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1356-1361",
          "snippet": "int virStorageFileGetLVMKey(const char *path,\n                            char **key G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"Unable to get LVM key for %s\"), path);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetLVMKey(const char *path,\n                            char **key G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"Unable to get LVM key for %s\"), path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Trying to find an LVM UUID for %s\"",
            "name"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "name",
            "\"/dev\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpected parameters for disk resource\")"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED",
            "-1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\n\nstatic int virLockManagerLockDaemonAddResource(virLockManagerPtr lock,\n                                               unsigned int type,\n                                               const char *name,\n                                               size_t nparams,\n                                               virLockManagerParamPtr params,\n                                               unsigned int flags)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    char *newName = NULL;\n    char *newLockspace = NULL;\n    bool autoCreate = false;\n    int ret = -1;\n\n    virCheckFlags(VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED, -1);\n\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_READONLY)\n        return 0;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_DISK:\n        if (params || nparams) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpected parameters for disk resource\"));\n            goto cleanup;\n        }\n        if (!driver->autoDiskLease) {\n            if (!(flags & (VIR_LOCK_MANAGER_RESOURCE_SHARED |\n                           VIR_LOCK_MANAGER_RESOURCE_READONLY)))\n                priv->hasRWDisks = true;\n            return 0;\n        }\n\n        /* XXX we should somehow pass in TYPE=BLOCK info\n         * from the domain_lock code, instead of assuming /dev\n         */\n        if (STRPREFIX(name, \"/dev\") &&\n            driver->lvmLockSpaceDir) {\n            VIR_DEBUG(\"Trying to find an LVM UUID for %s\", name);\n            if (virStorageFileGetLVMKey(name, &newName) < 0)\n                goto cleanup;\n\n            if (newName) {\n                VIR_DEBUG(\"Got an LVM UUID %s for %s\", newName, name);\n                newLockspace = g_strdup(driver->lvmLockSpaceDir);\n                autoCreate = true;\n                break;\n            }\n            virResetLastError();\n            /* Fallback to generic non-block code */\n        }\n\n        if (STRPREFIX(name, \"/dev\") &&\n            driver->scsiLockSpaceDir) {\n            VIR_DEBUG(\"Trying to find an SCSI ID for %s\", name);\n            if (virStorageFileGetSCSIKey(name, &newName, false) < 0)\n                goto cleanup;\n\n            if (newName) {\n                VIR_DEBUG(\"Got an SCSI ID %s for %s\", newName, name);\n                newLockspace = g_strdup(driver->scsiLockSpaceDir);\n                autoCreate = true;\n                break;\n            }\n            virResetLastError();\n            /* Fallback to generic non-block code */\n        }\n\n        if (driver->fileLockSpaceDir) {\n            newLockspace = g_strdup(driver->fileLockSpaceDir);\n            if (virCryptoHashString(VIR_CRYPTO_HASH_SHA256, name, &newName) < 0)\n                goto cleanup;\n            autoCreate = true;\n            VIR_DEBUG(\"Using indirect lease %s for %s\", newName, name);\n        } else {\n            newLockspace = g_strdup(\"\");\n            newName = g_strdup(name);\n            VIR_DEBUG(\"Using direct lease for %s\", name);\n        }\n\n        break;\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_LEASE: {\n        size_t i;\n        char *path = NULL;\n        char *lockspace = NULL;\n        for (i = 0; i < nparams; i++) {\n            if (STREQ(params[i].key, \"offset\")) {\n                if (params[i].value.ul != 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Offset must be zero for this lock manager\"));\n                    goto cleanup;\n                }\n            } else if (STREQ(params[i].key, \"lockspace\")) {\n                lockspace = params[i].value.str;\n            } else if (STREQ(params[i].key, \"path\")) {\n                path = params[i].value.str;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected parameter %s for lease resource\"),\n                               params[i].key);\n                goto cleanup;\n            }\n        }\n        if (!path || !lockspace) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing path or lockspace for lease resource\"));\n            goto cleanup;\n        }\n        newLockspace = g_strdup_printf(\"%s/%s\", path, lockspace);\n        newName = g_strdup(name);\n\n    }   break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d\"),\n                       type);\n        goto cleanup;\n    }\n\n    if (VIR_EXPAND_N(priv->resources, priv->nresources, 1) < 0)\n        goto cleanup;\n\n    priv->resources[priv->nresources-1].lockspace = g_steal_pointer(&newLockspace);\n    priv->resources[priv->nresources-1].name = g_steal_pointer(&newName);\n\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)\n        priv->resources[priv->nresources-1].flags |=\n            VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED;\n\n    if (autoCreate)\n        priv->resources[priv->nresources-1].flags |=\n            VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(newLockspace);\n    VIR_FREE(newName);\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "390-456",
    "snippet": "static int virLockManagerLockDaemonNew(virLockManagerPtr lock,\n                                       unsigned int type,\n                                       size_t nparams,\n                                       virLockManagerParamPtr params,\n                                       unsigned int flags)\n{\n    virLockManagerLockDaemonPrivatePtr priv = NULL;\n    size_t i;\n    int ret = -1;\n\n    virCheckFlags(VIR_LOCK_MANAGER_NEW_STARTED, -1);\n\n    if (VIR_ALLOC(priv) < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_OBJECT_TYPE_DOMAIN:\n        for (i = 0; i < nparams; i++) {\n            if (STREQ(params[i].key, \"uuid\")) {\n                memcpy(priv->uuid, params[i].value.uuid, VIR_UUID_BUFLEN);\n            } else if (STREQ(params[i].key, \"name\")) {\n                priv->name = g_strdup(params[i].value.str);\n            } else if (STREQ(params[i].key, \"id\")) {\n                priv->id = params[i].value.iv;\n            } else if (STREQ(params[i].key, \"pid\")) {\n                priv->pid = params[i].value.iv;\n            } else if (STREQ(params[i].key, \"uri\")) {\n                /* ignored */\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected parameter %s for object\"),\n                               params[i].key);\n                goto cleanup;\n            }\n        }\n        if (priv->id == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing ID parameter for domain object\"));\n            goto cleanup;\n        }\n        if (priv->pid == 0)\n            VIR_DEBUG(\"Missing PID parameter for domain object\");\n        if (!priv->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing name parameter for domain object\"));\n            goto cleanup;\n        }\n        if (!virUUIDIsValid(priv->uuid)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing UUID parameter for domain object\"));\n            goto cleanup;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d\"),\n                       type);\n        goto cleanup;\n    }\n\n    lock->privateData = g_steal_pointer(&priv);\n    ret = 0;\n cleanup:\n    virLockManagerLockDaemonPrivateFree(priv);\n    return ret;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonPrivateFree",
          "args": [
            "priv"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonPrivateFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "362-378",
          "snippet": "static void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&priv"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown lock manager object type %d\")",
            "type"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown lock manager object type %d\""
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing UUID parameter for domain object\")"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDIsValid",
          "args": [
            "priv->uuid"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "173-190",
          "snippet": "int\nvirUUIDIsValid(unsigned char *uuid)\n{\n    size_t i;\n    unsigned int ctr = 1;\n    unsigned char c;\n\n    if (!uuid)\n        return 0;\n\n    c = uuid[0];\n\n    for (i = 1; i < VIR_UUID_BUFLEN; i++)\n        if (uuid[i] == c)\n            ctr++;\n\n    return ctr != VIR_UUID_BUFLEN;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDIsValid(unsigned char *uuid)\n{\n    size_t i;\n    unsigned int ctr = 1;\n    unsigned char c;\n\n    if (!uuid)\n        return 0;\n\n    c = uuid[0];\n\n    for (i = 1; i < VIR_UUID_BUFLEN; i++)\n        if (uuid[i] == c)\n            ctr++;\n\n    return ctr != VIR_UUID_BUFLEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing name parameter for domain object\")"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Missing PID parameter for domain object\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ID parameter for domain object\")"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected parameter %s for object\")",
            "params[i].key"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"uri\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"pid\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"id\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "params[i].value.str"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"name\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->uuid",
            "params[i].value.uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"uuid\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_NEW_STARTED",
            "-1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int virLockManagerLockDaemonNew(virLockManagerPtr lock,\n                                       unsigned int type,\n                                       size_t nparams,\n                                       virLockManagerParamPtr params,\n                                       unsigned int flags)\n{\n    virLockManagerLockDaemonPrivatePtr priv = NULL;\n    size_t i;\n    int ret = -1;\n\n    virCheckFlags(VIR_LOCK_MANAGER_NEW_STARTED, -1);\n\n    if (VIR_ALLOC(priv) < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_OBJECT_TYPE_DOMAIN:\n        for (i = 0; i < nparams; i++) {\n            if (STREQ(params[i].key, \"uuid\")) {\n                memcpy(priv->uuid, params[i].value.uuid, VIR_UUID_BUFLEN);\n            } else if (STREQ(params[i].key, \"name\")) {\n                priv->name = g_strdup(params[i].value.str);\n            } else if (STREQ(params[i].key, \"id\")) {\n                priv->id = params[i].value.iv;\n            } else if (STREQ(params[i].key, \"pid\")) {\n                priv->pid = params[i].value.iv;\n            } else if (STREQ(params[i].key, \"uri\")) {\n                /* ignored */\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected parameter %s for object\"),\n                               params[i].key);\n                goto cleanup;\n            }\n        }\n        if (priv->id == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing ID parameter for domain object\"));\n            goto cleanup;\n        }\n        if (priv->pid == 0)\n            VIR_DEBUG(\"Missing PID parameter for domain object\");\n        if (!priv->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing name parameter for domain object\"));\n            goto cleanup;\n        }\n        if (!virUUIDIsValid(priv->uuid)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing UUID parameter for domain object\"));\n            goto cleanup;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d\"),\n                       type);\n        goto cleanup;\n    }\n\n    lock->privateData = g_steal_pointer(&priv);\n    ret = 0;\n cleanup:\n    virLockManagerLockDaemonPrivateFree(priv);\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "380-387",
    "snippet": "static void virLockManagerLockDaemonFree(virLockManagerPtr lock)\n{\n    if (!lock)\n        return;\n\n    virLockManagerLockDaemonPrivateFree(lock->privateData);\n    lock->privateData = NULL;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonPrivateFree",
          "args": [
            "lock->privateData"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonPrivateFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "362-378",
          "snippet": "static void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic void virLockManagerLockDaemonFree(virLockManagerPtr lock)\n{\n    if (!lock)\n        return;\n\n    virLockManagerLockDaemonPrivateFree(lock->privateData);\n    lock->privateData = NULL;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonPrivateFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "362-378",
    "snippet": "static void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->name"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->resources"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->resources[i].name"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->resources[i].lockspace"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic void\nvirLockManagerLockDaemonPrivateFree(virLockManagerLockDaemonPrivatePtr priv)\n{\n    size_t i;\n\n    if (!priv)\n        return;\n\n    for (i = 0; i < priv->nresources; i++) {\n        VIR_FREE(priv->resources[i].lockspace);\n        VIR_FREE(priv->resources[i].name);\n    }\n    VIR_FREE(priv->resources);\n\n    VIR_FREE(priv->name);\n    VIR_FREE(priv);\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "349-360",
    "snippet": "static int virLockManagerLockDaemonDeinit(void)\n{\n    if (!driver)\n        return 0;\n\n    VIR_FREE(driver->scsiLockSpaceDir);\n    VIR_FREE(driver->lvmLockSpaceDir);\n    VIR_FREE(driver->fileLockSpaceDir);\n    VIR_FREE(driver);\n\n    return 0;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerLockDaemonDriverPtr driver;",
      "static int virLockManagerLockDaemonDeinit(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->fileLockSpaceDir"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->lvmLockSpaceDir"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->scsiLockSpaceDir"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\nstatic int virLockManagerLockDaemonDeinit(void);\n\nstatic int virLockManagerLockDaemonDeinit(void)\n{\n    if (!driver)\n        return 0;\n\n    VIR_FREE(driver->scsiLockSpaceDir);\n    VIR_FREE(driver->lvmLockSpaceDir);\n    VIR_FREE(driver->fileLockSpaceDir);\n    VIR_FREE(driver);\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "308-347",
    "snippet": "static int virLockManagerLockDaemonInit(unsigned int version,\n                                        const char *configFile,\n                                        unsigned int flags)\n{\n    VIR_DEBUG(\"version=%u configFile=%s flags=0x%x\", version, NULLSTR(configFile), flags);\n\n    virCheckFlags(0, -1);\n\n    if (driver)\n        return 0;\n\n    if (VIR_ALLOC(driver) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = true;\n    driver->autoDiskLease = true;\n\n    if (virLockManagerLockDaemonLoadConfig(configFile) < 0)\n        goto error;\n\n    if (driver->autoDiskLease) {\n        if (driver->fileLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->fileLockSpaceDir) < 0)\n            goto error;\n\n        if (driver->lvmLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->lvmLockSpaceDir) < 0)\n            goto error;\n\n        if (driver->scsiLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->scsiLockSpaceDir) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virLockManagerLockDaemonDeinit();\n    return -1;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerLockDaemonDriverPtr driver;",
      "static int virLockManagerLockDaemonDeinit(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonDeinit",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "349-360",
          "snippet": "static int virLockManagerLockDaemonDeinit(void)\n{\n    if (!driver)\n        return 0;\n\n    VIR_FREE(driver->scsiLockSpaceDir);\n    VIR_FREE(driver->lvmLockSpaceDir);\n    VIR_FREE(driver->fileLockSpaceDir);\n    VIR_FREE(driver);\n\n    return 0;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLockManagerLockDaemonDriverPtr driver;",
            "static int virLockManagerLockDaemonDeinit(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\nstatic int virLockManagerLockDaemonDeinit(void);\n\nstatic int virLockManagerLockDaemonDeinit(void)\n{\n    if (!driver)\n        return 0;\n\n    VIR_FREE(driver->scsiLockSpaceDir);\n    VIR_FREE(driver->lvmLockSpaceDir);\n    VIR_FREE(driver->fileLockSpaceDir);\n    VIR_FREE(driver);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonSetupLockspace",
          "args": [
            "driver->scsiLockSpaceDir"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonSetupLockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "266-303",
          "snippet": "static int virLockManagerLockDaemonSetupLockspace(const char *path)\n{\n    virNetClientPtr client;\n    virNetClientProgramPtr program = NULL;\n    virLockSpaceProtocolCreateLockSpaceArgs args;\n    int rv = -1;\n    int counter = 0;\n\n    memset(&args, 0, sizeof(args));\n    args.path = (char*)path;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, &program)))\n        return -1;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                counter++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_CREATE_LOCKSPACE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolCreateLockSpaceArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OPERATION_INVALID) {\n            /* The lockspace already exists */\n            virResetLastError();\n            rv = 0;\n        } else {\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    virObjectUnref(program);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return rv;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int virLockManagerLockDaemonSetupLockspace(const char *path)\n{\n    virNetClientPtr client;\n    virNetClientProgramPtr program = NULL;\n    virLockSpaceProtocolCreateLockSpaceArgs args;\n    int rv = -1;\n    int counter = 0;\n\n    memset(&args, 0, sizeof(args));\n    args.path = (char*)path;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, &program)))\n        return -1;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                counter++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_CREATE_LOCKSPACE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolCreateLockSpaceArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OPERATION_INVALID) {\n            /* The lockspace already exists */\n            virResetLastError();\n            rv = 0;\n        } else {\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    virObjectUnref(program);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonLoadConfig",
          "args": [
            "configFile"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonLoadConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "83-117",
          "snippet": "static int virLockManagerLockDaemonLoadConfig(const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"file_lockspace_dir\", &driver->fileLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lvm_lockspace_dir\", &driver->lvmLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"scsi_lockspace_dir\", &driver->scsiLockSpaceDir) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLockManagerLockDaemonDriverPtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\n\nstatic int virLockManagerLockDaemonLoadConfig(const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"file_lockspace_dir\", &driver->fileLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lvm_lockspace_dir\", &driver->lvmLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"scsi_lockspace_dir\", &driver->scsiLockSpaceDir) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "driver"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"version=%u configFile=%s flags=0x%x\"",
            "version",
            "NULLSTR(configFile)",
            "flags"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "configFile"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\nstatic int virLockManagerLockDaemonDeinit(void);\n\nstatic int virLockManagerLockDaemonInit(unsigned int version,\n                                        const char *configFile,\n                                        unsigned int flags)\n{\n    VIR_DEBUG(\"version=%u configFile=%s flags=0x%x\", version, NULLSTR(configFile), flags);\n\n    virCheckFlags(0, -1);\n\n    if (driver)\n        return 0;\n\n    if (VIR_ALLOC(driver) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = true;\n    driver->autoDiskLease = true;\n\n    if (virLockManagerLockDaemonLoadConfig(configFile) < 0)\n        goto error;\n\n    if (driver->autoDiskLease) {\n        if (driver->fileLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->fileLockSpaceDir) < 0)\n            goto error;\n\n        if (driver->lvmLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->lvmLockSpaceDir) < 0)\n            goto error;\n\n        if (driver->scsiLockSpaceDir &&\n            virLockManagerLockDaemonSetupLockspace(driver->scsiLockSpaceDir) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virLockManagerLockDaemonDeinit();\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonSetupLockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "266-303",
    "snippet": "static int virLockManagerLockDaemonSetupLockspace(const char *path)\n{\n    virNetClientPtr client;\n    virNetClientProgramPtr program = NULL;\n    virLockSpaceProtocolCreateLockSpaceArgs args;\n    int rv = -1;\n    int counter = 0;\n\n    memset(&args, 0, sizeof(args));\n    args.path = (char*)path;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, &program)))\n        return -1;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                counter++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_CREATE_LOCKSPACE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolCreateLockSpaceArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OPERATION_INVALID) {\n            /* The lockspace already exists */\n            virResetLastError();\n            rv = 0;\n        } else {\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    virObjectUnref(program);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return rv;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "program",
            "client",
            "counter++",
            "VIR_LOCK_SPACE_PROTOCOL_PROC_CREATE_LOCKSPACE",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLockSpaceProtocolCreateLockSpaceArgs",
            "(char*)&args",
            "(xdrproc_t)xdr_void",
            "NULL"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnectionNew",
          "args": [
            "geteuid() == 0",
            "&program"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnectionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "191-238",
          "snippet": "static virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int virLockManagerLockDaemonSetupLockspace(const char *path)\n{\n    virNetClientPtr client;\n    virNetClientProgramPtr program = NULL;\n    virLockSpaceProtocolCreateLockSpaceArgs args;\n    int rv = -1;\n    int counter = 0;\n\n    memset(&args, 0, sizeof(args));\n    args.path = (char*)path;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, &program)))\n        return -1;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                counter++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_CREATE_LOCKSPACE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolCreateLockSpaceArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OPERATION_INVALID) {\n            /* The lockspace already exists */\n            virResetLastError();\n            rv = 0;\n        } else {\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    virObjectUnref(program);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return rv;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "241-263",
    "snippet": "static virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnectionRegister",
          "args": [
            "lock",
            "client",
            "*program",
            "counter"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnectionRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "136-163",
          "snippet": "static int\nvirLockManagerLockDaemonConnectionRegister(virLockManagerPtr lock,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    virLockSpaceProtocolRegisterArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n    memcpy(args.owner.uuid, priv->uuid, VIR_UUID_BUFLEN);\n    args.owner.name = priv->name;\n    args.owner.id = priv->id;\n    args.owner.pid = priv->pid;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_REGISTER,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRegisterArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int\nvirLockManagerLockDaemonConnectionRegister(virLockManagerPtr lock,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    virLockSpaceProtocolRegisterArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n    memcpy(args.owner.uuid, priv->uuid, VIR_UUID_BUFLEN);\n    args.owner.name = priv->name;\n    args.owner.id = priv->id;\n    args.owner.pid = priv->pid;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_REGISTER,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRegisterArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonConnectionNew",
          "args": [
            "geteuid() == 0",
            "program"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonConnectionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "191-238",
          "snippet": "static virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr\nvirLockManagerLockDaemonConnect(virLockManagerPtr lock,\n                                virNetClientProgramPtr *program,\n                                int *counter)\n{\n    virNetClientPtr client;\n\n    if (!(client = virLockManagerLockDaemonConnectionNew(geteuid() == 0, program)))\n        return NULL;\n\n    if (virLockManagerLockDaemonConnectionRegister(lock,\n                                                   client,\n                                                   *program,\n                                                   counter) < 0)\n        goto error;\n\n    return client;\n\n error:\n    virNetClientClose(client);\n    virObjectUnref(client);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonConnectionNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "191-238",
    "snippet": "static virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "*prog"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockdpath"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "daemonPath"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockdpath"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "daemonPath"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientAddProgram",
          "args": [
            "client",
            "*prog"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientAddProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1005-1021",
          "snippet": "int virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramNew",
          "args": [
            "VIR_LOCK_SPACE_PROTOCOL_PROGRAM",
            "VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "64-85",
          "snippet": "virNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientProgramClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientProgramClass;\n\nvirNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientNewUNIX",
          "args": [
            "lockdpath",
            "daemonPath != NULL",
            "daemonPath"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNewUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "367-377",
          "snippet": "virNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResourceFull",
          "args": [
            "\"virtlockd\"",
            "NULL",
            "NULL",
            "abs_top_builddir \"/src\"",
            "SBINDIR",
            "\"VIRTLOCKD_PATH\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResourceFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1741-1769",
          "snippet": "char *\nvirFileFindResourceFull(const char *filename,\n                        const char *prefix,\n                        const char *suffix,\n                        const char *builddir,\n                        const char *installdir,\n                        const char *envname)\n{\n    char *ret = NULL;\n    const char *envval = envname ? getenv(envname) : NULL;\n    const char *path;\n\n    if (!prefix)\n        prefix = \"\";\n    if (!suffix)\n        suffix = \"\";\n\n    if (envval)\n        path = envval;\n    else if (useDirOverride)\n        path = builddir;\n    else\n        path = installdir;\n\n    ret = g_strdup_printf(\"%s/%s%s%s\", path, prefix, filename, suffix);\n\n    VIR_DEBUG(\"Resolved '%s' to '%s'\", filename, ret);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nchar *\nvirFileFindResourceFull(const char *filename,\n                        const char *prefix,\n                        const char *suffix,\n                        const char *builddir,\n                        const char *installdir,\n                        const char *envname)\n{\n    char *ret = NULL;\n    const char *envval = envname ? getenv(envname) : NULL;\n    const char *path;\n\n    if (!prefix)\n        prefix = \"\";\n    if (!suffix)\n        suffix = \"\";\n\n    if (envval)\n        path = envval;\n    else if (useDirOverride)\n        path = builddir;\n    else\n        path = installdir;\n\n    ret = g_strdup_printf(\"%s/%s%s%s\", path, prefix, filename, suffix);\n\n    VIR_DEBUG(\"Resolved '%s' to '%s'\", filename, ret);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerLockDaemonPath",
          "args": [
            "privileged"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerLockDaemonPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
          "lines": "120-133",
          "snippet": "static char *virLockManagerLockDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n    }\n    return path;\n}",
          "includes": [
            "#include \"lock_driver_lockd.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"lock_protocol.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic char *virLockManagerLockDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n    }\n    return path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virNetClientPtr virLockManagerLockDaemonConnectionNew(bool privileged,\n                                                             virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *lockdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(lockdpath = virLockManagerLockDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlockd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOCKD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(lockdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                         VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(lockdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonConnectionRestrict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "166-188",
    "snippet": "static int\nvirLockManagerLockDaemonConnectionRestrict(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockSpaceProtocolRestrictArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_RESTRICT,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRestrictArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "program",
            "client",
            "(*counter)++",
            "VIR_LOCK_SPACE_PROTOCOL_PROC_RESTRICT",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLockSpaceProtocolRestrictArgs",
            "(char*)&args",
            "(xdrproc_t)xdr_void",
            "NULL"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int\nvirLockManagerLockDaemonConnectionRestrict(virLockManagerPtr lock G_GNUC_UNUSED,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockSpaceProtocolRestrictArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_RESTRICT,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRestrictArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonConnectionRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "136-163",
    "snippet": "static int\nvirLockManagerLockDaemonConnectionRegister(virLockManagerPtr lock,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    virLockSpaceProtocolRegisterArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n    memcpy(args.owner.uuid, priv->uuid, VIR_UUID_BUFLEN);\n    args.owner.name = priv->name;\n    args.owner.id = priv->id;\n    args.owner.pid = priv->pid;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_REGISTER,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRegisterArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "program",
            "client",
            "(*counter)++",
            "VIR_LOCK_SPACE_PROTOCOL_PROC_REGISTER",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLockSpaceProtocolRegisterArgs",
            "(char*)&args",
            "(xdrproc_t)xdr_void",
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args.owner.uuid",
            "priv->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic int\nvirLockManagerLockDaemonConnectionRegister(virLockManagerPtr lock,\n                                           virNetClientPtr client,\n                                           virNetClientProgramPtr program,\n                                           int *counter)\n{\n    virLockManagerLockDaemonPrivatePtr priv = lock->privateData;\n    virLockSpaceProtocolRegisterArgs args;\n\n    memset(&args, 0, sizeof(args));\n\n    args.flags = 0;\n    memcpy(args.owner.uuid, priv->uuid, VIR_UUID_BUFLEN);\n    args.owner.name = priv->name;\n    args.owner.id = priv->id;\n    args.owner.pid = priv->pid;\n\n    if (virNetClientProgramCall(program,\n                                client,\n                                (*counter)++,\n                                VIR_LOCK_SPACE_PROTOCOL_PROC_REGISTER,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLockSpaceProtocolRegisterArgs, (char*)&args,\n                                (xdrproc_t)xdr_void, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "120-133",
    "snippet": "static char *virLockManagerLockDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n    }\n    return path;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/virtlockd-sock\"",
            "rundir"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic char *virLockManagerLockDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n    }\n    return path;\n}"
  },
  {
    "function_name": "virLockManagerLockDaemonLoadConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_lockd.c",
    "lines": "83-117",
    "snippet": "static int virLockManagerLockDaemonLoadConfig(const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"file_lockspace_dir\", &driver->fileLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lvm_lockspace_dir\", &driver->lvmLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"scsi_lockspace_dir\", &driver->scsiLockSpaceDir) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"lock_driver_lockd.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"lock_driver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerLockDaemonDriverPtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfGetValueBool",
          "args": [
            "conf",
            "\"require_lease_for_disks\"",
            "&driver->requireLeaseForDisks"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1002-1031",
          "snippet": "int virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "\"scsi_lockspace_dir\"",
            "&driver->scsiLockSpaceDir"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfReadFile",
          "args": [
            "configFile",
            "0"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "730-752",
          "snippet": "virConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONFIG_FILE_SIZE (1024*1024*10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CONFIG_FILE_SIZE (1024*1024*10)\n\nvirConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to access config file %s\")",
            "configFile"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to access config file %s\""
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "configFile",
            "R_OK"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lock_driver_lockd.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"lock_protocol.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_driver.h\"\n#include <config.h>\n\nstatic virLockManagerLockDaemonDriverPtr driver;\n\nstatic int virLockManagerLockDaemonLoadConfig(const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"file_lockspace_dir\", &driver->fileLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lvm_lockspace_dir\", &driver->lvmLockSpaceDir) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"scsi_lockspace_dir\", &driver->scsiLockSpaceDir) < 0)\n        return -1;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        return -1;\n\n    return 0;\n}"
  }
]