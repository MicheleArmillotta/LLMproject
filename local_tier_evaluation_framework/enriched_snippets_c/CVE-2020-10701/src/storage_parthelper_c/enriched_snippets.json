[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/parthelper.c",
    "lines": "58-178",
    "snippet": "int main(int argc, char **argv)\n{\n    PedDevice *dev;\n    PedDisk *disk;\n    PedPartition *part;\n    int cmd = DISK_LAYOUT;\n    const char *path;\n    char *canonical_path;\n    const char *partsep;\n    bool devmap_partsep = false;\n\n    if (virGettextInitialize() < 0)\n        exit(EXIT_FAILURE);\n\n    if (argc == 3 && STREQ(argv[2], \"-g\")) {\n        cmd = DISK_GEOMETRY;\n    } else if (argc == 3 && STREQ(argv[2], \"-p\")) {\n        devmap_partsep = true;\n    } else if (argc != 2) {\n        fprintf(stderr, _(\"syntax: %s DEVICE [-g]|[-p]\\n\"), argv[0]);\n        return 1;\n    }\n\n    /* NB: Changes to the following algorithm will need corresponding\n     * changes to virStorageBackendDiskDeleteVol */\n    path = argv[1];\n    if (virIsDevMapperDevice(path)) {\n        /* If the path ends with a number or we explicitly request it for\n         * path, then append the \"p\" partition separator. Otherwise, if\n         * the path ends with a letter already, then no need for a separator.\n         */\n        if (g_ascii_isdigit(path[strlen(path)-1]) || devmap_partsep)\n            partsep = \"p\";\n        else\n            partsep = \"\";\n        canonical_path = g_strdup(path);\n    } else {\n        if (virFileResolveLink(path, &canonical_path) != 0)\n            return 2;\n\n        partsep = *canonical_path &&\n            g_ascii_isdigit(canonical_path[strlen(canonical_path)-1]) ? \"p\" : \"\";\n    }\n\n    if ((dev = ped_device_get(path)) == NULL) {\n        fprintf(stderr, _(\"unable to access device %s\\n\"), path);\n        return 2;\n    }\n\n    /* return the geometry of the disk and then exit */\n    if (cmd == DISK_GEOMETRY) {\n        printf(\"%d%c%d%c%d%c\",\n               dev->hw_geom.cylinders, '\\0',\n               dev->hw_geom.heads, '\\0',\n               dev->hw_geom.sectors, '\\0');\n        return 0;\n    }\n\n    if ((disk = ped_disk_new(dev)) == NULL) {\n        fprintf(stderr, _(\"unable to access disk %s\\n\"), argv[1]);\n        return 2;\n    }\n\n    /* Get the first partition, and then iterate over all */\n    part = ped_disk_next_partition(disk, NULL);\n    while (part) {\n        const char *type;\n        const char *content;\n        if (part->type & PED_PARTITION_LOGICAL) {\n            type = \"logical\";\n            if (part->type & PED_PARTITION_FREESPACE)\n                content = \"free\";\n            else if (part->type & PED_PARTITION_METADATA)\n                content = \"metadata\";\n            /* coverity[dead_error_condition] - not true if defined */\n            else if (part->type & PED_PARTITION_PROTECTED)\n                content = \"protected\";\n            else\n                content = \"data\";\n        } else if (part->type == PED_PARTITION_EXTENDED) {\n            type = \"extended\";\n            content = \"metadata\";\n        } else {\n            type = \"normal\";\n            if (part->type & PED_PARTITION_FREESPACE)\n                content = \"free\";\n            else if (part->type & PED_PARTITION_METADATA)\n                content = \"metadata\";\n            /* coverity[dead_error_condition] - not true if defined */\n            else if (part->type & PED_PARTITION_PROTECTED)\n                content = \"protected\";\n            else\n                content = \"data\";\n        }\n\n        /* We do +1 on geom.end, because we want end of the last sector\n         * in bytes, not the last sector number\n         */\n        if (part->num != -1) {\n            printf(\"%s%s%d%c%s%c%s%c%llu%c%llu%c%llu%c\",\n                   canonical_path, partsep,\n                   part->num, '\\0',\n                   type, '\\0',\n                   content, '\\0',\n                   part->geom.start * dev->sector_size, '\\0',\n                   (part->geom.end + 1) * dev->sector_size, '\\0',\n                   part->geom.length * dev->sector_size, '\\0');\n        } else {\n            printf(\"%s%c%s%c%s%c%llu%c%llu%c%llu%c\",\n                   \"-\", '\\0',\n                   type, '\\0',\n                   content, '\\0',\n                   part->geom.start * dev->sector_size, '\\0',\n                   (part->geom.end + 1) * dev->sector_size, '\\0',\n                   part->geom.length * dev->sector_size, '\\0');\n        }\n        part = ped_disk_next_partition(disk, part);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <libdevmapper.h>",
      "#include <parted/parted.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ped_disk_next_partition",
          "args": [
            "disk",
            "part"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s%c%s%c%s%c%llu%c%llu%c%llu%c\"",
            "\"-\"",
            "'\\0'",
            "type",
            "'\\0'",
            "content",
            "'\\0'",
            "part->geom.start * dev->sector_size",
            "'\\0'",
            "(part->geom.end + 1) * dev->sector_size",
            "'\\0'",
            "part->geom.length * dev->sector_size",
            "'\\0'"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ped_disk_next_partition",
          "args": [
            "disk",
            "NULL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"unable to access disk %s\\n\")",
            "argv[1]"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ped_disk_new",
          "args": [
            "dev"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"unable to access device %s\\n\")",
            "path"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ped_device_get",
          "args": [
            "path"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isdigit",
          "args": [
            "canonical_path[strlen(canonical_path)-1]"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "canonical_path"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "path",
            "&canonical_path"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ascii_isdigit",
          "args": [
            "path[strlen(path)-1]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virIsDevMapperDevice",
          "args": [
            "path"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "virIsDevMapperDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1357-1360",
          "snippet": "bool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"syntax: %s DEVICE [-g]|[-p]\\n\")",
            "argv[0]"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "argv[2]",
            "\"-p\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "argv[2]",
            "\"-g\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <libdevmapper.h>\n#include <parted/parted.h>\n#include <config.h>\n\nint main(int argc, char **argv)\n{\n    PedDevice *dev;\n    PedDisk *disk;\n    PedPartition *part;\n    int cmd = DISK_LAYOUT;\n    const char *path;\n    char *canonical_path;\n    const char *partsep;\n    bool devmap_partsep = false;\n\n    if (virGettextInitialize() < 0)\n        exit(EXIT_FAILURE);\n\n    if (argc == 3 && STREQ(argv[2], \"-g\")) {\n        cmd = DISK_GEOMETRY;\n    } else if (argc == 3 && STREQ(argv[2], \"-p\")) {\n        devmap_partsep = true;\n    } else if (argc != 2) {\n        fprintf(stderr, _(\"syntax: %s DEVICE [-g]|[-p]\\n\"), argv[0]);\n        return 1;\n    }\n\n    /* NB: Changes to the following algorithm will need corresponding\n     * changes to virStorageBackendDiskDeleteVol */\n    path = argv[1];\n    if (virIsDevMapperDevice(path)) {\n        /* If the path ends with a number or we explicitly request it for\n         * path, then append the \"p\" partition separator. Otherwise, if\n         * the path ends with a letter already, then no need for a separator.\n         */\n        if (g_ascii_isdigit(path[strlen(path)-1]) || devmap_partsep)\n            partsep = \"p\";\n        else\n            partsep = \"\";\n        canonical_path = g_strdup(path);\n    } else {\n        if (virFileResolveLink(path, &canonical_path) != 0)\n            return 2;\n\n        partsep = *canonical_path &&\n            g_ascii_isdigit(canonical_path[strlen(canonical_path)-1]) ? \"p\" : \"\";\n    }\n\n    if ((dev = ped_device_get(path)) == NULL) {\n        fprintf(stderr, _(\"unable to access device %s\\n\"), path);\n        return 2;\n    }\n\n    /* return the geometry of the disk and then exit */\n    if (cmd == DISK_GEOMETRY) {\n        printf(\"%d%c%d%c%d%c\",\n               dev->hw_geom.cylinders, '\\0',\n               dev->hw_geom.heads, '\\0',\n               dev->hw_geom.sectors, '\\0');\n        return 0;\n    }\n\n    if ((disk = ped_disk_new(dev)) == NULL) {\n        fprintf(stderr, _(\"unable to access disk %s\\n\"), argv[1]);\n        return 2;\n    }\n\n    /* Get the first partition, and then iterate over all */\n    part = ped_disk_next_partition(disk, NULL);\n    while (part) {\n        const char *type;\n        const char *content;\n        if (part->type & PED_PARTITION_LOGICAL) {\n            type = \"logical\";\n            if (part->type & PED_PARTITION_FREESPACE)\n                content = \"free\";\n            else if (part->type & PED_PARTITION_METADATA)\n                content = \"metadata\";\n            /* coverity[dead_error_condition] - not true if defined */\n            else if (part->type & PED_PARTITION_PROTECTED)\n                content = \"protected\";\n            else\n                content = \"data\";\n        } else if (part->type == PED_PARTITION_EXTENDED) {\n            type = \"extended\";\n            content = \"metadata\";\n        } else {\n            type = \"normal\";\n            if (part->type & PED_PARTITION_FREESPACE)\n                content = \"free\";\n            else if (part->type & PED_PARTITION_METADATA)\n                content = \"metadata\";\n            /* coverity[dead_error_condition] - not true if defined */\n            else if (part->type & PED_PARTITION_PROTECTED)\n                content = \"protected\";\n            else\n                content = \"data\";\n        }\n\n        /* We do +1 on geom.end, because we want end of the last sector\n         * in bytes, not the last sector number\n         */\n        if (part->num != -1) {\n            printf(\"%s%s%d%c%s%c%s%c%llu%c%llu%c%llu%c\",\n                   canonical_path, partsep,\n                   part->num, '\\0',\n                   type, '\\0',\n                   content, '\\0',\n                   part->geom.start * dev->sector_size, '\\0',\n                   (part->geom.end + 1) * dev->sector_size, '\\0',\n                   part->geom.length * dev->sector_size, '\\0');\n        } else {\n            printf(\"%s%c%s%c%s%c%llu%c%llu%c%llu%c\",\n                   \"-\", '\\0',\n                   type, '\\0',\n                   content, '\\0',\n                   part->geom.start * dev->sector_size, '\\0',\n                   (part->geom.end + 1) * dev->sector_size, '\\0',\n                   part->geom.length * dev->sector_size, '\\0');\n        }\n        part = ped_disk_next_partition(disk, part);\n    }\n\n    return 0;\n}"
  }
]