[
  {
    "function_name": "virSecretDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "277-306",
    "snippet": "char *\nvirSecretDefFormat(const virSecretDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"<secret ephemeral='%s' private='%s'>\\n\",\n                      def->isephemeral ? \"yes\" : \"no\",\n                      def->isprivate ? \"yes\" : \"no\");\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    if (def->description != NULL)\n        virBufferEscapeString(&buf, \"<description>%s</description>\\n\",\n                              def->description);\n    if (def->usage_type != VIR_SECRET_USAGE_TYPE_NONE &&\n        virSecretDefFormatUsage(&buf, def) < 0)\n        goto error;\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</secret>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</secret>\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecretDefFormatUsage",
          "args": [
            "&buf",
            "def"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretDefFormatUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
          "lines": "226-275",
          "snippet": "static int\nvirSecretDefFormatUsage(virBufferPtr buf,\n                        const virSecretDef *def)\n{\n    const char *type;\n\n    type = virSecretUsageTypeToString(def->usage_type);\n    if (type == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAsprintf(buf, \"<usage type='%s'>\\n\", type);\n    virBufferAdjustIndent(buf, 2);\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        virBufferEscapeString(buf, \"<volume>%s</volume>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        virBufferEscapeString(buf, \"<target>%s</target>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</usage>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virerror.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirSecretDefFormatUsage(virBufferPtr buf,\n                        const virSecretDef *def)\n{\n    const char *type;\n\n    type = virSecretUsageTypeToString(def->usage_type);\n    if (type == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAsprintf(buf, \"<usage type='%s'>\\n\", type);\n    virBufferAdjustIndent(buf, 2);\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        virBufferEscapeString(buf, \"<volume>%s</volume>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        virBufferEscapeString(buf, \"<target>%s</target>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</usage>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"<description>%s</description>\\n\"",
            "def->description"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<secret ephemeral='%s' private='%s'>\\n\"",
            "def->isephemeral ? \"yes\" : \"no\"",
            "def->isprivate ? \"yes\" : \"no\""
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirSecretDefFormat(const virSecretDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"<secret ephemeral='%s' private='%s'>\\n\",\n                      def->isephemeral ? \"yes\" : \"no\",\n                      def->isprivate ? \"yes\" : \"no\");\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    if (def->description != NULL)\n        virBufferEscapeString(&buf, \"<description>%s</description>\\n\",\n                              def->description);\n    if (def->usage_type != VIR_SECRET_USAGE_TYPE_NONE &&\n        virSecretDefFormatUsage(&buf, def) < 0)\n        goto error;\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</secret>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
  },
  {
    "function_name": "virSecretDefFormatUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "226-275",
    "snippet": "static int\nvirSecretDefFormatUsage(virBufferPtr buf,\n                        const virSecretDef *def)\n{\n    const char *type;\n\n    type = virSecretUsageTypeToString(def->usage_type);\n    if (type == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAsprintf(buf, \"<usage type='%s'>\\n\", type);\n    virBufferAdjustIndent(buf, 2);\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        virBufferEscapeString(buf, \"<volume>%s</volume>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        virBufferEscapeString(buf, \"<target>%s</target>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</usage>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</usage>\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected secret usage type %d\")",
            "def->usage_type"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected secret usage type %d\""
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<name>%s</name>\\n\"",
            "def->usage_id"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<usage type='%s'>\\n\"",
            "type"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected secret usage type %d\")",
            "def->usage_type"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretUsageTypeToString",
          "args": [
            "def->usage_type"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirSecretDefFormatUsage(virBufferPtr buf,\n                        const virSecretDef *def)\n{\n    const char *type;\n\n    type = virSecretUsageTypeToString(def->usage_type);\n    if (type == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAsprintf(buf, \"<usage type='%s'>\\n\", type);\n    virBufferAdjustIndent(buf, 2);\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        virBufferEscapeString(buf, \"<volume>%s</volume>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        virBufferEscapeString(buf, \"<target>%s</target>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->usage_id);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</usage>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecretDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "220-224",
    "snippet": "virSecretDefPtr\nvirSecretDefParseFile(const char *filename)\n{\n    return virSecretDefParse(NULL, filename);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecretDefParse",
          "args": [
            "NULL",
            "filename"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
          "lines": "199-212",
          "snippet": "static virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virerror.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirSecretDefPtr\nvirSecretDefParseFile(const char *filename)\n{\n    return virSecretDefParse(NULL, filename);\n}"
  },
  {
    "function_name": "virSecretDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "214-218",
    "snippet": "virSecretDefPtr\nvirSecretDefParseString(const char *xmlStr)\n{\n    return virSecretDefParse(xmlStr, NULL);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecretDefParse",
          "args": [
            "xmlStr",
            "NULL"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
          "lines": "199-212",
          "snippet": "static virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virerror.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirSecretDefPtr\nvirSecretDefParseString(const char *xmlStr)\n{\n    return virSecretDefParse(xmlStr, NULL);\n}"
  },
  {
    "function_name": "virSecretDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "199-212",
    "snippet": "static virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secretXMLParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "secretXMLParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
          "lines": "131-197",
          "snippet": "static virSecretDefPtr\nsecretXMLParseNode(xmlDocPtr xml, xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virSecretDef) def = NULL;\n    g_autofree char *prop = NULL;\n    g_autofree char *uuidstr = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"secret\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <secret>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    prop = virXPathString(\"string(./@ephemeral)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isephemeral) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'ephemeral'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    prop = virXPathString(\"string(./@private)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isprivate) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'private'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    uuidstr = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuidstr) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return NULL;\n        }\n    } else {\n        if (virUUIDParse(uuidstr, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            return NULL;\n        }\n        VIR_FREE(uuidstr);\n    }\n\n    def->description = virXPathString(\"string(./description)\", ctxt);\n    if (virXPathNode(\"./usage\", ctxt) != NULL\n        && virSecretDefParseUsage(ctxt, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virerror.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virSecretDefPtr\nsecretXMLParseNode(xmlDocPtr xml, xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virSecretDef) def = NULL;\n    g_autofree char *prop = NULL;\n    g_autofree char *uuidstr = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"secret\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <secret>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    prop = virXPathString(\"string(./@ephemeral)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isephemeral) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'ephemeral'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    prop = virXPathString(\"string(./@private)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isprivate) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'private'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    uuidstr = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuidstr) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return NULL;\n        }\n    } else {\n        if (virUUIDParse(uuidstr, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            return NULL;\n        }\n        VIR_FREE(uuidstr);\n    }\n\n    def->description = virXPathString(\"string(./description)\", ctxt);\n    if (virXPathNode(\"./usage\", ctxt) != NULL\n        && virSecretDefParseUsage(ctxt, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "xmlStr",
            "_(\"(definition_of_secret)\")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(definition_of_secret)\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virSecretDefPtr\nvirSecretDefParse(const char *xmlStr,\n                  const char *filename)\n{\n    xmlDocPtr xml;\n    virSecretDefPtr ret = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(definition_of_secret)\")))) {\n        ret = secretXMLParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "secretXMLParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "131-197",
    "snippet": "static virSecretDefPtr\nsecretXMLParseNode(xmlDocPtr xml, xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virSecretDef) def = NULL;\n    g_autofree char *prop = NULL;\n    g_autofree char *uuidstr = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"secret\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <secret>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    prop = virXPathString(\"string(./@ephemeral)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isephemeral) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'ephemeral'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    prop = virXPathString(\"string(./@private)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isprivate) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'private'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    uuidstr = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuidstr) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return NULL;\n        }\n    } else {\n        if (virUUIDParse(uuidstr, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            return NULL;\n        }\n        VIR_FREE(uuidstr);\n    }\n\n    def->description = virXPathString(\"string(./description)\", ctxt);\n    if (virXPathNode(\"./usage\", ctxt) != NULL\n        && virSecretDefParseUsage(ctxt, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretDefParseUsage",
          "args": [
            "ctxt",
            "def"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretDefParseUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
          "lines": "51-129",
          "snippet": "static int\nvirSecretDefParseUsage(xmlXPathContextPtr ctxt,\n                       virSecretDefPtr def)\n{\n    char *type_str;\n    int type;\n\n    type_str = virXPathString(\"string(./usage/@type)\", ctxt);\n    if (type_str == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"unknown secret usage type\"));\n        return -1;\n    }\n    type = virSecretUsageTypeFromString(type_str);\n    if (type < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown secret usage type %s\"), type_str);\n        VIR_FREE(type_str);\n        return -1;\n    }\n    VIR_FREE(type_str);\n    def->usage_type = type;\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        def->usage_id = virXPathString(\"string(./usage/volume)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"volume usage specified, but volume path is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Ceph usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        def->usage_id = virXPathString(\"string(./usage/target)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"iSCSI usage specified, but target is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"TLS usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"vTPM usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virerror.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirSecretDefParseUsage(xmlXPathContextPtr ctxt,\n                       virSecretDefPtr def)\n{\n    char *type_str;\n    int type;\n\n    type_str = virXPathString(\"string(./usage/@type)\", ctxt);\n    if (type_str == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"unknown secret usage type\"));\n        return -1;\n    }\n    type = virSecretUsageTypeFromString(type_str);\n    if (type < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown secret usage type %s\"), type_str);\n        VIR_FREE(type_str);\n        return -1;\n    }\n    VIR_FREE(type_str);\n    def->usage_type = type;\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        def->usage_id = virXPathString(\"string(./usage/volume)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"volume usage specified, but volume path is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Ceph usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        def->usage_id = virXPathString(\"string(./usage/target)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"iSCSI usage specified, but target is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"TLS usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"vTPM usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./usage\"",
            "ctxt"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./description)\"",
            "ctxt"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuidstr"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed uuid element\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed uuid element\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuidstr",
            "def->uuid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to generate UUID\")"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "def->uuid"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prop"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"invalid value of 'private'\")"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringParseYesNo",
          "args": [
            "prop",
            "&def->isprivate"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParseYesNo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1396-1406",
          "snippet": "int virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prop"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"invalid value of 'ephemeral'\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected root element <%s>, \"\n                         \"expecting <secret>\")",
            "root->name"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"secret\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virSecretDefPtr\nsecretXMLParseNode(xmlDocPtr xml, xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virSecretDef) def = NULL;\n    g_autofree char *prop = NULL;\n    g_autofree char *uuidstr = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"secret\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <secret>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    prop = virXPathString(\"string(./@ephemeral)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isephemeral) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'ephemeral'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    prop = virXPathString(\"string(./@private)\", ctxt);\n    if (prop != NULL) {\n        if (virStringParseYesNo(prop, &def->isprivate) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid value of 'private'\"));\n            return NULL;\n        }\n        VIR_FREE(prop);\n    }\n\n    uuidstr = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuidstr) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return NULL;\n        }\n    } else {\n        if (virUUIDParse(uuidstr, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            return NULL;\n        }\n        VIR_FREE(uuidstr);\n    }\n\n    def->description = virXPathString(\"string(./description)\", ctxt);\n    if (virXPathNode(\"./usage\", ctxt) != NULL\n        && virSecretDefParseUsage(ctxt, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virSecretDefParseUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "51-129",
    "snippet": "static int\nvirSecretDefParseUsage(xmlXPathContextPtr ctxt,\n                       virSecretDefPtr def)\n{\n    char *type_str;\n    int type;\n\n    type_str = virXPathString(\"string(./usage/@type)\", ctxt);\n    if (type_str == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"unknown secret usage type\"));\n        return -1;\n    }\n    type = virSecretUsageTypeFromString(type_str);\n    if (type < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown secret usage type %s\"), type_str);\n        VIR_FREE(type_str);\n        return -1;\n    }\n    VIR_FREE(type_str);\n    def->usage_type = type;\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        def->usage_id = virXPathString(\"string(./usage/volume)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"volume usage specified, but volume path is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Ceph usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        def->usage_id = virXPathString(\"string(./usage/target)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"iSCSI usage specified, but target is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"TLS usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"vTPM usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected secret usage type %d\")",
            "def->usage_type"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected secret usage type %d\""
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vTPM usage specified, but name is missing\")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./usage/name)\"",
            "ctxt"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"TLS usage specified, but name is missing\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"iSCSI usage specified, but target is missing\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Ceph usage specified, but name is missing\")"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"volume usage specified, but volume path is missing\")"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type_str"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type_str"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown secret usage type %s\")",
            "type_str"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretUsageTypeFromString",
          "args": [
            "type_str"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"unknown secret usage type\")"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirSecretDefParseUsage(xmlXPathContextPtr ctxt,\n                       virSecretDefPtr def)\n{\n    char *type_str;\n    int type;\n\n    type_str = virXPathString(\"string(./usage/@type)\", ctxt);\n    if (type_str == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"unknown secret usage type\"));\n        return -1;\n    }\n    type = virSecretUsageTypeFromString(type_str);\n    if (type < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown secret usage type %s\"), type_str);\n        VIR_FREE(type_str);\n        return -1;\n    }\n    VIR_FREE(type_str);\n    def->usage_type = type;\n    switch (def->usage_type) {\n    case VIR_SECRET_USAGE_TYPE_NONE:\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VOLUME:\n        def->usage_id = virXPathString(\"string(./usage/volume)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"volume usage specified, but volume path is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_CEPH:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Ceph usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_ISCSI:\n        def->usage_id = virXPathString(\"string(./usage/target)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"iSCSI usage specified, but target is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_TLS:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"TLS usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    case VIR_SECRET_USAGE_TYPE_VTPM:\n        def->usage_id = virXPathString(\"string(./usage/name)\", ctxt);\n        if (!def->usage_id) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"vTPM usage specified, but name is missing\"));\n            return -1;\n        }\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected secret usage type %d\"),\n                       def->usage_type);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecretDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/secret_conf.c",
    "lines": "40-49",
    "snippet": "void\nvirSecretDefFree(virSecretDefPtr def)\n{\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->description);\n    VIR_FREE(def->usage_id);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virerror.h\"",
      "#include \"virsecretobj.h\"",
      "#include \"secret_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->usage_id"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->description"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virerror.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirSecretDefFree(virSecretDefPtr def)\n{\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->description);\n    VIR_FREE(def->usage_id);\n    VIR_FREE(def);\n}"
  }
]