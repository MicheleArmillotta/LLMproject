[
  {
    "function_name": "virEventThreadGetContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "186-190",
    "snippet": "GMainContext *\nvirEventThreadGetContext(virEventThread *evt)\n{\n    return evt->context;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nGMainContext *\nvirEventThreadGetContext(virEventThread *evt)\n{\n    return evt->context;\n}"
  },
  {
    "function_name": "virEventThreadNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "174-183",
    "snippet": "virEventThread *\nvirEventThreadNew(const char *name)\n{\n    g_autoptr(virEventThread) evt = VIR_EVENT_THREAD(g_object_new(VIR_TYPE_EVENT_THREAD, NULL));\n\n    if (virEventThreadStart(evt, name) < 0)\n        return NULL;\n\n    return g_steal_pointer(&evt);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&evt"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventThreadStart",
          "args": [
            "evt",
            "name"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "virEventThreadStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
          "lines": "128-171",
          "snippet": "static int\nvirEventThreadStart(virEventThread *evt, const char *name)\n{\n    g_autoptr(GError) gerr = NULL;\n    g_autofree char *thname = NULL;\n    size_t maxname = virThreadMaxName();\n    virEventThreadData *data;\n\n    if (maxname)\n        thname = g_strndup(name, maxname);\n    else\n        thname = g_strdup(name);\n\n    if (evt->thread) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Event thread is already running\"));\n        return -1;\n    }\n\n    data = g_new0(virEventThreadData, 1);\n    data->loop = g_main_loop_ref(evt->loop);\n    data->context = g_main_context_ref(evt->context);\n    g_mutex_init(&data->lock);\n    g_cond_init(&data->cond);\n\n    evt->thread = g_thread_try_new(thname,\n                                   virEventThreadWorker,\n                                   data,\n                                   &gerr);\n    if (!evt->thread) {\n        virEventThreadDataFree(data);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to start event thread: %s\"),\n                       gerr->message);\n        return -1;\n    }\n\n    g_mutex_lock(&data->lock);\n    while (!data->running)\n        g_cond_wait(&data->cond, &data->lock);\n    g_mutex_unlock(&data->lock);\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"vireventthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic int\nvirEventThreadStart(virEventThread *evt, const char *name)\n{\n    g_autoptr(GError) gerr = NULL;\n    g_autofree char *thname = NULL;\n    size_t maxname = virThreadMaxName();\n    virEventThreadData *data;\n\n    if (maxname)\n        thname = g_strndup(name, maxname);\n    else\n        thname = g_strdup(name);\n\n    if (evt->thread) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Event thread is already running\"));\n        return -1;\n    }\n\n    data = g_new0(virEventThreadData, 1);\n    data->loop = g_main_loop_ref(evt->loop);\n    data->context = g_main_context_ref(evt->context);\n    g_mutex_init(&data->lock);\n    g_cond_init(&data->cond);\n\n    evt->thread = g_thread_try_new(thname,\n                                   virEventThreadWorker,\n                                   data,\n                                   &gerr);\n    if (!evt->thread) {\n        virEventThreadDataFree(data);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to start event thread: %s\"),\n                       gerr->message);\n        return -1;\n    }\n\n    g_mutex_lock(&data->lock);\n    while (!data->running)\n        g_cond_wait(&data->cond, &data->lock);\n    g_mutex_unlock(&data->lock);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EVENT_THREAD",
          "args": [
            "g_object_new(VIR_TYPE_EVENT_THREAD, NULL)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_object_new",
          "args": [
            "VIR_TYPE_EVENT_THREAD",
            "NULL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nvirEventThread *\nvirEventThreadNew(const char *name)\n{\n    g_autoptr(virEventThread) evt = VIR_EVENT_THREAD(g_object_new(VIR_TYPE_EVENT_THREAD, NULL));\n\n    if (virEventThreadStart(evt, name) < 0)\n        return NULL;\n\n    return g_steal_pointer(&evt);\n}"
  },
  {
    "function_name": "virEventThreadStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "128-171",
    "snippet": "static int\nvirEventThreadStart(virEventThread *evt, const char *name)\n{\n    g_autoptr(GError) gerr = NULL;\n    g_autofree char *thname = NULL;\n    size_t maxname = virThreadMaxName();\n    virEventThreadData *data;\n\n    if (maxname)\n        thname = g_strndup(name, maxname);\n    else\n        thname = g_strdup(name);\n\n    if (evt->thread) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Event thread is already running\"));\n        return -1;\n    }\n\n    data = g_new0(virEventThreadData, 1);\n    data->loop = g_main_loop_ref(evt->loop);\n    data->context = g_main_context_ref(evt->context);\n    g_mutex_init(&data->lock);\n    g_cond_init(&data->cond);\n\n    evt->thread = g_thread_try_new(thname,\n                                   virEventThreadWorker,\n                                   data,\n                                   &gerr);\n    if (!evt->thread) {\n        virEventThreadDataFree(data);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to start event thread: %s\"),\n                       gerr->message);\n        return -1;\n    }\n\n    g_mutex_lock(&data->lock);\n    while (!data->running)\n        g_cond_wait(&data->cond, &data->lock);\n    g_mutex_unlock(&data->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "&data->lock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_cond_wait",
          "args": [
            "&data->cond",
            "&data->lock"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "&data->lock"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to start event thread: %s\")",
            "gerr->message"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to start event thread: %s\""
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "vir_event_thread_class_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
          "lines": "64-70",
          "snippet": "static void\nvir_event_thread_class_init(virEventThreadClass *klass)\n{\n    GObjectClass *obj = G_OBJECT_CLASS(klass);\n\n    obj->finalize = vir_event_thread_finalize;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"vireventthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvir_event_thread_class_init(virEventThreadClass *klass)\n{\n    GObjectClass *obj = G_OBJECT_CLASS(klass);\n\n    obj->finalize = vir_event_thread_finalize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventThreadDataFree",
          "args": [
            "data"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "virEventThreadDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
          "lines": "83-93",
          "snippet": "static void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"vireventthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_thread_try_new",
          "args": [
            "thname",
            "virEventThreadWorker",
            "data",
            "&gerr"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_cond_init",
          "args": [
            "&data->cond"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_init",
          "args": [
            "&data->lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_ref",
          "args": [
            "evt->context"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_ref",
          "args": [
            "evt->loop"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virEventThreadData",
            "1"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Event thread is already running\")"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "name",
            "maxname"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadMaxName",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadMaxName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "187-198",
          "snippet": "size_t virThreadMaxName(void)\n{\n#if defined(__FreeBSD__) || defined(__APPLE__)\n    return 63;\n#else\n# ifdef __linux__\n    return 15;\n# else\n    return 0; /* unlimited */\n# endif\n#endif\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nsize_t virThreadMaxName(void)\n{\n#if defined(__FreeBSD__) || defined(__APPLE__)\n    return 63;\n#else\n# ifdef __linux__\n    return 15;\n# else\n    return 0; /* unlimited */\n# endif\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic int\nvirEventThreadStart(virEventThread *evt, const char *name)\n{\n    g_autoptr(GError) gerr = NULL;\n    g_autofree char *thname = NULL;\n    size_t maxname = virThreadMaxName();\n    virEventThreadData *data;\n\n    if (maxname)\n        thname = g_strndup(name, maxname);\n    else\n        thname = g_strdup(name);\n\n    if (evt->thread) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Event thread is already running\"));\n        return -1;\n    }\n\n    data = g_new0(virEventThreadData, 1);\n    data->loop = g_main_loop_ref(evt->loop);\n    data->context = g_main_context_ref(evt->context);\n    g_mutex_init(&data->lock);\n    g_cond_init(&data->cond);\n\n    evt->thread = g_thread_try_new(thname,\n                                   virEventThreadWorker,\n                                   data,\n                                   &gerr);\n    if (!evt->thread) {\n        virEventThreadDataFree(data);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to start event thread: %s\"),\n                       gerr->message);\n        return -1;\n    }\n\n    g_mutex_lock(&data->lock);\n    while (!data->running)\n        g_cond_wait(&data->cond, &data->lock);\n    g_mutex_unlock(&data->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "virEventThreadWorker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "110-125",
    "snippet": "static void *\nvirEventThreadWorker(void *opaque)\n{\n    virEventThreadData *data = opaque;\n    g_autoptr(GSource) running = g_idle_source_new();\n\n    g_source_set_callback(running, virEventThreadNotify, data, NULL);\n\n    g_source_attach(running, data->context);\n\n    g_main_loop_run(data->loop);\n\n    virEventThreadDataFree(data);\n\n    return NULL;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventThreadDataFree",
          "args": [
            "data"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virEventThreadDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
          "lines": "83-93",
          "snippet": "static void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"vireventthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_loop_run",
          "args": [
            "data->loop"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_attach",
          "args": [
            "running",
            "data->context"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_set_callback",
          "args": [
            "running",
            "virEventThreadNotify",
            "data",
            "NULL"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_idle_source_new",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void *\nvirEventThreadWorker(void *opaque)\n{\n    virEventThreadData *data = opaque;\n    g_autoptr(GSource) running = g_idle_source_new();\n\n    g_source_set_callback(running, virEventThreadNotify, data, NULL);\n\n    g_source_attach(running, data->context);\n\n    g_main_loop_run(data->loop);\n\n    virEventThreadDataFree(data);\n\n    return NULL;\n}"
  },
  {
    "function_name": "virEventThreadNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "96-107",
    "snippet": "static gboolean\nvirEventThreadNotify(void *opaque)\n{\n    virEventThreadData *data = opaque;\n\n    g_mutex_lock(&data->lock);\n    data->running = TRUE;\n    g_mutex_unlock(&data->lock);\n    g_cond_signal(&data->cond);\n\n    return G_SOURCE_REMOVE;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_cond_signal",
          "args": [
            "&data->cond"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "&data->lock"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "&data->lock"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic gboolean\nvirEventThreadNotify(void *opaque)\n{\n    virEventThreadData *data = opaque;\n\n    g_mutex_lock(&data->lock);\n    data->running = TRUE;\n    g_mutex_unlock(&data->lock);\n    g_cond_signal(&data->cond);\n\n    return G_SOURCE_REMOVE;\n}"
  },
  {
    "function_name": "virEventThreadDataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "83-93",
    "snippet": "static void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "data"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_cond_clear",
          "args": [
            "&data->cond"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_clear",
          "args": [
            "&data->lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_unref",
          "args": [
            "data->context"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_unref",
          "args": [
            "data->loop"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvirEventThreadDataFree(virEventThreadData *data)\n{\n    g_main_loop_unref(data->loop);\n    g_main_context_unref(data->context);\n\n    g_mutex_clear(&data->lock);\n    g_cond_clear(&data->cond);\n\n    g_free(data);\n}"
  },
  {
    "function_name": "vir_event_thread_class_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "64-70",
    "snippet": "static void\nvir_event_thread_class_init(virEventThreadClass *klass)\n{\n    GObjectClass *obj = G_OBJECT_CLASS(klass);\n\n    obj->finalize = vir_event_thread_finalize;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "G_OBJECT_CLASS",
          "args": [
            "klass"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvir_event_thread_class_init(virEventThreadClass *klass)\n{\n    GObjectClass *obj = G_OBJECT_CLASS(klass);\n\n    obj->finalize = vir_event_thread_finalize;\n}"
  },
  {
    "function_name": "vir_event_thread_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "56-61",
    "snippet": "static void\nvir_event_thread_init(virEventThread *evt)\n{\n    evt->context = g_main_context_new();\n    evt->loop = g_main_loop_new(evt->context, FALSE);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_main_loop_new",
          "args": [
            "evt->context",
            "FALSE"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_new",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvir_event_thread_init(virEventThread *evt)\n{\n    evt->context = g_main_context_new();\n    evt->loop = g_main_loop_new(evt->context, FALSE);\n}"
  },
  {
    "function_name": "vir_event_thread_finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventthread.c",
    "lines": "39-53",
    "snippet": "static void\nvir_event_thread_finalize(GObject *object)\n{\n    virEventThread *evt = VIR_EVENT_THREAD(object);\n\n    if (evt->thread) {\n        g_main_loop_quit(evt->loop);\n        g_thread_unref(evt->thread);\n    }\n\n    g_main_loop_unref(evt->loop);\n    g_main_context_unref(evt->context);\n\n    G_OBJECT_CLASS(vir_event_thread_parent_class)->finalize(object);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"vireventthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "G_OBJECT_CLASS",
          "args": [
            "object"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_OBJECT_CLASS",
          "args": [
            "vir_event_thread_parent_class"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_context_unref",
          "args": [
            "evt->context"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_unref",
          "args": [
            "evt->loop"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_thread_unref",
          "args": [
            "evt->thread"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_main_loop_quit",
          "args": [
            "evt->loop"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EVENT_THREAD",
          "args": [
            "object"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"vireventthread.h\"\n#include <config.h>\n\nstatic void\nvir_event_thread_finalize(GObject *object)\n{\n    virEventThread *evt = VIR_EVENT_THREAD(object);\n\n    if (evt->thread) {\n        g_main_loop_quit(evt->loop);\n        g_thread_unref(evt->thread);\n    }\n\n    g_main_loop_unref(evt->loop);\n    g_main_context_unref(evt->context);\n\n    G_OBJECT_CLASS(vir_event_thread_parent_class)->finalize(object);\n}"
  }
]