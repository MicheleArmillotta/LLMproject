[
  {
    "function_name": "vboxRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_driver.c",
    "lines": "79-98",
    "snippet": "int vboxRegister(void)\n{\n    uint32_t uVersion;\n\n    if (VBoxCGlueInit(&uVersion) == 0)\n        vboxConnectDriver.hypervisorDriver = vboxGetHypervisorDriver(uVersion);\n\n    if (vboxConnectDriver.hypervisorDriver) {\n        vboxConnectDriver.networkDriver = vboxGetNetworkDriver(uVersion);\n        vboxConnectDriver.storageDriver = vboxGetStorageDriver(uVersion);\n    } else {\n        vboxConnectDriver.hypervisorDriver = &vboxDriverDummy;\n    }\n\n    if (virRegisterConnectDriver(&vboxConnectDriver,\n                                 false) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"domain_event.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_glue.h\"",
      "#include \"vbox_driver.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&vboxConnectDriver",
            "false"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxGetStorageDriver",
          "args": [
            "uVersion"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGetStorageDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
          "lines": "878-893",
          "snippet": "virStorageDriverPtr vboxGetStorageDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version.\n     * Return -1 for unsupported version.\n     */\n    if (uVersion >= 5000000 && uVersion < 5000051) {\n        vbox50InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5000051 && uVersion < 5001051) {\n        vbox51InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5001051 && uVersion < 5002051) {\n        vbox52InstallUniformedAPI(&gVBoxAPI);\n    } else {\n        return NULL;\n    }\n    return &vboxStorageDriver;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "virStorageDriver vboxStorageDriver = {\n    .connectNumOfStoragePools = vboxConnectNumOfStoragePools, /* 0.7.1 */\n    .connectListStoragePools = vboxConnectListStoragePools, /* 0.7.1 */\n    .storagePoolLookupByName = vboxStoragePoolLookupByName, /* 0.7.1 */\n    .storagePoolNumOfVolumes = vboxStoragePoolNumOfVolumes, /* 0.7.1 */\n    .storagePoolListVolumes = vboxStoragePoolListVolumes, /* 0.7.1 */\n\n    .storageVolLookupByName = vboxStorageVolLookupByName, /* 0.7.1 */\n    .storageVolLookupByKey = vboxStorageVolLookupByKey, /* 0.7.1 */\n    .storageVolLookupByPath = vboxStorageVolLookupByPath, /* 0.7.1 */\n    .storageVolCreateXML = vboxStorageVolCreateXML, /* 0.7.1 */\n    .storageVolDelete = vboxStorageVolDelete, /* 0.7.1 */\n    .storageVolGetInfo = vboxStorageVolGetInfo, /* 0.7.1 */\n    .storageVolGetXMLDesc = vboxStorageVolGetXMLDesc, /* 0.7.1 */\n    .storageVolGetPath = vboxStorageVolGetPath /* 0.7.1 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nvirStorageDriver vboxStorageDriver = {\n    .connectNumOfStoragePools = vboxConnectNumOfStoragePools, /* 0.7.1 */\n    .connectListStoragePools = vboxConnectListStoragePools, /* 0.7.1 */\n    .storagePoolLookupByName = vboxStoragePoolLookupByName, /* 0.7.1 */\n    .storagePoolNumOfVolumes = vboxStoragePoolNumOfVolumes, /* 0.7.1 */\n    .storagePoolListVolumes = vboxStoragePoolListVolumes, /* 0.7.1 */\n\n    .storageVolLookupByName = vboxStorageVolLookupByName, /* 0.7.1 */\n    .storageVolLookupByKey = vboxStorageVolLookupByKey, /* 0.7.1 */\n    .storageVolLookupByPath = vboxStorageVolLookupByPath, /* 0.7.1 */\n    .storageVolCreateXML = vboxStorageVolCreateXML, /* 0.7.1 */\n    .storageVolDelete = vboxStorageVolDelete, /* 0.7.1 */\n    .storageVolGetInfo = vboxStorageVolGetInfo, /* 0.7.1 */\n    .storageVolGetXMLDesc = vboxStorageVolGetXMLDesc, /* 0.7.1 */\n    .storageVolGetPath = vboxStorageVolGetPath /* 0.7.1 */\n};\n\nvirStorageDriverPtr vboxGetStorageDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version.\n     * Return -1 for unsupported version.\n     */\n    if (uVersion >= 5000000 && uVersion < 5000051) {\n        vbox50InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5000051 && uVersion < 5001051) {\n        vbox51InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5001051 && uVersion < 5002051) {\n        vbox52InstallUniformedAPI(&gVBoxAPI);\n    } else {\n        return NULL;\n    }\n    return &vboxStorageDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxGetNetworkDriver",
          "args": [
            "uVersion"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGetNetworkDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "935-942",
          "snippet": "virNetworkDriverPtr vboxGetNetworkDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) return NULL;\n    return &vboxNetworkDriver;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "virNetworkDriver vboxNetworkDriver = {\n    .connectNumOfNetworks = vboxConnectNumOfNetworks, /* 0.6.4 */\n    .connectListNetworks = vboxConnectListNetworks, /* 0.6.4 */\n    .connectNumOfDefinedNetworks = vboxConnectNumOfDefinedNetworks, /* 0.6.4 */\n    .connectListDefinedNetworks = vboxConnectListDefinedNetworks, /* 0.6.4 */\n    .networkLookupByUUID = vboxNetworkLookupByUUID, /* 0.6.4 */\n    .networkLookupByName = vboxNetworkLookupByName, /* 0.6.4 */\n    .networkCreateXML = vboxNetworkCreateXML, /* 0.6.4 */\n    .networkDefineXML = vboxNetworkDefineXML, /* 0.6.4 */\n    .networkUndefine = vboxNetworkUndefine, /* 0.6.4 */\n    .networkCreate = vboxNetworkCreate, /* 0.6.4 */\n    .networkDestroy = vboxNetworkDestroy, /* 0.6.4 */\n    .networkGetXMLDesc = vboxNetworkGetXMLDesc, /* 0.6.4 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nvirNetworkDriver vboxNetworkDriver = {\n    .connectNumOfNetworks = vboxConnectNumOfNetworks, /* 0.6.4 */\n    .connectListNetworks = vboxConnectListNetworks, /* 0.6.4 */\n    .connectNumOfDefinedNetworks = vboxConnectNumOfDefinedNetworks, /* 0.6.4 */\n    .connectListDefinedNetworks = vboxConnectListDefinedNetworks, /* 0.6.4 */\n    .networkLookupByUUID = vboxNetworkLookupByUUID, /* 0.6.4 */\n    .networkLookupByName = vboxNetworkLookupByName, /* 0.6.4 */\n    .networkCreateXML = vboxNetworkCreateXML, /* 0.6.4 */\n    .networkDefineXML = vboxNetworkDefineXML, /* 0.6.4 */\n    .networkUndefine = vboxNetworkUndefine, /* 0.6.4 */\n    .networkCreate = vboxNetworkCreate, /* 0.6.4 */\n    .networkDestroy = vboxNetworkDestroy, /* 0.6.4 */\n    .networkGetXMLDesc = vboxNetworkGetXMLDesc, /* 0.6.4 */\n};\n\nvirNetworkDriverPtr vboxGetNetworkDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) return NULL;\n    return &vboxNetworkDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxGetHypervisorDriver",
          "args": [
            "uVersion"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGetHypervisorDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "7941-7953",
          "snippet": "virHypervisorDriverPtr vboxGetHypervisorDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) {\n        VIR_WARN(\"Libvirt doesn't support VirtualBox API version %u\",\n                 uVersion);\n        return NULL;\n    }\n\n    return &vboxCommonDriver;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "static virHypervisorDriver vboxCommonDriver = {\n    .name = \"VBOX\",\n    .connectURIProbe = vboxConnectURIProbe,\n    .connectOpen = vboxConnectOpen, /* 0.6.3 */\n    .connectClose = vboxConnectClose, /* 0.6.3 */\n    .connectGetVersion = vboxConnectGetVersion, /* 0.6.3 */\n    .connectGetHostname = vboxConnectGetHostname, /* 0.6.3 */\n    .connectGetMaxVcpus = vboxConnectGetMaxVcpus, /* 0.6.3 */\n    .nodeGetInfo = vboxNodeGetInfo, /* 0.6.3 */\n    .connectGetCapabilities = vboxConnectGetCapabilities, /* 0.6.3 */\n    .connectListDomains = vboxConnectListDomains, /* 0.6.3 */\n    .connectNumOfDomains = vboxConnectNumOfDomains, /* 0.6.3 */\n    .connectListAllDomains = vboxConnectListAllDomains, /* 0.9.13 */\n    .domainCreateXML = vboxDomainCreateXML, /* 0.6.3 */\n    .domainLookupByID = vboxDomainLookupByID, /* 0.6.3 */\n    .domainLookupByUUID = vboxDomainLookupByUUID, /* 0.6.3 */\n    .domainLookupByName = vboxDomainLookupByName, /* 0.6.3 */\n    .domainSuspend = vboxDomainSuspend, /* 0.6.3 */\n    .domainResume = vboxDomainResume, /* 0.6.3 */\n    .domainShutdown = vboxDomainShutdown, /* 0.6.3 */\n    .domainShutdownFlags = vboxDomainShutdownFlags, /* 0.9.10 */\n    .domainReboot = vboxDomainReboot, /* 0.6.3 */\n    .domainDestroy = vboxDomainDestroy, /* 0.6.3 */\n    .domainDestroyFlags = vboxDomainDestroyFlags, /* 0.9.4 */\n    .domainGetOSType = vboxDomainGetOSType, /* 0.6.3 */\n    .domainSetMemory = vboxDomainSetMemory, /* 0.6.3 */\n    .domainGetInfo = vboxDomainGetInfo, /* 0.6.3 */\n    .domainGetState = vboxDomainGetState, /* 0.9.2 */\n    .domainSave = vboxDomainSave, /* 0.6.3 */\n    .domainSetVcpus = vboxDomainSetVcpus, /* 0.7.1 */\n    .domainSetVcpusFlags = vboxDomainSetVcpusFlags, /* 0.8.5 */\n    .domainGetVcpusFlags = vboxDomainGetVcpusFlags, /* 0.8.5 */\n    .domainGetMaxVcpus = vboxDomainGetMaxVcpus, /* 0.7.1 */\n    .domainGetXMLDesc = vboxDomainGetXMLDesc, /* 0.6.3 */\n    .connectListDefinedDomains = vboxConnectListDefinedDomains, /* 0.6.3 */\n    .connectNumOfDefinedDomains = vboxConnectNumOfDefinedDomains, /* 0.6.3 */\n    .domainCreate = vboxDomainCreate, /* 0.6.3 */\n    .domainCreateWithFlags = vboxDomainCreateWithFlags, /* 0.8.2 */\n    .domainDefineXML = vboxDomainDefineXML, /* 0.6.3 */\n    .domainDefineXMLFlags = vboxDomainDefineXMLFlags, /* 1.2.12 */\n    .domainUndefine = vboxDomainUndefine, /* 0.6.3 */\n    .domainUndefineFlags = vboxDomainUndefineFlags, /* 0.9.5 */\n    .domainAttachDevice = vboxDomainAttachDevice, /* 0.6.3 */\n    .domainAttachDeviceFlags = vboxDomainAttachDeviceFlags, /* 0.7.7 */\n    .domainDetachDevice = vboxDomainDetachDevice, /* 0.6.3 */\n    .domainDetachDeviceFlags = vboxDomainDetachDeviceFlags, /* 0.7.7 */\n    .domainUpdateDeviceFlags = vboxDomainUpdateDeviceFlags, /* 0.8.0 */\n    .nodeGetCellsFreeMemory = vboxNodeGetCellsFreeMemory, /* 0.6.5 */\n    .nodeGetFreeMemory = vboxNodeGetFreeMemory, /* 0.6.5 */\n    .connectIsEncrypted = vboxConnectIsEncrypted, /* 0.7.3 */\n    .connectIsSecure = vboxConnectIsSecure, /* 0.7.3 */\n    .domainIsActive = vboxDomainIsActive, /* 0.7.3 */\n    .domainIsPersistent = vboxDomainIsPersistent, /* 0.7.3 */\n    .domainIsUpdated = vboxDomainIsUpdated, /* 0.8.6 */\n    .domainSnapshotCreateXML = vboxDomainSnapshotCreateXML, /* 0.8.0 */\n    .domainSnapshotGetXMLDesc = vboxDomainSnapshotGetXMLDesc, /* 0.8.0 */\n    .domainSnapshotNum = vboxDomainSnapshotNum, /* 0.8.0 */\n    .domainSnapshotListNames = vboxDomainSnapshotListNames, /* 0.8.0 */\n    .domainSnapshotLookupByName = vboxDomainSnapshotLookupByName, /* 0.8.0 */\n    .domainHasCurrentSnapshot = vboxDomainHasCurrentSnapshot, /* 0.8.0 */\n    .domainSnapshotGetParent = vboxDomainSnapshotGetParent, /* 0.9.7 */\n    .domainSnapshotCurrent = vboxDomainSnapshotCurrent, /* 0.8.0 */\n    .domainSnapshotIsCurrent = vboxDomainSnapshotIsCurrent, /* 0.9.13 */\n    .domainSnapshotHasMetadata = vboxDomainSnapshotHasMetadata, /* 0.9.13 */\n    .domainRevertToSnapshot = vboxDomainRevertToSnapshot, /* 0.8.0 */\n    .domainSnapshotDelete = vboxDomainSnapshotDelete, /* 0.8.0 */\n    .connectIsAlive = vboxConnectIsAlive, /* 0.9.8 */\n    .nodeGetFreePages = vboxNodeGetFreePages, /* 1.2.6 */\n    .nodeAllocPages = vboxNodeAllocPages, /* 1.2.9 */\n    .domainHasManagedSaveImage = vboxDomainHasManagedSaveImage, /* 1.2.13 */\n    .domainSendKey = vboxDomainSendKey, /* 1.2.15 */\n    .domainScreenshot = vboxDomainScreenshot, /* 0.9.2 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic virHypervisorDriver vboxCommonDriver = {\n    .name = \"VBOX\",\n    .connectURIProbe = vboxConnectURIProbe,\n    .connectOpen = vboxConnectOpen, /* 0.6.3 */\n    .connectClose = vboxConnectClose, /* 0.6.3 */\n    .connectGetVersion = vboxConnectGetVersion, /* 0.6.3 */\n    .connectGetHostname = vboxConnectGetHostname, /* 0.6.3 */\n    .connectGetMaxVcpus = vboxConnectGetMaxVcpus, /* 0.6.3 */\n    .nodeGetInfo = vboxNodeGetInfo, /* 0.6.3 */\n    .connectGetCapabilities = vboxConnectGetCapabilities, /* 0.6.3 */\n    .connectListDomains = vboxConnectListDomains, /* 0.6.3 */\n    .connectNumOfDomains = vboxConnectNumOfDomains, /* 0.6.3 */\n    .connectListAllDomains = vboxConnectListAllDomains, /* 0.9.13 */\n    .domainCreateXML = vboxDomainCreateXML, /* 0.6.3 */\n    .domainLookupByID = vboxDomainLookupByID, /* 0.6.3 */\n    .domainLookupByUUID = vboxDomainLookupByUUID, /* 0.6.3 */\n    .domainLookupByName = vboxDomainLookupByName, /* 0.6.3 */\n    .domainSuspend = vboxDomainSuspend, /* 0.6.3 */\n    .domainResume = vboxDomainResume, /* 0.6.3 */\n    .domainShutdown = vboxDomainShutdown, /* 0.6.3 */\n    .domainShutdownFlags = vboxDomainShutdownFlags, /* 0.9.10 */\n    .domainReboot = vboxDomainReboot, /* 0.6.3 */\n    .domainDestroy = vboxDomainDestroy, /* 0.6.3 */\n    .domainDestroyFlags = vboxDomainDestroyFlags, /* 0.9.4 */\n    .domainGetOSType = vboxDomainGetOSType, /* 0.6.3 */\n    .domainSetMemory = vboxDomainSetMemory, /* 0.6.3 */\n    .domainGetInfo = vboxDomainGetInfo, /* 0.6.3 */\n    .domainGetState = vboxDomainGetState, /* 0.9.2 */\n    .domainSave = vboxDomainSave, /* 0.6.3 */\n    .domainSetVcpus = vboxDomainSetVcpus, /* 0.7.1 */\n    .domainSetVcpusFlags = vboxDomainSetVcpusFlags, /* 0.8.5 */\n    .domainGetVcpusFlags = vboxDomainGetVcpusFlags, /* 0.8.5 */\n    .domainGetMaxVcpus = vboxDomainGetMaxVcpus, /* 0.7.1 */\n    .domainGetXMLDesc = vboxDomainGetXMLDesc, /* 0.6.3 */\n    .connectListDefinedDomains = vboxConnectListDefinedDomains, /* 0.6.3 */\n    .connectNumOfDefinedDomains = vboxConnectNumOfDefinedDomains, /* 0.6.3 */\n    .domainCreate = vboxDomainCreate, /* 0.6.3 */\n    .domainCreateWithFlags = vboxDomainCreateWithFlags, /* 0.8.2 */\n    .domainDefineXML = vboxDomainDefineXML, /* 0.6.3 */\n    .domainDefineXMLFlags = vboxDomainDefineXMLFlags, /* 1.2.12 */\n    .domainUndefine = vboxDomainUndefine, /* 0.6.3 */\n    .domainUndefineFlags = vboxDomainUndefineFlags, /* 0.9.5 */\n    .domainAttachDevice = vboxDomainAttachDevice, /* 0.6.3 */\n    .domainAttachDeviceFlags = vboxDomainAttachDeviceFlags, /* 0.7.7 */\n    .domainDetachDevice = vboxDomainDetachDevice, /* 0.6.3 */\n    .domainDetachDeviceFlags = vboxDomainDetachDeviceFlags, /* 0.7.7 */\n    .domainUpdateDeviceFlags = vboxDomainUpdateDeviceFlags, /* 0.8.0 */\n    .nodeGetCellsFreeMemory = vboxNodeGetCellsFreeMemory, /* 0.6.5 */\n    .nodeGetFreeMemory = vboxNodeGetFreeMemory, /* 0.6.5 */\n    .connectIsEncrypted = vboxConnectIsEncrypted, /* 0.7.3 */\n    .connectIsSecure = vboxConnectIsSecure, /* 0.7.3 */\n    .domainIsActive = vboxDomainIsActive, /* 0.7.3 */\n    .domainIsPersistent = vboxDomainIsPersistent, /* 0.7.3 */\n    .domainIsUpdated = vboxDomainIsUpdated, /* 0.8.6 */\n    .domainSnapshotCreateXML = vboxDomainSnapshotCreateXML, /* 0.8.0 */\n    .domainSnapshotGetXMLDesc = vboxDomainSnapshotGetXMLDesc, /* 0.8.0 */\n    .domainSnapshotNum = vboxDomainSnapshotNum, /* 0.8.0 */\n    .domainSnapshotListNames = vboxDomainSnapshotListNames, /* 0.8.0 */\n    .domainSnapshotLookupByName = vboxDomainSnapshotLookupByName, /* 0.8.0 */\n    .domainHasCurrentSnapshot = vboxDomainHasCurrentSnapshot, /* 0.8.0 */\n    .domainSnapshotGetParent = vboxDomainSnapshotGetParent, /* 0.9.7 */\n    .domainSnapshotCurrent = vboxDomainSnapshotCurrent, /* 0.8.0 */\n    .domainSnapshotIsCurrent = vboxDomainSnapshotIsCurrent, /* 0.9.13 */\n    .domainSnapshotHasMetadata = vboxDomainSnapshotHasMetadata, /* 0.9.13 */\n    .domainRevertToSnapshot = vboxDomainRevertToSnapshot, /* 0.8.0 */\n    .domainSnapshotDelete = vboxDomainSnapshotDelete, /* 0.8.0 */\n    .connectIsAlive = vboxConnectIsAlive, /* 0.9.8 */\n    .nodeGetFreePages = vboxNodeGetFreePages, /* 1.2.6 */\n    .nodeAllocPages = vboxNodeAllocPages, /* 1.2.9 */\n    .domainHasManagedSaveImage = vboxDomainHasManagedSaveImage, /* 1.2.13 */\n    .domainSendKey = vboxDomainSendKey, /* 1.2.15 */\n    .domainScreenshot = vboxDomainScreenshot, /* 0.9.2 */\n};\n\nvirHypervisorDriverPtr vboxGetHypervisorDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) {\n        VIR_WARN(\"Libvirt doesn't support VirtualBox API version %u\",\n                 uVersion);\n        return NULL;\n    }\n\n    return &vboxCommonDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBoxCGlueInit",
          "args": [
            "&uVersion"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "VBoxCGlueInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "171-217",
          "snippet": "int\nVBoxCGlueInit(unsigned int *version)\n{\n    size_t i;\n    static const char *knownDirs[] = {\n        \"/usr/lib/virtualbox\",\n        \"/usr/lib/virtualbox-ose\",\n        \"/usr/lib64/virtualbox\",\n        \"/usr/lib64/virtualbox-ose\",\n        \"/usr/lib/VirtualBox\",\n        \"/opt/virtualbox\",\n        \"/opt/VirtualBox\",\n        \"/opt/virtualbox/i386\",\n        \"/opt/VirtualBox/i386\",\n        \"/opt/virtualbox/amd64\",\n        \"/opt/VirtualBox/amd64\",\n        \"/usr/local/lib/virtualbox\",\n        \"/usr/local/lib/VirtualBox\",\n        \"/Applications/VirtualBox.app/Contents/MacOS\"\n    };\n    const char *home = getenv(\"VBOX_APP_HOME\");\n\n    /* If the user specifies the location, try only that. */\n    if (home != NULL) {\n        if (tryLoadOne(home, false, false, version) < 0)\n            return -1;\n    }\n\n    /* Try the additionally configured location. */\n    if (VBOX_XPCOMC_DIR[0] != '\\0') {\n        if (tryLoadOne(VBOX_XPCOMC_DIR, true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Try the known locations. */\n    for (i = 0; i < G_N_ELEMENTS(knownDirs); ++i) {\n        if (tryLoadOne(knownDirs[i], true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Finally try the dynamic linker search path. */\n    if (tryLoadOne(NULL, false, true, version) >= 0)\n        return 0;\n\n    /* No luck, return failure. */\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nint\nVBoxCGlueInit(unsigned int *version)\n{\n    size_t i;\n    static const char *knownDirs[] = {\n        \"/usr/lib/virtualbox\",\n        \"/usr/lib/virtualbox-ose\",\n        \"/usr/lib64/virtualbox\",\n        \"/usr/lib64/virtualbox-ose\",\n        \"/usr/lib/VirtualBox\",\n        \"/opt/virtualbox\",\n        \"/opt/VirtualBox\",\n        \"/opt/virtualbox/i386\",\n        \"/opt/VirtualBox/i386\",\n        \"/opt/virtualbox/amd64\",\n        \"/opt/VirtualBox/amd64\",\n        \"/usr/local/lib/virtualbox\",\n        \"/usr/local/lib/VirtualBox\",\n        \"/Applications/VirtualBox.app/Contents/MacOS\"\n    };\n    const char *home = getenv(\"VBOX_APP_HOME\");\n\n    /* If the user specifies the location, try only that. */\n    if (home != NULL) {\n        if (tryLoadOne(home, false, false, version) < 0)\n            return -1;\n    }\n\n    /* Try the additionally configured location. */\n    if (VBOX_XPCOMC_DIR[0] != '\\0') {\n        if (tryLoadOne(VBOX_XPCOMC_DIR, true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Try the known locations. */\n    for (i = 0; i < G_N_ELEMENTS(knownDirs); ++i) {\n        if (tryLoadOne(knownDirs[i], true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Finally try the dynamic linker search path. */\n    if (tryLoadOne(NULL, false, true, version) >= 0)\n        return 0;\n\n    /* No luck, return failure. */\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"domain_conf.h\"\n#include \"domain_event.h\"\n#include \"virerror.h\"\n#include \"vbox_glue.h\"\n#include \"vbox_driver.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nint vboxRegister(void)\n{\n    uint32_t uVersion;\n\n    if (VBoxCGlueInit(&uVersion) == 0)\n        vboxConnectDriver.hypervisorDriver = vboxGetHypervisorDriver(uVersion);\n\n    if (vboxConnectDriver.hypervisorDriver) {\n        vboxConnectDriver.networkDriver = vboxGetNetworkDriver(uVersion);\n        vboxConnectDriver.storageDriver = vboxGetStorageDriver(uVersion);\n    } else {\n        vboxConnectDriver.hypervisorDriver = &vboxDriverDummy;\n    }\n\n    if (virRegisterConnectDriver(&vboxConnectDriver,\n                                 false) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "dummyConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_driver.c",
    "lines": "51-66",
    "snippet": "static virDrvOpenStatus dummyConnectOpen(virConnectPtr conn,\n                                         virConnectAuthPtr auth G_GNUC_UNUSED,\n                                         virConfPtr conf G_GNUC_UNUSED,\n                                         unsigned int flags)\n{\n    uid_t uid = geteuid();\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (!virConnectValidateURIPath(conn->uri->path, \"vbox\", uid == 0))\n        return VIR_DRV_OPEN_ERROR;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"unable to initialize VirtualBox driver API\"));\n    return VIR_DRV_OPEN_ERROR;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"domain_event.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_glue.h\"",
      "#include \"vbox_driver.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to initialize VirtualBox driver API\")"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to initialize VirtualBox driver API\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectValidateURIPath",
          "args": [
            "conn->uri->path",
            "\"vbox\"",
            "uid == 0"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectValidateURIPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "260-296",
          "snippet": "bool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"domain_conf.h\"\n#include \"domain_event.h\"\n#include \"virerror.h\"\n#include \"vbox_glue.h\"\n#include \"vbox_driver.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virDrvOpenStatus dummyConnectOpen(virConnectPtr conn,\n                                         virConnectAuthPtr auth G_GNUC_UNUSED,\n                                         virConfPtr conf G_GNUC_UNUSED,\n                                         unsigned int flags)\n{\n    uid_t uid = geteuid();\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (!virConnectValidateURIPath(conn->uri->path, \"vbox\", uid == 0))\n        return VIR_DRV_OPEN_ERROR;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"unable to initialize VirtualBox driver API\"));\n    return VIR_DRV_OPEN_ERROR;\n}"
  }
]