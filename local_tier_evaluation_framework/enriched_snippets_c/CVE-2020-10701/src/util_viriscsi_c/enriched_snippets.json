[
  {
    "function_name": "virISCSINodeUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "545-572",
    "snippet": "int\nvirISCSINodeUpdate(const char *portal,\n                   const char *target,\n                   const char *name,\n                   const char *value)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"node\",\n                               \"--portal\", portal,\n                               \"--target\", target,\n                               \"--op\", \"update\",\n                               \"--name\", name,\n                               \"--value\", value,\n                               NULL);\n\n    /* Ignore non-zero status.  */\n    if (virCommandRun(cmd, &status) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to update '%s' of node mode for target '%s'\"),\n                       name, target);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to update '%s' of node mode for target '%s'\")",
            "name",
            "target"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to update '%s' of node mode for target '%s'\""
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"node\"",
            "\"--portal\"",
            "portal",
            "\"--target\"",
            "target",
            "\"--op\"",
            "\"update\"",
            "\"--name\"",
            "name",
            "\"--value\"",
            "value",
            "NULL"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nint\nvirISCSINodeUpdate(const char *portal,\n                   const char *target,\n                   const char *name,\n                   const char *value)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"node\",\n                               \"--portal\", portal,\n                               \"--target\", target,\n                               \"--op\", \"update\",\n                               \"--name\", name,\n                               \"--value\", value,\n                               NULL);\n\n    /* Ignore non-zero status.  */\n    if (virCommandRun(cmd, &status) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to update '%s' of node mode for target '%s'\"),\n                       name, target);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virISCSINodeNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "513-542",
    "snippet": "int\nvirISCSINodeNew(const char *portal,\n                const char *target)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"node\",\n                               \"--portal\", portal,\n                               \"--targetname\", target,\n                               \"--op\", \"new\",\n                               NULL);\n\n    if (virCommandRun(cmd, &status) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed new node mode for target '%s'\"),\n                       target);\n        return -1;\n    }\n\n    if (status != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s failed new mode for target '%s' with status '%d'\"),\n                       ISCSIADM, target, status);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s failed new mode for target '%s' with status '%d'\")",
            "ISCSIADM",
            "target",
            "status"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s failed new mode for target '%s' with status '%d'\""
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed new node mode for target '%s'\")",
            "target"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"node\"",
            "\"--portal\"",
            "portal",
            "\"--targetname\"",
            "target",
            "\"--op\"",
            "\"new\"",
            "NULL"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nint\nvirISCSINodeNew(const char *portal,\n                const char *target)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"node\",\n                               \"--portal\", portal,\n                               \"--targetname\", target,\n                               \"--op\", \"new\",\n                               NULL);\n\n    if (virCommandRun(cmd, &status) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed new node mode for target '%s'\"),\n                       target);\n        return -1;\n    }\n\n    if (status != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s failed new mode for target '%s' with status '%d'\"),\n                       ISCSIADM, target, status);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIScanTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "462-494",
    "snippet": "int\nvirISCSIScanTargets(const char *portal,\n                    const char *initiatoriqn,\n                    bool persist,\n                    size_t *ntargets,\n                    char ***targets)\n{\n    g_autofree char *ifacename = NULL;\n\n    if (ntargets)\n        *ntargets = 0;\n    if (targets)\n        *targets = NULL;\n\n    if (initiatoriqn) {\n        switch ((virStorageBackendIQNFound(initiatoriqn, &ifacename))) {\n        case IQN_FOUND:\n            break;\n\n        case IQN_MISSING:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"no iSCSI interface defined for IQN %s\"),\n                           initiatoriqn);\n            G_GNUC_FALLTHROUGH;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n    }\n\n    return virISCSIScanTargetsInternal(portal, ifacename,\n                                       persist, ntargets, targets);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define IQN_ERROR -1",
      "#define IQN_MISSING 0",
      "#define IQN_FOUND 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virISCSIScanTargetsInternal",
          "args": [
            "portal",
            "ifacename",
            "persist",
            "ntargets",
            "targets"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIScanTargetsInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "379-440",
          "snippet": "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"no iSCSI interface defined for IQN %s\")",
            "initiatoriqn"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no iSCSI interface defined for IQN %s\""
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendIQNFound",
          "args": [
            "initiatoriqn",
            "&ifacename"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendIQNFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "119-201",
          "snippet": "static int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_ERROR -1",
            "#define IQN_MISSING 0",
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nint\nvirISCSIScanTargets(const char *portal,\n                    const char *initiatoriqn,\n                    bool persist,\n                    size_t *ntargets,\n                    char ***targets)\n{\n    g_autofree char *ifacename = NULL;\n\n    if (ntargets)\n        *ntargets = 0;\n    if (targets)\n        *targets = NULL;\n\n    if (initiatoriqn) {\n        switch ((virStorageBackendIQNFound(initiatoriqn, &ifacename))) {\n        case IQN_FOUND:\n            break;\n\n        case IQN_MISSING:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"no iSCSI interface defined for IQN %s\"),\n                           initiatoriqn);\n            G_GNUC_FALLTHROUGH;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n    }\n\n    return virISCSIScanTargetsInternal(portal, ifacename,\n                                       persist, ntargets, targets);\n}"
  },
  {
    "function_name": "virISCSIScanTargetsInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "379-440",
    "snippet": "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.targets"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.targets[i]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRunRegex",
          "args": [
            "cmd",
            "1",
            "regexes",
            "vars",
            "virISCSIGetTargets",
            "&list",
            "NULL",
            "NULL"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunRegex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3341-3354",
          "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&list",
            "0",
            "sizeof(list)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--interface\"",
            "ifacename",
            "NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"discovery\"",
            "\"--type\"",
            "\"sendtargets\"",
            "\"--portal\"",
            "portal",
            "NULL"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIGetTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "363-376",
    "snippet": "static int\nvirISCSIGetTargets(char **const groups,\n                   void *data)\n{\n    struct virISCSITargetList *list = data;\n    g_autofree char *target = NULL;\n\n    target = g_strdup(groups[1]);\n\n    if (VIR_APPEND_ELEMENT(list->targets, list->ntargets, target) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "list->targets",
            "list->ntargets",
            "target"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "groups[1]"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nstatic int\nvirISCSIGetTargets(char **const groups,\n                   void *data)\n{\n    struct virISCSITargetList *list = data;\n    g_autofree char *target = NULL;\n\n    target = g_strdup(groups[1]);\n\n    if (VIR_APPEND_ELEMENT(list->targets, list->ntargets, target) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIRescanLUNs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "345-354",
    "snippet": "int\nvirISCSIRescanLUNs(const char *session)\n{\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"session\",\n                                                       \"-r\", session,\n                                                       \"-R\",\n                                                       NULL);\n    return virCommandRun(cmd, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"session\"",
            "\"-r\"",
            "session",
            "\"-R\"",
            "NULL"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nint\nvirISCSIRescanLUNs(const char *session)\n{\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"session\",\n                                                       \"-r\", session,\n                                                       \"-R\",\n                                                       NULL);\n    return virCommandRun(cmd, NULL);\n}"
  },
  {
    "function_name": "virISCSIConnectionLogout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "335-342",
    "snippet": "int\nvirISCSIConnectionLogout(const char *portal,\n                         const char *initiatoriqn,\n                         const char *target)\n{\n    const char *extraargv[] = { \"--logout\", NULL };\n    return virISCSIConnection(portal, initiatoriqn, target, extraargv);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virISCSIConnection",
          "args": [
            "portal",
            "initiatoriqn",
            "target",
            "extraargv"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "271-322",
          "snippet": "static int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_ERROR -1",
            "#define IQN_MISSING 0",
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nint\nvirISCSIConnectionLogout(const char *portal,\n                         const char *initiatoriqn,\n                         const char *target)\n{\n    const char *extraargv[] = { \"--logout\", NULL };\n    return virISCSIConnection(portal, initiatoriqn, target, extraargv);\n}"
  },
  {
    "function_name": "virISCSIConnectionLogin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "325-332",
    "snippet": "int\nvirISCSIConnectionLogin(const char *portal,\n                        const char *initiatoriqn,\n                        const char *target)\n{\n    const char *extraargv[] = { \"--login\", NULL };\n    return virISCSIConnection(portal, initiatoriqn, target, extraargv);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virISCSIConnection",
          "args": [
            "portal",
            "initiatoriqn",
            "target",
            "extraargv"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "271-322",
          "snippet": "static int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_ERROR -1",
            "#define IQN_MISSING 0",
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nint\nvirISCSIConnectionLogin(const char *portal,\n                        const char *initiatoriqn,\n                        const char *target)\n{\n    const char *extraargv[] = { \"--login\", NULL };\n    return virISCSIConnection(portal, initiatoriqn, target, extraargv);\n}"
  },
  {
    "function_name": "virISCSIConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "271-322",
    "snippet": "static int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define IQN_ERROR -1",
      "#define IQN_MISSING 0",
      "#define IQN_FOUND 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--interface\"",
            "ifacename",
            "NULL"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIScanTargetsInternal",
          "args": [
            "portal",
            "ifacename",
            "true",
            "NULL",
            "NULL"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIScanTargetsInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "379-440",
          "snippet": "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret);\n\nstatic int\nvirISCSIScanTargetsInternal(const char *portal,\n                            const char *ifacename,\n                            bool persist,\n                            size_t *ntargetsret,\n                            char ***targetsret)\n{\n    /**\n     *\n     * The output of sendtargets is very simple, just two columns,\n     * portal then target name\n     *\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo0.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo1.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo2.bf6d84\n     * 192.168.122.185:3260,1 iqn.2004-04.com:fedora14:iscsi.demo3.bf6d84\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = { 2 };\n    struct virISCSITargetList list;\n    size_t i;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"discovery\",\n                                                       \"--type\", \"sendtargets\",\n                                                       \"--portal\", portal,\n                                                       NULL);\n\n    if (!persist) {\n        virCommandAddArgList(cmd,\n                             \"--op\", \"nonpersistent\",\n                             NULL);\n    }\n\n    if (ifacename) {\n        virCommandAddArgList(cmd,\n                             \"--interface\", ifacename,\n                             NULL);\n    }\n\n    memset(&list, 0, sizeof(list));\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIGetTargets,\n                           &list, NULL, NULL) < 0)\n        return -1;\n\n    if (ntargetsret && targetsret) {\n        *ntargetsret = list.ntargets;\n        *targetsret = list.targets;\n    } else {\n        for (i = 0; i < list.ntargets; i++)\n            VIR_FREE(list.targets[i]);\n        VIR_FREE(list.targets);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCreateIfaceIQN",
          "args": [
            "initiatoriqn",
            "&ifacename"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateIfaceIQN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "204-268",
          "snippet": "static int\nvirStorageBackendCreateIfaceIQN(const char *initiatoriqn,\n                                char **ifacename)\n{\n    int exitstatus = -1;\n    g_autofree char *iface_name = NULL;\n    g_autofree char *temp_ifacename = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    temp_ifacename = g_strdup_printf(\"libvirt-iface-%08llx\",\n                                     (unsigned long long)virRandomBits(32));\n\n    VIR_DEBUG(\"Attempting to create interface '%s' with IQN '%s'\",\n              temp_ifacename, initiatoriqn);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"new\",\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm\n     * tools returned an exit status of > 0, even if they succeeded.\n     * We will just rely on whether the interface got created\n     * properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to create new iscsi interface\"),\n                       ISCSIADM);\n        return -1;\n    }\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"update\",\n                               \"--name\", \"iface.initiatorname\",\n                               \"--value\",\n                               initiatoriqn,\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm tools\n     * returned an exit status of > 0, even if they succeeded.  We will just\n     * rely on whether iface file got updated properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to update iscsi interface with IQN '%s'\"),\n                       ISCSIADM, initiatoriqn);\n        return -1;\n    }\n\n    /* Check again to make sure the interface was created. */\n    if (virStorageBackendIQNFound(initiatoriqn, &iface_name) != IQN_FOUND) {\n        VIR_DEBUG(\"Failed to find interface '%s' with IQN '%s' \"\n                  \"after attempting to create it\",\n                  &temp_ifacename[0], initiatoriqn);\n        return -1;\n    } else {\n        VIR_DEBUG(\"Interface '%s' with IQN '%s' was created successfully\",\n                  iface_name, initiatoriqn);\n    }\n\n    *ifacename = g_steal_pointer(&iface_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendCreateIfaceIQN(const char *initiatoriqn,\n                                char **ifacename)\n{\n    int exitstatus = -1;\n    g_autofree char *iface_name = NULL;\n    g_autofree char *temp_ifacename = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    temp_ifacename = g_strdup_printf(\"libvirt-iface-%08llx\",\n                                     (unsigned long long)virRandomBits(32));\n\n    VIR_DEBUG(\"Attempting to create interface '%s' with IQN '%s'\",\n              temp_ifacename, initiatoriqn);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"new\",\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm\n     * tools returned an exit status of > 0, even if they succeeded.\n     * We will just rely on whether the interface got created\n     * properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to create new iscsi interface\"),\n                       ISCSIADM);\n        return -1;\n    }\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"update\",\n                               \"--name\", \"iface.initiatorname\",\n                               \"--value\",\n                               initiatoriqn,\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm tools\n     * returned an exit status of > 0, even if they succeeded.  We will just\n     * rely on whether iface file got updated properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to update iscsi interface with IQN '%s'\"),\n                       ISCSIADM, initiatoriqn);\n        return -1;\n    }\n\n    /* Check again to make sure the interface was created. */\n    if (virStorageBackendIQNFound(initiatoriqn, &iface_name) != IQN_FOUND) {\n        VIR_DEBUG(\"Failed to find interface '%s' with IQN '%s' \"\n                  \"after attempting to create it\",\n                  &temp_ifacename[0], initiatoriqn);\n        return -1;\n    } else {\n        VIR_DEBUG(\"Interface '%s' with IQN '%s' was created successfully\",\n                  iface_name, initiatoriqn);\n    }\n\n    *ifacename = g_steal_pointer(&iface_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ifacename: '%s'\"",
            "ifacename"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendIQNFound",
          "args": [
            "initiatoriqn",
            "&ifacename"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendIQNFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "119-201",
          "snippet": "static int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_ERROR -1",
            "#define IQN_MISSING 0",
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgSet",
          "args": [
            "cmd",
            "extraargv"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1617-1646",
          "snippet": "void\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "baseargv"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirISCSIConnection(const char *portal,\n                   const char *initiatoriqn,\n                   const char *target,\n                   const char **extraargv)\n{\n    const char *const baseargv[] = {\n        ISCSIADM,\n        \"--mode\", \"node\",\n        \"--portal\", portal,\n        \"--targetname\", target,\n        NULL\n    };\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *ifacename = NULL;\n\n    cmd = virCommandNewArgs(baseargv);\n    virCommandAddArgSet(cmd, extraargv);\n\n    if (initiatoriqn) {\n        switch (virStorageBackendIQNFound(initiatoriqn, &ifacename)) {\n        case IQN_FOUND:\n            VIR_DEBUG(\"ifacename: '%s'\", ifacename);\n            break;\n        case IQN_MISSING:\n            if (virStorageBackendCreateIfaceIQN(initiatoriqn, &ifacename) != 0)\n                return -1;\n            /*\n             * iscsiadm doesn't let you send commands to the Interface IQN,\n             * unless you've first issued a 'sendtargets' command to the\n             * portal. Without the sendtargets all that is received is a\n             * \"iscsiadm: No records found\". However, we must ensure that\n             * the command is issued over interface name we invented above\n             * and that targets are made persistent.\n             */\n            if (virISCSIScanTargetsInternal(portal, ifacename,\n                                            true, NULL, NULL) < 0)\n                return -1;\n\n            break;\n        case IQN_ERROR:\n        default:\n            return -1;\n        }\n        virCommandAddArgList(cmd, \"--interface\", ifacename, NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendCreateIfaceIQN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "204-268",
    "snippet": "static int\nvirStorageBackendCreateIfaceIQN(const char *initiatoriqn,\n                                char **ifacename)\n{\n    int exitstatus = -1;\n    g_autofree char *iface_name = NULL;\n    g_autofree char *temp_ifacename = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    temp_ifacename = g_strdup_printf(\"libvirt-iface-%08llx\",\n                                     (unsigned long long)virRandomBits(32));\n\n    VIR_DEBUG(\"Attempting to create interface '%s' with IQN '%s'\",\n              temp_ifacename, initiatoriqn);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"new\",\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm\n     * tools returned an exit status of > 0, even if they succeeded.\n     * We will just rely on whether the interface got created\n     * properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to create new iscsi interface\"),\n                       ISCSIADM);\n        return -1;\n    }\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"update\",\n                               \"--name\", \"iface.initiatorname\",\n                               \"--value\",\n                               initiatoriqn,\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm tools\n     * returned an exit status of > 0, even if they succeeded.  We will just\n     * rely on whether iface file got updated properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to update iscsi interface with IQN '%s'\"),\n                       ISCSIADM, initiatoriqn);\n        return -1;\n    }\n\n    /* Check again to make sure the interface was created. */\n    if (virStorageBackendIQNFound(initiatoriqn, &iface_name) != IQN_FOUND) {\n        VIR_DEBUG(\"Failed to find interface '%s' with IQN '%s' \"\n                  \"after attempting to create it\",\n                  &temp_ifacename[0], initiatoriqn);\n        return -1;\n    } else {\n        VIR_DEBUG(\"Interface '%s' with IQN '%s' was created successfully\",\n                  iface_name, initiatoriqn);\n    }\n\n    *ifacename = g_steal_pointer(&iface_name);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define IQN_FOUND 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&iface_name"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Interface '%s' with IQN '%s' was created successfully\"",
            "iface_name",
            "initiatoriqn"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to find interface '%s' with IQN '%s' \"\n                  \"after attempting to create it\"",
            "&temp_ifacename[0]",
            "initiatoriqn"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendIQNFound",
          "args": [
            "initiatoriqn",
            "&iface_name"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendIQNFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
          "lines": "119-201",
          "snippet": "static int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"viriscsi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define IQN_ERROR -1",
            "#define IQN_MISSING 0",
            "#define IQN_FOUND 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to run command '%s' to update iscsi interface with IQN '%s'\")",
            "ISCSIADM",
            "initiatoriqn"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to run command '%s' to update iscsi interface with IQN '%s'\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&exitstatus"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"iface\"",
            "\"--interface\"",
            "temp_ifacename",
            "\"--op\"",
            "\"update\"",
            "\"--name\"",
            "\"iface.initiatorname\"",
            "\"--value\"",
            "initiatoriqn",
            "NULL"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to run command '%s' to create new iscsi interface\")",
            "ISCSIADM"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Attempting to create interface '%s' with IQN '%s'\"",
            "temp_ifacename",
            "initiatoriqn"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virRandomBits",
          "args": [
            "32"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virRandomBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrandom.c",
          "lines": "50-64",
          "snippet": "uint64_t virRandomBits(int nbits)\n{\n    uint64_t ret = 0;\n\n    if (virRandomBytes((unsigned char *) &ret, sizeof(ret)) < 0) {\n        /* You're already hosed, so this particular non-random value\n         * isn't any worse.  */\n        return 0;\n    }\n\n    if (nbits < 64)\n        ret &= (1ULL << nbits) - 1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virrandom.h\"",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <inttypes.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virrandom.h\"\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <math.h>\n#include <inttypes.h>\n#include <config.h>\n\nuint64_t virRandomBits(int nbits)\n{\n    uint64_t ret = 0;\n\n    if (virRandomBytes((unsigned char *) &ret, sizeof(ret)) < 0) {\n        /* You're already hosed, so this particular non-random value\n         * isn't any worse.  */\n        return 0;\n    }\n\n    if (nbits < 64)\n        ret &= (1ULL << nbits) - 1;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendCreateIfaceIQN(const char *initiatoriqn,\n                                char **ifacename)\n{\n    int exitstatus = -1;\n    g_autofree char *iface_name = NULL;\n    g_autofree char *temp_ifacename = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    temp_ifacename = g_strdup_printf(\"libvirt-iface-%08llx\",\n                                     (unsigned long long)virRandomBits(32));\n\n    VIR_DEBUG(\"Attempting to create interface '%s' with IQN '%s'\",\n              temp_ifacename, initiatoriqn);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"new\",\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm\n     * tools returned an exit status of > 0, even if they succeeded.\n     * We will just rely on whether the interface got created\n     * properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to create new iscsi interface\"),\n                       ISCSIADM);\n        return -1;\n    }\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(ISCSIADM,\n                               \"--mode\", \"iface\",\n                               \"--interface\", temp_ifacename,\n                               \"--op\", \"update\",\n                               \"--name\", \"iface.initiatorname\",\n                               \"--value\",\n                               initiatoriqn,\n                               NULL);\n    /* Note that we ignore the exitstatus.  Older versions of iscsiadm tools\n     * returned an exit status of > 0, even if they succeeded.  We will just\n     * rely on whether iface file got updated properly. */\n    if (virCommandRun(cmd, &exitstatus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to run command '%s' to update iscsi interface with IQN '%s'\"),\n                       ISCSIADM, initiatoriqn);\n        return -1;\n    }\n\n    /* Check again to make sure the interface was created. */\n    if (virStorageBackendIQNFound(initiatoriqn, &iface_name) != IQN_FOUND) {\n        VIR_DEBUG(\"Failed to find interface '%s' with IQN '%s' \"\n                  \"after attempting to create it\",\n                  &temp_ifacename[0], initiatoriqn);\n        return -1;\n    } else {\n        VIR_DEBUG(\"Interface '%s' with IQN '%s' was created successfully\",\n                  iface_name, initiatoriqn);\n    }\n\n    *ifacename = g_steal_pointer(&iface_name);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendIQNFound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "119-201",
    "snippet": "static int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define IQN_ERROR -1",
      "#define IQN_MISSING 0",
      "#define IQN_FOUND 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed output of %s: %s\")",
            "ISCSIADM",
            "line"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed output of %s: %s\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not find interface with IQN '%s'\"",
            "iqn"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found interface '%s' with IQN '%s'\"",
            "*ifacename",
            "iqn"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&iface"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "iqn",
            "initiatoriqn"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "current",
            "','"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "current",
            "next - current"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "current",
            "' '"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "iqn"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "iface"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"iface\"",
            "NULL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\n#define IQN_ERROR -1\n#define IQN_MISSING 0\n#define IQN_FOUND 1\n\nstatic int\nvirStorageBackendIQNFound(const char *initiatoriqn,\n                          char **ifacename)\n{\n    int ret = IQN_ERROR;\n    char *line = NULL;\n    g_autofree char *outbuf = NULL;\n    g_autofree char *iface = NULL;\n    g_autofree char *iqn = NULL;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM,\n                                                       \"--mode\", \"iface\", NULL);\n\n    *ifacename = NULL;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    /* Example of data we are dealing with:\n     * default tcp,<empty>,<empty>,<empty>,<empty>\n     * iser iser,<empty>,<empty>,<empty>,<empty>\n     * libvirt-iface-253db048 tcp,<empty>,<empty>,<empty>,iqn.2017-03.com.user:client\n     */\n\n    line = outbuf;\n    while (line && *line) {\n        char *current = line;\n        char *newline;\n        char *next;\n        size_t i;\n\n        if (!(newline = strchr(line, '\\n')))\n            break;\n\n        *newline = '\\0';\n\n        VIR_FREE(iface);\n        VIR_FREE(iqn);\n\n        /* Find the first space, copy everything up to that point into\n         * iface and move past it to continue processing */\n        if (!(next = strchr(current, ' ')))\n            goto error;\n\n        iface = g_strndup(current, next - current);\n\n        current = next + 1;\n\n        /* There are five comma separated fields after iface and we only\n         * care about the last one, so we need to skip four commas and\n         * copy whatever's left into iqn */\n        for (i = 0; i < 4; i++) {\n            if (!(next = strchr(current, ',')))\n                goto error;\n            current = next + 1;\n        }\n\n        iqn = g_strdup(current);\n\n        if (STREQ(iqn, initiatoriqn)) {\n            *ifacename = g_steal_pointer(&iface);\n\n            VIR_DEBUG(\"Found interface '%s' with IQN '%s'\", *ifacename, iqn);\n            break;\n        }\n\n        line = newline + 1;\n    }\n\n    ret = *ifacename ? IQN_FOUND : IQN_MISSING;\n\n cleanup:\n    if (ret == IQN_MISSING)\n        VIR_DEBUG(\"Could not find interface with IQN '%s'\", iqn);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"malformed output of %s: %s\"),\n                   ISCSIADM, line);\n    goto cleanup;\n}"
  },
  {
    "function_name": "virISCSIGetSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "69-111",
    "snippet": "char *\nvirISCSIGetSession(const char *devpath,\n                   bool probe)\n{\n    /*\n     * # iscsiadm --mode session\n     * tcp: [1] 192.168.122.170:3260,1 demo-tgt-b\n     * tcp: [2] 192.168.122.170:3260,1 demo-tgt-a\n     *\n     * Pull out 2nd and 4th fields\n     */\n    const char *regexes[] = {\n        \"^tcp:\\\\s+\\\\[(\\\\S+)\\\\]\\\\s+\\\\S+\\\\s+(\\\\S+).*$\"\n    };\n    int vars[] = {\n        2,\n    };\n    struct virISCSISessionData cbdata = {\n        .session = NULL,\n        .devpath = devpath,\n    };\n    int exitstatus = 0;\n    g_autofree char *error = NULL;\n\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM, \"--mode\",\n                                                       \"session\", NULL);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIExtractSession,\n                           &cbdata, NULL, &exitstatus) < 0)\n        return NULL;\n\n    if (cbdata.session == NULL && !probe)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find iscsiadm session: %s\"),\n                       NULLSTR(error));\n\n    return cbdata.session;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot find iscsiadm session: %s\")",
            "NULLSTR(error)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "error"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot find iscsiadm session: %s\""
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRunRegex",
          "args": [
            "cmd",
            "1",
            "regexes",
            "vars",
            "virISCSIExtractSession",
            "&cbdata",
            "NULL",
            "&exitstatus"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunRegex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3341-3354",
          "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorBuffer",
          "args": [
            "cmd",
            "&error"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1903-1918",
          "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "ISCSIADM",
            "\"--mode\"",
            "\"session\"",
            "NULL"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nchar *\nvirISCSIGetSession(const char *devpath,\n                   bool probe)\n{\n    /*\n     * # iscsiadm --mode session\n     * tcp: [1] 192.168.122.170:3260,1 demo-tgt-b\n     * tcp: [2] 192.168.122.170:3260,1 demo-tgt-a\n     *\n     * Pull out 2nd and 4th fields\n     */\n    const char *regexes[] = {\n        \"^tcp:\\\\s+\\\\[(\\\\S+)\\\\]\\\\s+\\\\S+\\\\s+(\\\\S+).*$\"\n    };\n    int vars[] = {\n        2,\n    };\n    struct virISCSISessionData cbdata = {\n        .session = NULL,\n        .devpath = devpath,\n    };\n    int exitstatus = 0;\n    g_autofree char *error = NULL;\n\n    g_autoptr(virCommand) cmd = virCommandNewArgList(ISCSIADM, \"--mode\",\n                                                       \"session\", NULL);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virISCSIExtractSession,\n                           &cbdata, NULL, &exitstatus) < 0)\n        return NULL;\n\n    if (cbdata.session == NULL && !probe)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find iscsiadm session: %s\"),\n                       NULLSTR(error));\n\n    return cbdata.session;\n}"
  },
  {
    "function_name": "virISCSIExtractSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viriscsi.c",
    "lines": "54-66",
    "snippet": "static int\nvirISCSIExtractSession(char **const groups,\n                       void *opaque)\n{\n    struct virISCSISessionData *data = opaque;\n\n    if (!data->session &&\n        STREQ(groups[1], data->devpath)) {\n        data->session = g_strdup(groups[0]);\n        return 0;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"viriscsi.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "groups[0]"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "data->devpath"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"viriscsi.h\"\n#include <config.h>\n\nstatic int\nvirISCSIExtractSession(char **const groups,\n                       void *opaque)\n{\n    struct virISCSISessionData *data = opaque;\n\n    if (!data->session &&\n        STREQ(groups[1], data->devpath)) {\n        data->session = g_strdup(groups[0]);\n        return 0;\n    }\n    return 0;\n}"
  }
]