[
  {
    "function_name": "virNWFilterLearnShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "815-828",
    "snippet": "void\nvirNWFilterLearnShutdown(void)\n{\n    if (!pendingLearnReq)\n        return;\n\n    virNWFilterLearnThreadsTerminate(false);\n\n    virHashFree(pendingLearnReq);\n    pendingLearnReq = NULL;\n\n    virHashFree(ifaceLockMap);\n    ifaceLockMap = NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virHashTablePtr pendingLearnReq;",
      "static virHashTablePtr ifaceLockMap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "ifaceLockMap"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterLearnThreadsTerminate",
          "args": [
            "false"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterLearnThreadsTerminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "799-809",
          "snippet": "void\nvirNWFilterLearnThreadsTerminate(bool allowNewThreads)\n{\n    threadsTerminate = true;\n\n    while (virHashSize(pendingLearnReq) != 0)\n        g_usleep((PKT_TIMEOUT_MS * 1000) / 3);\n\n    if (allowNewThreads)\n        threadsTerminate = false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PKT_TIMEOUT_MS 500 /* ms */"
          ],
          "globals_used": [
            "static virHashTablePtr pendingLearnReq;",
            "static bool threadsTerminate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\n#define PKT_TIMEOUT_MS 500 /* ms */\n\nstatic virHashTablePtr pendingLearnReq;\nstatic bool threadsTerminate;\n\nvoid\nvirNWFilterLearnThreadsTerminate(bool allowNewThreads)\n{\n    threadsTerminate = true;\n\n    while (virHashSize(pendingLearnReq) != 0)\n        g_usleep((PKT_TIMEOUT_MS * 1000) / 3);\n\n    if (allowNewThreads)\n        threadsTerminate = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virHashTablePtr pendingLearnReq;\nstatic virHashTablePtr ifaceLockMap;\n\nvoid\nvirNWFilterLearnShutdown(void)\n{\n    if (!pendingLearnReq)\n        return;\n\n    virNWFilterLearnThreadsTerminate(false);\n\n    virHashFree(pendingLearnReq);\n    pendingLearnReq = NULL;\n\n    virHashFree(ifaceLockMap);\n    ifaceLockMap = NULL;\n}"
  },
  {
    "function_name": "virNWFilterLearnThreadsTerminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "799-809",
    "snippet": "void\nvirNWFilterLearnThreadsTerminate(bool allowNewThreads)\n{\n    threadsTerminate = true;\n\n    while (virHashSize(pendingLearnReq) != 0)\n        g_usleep((PKT_TIMEOUT_MS * 1000) / 3);\n\n    if (allowNewThreads)\n        threadsTerminate = false;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PKT_TIMEOUT_MS 500 /* ms */"
    ],
    "globals_used": [
      "static virHashTablePtr pendingLearnReq;",
      "static bool threadsTerminate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "(PKT_TIMEOUT_MS * 1000) / 3"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "pendingLearnReq"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\n#define PKT_TIMEOUT_MS 500 /* ms */\n\nstatic virHashTablePtr pendingLearnReq;\nstatic bool threadsTerminate;\n\nvoid\nvirNWFilterLearnThreadsTerminate(bool allowNewThreads)\n{\n    threadsTerminate = true;\n\n    while (virHashSize(pendingLearnReq) != 0)\n        g_usleep((PKT_TIMEOUT_MS * 1000) / 3);\n\n    if (allowNewThreads)\n        threadsTerminate = false;\n}"
  },
  {
    "function_name": "virNWFilterLearnInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "776-796",
    "snippet": "int\nvirNWFilterLearnInit(void)\n{\n    if (pendingLearnReq)\n        return 0;\n\n    VIR_DEBUG(\"Initializing IP address learning\");\n    threadsTerminate = false;\n\n    pendingLearnReq = virHashCreate(0, freeLearnReqEntry);\n    if (!pendingLearnReq)\n        return -1;\n\n    ifaceLockMap = virHashCreate(0, virHashValueFree);\n    if (!ifaceLockMap) {\n        virNWFilterLearnShutdown();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virHashTablePtr pendingLearnReq;",
      "static virHashTablePtr ifaceLockMap;",
      "static bool threadsTerminate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterLearnShutdown",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterLearnShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "815-828",
          "snippet": "void\nvirNWFilterLearnShutdown(void)\n{\n    if (!pendingLearnReq)\n        return;\n\n    virNWFilterLearnThreadsTerminate(false);\n\n    virHashFree(pendingLearnReq);\n    pendingLearnReq = NULL;\n\n    virHashFree(ifaceLockMap);\n    ifaceLockMap = NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virHashTablePtr pendingLearnReq;",
            "static virHashTablePtr ifaceLockMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virHashTablePtr pendingLearnReq;\nstatic virHashTablePtr ifaceLockMap;\n\nvoid\nvirNWFilterLearnShutdown(void)\n{\n    if (!pendingLearnReq)\n        return;\n\n    virNWFilterLearnThreadsTerminate(false);\n\n    virHashFree(pendingLearnReq);\n    pendingLearnReq = NULL;\n\n    virHashFree(ifaceLockMap);\n    ifaceLockMap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "0",
            "virHashValueFree"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Initializing IP address learning\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virHashTablePtr pendingLearnReq;\nstatic virHashTablePtr ifaceLockMap;\nstatic bool threadsTerminate;\n\nint\nvirNWFilterLearnInit(void)\n{\n    if (pendingLearnReq)\n        return 0;\n\n    VIR_DEBUG(\"Initializing IP address learning\");\n    threadsTerminate = false;\n\n    pendingLearnReq = virHashCreate(0, freeLearnReqEntry);\n    if (!pendingLearnReq)\n        return -1;\n\n    ifaceLockMap = virHashCreate(0, virHashValueFree);\n    if (!ifaceLockMap) {\n        virNWFilterLearnShutdown();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNWFilterLearnIPAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "756-768",
    "snippet": "int\nvirNWFilterLearnIPAddress(virNWFilterTechDriverPtr techdriver G_GNUC_UNUSED,\n                          virNWFilterBindingDefPtr binding G_GNUC_UNUSED,\n                          int ifindex G_GNUC_UNUSED,\n                          virNWFilterDriverStatePtr driver G_GNUC_UNUSED,\n                          int howDetect G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"IP parameter must be given since libvirt \"\n                     \"was not compiled with IP address learning \"\n                     \"support\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"IP parameter must be given since libvirt \"\n                     \"was not compiled with IP address learning \"\n                     \"support\")"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"IP parameter must be given since libvirt \"\n                     \"was not compiled with IP address learning \"\n                     \"support\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nint\nvirNWFilterLearnIPAddress(virNWFilterTechDriverPtr techdriver G_GNUC_UNUSED,\n                          virNWFilterBindingDefPtr binding G_GNUC_UNUSED,\n                          int ifindex G_GNUC_UNUSED,\n                          virNWFilterDriverStatePtr driver G_GNUC_UNUSED,\n                          int howDetect G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"IP parameter must be given since libvirt \"\n                     \"was not compiled with IP address learning \"\n                     \"support\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNWFilterLearnIPAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "699-752",
    "snippet": "int\nvirNWFilterLearnIPAddress(virNWFilterTechDriverPtr techdriver,\n                          virNWFilterBindingDefPtr binding,\n                          int ifindex,\n                          virNWFilterDriverStatePtr driver,\n                          int howDetect)\n{\n    int rc;\n    virThread thread;\n    virNWFilterIPAddrLearnReqPtr req = NULL;\n\n    if (howDetect == 0)\n        return -1;\n\n    if (!techdriver->canApplyBasicRules()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IP parameter must be provided since \"\n                         \"snooping the IP address does not work \"\n                         \"possibly due to missing tools\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(req) < 0)\n        return -1;\n\n    if (!(req->binding = virNWFilterBindingDefCopy(binding)))\n        goto err_free_req;\n\n    req->ifindex = ifindex;\n    req->driver = driver;\n    req->howDetect = howDetect;\n    req->techdriver = techdriver;\n\n    rc = virNWFilterRegisterLearnReq(req);\n\n    if (rc < 0)\n        goto err_free_req;\n\n    if (virThreadCreateFull(&thread,\n                            false,\n                            learnIPAddressThread,\n                            \"ip-learn\",\n                            false,\n                            req) != 0)\n        goto err_dereg_req;\n\n    return 0;\n\n err_dereg_req:\n    virNWFilterDeregisterLearnReq(ifindex);\n err_free_req:\n    virNWFilterIPAddrLearnReqFree(req);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterIPAddrLearnReqFree",
          "args": [
            "req"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIPAddrLearnReqFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "217-226",
          "snippet": "static void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterDeregisterLearnReq",
          "args": [
            "ifindex"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDeregisterLearnReq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "312-325",
          "snippet": "static virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr pendingLearnReq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nstatic virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&thread",
            "false",
            "learnIPAddressThread",
            "\"ip-learn\"",
            "false",
            "req"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRegisterLearnReq",
          "args": [
            "req"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRegisterLearnReq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "231-245",
          "snippet": "static int\nvirNWFilterRegisterLearnReq(virNWFilterIPAddrLearnReqPtr req)\n{\n    int res = -1;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", req->ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    if (!virHashLookup(pendingLearnReq, ifindex_str))\n        res = virHashAddEntry(pendingLearnReq, ifindex_str, req);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr pendingLearnReq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nstatic int\nvirNWFilterRegisterLearnReq(virNWFilterIPAddrLearnReqPtr req)\n{\n    int res = -1;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", req->ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    if (!virHashLookup(pendingLearnReq, ifindex_str))\n        res = virHashAddEntry(pendingLearnReq, ifindex_str, req);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterBindingDefCopy",
          "args": [
            "binding"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterBindingDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnwfilterbindingdef.c",
          "lines": "49-80",
          "snippet": "virNWFilterBindingDefPtr\nvirNWFilterBindingDefCopy(virNWFilterBindingDefPtr src)\n{\n    virNWFilterBindingDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->ownername = g_strdup(src->ownername);\n\n    memcpy(ret->owneruuid, src->owneruuid, sizeof(ret->owneruuid));\n\n    ret->portdevname = g_strdup(src->portdevname);\n\n    ret->linkdevname = g_strdup(src->linkdevname);\n\n    ret->mac = src->mac;\n\n    ret->filter = g_strdup(src->filter);\n\n    if (!(ret->filterparams = virNWFilterHashTableCreate(0)))\n        goto error;\n\n    if (virNWFilterHashTablePutAll(src->filterparams, ret->filterparams) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virNWFilterBindingDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virnwfilterbindingdef.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virnwfilterbindingdef.h\"\n#include \"nwfilter_params.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirNWFilterBindingDefPtr\nvirNWFilterBindingDefCopy(virNWFilterBindingDefPtr src)\n{\n    virNWFilterBindingDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->ownername = g_strdup(src->ownername);\n\n    memcpy(ret->owneruuid, src->owneruuid, sizeof(ret->owneruuid));\n\n    ret->portdevname = g_strdup(src->portdevname);\n\n    ret->linkdevname = g_strdup(src->linkdevname);\n\n    ret->mac = src->mac;\n\n    ret->filter = g_strdup(src->filter);\n\n    if (!(ret->filterparams = virNWFilterHashTableCreate(0)))\n        goto error;\n\n    if (virNWFilterHashTablePutAll(src->filterparams, ret->filterparams) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virNWFilterBindingDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "req"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"IP parameter must be provided since \"\n                         \"snooping the IP address does not work \"\n                         \"possibly due to missing tools\")"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"IP parameter must be provided since \"\n                         \"snooping the IP address does not work \"\n                         \"possibly due to missing tools\""
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "techdriver->canApplyBasicRules",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nint\nvirNWFilterLearnIPAddress(virNWFilterTechDriverPtr techdriver,\n                          virNWFilterBindingDefPtr binding,\n                          int ifindex,\n                          virNWFilterDriverStatePtr driver,\n                          int howDetect)\n{\n    int rc;\n    virThread thread;\n    virNWFilterIPAddrLearnReqPtr req = NULL;\n\n    if (howDetect == 0)\n        return -1;\n\n    if (!techdriver->canApplyBasicRules()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IP parameter must be provided since \"\n                         \"snooping the IP address does not work \"\n                         \"possibly due to missing tools\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(req) < 0)\n        return -1;\n\n    if (!(req->binding = virNWFilterBindingDefCopy(binding)))\n        goto err_free_req;\n\n    req->ifindex = ifindex;\n    req->driver = driver;\n    req->howDetect = howDetect;\n    req->techdriver = techdriver;\n\n    rc = virNWFilterRegisterLearnReq(req);\n\n    if (rc < 0)\n        goto err_free_req;\n\n    if (virThreadCreateFull(&thread,\n                            false,\n                            learnIPAddressThread,\n                            \"ip-learn\",\n                            false,\n                            req) != 0)\n        goto err_dereg_req;\n\n    return 0;\n\n err_dereg_req:\n    virNWFilterDeregisterLearnReq(ifindex);\n err_free_req:\n    virNWFilterIPAddrLearnReqFree(req);\n    return -1;\n}"
  },
  {
    "function_name": "learnIPAddressThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "382-680",
    "snippet": "static void\nlearnIPAddressThread(void *arg)\n{\n    char errbuf[PCAP_ERRBUF_SIZE] = {0};\n    pcap_t *handle = NULL;\n    struct bpf_program fp;\n    struct pcap_pkthdr header;\n    const u_char *packet;\n    struct ether_header *ether_hdr;\n    struct ether_vlan_header *vlan_hdr;\n    virNWFilterIPAddrLearnReqPtr req = arg;\n    uint32_t vmaddr = 0, bcastaddr = 0;\n    unsigned int ethHdrSize;\n    char *listen_if = (req->binding->linkdevname ?\n                       req->binding->linkdevname :\n                       req->binding->portdevname);\n    int dhcp_opts_len;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *filter = NULL;\n    uint16_t etherType;\n    bool showError = true;\n    enum howDetect howDetected = 0;\n    virNWFilterTechDriverPtr techdriver = req->techdriver;\n    struct pollfd fds[1];\n\n    if (virNWFilterLockIface(req->binding->portdevname) < 0)\n       goto err_no_lock;\n\n    req->status = 0;\n\n    /* anything change to the VM's interface -- check at least once */\n    if (virNetDevValidateConfig(req->binding->portdevname, NULL, req->ifindex) <= 0) {\n        virResetLastError();\n        req->status = ENODEV;\n        goto done;\n    }\n\n    handle = pcap_open_live(listen_if, BUFSIZ, 0, PKT_TIMEOUT_MS, errbuf);\n\n    if (handle == NULL) {\n        VIR_DEBUG(\"Couldn't open device %s: %s\", listen_if, errbuf);\n        req->status = ENODEV;\n        goto done;\n    }\n\n    fds[0].fd = pcap_fileno(handle);\n    fds[0].events = POLLIN | POLLERR;\n\n    virMacAddrFormat(&req->binding->mac, macaddr);\n\n    if (req->howDetect == DETECT_DHCP) {\n        if (techdriver->applyDHCPOnlyRules(req->binding->portdevname,\n                                           &req->binding->mac,\n                                           NULL, false) < 0) {\n            VIR_DEBUG(\"Unable to apply DHCP only rules\");\n            req->status = EINVAL;\n            goto done;\n        }\n        virBufferAddLit(&buf, \"src port 67 and dst port 68\");\n    } else {\n        if (techdriver->applyBasicRules(req->binding->portdevname,\n                                        &req->binding->mac) < 0) {\n            VIR_DEBUG(\"Unable to apply basic rules\");\n            req->status = EINVAL;\n            goto done;\n        }\n        virBufferAsprintf(&buf, \"ether host %s or ether dst ff:ff:ff:ff:ff:ff\",\n                          macaddr);\n    }\n\n    filter = virBufferContentAndReset(&buf);\n\n    if (pcap_compile(handle, &fp, filter, 1, 0) != 0) {\n        VIR_DEBUG(\"Couldn't compile filter '%s'\", filter);\n        req->status = EINVAL;\n        goto done;\n    }\n\n    if (pcap_setfilter(handle, &fp) != 0) {\n        VIR_DEBUG(\"Couldn't set filter '%s'\", filter);\n        req->status = EINVAL;\n        pcap_freecode(&fp);\n        goto done;\n    }\n\n    pcap_freecode(&fp);\n\n    while (req->status == 0 && vmaddr == 0) {\n        int n = poll(fds, G_N_ELEMENTS(fds), PKT_TIMEOUT_MS);\n\n        if (threadsTerminate || req->terminate) {\n            req->status = ECANCELED;\n            showError = false;\n            break;\n        }\n\n        if (n < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n\n            req->status = errno;\n            showError = true;\n            break;\n        }\n\n        if (n == 0)\n            continue;\n\n        if (fds[0].revents & (POLLHUP | POLLERR)) {\n            VIR_DEBUG(\"Error from FD probably dev deleted\");\n            req->status = ENODEV;\n            showError = false;\n            break;\n        }\n\n        packet = pcap_next(handle, &header);\n\n        if (!packet) {\n            /* Again, already handled above, but lets be sure */\n            if (virNetDevValidateConfig(req->binding->portdevname, NULL, req->ifindex) <= 0) {\n                virResetLastError();\n                req->status = ENODEV;\n                showError = false;\n                break;\n            }\n            continue;\n        }\n\n        if (header.len >= sizeof(struct ether_header)) {\n            ether_hdr = (struct ether_header*)packet;\n\n            switch (ntohs(ether_hdr->ether_type)) {\n\n            case ETHERTYPE_IP:\n                ethHdrSize = sizeof(struct ether_header);\n                etherType = ntohs(ether_hdr->ether_type);\n                break;\n\n            case ETHERTYPE_VLAN:\n                ethHdrSize = sizeof(struct ether_vlan_header);\n                vlan_hdr = (struct ether_vlan_header *)packet;\n                if (ntohs(vlan_hdr->ether_type) != ETHERTYPE_IP ||\n                    header.len < ethHdrSize)\n                    continue;\n                etherType = ntohs(vlan_hdr->ether_type);\n                break;\n\n            default:\n                continue;\n            }\n\n            if (virMacAddrCmpRaw(&req->binding->mac, ether_hdr->ether_shost) == 0) {\n                /* packets from the VM */\n\n                if (etherType == ETHERTYPE_IP &&\n                    (header.len >= ethHdrSize +\n                                   sizeof(struct iphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct iphdr *iphdr = (struct iphdr*)(packet +\n                                                          ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    vmaddr = iphdr->saddr;\n                    /* skip mcast addresses (224.0.0.0 - 239.255.255.255),\n                     * class E (240.0.0.0 - 255.255.255.255, includes eth.\n                     * bcast) and zero address in DHCP Requests */\n                    if ((ntohl(vmaddr) & 0xe0000000) == 0xe0000000 ||\n                        vmaddr == 0) {\n                        vmaddr = 0;\n                        continue;\n                    }\n\n                    howDetected = DETECT_STATIC;\n                } else if (etherType == ETHERTYPE_ARP &&\n                           (header.len >= ethHdrSize +\n                                          sizeof(struct f_arphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct f_arphdr *arphdr = (struct f_arphdr*)(packet +\n                                                         ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    switch (ntohs(arphdr->arphdr.ar_op)) {\n                    case ARPOP_REPLY:\n                        vmaddr = arphdr->ar_sip;\n                        howDetected = DETECT_STATIC;\n                    break;\n                    case ARPOP_REQUEST:\n                        vmaddr = arphdr->ar_tip;\n                        howDetected = DETECT_STATIC;\n                    break;\n                    }\n                }\n            } else if (virMacAddrCmpRaw(&req->binding->mac,\n                                        ether_hdr->ether_dhost) == 0 ||\n                       /* allow Broadcast replies from DHCP server */\n                       virMacAddrIsBroadcastRaw(ether_hdr->ether_dhost)) {\n                /* packets to the VM */\n                if (etherType == ETHERTYPE_IP &&\n                    (header.len >= ethHdrSize +\n                                   sizeof(struct iphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct iphdr *iphdr = (struct iphdr*)(packet +\n                                                          ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    if ((iphdr->protocol == IPPROTO_UDP) &&\n                        (header.len >= ethHdrSize +\n                                       iphdr->ihl * 4 +\n                                       sizeof(struct udphdr))) {\n                        VIR_WARNINGS_NO_CAST_ALIGN\n                        struct udphdr *udphdr = (struct udphdr *)\n                                          ((char *)iphdr + iphdr->ihl * 4);\n                        VIR_WARNINGS_RESET\n                        if (ntohs(udphdr->source) == 67 &&\n                            ntohs(udphdr->dest)   == 68 &&\n                            header.len >= ethHdrSize +\n                                          iphdr->ihl * 4 +\n                                          sizeof(struct udphdr) +\n                                          sizeof(struct dhcp)) {\n                            struct dhcp *dhcp = (struct dhcp *)\n                                        ((char *)udphdr + sizeof(udphdr));\n                            if (dhcp->op == 2 /* BOOTREPLY */ &&\n                                virMacAddrCmpRaw(\n                                        &req->binding->mac,\n                                        &dhcp->chaddr[0]) == 0) {\n                                dhcp_opts_len = header.len -\n                                    (ethHdrSize + iphdr->ihl * 4 +\n                                     sizeof(struct udphdr) +\n                                     sizeof(struct dhcp));\n                                procDHCPOpts(dhcp, dhcp_opts_len,\n                                             &vmaddr,\n                                             &bcastaddr,\n                                             &howDetected);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (vmaddr && (req->howDetect & howDetected) == 0) {\n            vmaddr = 0;\n            howDetected = 0;\n        }\n    } /* while */\n\n done:\n    VIR_FREE(filter);\n\n    if (handle)\n        pcap_close(handle);\n\n    if (req->status == 0) {\n        int ret;\n        virSocketAddr sa;\n        sa.len = sizeof(sa.data.inet4);\n        sa.data.inet4.sin_family = AF_INET;\n        sa.data.inet4.sin_addr.s_addr = vmaddr;\n        char *inetaddr;\n\n        /* It is necessary to unlock interface here to avoid updateMutex and\n         * interface ordering deadlocks. Otherwise we are going to\n         * instantiate the filter, which will try to lock updateMutex, and\n         * some other thread instantiating a filter in parallel is holding\n         * updateMutex and is trying to lock interface, both will deadlock.\n         * Also it is safe to unlock interface here because we stopped\n         * capturing and applied necessary rules on the interface, while\n         * instantiating a new filter doesn't require a locked interface.*/\n        virNWFilterUnlockIface(req->binding->portdevname);\n\n        if ((inetaddr = virSocketAddrFormat(&sa)) != NULL) {\n            if (virNWFilterIPAddrMapAddIPAddr(req->binding->portdevname, inetaddr) < 0) {\n                VIR_ERROR(_(\"Failed to add IP address %s to IP address \"\n                          \"cache for interface %s\"), inetaddr, req->binding->portdevname);\n            }\n\n            ret = virNWFilterInstantiateFilterLate(req->driver,\n                                                   req->binding,\n                                                   req->ifindex);\n            VIR_DEBUG(\"Result from applying firewall rules on \"\n                      \"%s with IP addr %s : %d\", req->binding->portdevname, inetaddr, ret);\n            VIR_FREE(inetaddr);\n        }\n    } else {\n        if (showError)\n            virReportSystemError(req->status,\n                                 _(\"encountered an error on interface %s \"\n                                   \"index %d\"),\n                                 req->binding->portdevname, req->ifindex);\n\n        techdriver->applyDropAllRules(req->binding->portdevname);\n        virNWFilterUnlockIface(req->binding->portdevname);\n    }\n\n    VIR_DEBUG(\"pcap thread terminating for interface %s\", req->binding->portdevname);\n\n\n err_no_lock:\n    virNWFilterDeregisterLearnReq(req->ifindex);\n\n    virNWFilterIPAddrLearnReqFree(req);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PKT_TIMEOUT_MS 500 /* ms */"
    ],
    "globals_used": [
      "struct dhcp {\n    uint8_t op;\n    uint8_t htype;\n    uint8_t hlen;\n    uint8_t hops;\n    uint32_t xid;\n    uint16_t secs;\n    uint16_t flags;\n    uint32_t ciaddr;\n    uint32_t yiaddr;\n    uint32_t siaddr;\n    uint32_t giaddr;\n    uint8_t chaddr[16];\n    uint8_t zeroes[192];\n    uint32_t magic;\n    struct dhcp_option options[0];\n} ATTRIBUTE_PACKED;",
      "static bool threadsTerminate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterIPAddrLearnReqFree",
          "args": [
            "req"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIPAddrLearnReqFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "217-226",
          "snippet": "static void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterDeregisterLearnReq",
          "args": [
            "req->ifindex"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDeregisterLearnReq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "312-325",
          "snippet": "static virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr pendingLearnReq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nstatic virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"pcap thread terminating for interface %s\"",
            "req->binding->portdevname"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterUnlockIface",
          "args": [
            "req->binding->portdevname"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterUnlockIface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "196-214",
          "snippet": "void\nvirNWFilterUnlockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n\n    if (ifaceLock) {\n        virMutexUnlock(&ifaceLock->lock);\n\n        ifaceLock->refctr--;\n        if (ifaceLock->refctr == 0)\n            virHashRemoveEntry(ifaceLockMap, ifname);\n    }\n\n    virMutexUnlock(&ifaceMapLock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr ifaceLockMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr ifaceLockMap;\n\nvoid\nvirNWFilterUnlockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n\n    if (ifaceLock) {\n        virMutexUnlock(&ifaceLock->lock);\n\n        ifaceLock->refctr--;\n        if (ifaceLock->refctr == 0)\n            virHashRemoveEntry(ifaceLockMap, ifname);\n    }\n\n    virMutexUnlock(&ifaceMapLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "techdriver->applyDropAllRules",
          "args": [
            "req->binding->portdevname"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "req->status",
            "_(\"encountered an error on interface %s \"\n                                   \"index %d\")",
            "req->binding->portdevname",
            "req->ifindex"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"encountered an error on interface %s \"\n                                   \"index %d\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "inetaddr"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Result from applying firewall rules on \"\n                      \"%s with IP addr %s : %d\"",
            "req->binding->portdevname",
            "inetaddr",
            "ret"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterInstantiateFilterLate",
          "args": [
            "req->driver",
            "req->binding",
            "req->ifindex"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterInstantiateFilterLate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "785-814",
          "snippet": "int\nvirNWFilterInstantiateFilterLate(virNWFilterDriverStatePtr driver,\n                                 virNWFilterBindingDefPtr binding,\n                                 int ifindex)\n{\n    int rc;\n    bool foundNewFilter = false;\n\n    virNWFilterReadLockFilterUpdates();\n    virMutexLock(&updateMutex);\n\n    rc = virNWFilterInstantiateFilterUpdate(driver, true,\n                                            binding, ifindex,\n                                            INSTANTIATE_ALWAYS, true,\n                                            &foundNewFilter);\n    if (rc < 0) {\n        /* something went wrong... 'DOWN' the interface */\n        if ((virNetDevValidateConfig(binding->portdevname, NULL, ifindex) <= 0) ||\n            (virNetDevSetOnline(binding->portdevname, false) < 0)) {\n            virResetLastError();\n            /* assuming interface disappeared... */\n            _virNWFilterTeardownFilter(binding->portdevname);\n        }\n    }\n\n    virNWFilterUnlockFilterUpdates();\n    virMutexUnlock(&updateMutex);\n\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex updateMutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virMutex updateMutex;\n\nint\nvirNWFilterInstantiateFilterLate(virNWFilterDriverStatePtr driver,\n                                 virNWFilterBindingDefPtr binding,\n                                 int ifindex)\n{\n    int rc;\n    bool foundNewFilter = false;\n\n    virNWFilterReadLockFilterUpdates();\n    virMutexLock(&updateMutex);\n\n    rc = virNWFilterInstantiateFilterUpdate(driver, true,\n                                            binding, ifindex,\n                                            INSTANTIATE_ALWAYS, true,\n                                            &foundNewFilter);\n    if (rc < 0) {\n        /* something went wrong... 'DOWN' the interface */\n        if ((virNetDevValidateConfig(binding->portdevname, NULL, ifindex) <= 0) ||\n            (virNetDevSetOnline(binding->portdevname, false) < 0)) {\n            virResetLastError();\n            /* assuming interface disappeared... */\n            _virNWFilterTeardownFilter(binding->portdevname);\n        }\n    }\n\n    virNWFilterUnlockFilterUpdates();\n    virMutexUnlock(&updateMutex);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to add IP address %s to IP address \"\n                          \"cache for interface %s\")",
            "inetaddr",
            "req->binding->portdevname"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterIPAddrMapAddIPAddr",
          "args": [
            "req->binding->portdevname",
            "inetaddr"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIPAddrMapAddIPAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_ipaddrmap.c",
          "lines": "49-83",
          "snippet": "int\nvirNWFilterIPAddrMapAddIPAddr(const char *ifname, char *addr)\n{\n    int ret = -1;\n    char *addrCopy;\n    virNWFilterVarValuePtr val;\n\n    addrCopy = g_strdup(addr);\n\n    virMutexLock(&ipAddressMapLock);\n\n    val = virHashLookup(ipAddressMap, ifname);\n    if (!val) {\n        val = virNWFilterVarValueCreateSimple(addrCopy);\n        if (!val)\n            goto cleanup;\n        addrCopy = NULL;\n        ret = virHashUpdateEntry(ipAddressMap, ifname, val);\n        if (ret < 0)\n            virNWFilterVarValueFree(val);\n        goto cleanup;\n    } else {\n        if (virNWFilterVarValueAddValue(val, addrCopy) < 0)\n            goto cleanup;\n        addrCopy = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&ipAddressMapLock);\n    VIR_FREE(addrCopy);\n\n    return ret;\n}",
          "includes": [
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex ipAddressMapLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr ipAddressMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virMutex ipAddressMapLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr ipAddressMap;\n\nint\nvirNWFilterIPAddrMapAddIPAddr(const char *ifname, char *addr)\n{\n    int ret = -1;\n    char *addrCopy;\n    virNWFilterVarValuePtr val;\n\n    addrCopy = g_strdup(addr);\n\n    virMutexLock(&ipAddressMapLock);\n\n    val = virHashLookup(ipAddressMap, ifname);\n    if (!val) {\n        val = virNWFilterVarValueCreateSimple(addrCopy);\n        if (!val)\n            goto cleanup;\n        addrCopy = NULL;\n        ret = virHashUpdateEntry(ipAddressMap, ifname, val);\n        if (ret < 0)\n            virNWFilterVarValueFree(val);\n        goto cleanup;\n    } else {\n        if (virNWFilterVarValueAddValue(val, addrCopy) < 0)\n            goto cleanup;\n        addrCopy = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&ipAddressMapLock);\n    VIR_FREE(addrCopy);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&sa"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcap_close",
          "args": [
            "handle"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filter"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "procDHCPOpts",
          "args": [
            "dhcp",
            "dhcp_opts_len",
            "&vmaddr",
            "&bcastaddr",
            "&howDetected"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "procDHCPOpts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "331-366",
          "snippet": "static void\nprocDHCPOpts(struct dhcp *dhcp, int dhcp_opts_len,\n             uint32_t *vmaddr, uint32_t *bcastaddr,\n             enum howDetect *howDetected)\n{\n    struct dhcp_option *dhcpopt = &dhcp->options[0];\n\n    while (dhcp_opts_len >= 2) {\n\n        switch (dhcpopt->code) {\n\n        case DHCP_OPT_BCASTADDRESS: /* Broadcast address */\n            if (dhcp_opts_len >= 6) {\n                VIR_WARNINGS_NO_CAST_ALIGN\n                uint32_t *tmp = (uint32_t *)&dhcpopt->value;\n                VIR_WARNINGS_RESET\n                (*bcastaddr) = ntohl(*tmp);\n            }\n        break;\n\n        case DHCP_OPT_MESSAGETYPE: /* Message type */\n            if (dhcp_opts_len >= 3) {\n                uint8_t *val = (uint8_t *)&dhcpopt->value;\n                switch (*val) {\n                case DHCP_MSGT_DHCPACK:\n                case DHCP_MSGT_DHCPOFFER:\n                    *vmaddr = dhcp->yiaddr;\n                    *howDetected = DETECT_DHCP;\n                break;\n                }\n            }\n        }\n        dhcp_opts_len -= (2 + dhcpopt->len);\n        dhcpopt = (struct dhcp_option*)((char *)dhcpopt + 2 + dhcpopt->len);\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DHCP_OPT_MESSAGETYPE  53",
            "#define DHCP_OPT_BCASTADDRESS 28",
            "#define DHCP_MSGT_DHCPACK   5",
            "#define DHCP_MSGT_DHCPOFFER 2"
          ],
          "globals_used": [
            "struct dhcp_option {\n    uint8_t code;\n    uint8_t len;\n    uint8_t value[0]; /* length varies */\n} ATTRIBUTE_PACKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\n#define DHCP_OPT_MESSAGETYPE  53\n#define DHCP_OPT_BCASTADDRESS 28\n#define DHCP_MSGT_DHCPACK   5\n#define DHCP_MSGT_DHCPOFFER 2\n\nstruct dhcp_option {\n    uint8_t code;\n    uint8_t len;\n    uint8_t value[0]; /* length varies */\n} ATTRIBUTE_PACKED;\n\nstatic void\nprocDHCPOpts(struct dhcp *dhcp, int dhcp_opts_len,\n             uint32_t *vmaddr, uint32_t *bcastaddr,\n             enum howDetect *howDetected)\n{\n    struct dhcp_option *dhcpopt = &dhcp->options[0];\n\n    while (dhcp_opts_len >= 2) {\n\n        switch (dhcpopt->code) {\n\n        case DHCP_OPT_BCASTADDRESS: /* Broadcast address */\n            if (dhcp_opts_len >= 6) {\n                VIR_WARNINGS_NO_CAST_ALIGN\n                uint32_t *tmp = (uint32_t *)&dhcpopt->value;\n                VIR_WARNINGS_RESET\n                (*bcastaddr) = ntohl(*tmp);\n            }\n        break;\n\n        case DHCP_OPT_MESSAGETYPE: /* Message type */\n            if (dhcp_opts_len >= 3) {\n                uint8_t *val = (uint8_t *)&dhcpopt->value;\n                switch (*val) {\n                case DHCP_MSGT_DHCPACK:\n                case DHCP_MSGT_DHCPOFFER:\n                    *vmaddr = dhcp->yiaddr;\n                    *howDetected = DETECT_DHCP;\n                break;\n                }\n            }\n        }\n        dhcp_opts_len -= (2 + dhcpopt->len);\n        dhcpopt = (struct dhcp_option*)((char *)dhcpopt + 2 + dhcpopt->len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrCmpRaw",
          "args": [
            "&req->binding->mac",
            "&dhcp->chaddr[0]"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrCmpRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "86-91",
          "snippet": "int\nvirMacAddrCmpRaw(const virMacAddr *mac1,\n                 const unsigned char mac2[VIR_MAC_BUFLEN])\n{\n    return memcmp(mac1->addr, mac2, VIR_MAC_BUFLEN);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrCmpRaw(const virMacAddr *mac1,\n                 const unsigned char mac2[VIR_MAC_BUFLEN])\n{\n    return memcmp(mac1->addr, mac2, VIR_MAC_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrIsBroadcastRaw",
          "args": [
            "ether_hdr->ether_dhost"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrIsBroadcastRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "244-248",
          "snippet": "bool\nvirMacAddrIsBroadcastRaw(const unsigned char s[VIR_MAC_BUFLEN])\n{\n    return memcmp(virMacAddrBroadcastAddrRaw, s, sizeof(*s)) == 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char virMacAddrBroadcastAddrRaw[VIR_MAC_BUFLEN] =\n    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nstatic const unsigned char virMacAddrBroadcastAddrRaw[VIR_MAC_BUFLEN] =\n    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\nbool\nvirMacAddrIsBroadcastRaw(const unsigned char s[VIR_MAC_BUFLEN])\n{\n    return memcmp(virMacAddrBroadcastAddrRaw, s, sizeof(*s)) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vmaddr"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "vlan_hdr->ether_type"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "vlan_hdr->ether_type"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "ether_hdr->ether_type"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "ether_hdr->ether_type"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevValidateConfig",
          "args": [
            "req->binding->portdevname",
            "NULL",
            "req->ifindex"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevValidateConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1050-1057",
          "snippet": "int virNetDevValidateConfig(const char *ifname G_GNUC_UNUSED,\n                            const virMacAddr *macaddr G_GNUC_UNUSED,\n                            int ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to check interface config on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevValidateConfig(const char *ifname G_GNUC_UNUSED,\n                            const virMacAddr *macaddr G_GNUC_UNUSED,\n                            int ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to check interface config on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcap_next",
          "args": [
            "handle",
            "&header"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Error from FD probably dev deleted\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "G_N_ELEMENTS(fds)",
            "PKT_TIMEOUT_MS"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "fds"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcap_freecode",
          "args": [
            "&fp"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcap_freecode",
          "args": [
            "&fp"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Couldn't set filter '%s'\"",
            "filter"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcap_setfilter",
          "args": [
            "handle",
            "&fp"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Couldn't compile filter '%s'\"",
            "filter"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcap_compile",
          "args": [
            "handle",
            "&fp",
            "filter",
            "1",
            "0"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"ether host %s or ether dst ff:ff:ff:ff:ff:ff\"",
            "macaddr"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to apply basic rules\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "techdriver->applyBasicRules",
          "args": [
            "req->binding->portdevname",
            "&req->binding->mac"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"src port 67 and dst port 68\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to apply DHCP only rules\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "techdriver->applyDHCPOnlyRules",
          "args": [
            "req->binding->portdevname",
            "&req->binding->mac",
            "NULL",
            "false"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&req->binding->mac",
            "macaddr"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcap_fileno",
          "args": [
            "handle"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Couldn't open device %s: %s\"",
            "listen_if",
            "errbuf"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcap_open_live",
          "args": [
            "listen_if",
            "BUFSIZ",
            "0",
            "PKT_TIMEOUT_MS",
            "errbuf"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterLockIface",
          "args": [
            "req->binding->portdevname"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterLockIface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "145-193",
          "snippet": "int\nvirNWFilterLockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n    if (!ifaceLock) {\n        if (VIR_ALLOC(ifaceLock) < 0)\n            goto err_exit;\n\n        if (virMutexInitRecursive(&ifaceLock->lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"mutex initialization failed\"));\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        if (virStrcpyStatic(ifaceLock->ifname, ifname) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"interface name %s does not fit into \"\n                             \"buffer \"),\n                           ifaceLock->ifname);\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        while (virHashAddEntry(ifaceLockMap, ifname, ifaceLock)) {\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        ifaceLock->refctr = 0;\n    }\n\n    ifaceLock->refctr++;\n\n    virMutexUnlock(&ifaceMapLock);\n\n    virMutexLock(&ifaceLock->lock);\n\n    return 0;\n\n err_exit:\n    virMutexUnlock(&ifaceMapLock);\n\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;",
            "static virHashTablePtr ifaceLockMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr ifaceLockMap;\n\nint\nvirNWFilterLockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n    if (!ifaceLock) {\n        if (VIR_ALLOC(ifaceLock) < 0)\n            goto err_exit;\n\n        if (virMutexInitRecursive(&ifaceLock->lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"mutex initialization failed\"));\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        if (virStrcpyStatic(ifaceLock->ifname, ifname) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"interface name %s does not fit into \"\n                             \"buffer \"),\n                           ifaceLock->ifname);\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        while (virHashAddEntry(ifaceLockMap, ifname, ifaceLock)) {\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        ifaceLock->refctr = 0;\n    }\n\n    ifaceLock->refctr++;\n\n    virMutexUnlock(&ifaceMapLock);\n\n    virMutexLock(&ifaceLock->lock);\n\n    return 0;\n\n err_exit:\n    virMutexUnlock(&ifaceMapLock);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\n#define PKT_TIMEOUT_MS 500 /* ms */\n\nstruct dhcp {\n    uint8_t op;\n    uint8_t htype;\n    uint8_t hlen;\n    uint8_t hops;\n    uint32_t xid;\n    uint16_t secs;\n    uint16_t flags;\n    uint32_t ciaddr;\n    uint32_t yiaddr;\n    uint32_t siaddr;\n    uint32_t giaddr;\n    uint8_t chaddr[16];\n    uint8_t zeroes[192];\n    uint32_t magic;\n    struct dhcp_option options[0];\n} ATTRIBUTE_PACKED;\nstatic bool threadsTerminate;\n\nstatic void\nlearnIPAddressThread(void *arg)\n{\n    char errbuf[PCAP_ERRBUF_SIZE] = {0};\n    pcap_t *handle = NULL;\n    struct bpf_program fp;\n    struct pcap_pkthdr header;\n    const u_char *packet;\n    struct ether_header *ether_hdr;\n    struct ether_vlan_header *vlan_hdr;\n    virNWFilterIPAddrLearnReqPtr req = arg;\n    uint32_t vmaddr = 0, bcastaddr = 0;\n    unsigned int ethHdrSize;\n    char *listen_if = (req->binding->linkdevname ?\n                       req->binding->linkdevname :\n                       req->binding->portdevname);\n    int dhcp_opts_len;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *filter = NULL;\n    uint16_t etherType;\n    bool showError = true;\n    enum howDetect howDetected = 0;\n    virNWFilterTechDriverPtr techdriver = req->techdriver;\n    struct pollfd fds[1];\n\n    if (virNWFilterLockIface(req->binding->portdevname) < 0)\n       goto err_no_lock;\n\n    req->status = 0;\n\n    /* anything change to the VM's interface -- check at least once */\n    if (virNetDevValidateConfig(req->binding->portdevname, NULL, req->ifindex) <= 0) {\n        virResetLastError();\n        req->status = ENODEV;\n        goto done;\n    }\n\n    handle = pcap_open_live(listen_if, BUFSIZ, 0, PKT_TIMEOUT_MS, errbuf);\n\n    if (handle == NULL) {\n        VIR_DEBUG(\"Couldn't open device %s: %s\", listen_if, errbuf);\n        req->status = ENODEV;\n        goto done;\n    }\n\n    fds[0].fd = pcap_fileno(handle);\n    fds[0].events = POLLIN | POLLERR;\n\n    virMacAddrFormat(&req->binding->mac, macaddr);\n\n    if (req->howDetect == DETECT_DHCP) {\n        if (techdriver->applyDHCPOnlyRules(req->binding->portdevname,\n                                           &req->binding->mac,\n                                           NULL, false) < 0) {\n            VIR_DEBUG(\"Unable to apply DHCP only rules\");\n            req->status = EINVAL;\n            goto done;\n        }\n        virBufferAddLit(&buf, \"src port 67 and dst port 68\");\n    } else {\n        if (techdriver->applyBasicRules(req->binding->portdevname,\n                                        &req->binding->mac) < 0) {\n            VIR_DEBUG(\"Unable to apply basic rules\");\n            req->status = EINVAL;\n            goto done;\n        }\n        virBufferAsprintf(&buf, \"ether host %s or ether dst ff:ff:ff:ff:ff:ff\",\n                          macaddr);\n    }\n\n    filter = virBufferContentAndReset(&buf);\n\n    if (pcap_compile(handle, &fp, filter, 1, 0) != 0) {\n        VIR_DEBUG(\"Couldn't compile filter '%s'\", filter);\n        req->status = EINVAL;\n        goto done;\n    }\n\n    if (pcap_setfilter(handle, &fp) != 0) {\n        VIR_DEBUG(\"Couldn't set filter '%s'\", filter);\n        req->status = EINVAL;\n        pcap_freecode(&fp);\n        goto done;\n    }\n\n    pcap_freecode(&fp);\n\n    while (req->status == 0 && vmaddr == 0) {\n        int n = poll(fds, G_N_ELEMENTS(fds), PKT_TIMEOUT_MS);\n\n        if (threadsTerminate || req->terminate) {\n            req->status = ECANCELED;\n            showError = false;\n            break;\n        }\n\n        if (n < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n\n            req->status = errno;\n            showError = true;\n            break;\n        }\n\n        if (n == 0)\n            continue;\n\n        if (fds[0].revents & (POLLHUP | POLLERR)) {\n            VIR_DEBUG(\"Error from FD probably dev deleted\");\n            req->status = ENODEV;\n            showError = false;\n            break;\n        }\n\n        packet = pcap_next(handle, &header);\n\n        if (!packet) {\n            /* Again, already handled above, but lets be sure */\n            if (virNetDevValidateConfig(req->binding->portdevname, NULL, req->ifindex) <= 0) {\n                virResetLastError();\n                req->status = ENODEV;\n                showError = false;\n                break;\n            }\n            continue;\n        }\n\n        if (header.len >= sizeof(struct ether_header)) {\n            ether_hdr = (struct ether_header*)packet;\n\n            switch (ntohs(ether_hdr->ether_type)) {\n\n            case ETHERTYPE_IP:\n                ethHdrSize = sizeof(struct ether_header);\n                etherType = ntohs(ether_hdr->ether_type);\n                break;\n\n            case ETHERTYPE_VLAN:\n                ethHdrSize = sizeof(struct ether_vlan_header);\n                vlan_hdr = (struct ether_vlan_header *)packet;\n                if (ntohs(vlan_hdr->ether_type) != ETHERTYPE_IP ||\n                    header.len < ethHdrSize)\n                    continue;\n                etherType = ntohs(vlan_hdr->ether_type);\n                break;\n\n            default:\n                continue;\n            }\n\n            if (virMacAddrCmpRaw(&req->binding->mac, ether_hdr->ether_shost) == 0) {\n                /* packets from the VM */\n\n                if (etherType == ETHERTYPE_IP &&\n                    (header.len >= ethHdrSize +\n                                   sizeof(struct iphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct iphdr *iphdr = (struct iphdr*)(packet +\n                                                          ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    vmaddr = iphdr->saddr;\n                    /* skip mcast addresses (224.0.0.0 - 239.255.255.255),\n                     * class E (240.0.0.0 - 255.255.255.255, includes eth.\n                     * bcast) and zero address in DHCP Requests */\n                    if ((ntohl(vmaddr) & 0xe0000000) == 0xe0000000 ||\n                        vmaddr == 0) {\n                        vmaddr = 0;\n                        continue;\n                    }\n\n                    howDetected = DETECT_STATIC;\n                } else if (etherType == ETHERTYPE_ARP &&\n                           (header.len >= ethHdrSize +\n                                          sizeof(struct f_arphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct f_arphdr *arphdr = (struct f_arphdr*)(packet +\n                                                         ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    switch (ntohs(arphdr->arphdr.ar_op)) {\n                    case ARPOP_REPLY:\n                        vmaddr = arphdr->ar_sip;\n                        howDetected = DETECT_STATIC;\n                    break;\n                    case ARPOP_REQUEST:\n                        vmaddr = arphdr->ar_tip;\n                        howDetected = DETECT_STATIC;\n                    break;\n                    }\n                }\n            } else if (virMacAddrCmpRaw(&req->binding->mac,\n                                        ether_hdr->ether_dhost) == 0 ||\n                       /* allow Broadcast replies from DHCP server */\n                       virMacAddrIsBroadcastRaw(ether_hdr->ether_dhost)) {\n                /* packets to the VM */\n                if (etherType == ETHERTYPE_IP &&\n                    (header.len >= ethHdrSize +\n                                   sizeof(struct iphdr))) {\n                    VIR_WARNINGS_NO_CAST_ALIGN\n                    struct iphdr *iphdr = (struct iphdr*)(packet +\n                                                          ethHdrSize);\n                    VIR_WARNINGS_RESET\n                    if ((iphdr->protocol == IPPROTO_UDP) &&\n                        (header.len >= ethHdrSize +\n                                       iphdr->ihl * 4 +\n                                       sizeof(struct udphdr))) {\n                        VIR_WARNINGS_NO_CAST_ALIGN\n                        struct udphdr *udphdr = (struct udphdr *)\n                                          ((char *)iphdr + iphdr->ihl * 4);\n                        VIR_WARNINGS_RESET\n                        if (ntohs(udphdr->source) == 67 &&\n                            ntohs(udphdr->dest)   == 68 &&\n                            header.len >= ethHdrSize +\n                                          iphdr->ihl * 4 +\n                                          sizeof(struct udphdr) +\n                                          sizeof(struct dhcp)) {\n                            struct dhcp *dhcp = (struct dhcp *)\n                                        ((char *)udphdr + sizeof(udphdr));\n                            if (dhcp->op == 2 /* BOOTREPLY */ &&\n                                virMacAddrCmpRaw(\n                                        &req->binding->mac,\n                                        &dhcp->chaddr[0]) == 0) {\n                                dhcp_opts_len = header.len -\n                                    (ethHdrSize + iphdr->ihl * 4 +\n                                     sizeof(struct udphdr) +\n                                     sizeof(struct dhcp));\n                                procDHCPOpts(dhcp, dhcp_opts_len,\n                                             &vmaddr,\n                                             &bcastaddr,\n                                             &howDetected);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (vmaddr && (req->howDetect & howDetected) == 0) {\n            vmaddr = 0;\n            howDetected = 0;\n        }\n    } /* while */\n\n done:\n    VIR_FREE(filter);\n\n    if (handle)\n        pcap_close(handle);\n\n    if (req->status == 0) {\n        int ret;\n        virSocketAddr sa;\n        sa.len = sizeof(sa.data.inet4);\n        sa.data.inet4.sin_family = AF_INET;\n        sa.data.inet4.sin_addr.s_addr = vmaddr;\n        char *inetaddr;\n\n        /* It is necessary to unlock interface here to avoid updateMutex and\n         * interface ordering deadlocks. Otherwise we are going to\n         * instantiate the filter, which will try to lock updateMutex, and\n         * some other thread instantiating a filter in parallel is holding\n         * updateMutex and is trying to lock interface, both will deadlock.\n         * Also it is safe to unlock interface here because we stopped\n         * capturing and applied necessary rules on the interface, while\n         * instantiating a new filter doesn't require a locked interface.*/\n        virNWFilterUnlockIface(req->binding->portdevname);\n\n        if ((inetaddr = virSocketAddrFormat(&sa)) != NULL) {\n            if (virNWFilterIPAddrMapAddIPAddr(req->binding->portdevname, inetaddr) < 0) {\n                VIR_ERROR(_(\"Failed to add IP address %s to IP address \"\n                          \"cache for interface %s\"), inetaddr, req->binding->portdevname);\n            }\n\n            ret = virNWFilterInstantiateFilterLate(req->driver,\n                                                   req->binding,\n                                                   req->ifindex);\n            VIR_DEBUG(\"Result from applying firewall rules on \"\n                      \"%s with IP addr %s : %d\", req->binding->portdevname, inetaddr, ret);\n            VIR_FREE(inetaddr);\n        }\n    } else {\n        if (showError)\n            virReportSystemError(req->status,\n                                 _(\"encountered an error on interface %s \"\n                                   \"index %d\"),\n                                 req->binding->portdevname, req->ifindex);\n\n        techdriver->applyDropAllRules(req->binding->portdevname);\n        virNWFilterUnlockIface(req->binding->portdevname);\n    }\n\n    VIR_DEBUG(\"pcap thread terminating for interface %s\", req->binding->portdevname);\n\n\n err_no_lock:\n    virNWFilterDeregisterLearnReq(req->ifindex);\n\n    virNWFilterIPAddrLearnReqFree(req);\n}"
  },
  {
    "function_name": "procDHCPOpts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "331-366",
    "snippet": "static void\nprocDHCPOpts(struct dhcp *dhcp, int dhcp_opts_len,\n             uint32_t *vmaddr, uint32_t *bcastaddr,\n             enum howDetect *howDetected)\n{\n    struct dhcp_option *dhcpopt = &dhcp->options[0];\n\n    while (dhcp_opts_len >= 2) {\n\n        switch (dhcpopt->code) {\n\n        case DHCP_OPT_BCASTADDRESS: /* Broadcast address */\n            if (dhcp_opts_len >= 6) {\n                VIR_WARNINGS_NO_CAST_ALIGN\n                uint32_t *tmp = (uint32_t *)&dhcpopt->value;\n                VIR_WARNINGS_RESET\n                (*bcastaddr) = ntohl(*tmp);\n            }\n        break;\n\n        case DHCP_OPT_MESSAGETYPE: /* Message type */\n            if (dhcp_opts_len >= 3) {\n                uint8_t *val = (uint8_t *)&dhcpopt->value;\n                switch (*val) {\n                case DHCP_MSGT_DHCPACK:\n                case DHCP_MSGT_DHCPOFFER:\n                    *vmaddr = dhcp->yiaddr;\n                    *howDetected = DETECT_DHCP;\n                break;\n                }\n            }\n        }\n        dhcp_opts_len -= (2 + dhcpopt->len);\n        dhcpopt = (struct dhcp_option*)((char *)dhcpopt + 2 + dhcpopt->len);\n    }\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DHCP_OPT_MESSAGETYPE  53",
      "#define DHCP_OPT_BCASTADDRESS 28",
      "#define DHCP_MSGT_DHCPACK   5",
      "#define DHCP_MSGT_DHCPOFFER 2"
    ],
    "globals_used": [
      "struct dhcp_option {\n    uint8_t code;\n    uint8_t len;\n    uint8_t value[0]; /* length varies */\n} ATTRIBUTE_PACKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*tmp"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARNINGS_RESET",
          "args": [
            "*bcastaddr"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\n#define DHCP_OPT_MESSAGETYPE  53\n#define DHCP_OPT_BCASTADDRESS 28\n#define DHCP_MSGT_DHCPACK   5\n#define DHCP_MSGT_DHCPOFFER 2\n\nstruct dhcp_option {\n    uint8_t code;\n    uint8_t len;\n    uint8_t value[0]; /* length varies */\n} ATTRIBUTE_PACKED;\n\nstatic void\nprocDHCPOpts(struct dhcp *dhcp, int dhcp_opts_len,\n             uint32_t *vmaddr, uint32_t *bcastaddr,\n             enum howDetect *howDetected)\n{\n    struct dhcp_option *dhcpopt = &dhcp->options[0];\n\n    while (dhcp_opts_len >= 2) {\n\n        switch (dhcpopt->code) {\n\n        case DHCP_OPT_BCASTADDRESS: /* Broadcast address */\n            if (dhcp_opts_len >= 6) {\n                VIR_WARNINGS_NO_CAST_ALIGN\n                uint32_t *tmp = (uint32_t *)&dhcpopt->value;\n                VIR_WARNINGS_RESET\n                (*bcastaddr) = ntohl(*tmp);\n            }\n        break;\n\n        case DHCP_OPT_MESSAGETYPE: /* Message type */\n            if (dhcp_opts_len >= 3) {\n                uint8_t *val = (uint8_t *)&dhcpopt->value;\n                switch (*val) {\n                case DHCP_MSGT_DHCPACK:\n                case DHCP_MSGT_DHCPOFFER:\n                    *vmaddr = dhcp->yiaddr;\n                    *howDetected = DETECT_DHCP;\n                break;\n                }\n            }\n        }\n        dhcp_opts_len -= (2 + dhcpopt->len);\n        dhcpopt = (struct dhcp_option*)((char *)dhcpopt + 2 + dhcpopt->len);\n    }\n}"
  },
  {
    "function_name": "virNWFilterDeregisterLearnReq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "312-325",
    "snippet": "static virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr pendingLearnReq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSteal",
          "args": [
            "pendingLearnReq",
            "ifindex_str"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "512-522",
          "snippet": "void *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d\"",
            "ifindex"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nstatic virNWFilterIPAddrLearnReqPtr\nvirNWFilterDeregisterLearnReq(int ifindex)\n{\n    virNWFilterIPAddrLearnReqPtr res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashSteal(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}"
  },
  {
    "function_name": "freeLearnReqEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "303-307",
    "snippet": "static void\nfreeLearnReqEntry(void *payload)\n{\n    virNWFilterIPAddrLearnReqFree(payload);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterIPAddrLearnReqFree",
          "args": [
            "payload"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIPAddrLearnReqFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
          "lines": "217-226",
          "snippet": "static void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"conf/nwfilter_params.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <net/if_arp.h>",
            "#include <net/ethernet.h>",
            "#include <poll.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "# include <pcap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic void\nfreeLearnReqEntry(void *payload)\n{\n    virNWFilterIPAddrLearnReqFree(payload);\n}"
  },
  {
    "function_name": "virNWFilterHasLearnReq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "287-300",
    "snippet": "bool\nvirNWFilterHasLearnReq(int ifindex)\n{\n    void *res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashLookup(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res != NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr pendingLearnReq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "pendingLearnReq",
            "ifindex_str"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d\"",
            "ifindex"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nbool\nvirNWFilterHasLearnReq(int ifindex)\n{\n    void *res;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    res = virHashLookup(pendingLearnReq, ifindex_str);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res != NULL;\n}"
  },
  {
    "function_name": "virNWFilterTerminateLearnReq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "250-284",
    "snippet": "int\nvirNWFilterTerminateLearnReq(const char *ifname)\n{\n    int rc = -1;\n    int ifindex;\n    virNWFilterIPAddrLearnReqPtr req;\n    g_autofree char *ifindex_str = NULL;\n\n    /* It's possible that it's already been removed as a result of\n     * virNWFilterDeregisterLearnReq during learnIPAddressThread() exit\n     */\n    if (virNetDevExists(ifname) != 1) {\n        virResetLastError();\n        return 0;\n    }\n\n    if (virNetDevGetIndex(ifname, &ifindex) < 0) {\n        virResetLastError();\n        return rc;\n    }\n\n    ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    req = virHashLookup(pendingLearnReq, ifindex_str);\n    if (req) {\n        rc = 0;\n        req->terminate = true;\n    }\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return rc;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr pendingLearnReq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "pendingLearnReq",
            "ifindex_str"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d\"",
            "ifindex"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetIndex",
          "args": [
            "ifname",
            "&ifindex"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "893-899",
          "snippet": "int virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevExists",
          "args": [
            "ifname"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "218-223",
          "snippet": "int virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nint\nvirNWFilterTerminateLearnReq(const char *ifname)\n{\n    int rc = -1;\n    int ifindex;\n    virNWFilterIPAddrLearnReqPtr req;\n    g_autofree char *ifindex_str = NULL;\n\n    /* It's possible that it's already been removed as a result of\n     * virNWFilterDeregisterLearnReq during learnIPAddressThread() exit\n     */\n    if (virNetDevExists(ifname) != 1) {\n        virResetLastError();\n        return 0;\n    }\n\n    if (virNetDevGetIndex(ifname, &ifindex) < 0) {\n        virResetLastError();\n        return rc;\n    }\n\n    ifindex_str = g_strdup_printf(\"%d\", ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    req = virHashLookup(pendingLearnReq, ifindex_str);\n    if (req) {\n        rc = 0;\n        req->terminate = true;\n    }\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return rc;\n}"
  },
  {
    "function_name": "virNWFilterRegisterLearnReq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "231-245",
    "snippet": "static int\nvirNWFilterRegisterLearnReq(virNWFilterIPAddrLearnReqPtr req)\n{\n    int res = -1;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", req->ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    if (!virHashLookup(pendingLearnReq, ifindex_str))\n        res = virHashAddEntry(pendingLearnReq, ifindex_str, req);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr pendingLearnReq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "pendingLearnReq",
            "ifindex_str",
            "req"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "pendingLearnReq",
            "ifindex_str"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pendingLearnReqLock"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d\"",
            "req->ifindex"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex pendingLearnReqLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr pendingLearnReq;\n\nstatic int\nvirNWFilterRegisterLearnReq(virNWFilterIPAddrLearnReqPtr req)\n{\n    int res = -1;\n    g_autofree char *ifindex_str = g_strdup_printf(\"%d\", req->ifindex);\n\n    virMutexLock(&pendingLearnReqLock);\n\n    if (!virHashLookup(pendingLearnReq, ifindex_str))\n        res = virHashAddEntry(pendingLearnReq, ifindex_str, req);\n\n    virMutexUnlock(&pendingLearnReqLock);\n\n    return res;\n}"
  },
  {
    "function_name": "virNWFilterIPAddrLearnReqFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "217-226",
    "snippet": "static void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "req"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterBindingDefFree",
          "args": [
            "req->binding"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterBindingDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnwfilterbindingdef.c",
          "lines": "33-46",
          "snippet": "void\nvirNWFilterBindingDefFree(virNWFilterBindingDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->ownername);\n    VIR_FREE(def->portdevname);\n    VIR_FREE(def->linkdevname);\n    VIR_FREE(def->filter);\n    virHashFree(def->filterparams);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virnwfilterbindingdef.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virnwfilterbindingdef.h\"\n#include \"nwfilter_params.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirNWFilterBindingDefFree(virNWFilterBindingDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->ownername);\n    VIR_FREE(def->portdevname);\n    VIR_FREE(def->linkdevname);\n    VIR_FREE(def->filter);\n    virHashFree(def->filterparams);\n\n    VIR_FREE(def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIPAddrLearnReqFree(virNWFilterIPAddrLearnReqPtr req)\n{\n    if (!req)\n        return;\n\n    virNWFilterBindingDefFree(req->binding);\n\n    VIR_FREE(req);\n}"
  },
  {
    "function_name": "virNWFilterUnlockIface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "196-214",
    "snippet": "void\nvirNWFilterUnlockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n\n    if (ifaceLock) {\n        virMutexUnlock(&ifaceLock->lock);\n\n        ifaceLock->refctr--;\n        if (ifaceLock->refctr == 0)\n            virHashRemoveEntry(ifaceLockMap, ifname);\n    }\n\n    virMutexUnlock(&ifaceMapLock);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr ifaceLockMap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&ifaceMapLock"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "ifaceLockMap",
            "ifname"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "ifaceLockMap",
            "ifname"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&ifaceMapLock"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr ifaceLockMap;\n\nvoid\nvirNWFilterUnlockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n\n    if (ifaceLock) {\n        virMutexUnlock(&ifaceLock->lock);\n\n        ifaceLock->refctr--;\n        if (ifaceLock->refctr == 0)\n            virHashRemoveEntry(ifaceLockMap, ifname);\n    }\n\n    virMutexUnlock(&ifaceMapLock);\n}"
  },
  {
    "function_name": "virNWFilterLockIface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_learnipaddr.c",
    "lines": "145-193",
    "snippet": "int\nvirNWFilterLockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n    if (!ifaceLock) {\n        if (VIR_ALLOC(ifaceLock) < 0)\n            goto err_exit;\n\n        if (virMutexInitRecursive(&ifaceLock->lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"mutex initialization failed\"));\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        if (virStrcpyStatic(ifaceLock->ifname, ifname) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"interface name %s does not fit into \"\n                             \"buffer \"),\n                           ifaceLock->ifname);\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        while (virHashAddEntry(ifaceLockMap, ifname, ifaceLock)) {\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        ifaceLock->refctr = 0;\n    }\n\n    ifaceLock->refctr++;\n\n    virMutexUnlock(&ifaceMapLock);\n\n    virMutexLock(&ifaceLock->lock);\n\n    return 0;\n\n err_exit:\n    virMutexUnlock(&ifaceMapLock);\n\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"nwfilter_learnipaddr.h\"",
      "#include \"nwfilter_ipaddrmap.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"conf/nwfilter_params.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdev.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <net/if_arp.h>",
      "#include <net/ethernet.h>",
      "#include <poll.h>",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "# include <pcap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;",
      "static virHashTablePtr ifaceLockMap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&ifaceMapLock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&ifaceLock->lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ifaceLock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "ifaceLockMap",
            "ifname",
            "ifaceLock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ifaceLock"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"interface name %s does not fit into \"\n                             \"buffer \")",
            "ifaceLock->ifname"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"interface name %s does not fit into \"\n                             \"buffer \""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "ifaceLock->ifname",
            "ifname"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ifaceLock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"mutex initialization failed\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInitRecursive",
          "args": [
            "&ifaceLock->lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ifaceLock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "ifaceLockMap",
            "ifname"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"conf/domain_conf.h\"\n#include \"conf/nwfilter_params.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <net/if_arp.h>\n#include <net/ethernet.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n# include <pcap.h>\n#include <config.h>\n\nstatic virMutex ifaceMapLock = VIR_MUTEX_INITIALIZER;\nstatic virHashTablePtr ifaceLockMap;\n\nint\nvirNWFilterLockIface(const char *ifname)\n{\n    virNWFilterIfaceLockPtr ifaceLock;\n\n    virMutexLock(&ifaceMapLock);\n\n    ifaceLock = virHashLookup(ifaceLockMap, ifname);\n    if (!ifaceLock) {\n        if (VIR_ALLOC(ifaceLock) < 0)\n            goto err_exit;\n\n        if (virMutexInitRecursive(&ifaceLock->lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"mutex initialization failed\"));\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        if (virStrcpyStatic(ifaceLock->ifname, ifname) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"interface name %s does not fit into \"\n                             \"buffer \"),\n                           ifaceLock->ifname);\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        while (virHashAddEntry(ifaceLockMap, ifname, ifaceLock)) {\n            VIR_FREE(ifaceLock);\n            goto err_exit;\n        }\n\n        ifaceLock->refctr = 0;\n    }\n\n    ifaceLock->refctr++;\n\n    virMutexUnlock(&ifaceMapLock);\n\n    virMutexLock(&ifaceLock->lock);\n\n    return 0;\n\n err_exit:\n    virMutexUnlock(&ifaceMapLock);\n\n    return -1;\n}"
  }
]