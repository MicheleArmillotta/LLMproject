[
  {
    "function_name": "hypervRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1638-1646",
    "snippet": "int\nhypervRegister(void)\n{\n    /* Forward openwsman errors and warnings to libvirt's logging */\n    debug_add_handler(hypervDebugHandler, DEBUG_LEVEL_WARNING, NULL);\n\n    return virRegisterConnectDriver(&hypervConnectDriver,\n                                    false);\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectDriver hypervConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"hyperv\", NULL },\n    .hypervisorDriver = &hypervHypervisorDriver,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&hypervConnectDriver",
            "false"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_add_handler",
          "args": [
            "hypervDebugHandler",
            "DEBUG_LEVEL_WARNING",
            "NULL"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virConnectDriver hypervConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"hyperv\", NULL },\n    .hypervisorDriver = &hypervHypervisorDriver,\n};\n\nint\nhypervRegister(void)\n{\n    /* Forward openwsman errors and warnings to libvirt's logging */\n    debug_add_handler(hypervDebugHandler, DEBUG_LEVEL_WARNING, NULL);\n\n    return virRegisterConnectDriver(&hypervConnectDriver,\n                                    false);\n}"
  },
  {
    "function_name": "hypervDebugHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1597-1629",
    "snippet": "static void\nhypervDebugHandler(const char *message, debug_level_e level,\n                   void *user_data G_GNUC_UNUSED)\n{\n    switch (level) {\n      case DEBUG_LEVEL_ERROR:\n      case DEBUG_LEVEL_CRITICAL:\n      case DEBUG_LEVEL_ALWAYS:\n        VIR_ERROR(_(\"openwsman: %s\"), message);\n        break;\n\n      case DEBUG_LEVEL_WARNING:\n        VIR_WARN(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_MESSAGE:\n        VIR_INFO(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_INFO:\n        VIR_INFO(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_DEBUG:\n        VIR_DEBUG(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_NONE:\n      default:\n        /* Ignore the rest */\n        break;\n    }\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"openwsman: %s\"",
            "message"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"openwsman: %s\"",
            "message"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"openwsman: %s\"",
            "message"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"openwsman: %s\"",
            "message"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"openwsman: %s\")",
            "message"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"openwsman: %s\""
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nhypervDebugHandler(const char *message, debug_level_e level,\n                   void *user_data G_GNUC_UNUSED)\n{\n    switch (level) {\n      case DEBUG_LEVEL_ERROR:\n      case DEBUG_LEVEL_CRITICAL:\n      case DEBUG_LEVEL_ALWAYS:\n        VIR_ERROR(_(\"openwsman: %s\"), message);\n        break;\n\n      case DEBUG_LEVEL_WARNING:\n        VIR_WARN(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_MESSAGE:\n        VIR_INFO(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_INFO:\n        VIR_INFO(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_DEBUG:\n        VIR_DEBUG(\"openwsman: %s\", message);\n        break;\n\n      case DEBUG_LEVEL_NONE:\n      default:\n        /* Ignore the rest */\n        break;\n    }\n}"
  },
  {
    "function_name": "hypervDomainSetMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1549-1553",
    "snippet": "static int\nhypervDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    return hypervDomainSetMemoryFlags(domain, memory, 0);\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervDomainSetMemoryFlags",
          "args": [
            "domain",
            "memory",
            "0"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "hypervDomainSetMemoryFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "1445-1546",
          "snippet": "static int\nhypervDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n        unsigned int flags)\n{\n    int result = -1;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    hypervPrivate *priv = domain->conn->privateData;\n    char *memory_str = NULL;\n    hypervInvokeParamsListPtr params = NULL;\n    unsigned long memory_mb = VIR_ROUND_UP(VIR_DIV_UP(memory, 1024), 2);\n    Msvm_VirtualSystemSettingData *vssd = NULL;\n    Msvm_MemorySettingData *memsd = NULL;\n    virBuffer eprQuery = VIR_BUFFER_INITIALIZER;\n    virHashTablePtr memResource = NULL;\n\n    virCheckFlags(0, -1);\n\n    memory_str = g_strdup_printf(\"%lu\", memory_mb);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataFromUUID(priv, uuid_string, &vssd) < 0)\n        goto cleanup;\n\n    if (hypervGetMsvmMemorySettingDataFromVSSD(priv, vssd->data.common->InstanceID,\n                &memsd) < 0)\n        goto cleanup;\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyVirtualSystemResources\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n\n        virBufferAddLit(&eprQuery, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferEscapeSQL(&eprQuery, \"where Name = \\\"%s\\\"\", uuid_string);\n\n        if (hypervAddEprParam(params, \"ComputerSystem\", priv, &eprQuery,\n                    Msvm_ComputerSystem_WmiInfo) < 0)\n            goto params_cleanup;\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyResourceSettings\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n    }\n\n    memResource = hypervCreateEmbeddedParam(priv, Msvm_MemorySettingData_WmiInfo);\n    if (!memResource)\n        goto params_cleanup;\n\n    if (hypervSetEmbeddedProperty(memResource, \"VirtualQuantity\", memory_str) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (hypervSetEmbeddedProperty(memResource, \"InstanceID\",\n                memsd->data.common->InstanceID) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettingData\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettings\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n    }\n\n    if (hypervInvokeMethod(priv, params, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not set memory\"));\n        goto cleanup;\n    }\n\n    result = 0;\n    goto cleanup;\n\n params_cleanup:\n    hypervFreeInvokeParams(params);\n    virBufferFreeAndReset(&eprQuery);\n cleanup:\n    VIR_FREE(memory_str);\n    hypervFreeObject(priv, (hypervObject *)vssd);\n    hypervFreeObject(priv, (hypervObject *)memsd);\n    return result;\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n        unsigned int flags)\n{\n    int result = -1;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    hypervPrivate *priv = domain->conn->privateData;\n    char *memory_str = NULL;\n    hypervInvokeParamsListPtr params = NULL;\n    unsigned long memory_mb = VIR_ROUND_UP(VIR_DIV_UP(memory, 1024), 2);\n    Msvm_VirtualSystemSettingData *vssd = NULL;\n    Msvm_MemorySettingData *memsd = NULL;\n    virBuffer eprQuery = VIR_BUFFER_INITIALIZER;\n    virHashTablePtr memResource = NULL;\n\n    virCheckFlags(0, -1);\n\n    memory_str = g_strdup_printf(\"%lu\", memory_mb);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataFromUUID(priv, uuid_string, &vssd) < 0)\n        goto cleanup;\n\n    if (hypervGetMsvmMemorySettingDataFromVSSD(priv, vssd->data.common->InstanceID,\n                &memsd) < 0)\n        goto cleanup;\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyVirtualSystemResources\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n\n        virBufferAddLit(&eprQuery, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferEscapeSQL(&eprQuery, \"where Name = \\\"%s\\\"\", uuid_string);\n\n        if (hypervAddEprParam(params, \"ComputerSystem\", priv, &eprQuery,\n                    Msvm_ComputerSystem_WmiInfo) < 0)\n            goto params_cleanup;\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyResourceSettings\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n    }\n\n    memResource = hypervCreateEmbeddedParam(priv, Msvm_MemorySettingData_WmiInfo);\n    if (!memResource)\n        goto params_cleanup;\n\n    if (hypervSetEmbeddedProperty(memResource, \"VirtualQuantity\", memory_str) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (hypervSetEmbeddedProperty(memResource, \"InstanceID\",\n                memsd->data.common->InstanceID) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettingData\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettings\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n    }\n\n    if (hypervInvokeMethod(priv, params, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not set memory\"));\n        goto cleanup;\n    }\n\n    result = 0;\n    goto cleanup;\n\n params_cleanup:\n    hypervFreeInvokeParams(params);\n    virBufferFreeAndReset(&eprQuery);\n cleanup:\n    VIR_FREE(memory_str);\n    hypervFreeObject(priv, (hypervObject *)vssd);\n    hypervFreeObject(priv, (hypervObject *)memsd);\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    return hypervDomainSetMemoryFlags(domain, memory, 0);\n}"
  },
  {
    "function_name": "hypervDomainSetMemoryFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1445-1546",
    "snippet": "static int\nhypervDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n        unsigned int flags)\n{\n    int result = -1;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    hypervPrivate *priv = domain->conn->privateData;\n    char *memory_str = NULL;\n    hypervInvokeParamsListPtr params = NULL;\n    unsigned long memory_mb = VIR_ROUND_UP(VIR_DIV_UP(memory, 1024), 2);\n    Msvm_VirtualSystemSettingData *vssd = NULL;\n    Msvm_MemorySettingData *memsd = NULL;\n    virBuffer eprQuery = VIR_BUFFER_INITIALIZER;\n    virHashTablePtr memResource = NULL;\n\n    virCheckFlags(0, -1);\n\n    memory_str = g_strdup_printf(\"%lu\", memory_mb);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataFromUUID(priv, uuid_string, &vssd) < 0)\n        goto cleanup;\n\n    if (hypervGetMsvmMemorySettingDataFromVSSD(priv, vssd->data.common->InstanceID,\n                &memsd) < 0)\n        goto cleanup;\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyVirtualSystemResources\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n\n        virBufferAddLit(&eprQuery, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferEscapeSQL(&eprQuery, \"where Name = \\\"%s\\\"\", uuid_string);\n\n        if (hypervAddEprParam(params, \"ComputerSystem\", priv, &eprQuery,\n                    Msvm_ComputerSystem_WmiInfo) < 0)\n            goto params_cleanup;\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyResourceSettings\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n    }\n\n    memResource = hypervCreateEmbeddedParam(priv, Msvm_MemorySettingData_WmiInfo);\n    if (!memResource)\n        goto params_cleanup;\n\n    if (hypervSetEmbeddedProperty(memResource, \"VirtualQuantity\", memory_str) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (hypervSetEmbeddedProperty(memResource, \"InstanceID\",\n                memsd->data.common->InstanceID) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettingData\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettings\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n    }\n\n    if (hypervInvokeMethod(priv, params, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not set memory\"));\n        goto cleanup;\n    }\n\n    result = 0;\n    goto cleanup;\n\n params_cleanup:\n    hypervFreeInvokeParams(params);\n    virBufferFreeAndReset(&eprQuery);\n cleanup:\n    VIR_FREE(memory_str);\n    hypervFreeObject(priv, (hypervObject *)vssd);\n    hypervFreeObject(priv, (hypervObject *)memsd);\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)memsd"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "memory_str"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&eprQuery"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeInvokeParams",
          "args": [
            "params"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeInvokeParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "202-231",
          "snippet": "void\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not set memory\")"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not set memory\""
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMethod",
          "args": [
            "priv",
            "params",
            "NULL"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMethod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "765-946",
          "snippet": "int\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HYPERV_JOB_TIMEOUT_MS 300000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define HYPERV_JOB_TIMEOUT_MS 300000\n\nint\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeEmbeddedParam",
          "args": [
            "memResource"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeEmbeddedParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "403-407",
          "snippet": "void\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervAddEmbeddedParam",
          "args": [
            "params",
            "priv",
            "\"ResourceSettings\"",
            "memResource",
            "Msvm_MemorySettingData_WmiInfo"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "hypervAddEmbeddedParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "373-395",
          "snippet": "int\nhypervAddEmbeddedParam(hypervInvokeParamsListPtr params, hypervPrivate *priv,\n        const char *name, virHashTablePtr table, hypervWmiClassInfoListPtr info)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EMBEDDED_PARAM;\n    p->embedded.name = name;\n    p->embedded.table = table;\n    p->embedded.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddEmbeddedParam(hypervInvokeParamsListPtr params, hypervPrivate *priv,\n        const char *name, virHashTablePtr table, hypervWmiClassInfoListPtr info)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EMBEDDED_PARAM;\n    p->embedded.name = name;\n    p->embedded.table = table;\n    p->embedded.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervSetEmbeddedProperty",
          "args": [
            "memResource",
            "\"InstanceID\"",
            "memsd->data.common->InstanceID"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "hypervSetEmbeddedProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "356-360",
          "snippet": "int\nhypervSetEmbeddedProperty(virHashTablePtr table, const char *name, char *value)\n{\n    return virHashUpdateEntry(table, name, value);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervSetEmbeddedProperty(virHashTablePtr table, const char *name, char *value)\n{\n    return virHashUpdateEntry(table, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervCreateEmbeddedParam",
          "args": [
            "priv",
            "Msvm_MemorySettingData_WmiInfo"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCreateEmbeddedParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "318-354",
          "snippet": "virHashTablePtr\nhypervCreateEmbeddedParam(hypervPrivate *priv, hypervWmiClassInfoListPtr info)\n{\n    size_t i;\n    int count = 0;\n    virHashTablePtr table = NULL;\n    XmlSerializerInfo *typeinfo = NULL;\n    XmlSerializerInfo *item = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        goto error;\n\n    typeinfo = classInfo->serializerInfo;\n\n    /* loop through the items to find out how many fields there are */\n    for (i = 0; typeinfo[i].name != NULL; i++) {}\n    count = i;\n\n    table = virHashCreate(count, NULL);\n    if (table == NULL)\n        goto error;\n\n    for (i = 0; typeinfo[i].name != NULL; i++) {\n        item = &typeinfo[i];\n\n        if (virHashAddEntry(table, item->name, NULL) < 0)\n            goto error;\n    }\n\n    return table;\n\n error:\n    virHashFree(table);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvirHashTablePtr\nhypervCreateEmbeddedParam(hypervPrivate *priv, hypervWmiClassInfoListPtr info)\n{\n    size_t i;\n    int count = 0;\n    virHashTablePtr table = NULL;\n    XmlSerializerInfo *typeinfo = NULL;\n    XmlSerializerInfo *item = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        goto error;\n\n    typeinfo = classInfo->serializerInfo;\n\n    /* loop through the items to find out how many fields there are */\n    for (i = 0; typeinfo[i].name != NULL; i++) {}\n    count = i;\n\n    table = virHashCreate(count, NULL);\n    if (table == NULL)\n        goto error;\n\n    for (i = 0; typeinfo[i].name != NULL; i++) {\n        item = &typeinfo[i];\n\n        if (virHashAddEntry(table, item->name, NULL) < 0)\n            goto error;\n    }\n\n    return table;\n\n error:\n    virHashFree(table);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create params\")"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervCreateInvokeParamsList",
          "args": [
            "priv",
            "\"ModifyResourceSettings\"",
            "MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR",
            "Msvm_VirtualSystemManagementService_WmiInfo"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCreateInvokeParamsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "168-195",
          "snippet": "hypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nhypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervAddEprParam",
          "args": [
            "params",
            "\"ComputerSystem\"",
            "priv",
            "&eprQuery",
            "Msvm_ComputerSystem_WmiInfo"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "hypervAddEprParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "285-305",
          "snippet": "int\nhypervAddEprParam(hypervInvokeParamsListPtr params, const char *name,\n        hypervPrivate *priv, virBufferPtr query,\n        hypervWmiClassInfoListPtr eprInfo)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervGetWmiClassInfo(priv, eprInfo, &classInfo) < 0 ||\n            hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EPR_PARAM;\n    p->epr.name = name;\n    p->epr.query = query;\n    p->epr.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddEprParam(hypervInvokeParamsListPtr params, const char *name,\n        hypervPrivate *priv, virBufferPtr query,\n        hypervWmiClassInfoListPtr eprInfo)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervGetWmiClassInfo(priv, eprInfo, &classInfo) < 0 ||\n            hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EPR_PARAM;\n    p->epr.name = name;\n    p->epr.query = query;\n    p->epr.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&eprQuery",
            "\"where Name = \\\"%s\\\"\"",
            "uuid_string"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&eprQuery",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create params\")"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmMemorySettingDataFromVSSD",
          "args": [
            "priv",
            "vssd->data.common->InstanceID",
            "&memsd"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmMemorySettingDataFromVSSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1613-1631",
          "snippet": "int\nhypervGetMsvmMemorySettingDataFromVSSD(hypervPrivate *priv,\n        const char *vssd_instanceid, Msvm_MemorySettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n            \"ResultClass = Msvm_MemorySettingData\",\n            vssd_instanceid);\n\n    if (hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmMemorySettingDataFromVSSD(hypervPrivate *priv,\n        const char *vssd_instanceid, Msvm_MemorySettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n            \"ResultClass = Msvm_MemorySettingData\",\n            vssd_instanceid);\n\n    if (hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmVirtualSystemSettingDataFromUUID",
          "args": [
            "priv",
            "uuid_string",
            "&vssd"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmVirtualSystemSettingDataFromUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1587-1606",
          "snippet": "int\nhypervGetMsvmVirtualSystemSettingDataFromUUID(hypervPrivate *priv,\n        const char *uuid_string, Msvm_VirtualSystemSettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_SettingsDefineState \"\n            \"ResultClass = Msvm_VirtualSystemSettingData\",\n            uuid_string);\n\n    if (hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmVirtualSystemSettingDataFromUUID(hypervPrivate *priv,\n        const char *uuid_string, Msvm_VirtualSystemSettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_SettingsDefineState \"\n            \"ResultClass = Msvm_VirtualSystemSettingData\",\n            uuid_string);\n\n    if (hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ROUND_UP",
          "args": [
            "VIR_DIV_UP(memory, 1024)",
            "2"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "memory",
            "1024"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainSetMemoryFlags(virDomainPtr domain, unsigned long memory,\n        unsigned int flags)\n{\n    int result = -1;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    hypervPrivate *priv = domain->conn->privateData;\n    char *memory_str = NULL;\n    hypervInvokeParamsListPtr params = NULL;\n    unsigned long memory_mb = VIR_ROUND_UP(VIR_DIV_UP(memory, 1024), 2);\n    Msvm_VirtualSystemSettingData *vssd = NULL;\n    Msvm_MemorySettingData *memsd = NULL;\n    virBuffer eprQuery = VIR_BUFFER_INITIALIZER;\n    virHashTablePtr memResource = NULL;\n\n    virCheckFlags(0, -1);\n\n    memory_str = g_strdup_printf(\"%lu\", memory_mb);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataFromUUID(priv, uuid_string, &vssd) < 0)\n        goto cleanup;\n\n    if (hypervGetMsvmMemorySettingDataFromVSSD(priv, vssd->data.common->InstanceID,\n                &memsd) < 0)\n        goto cleanup;\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyVirtualSystemResources\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n\n        virBufferAddLit(&eprQuery, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferEscapeSQL(&eprQuery, \"where Name = \\\"%s\\\"\", uuid_string);\n\n        if (hypervAddEprParam(params, \"ComputerSystem\", priv, &eprQuery,\n                    Msvm_ComputerSystem_WmiInfo) < 0)\n            goto params_cleanup;\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        params = hypervCreateInvokeParamsList(priv, \"ModifyResourceSettings\",\n                MSVM_VIRTUALSYSTEMMANAGEMENTSERVICE_SELECTOR,\n                Msvm_VirtualSystemManagementService_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create params\"));\n            goto cleanup;\n        }\n    }\n\n    memResource = hypervCreateEmbeddedParam(priv, Msvm_MemorySettingData_WmiInfo);\n    if (!memResource)\n        goto params_cleanup;\n\n    if (hypervSetEmbeddedProperty(memResource, \"VirtualQuantity\", memory_str) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (hypervSetEmbeddedProperty(memResource, \"InstanceID\",\n                memsd->data.common->InstanceID) < 0) {\n        hypervFreeEmbeddedParam(memResource);\n        goto params_cleanup;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettingData\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2) {\n        if (hypervAddEmbeddedParam(params, priv, \"ResourceSettings\",\n                    memResource, Msvm_MemorySettingData_WmiInfo) < 0) {\n            hypervFreeEmbeddedParam(memResource);\n            goto params_cleanup;\n        }\n    }\n\n    if (hypervInvokeMethod(priv, params, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not set memory\"));\n        goto cleanup;\n    }\n\n    result = 0;\n    goto cleanup;\n\n params_cleanup:\n    hypervFreeInvokeParams(params);\n    virBufferFreeAndReset(&eprQuery);\n cleanup:\n    VIR_FREE(memory_str);\n    hypervFreeObject(priv, (hypervObject *)vssd);\n    hypervFreeObject(priv, (hypervObject *)memsd);\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainSendKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1325-1442",
    "snippet": "static int\nhypervDomainSendKey(virDomainPtr domain, unsigned int codeset,\n        unsigned int holdtime, unsigned int *keycodes, int nkeycodes,\n        unsigned int flags)\n{\n    int result = -1;\n    size_t i = 0;\n    int keycode = 0;\n    int *translatedKeycodes = NULL;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    char *selector = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_Keyboard *keyboard = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervInvokeParamsListPtr params = NULL;\n    char keycodeStr[VIR_INT64_STR_BUFLEN];\n\n    virCheckFlags(0, -1);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    virBufferEscapeSQL(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where ResultClass = Msvm_Keyboard\",\n            uuid_string);\n\n    if (hypervGetMsvmKeyboardList(priv, &query, &keyboard) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(translatedKeycodes, nkeycodes) < 0)\n        goto cleanup;\n\n    /* translate keycodes to win32 and generate keyup scancodes. */\n    for (i = 0; i < nkeycodes; i++) {\n        if (codeset != VIR_KEYCODE_SET_WIN32) {\n            keycode = virKeycodeValueTranslate(codeset, VIR_KEYCODE_SET_WIN32,\n                    keycodes[i]);\n\n            if (keycode < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not translate keycode\"));\n                goto cleanup;\n            }\n            translatedKeycodes[i] = keycode;\n        }\n    }\n\n    selector = g_strdup_printf(\"CreationClassName=Msvm_Keyboard&DeviceID=%s&\"\n                               \"SystemCreationClassName=Msvm_ComputerSystem&\"\n                               \"SystemName=%s\", keyboard->data.common->DeviceID, uuid_string);\n\n    /* press the keys */\n    for (i = 0; i < nkeycodes; i++) {\n        g_snprintf(keycodeStr, sizeof(keycodeStr), \"%d\", translatedKeycodes[i]);\n\n        params = hypervCreateInvokeParamsList(priv, \"PressKey\", selector,\n                Msvm_Keyboard_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create param\"));\n            goto cleanup;\n        }\n\n        if (hypervAddSimpleParam(params, \"keyCode\", keycodeStr) < 0) {\n            hypervFreeInvokeParams(params);\n            goto cleanup;\n        }\n\n        if (hypervInvokeMethod(priv, params, NULL) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not press key %d\"),\n                           translatedKeycodes[i]);\n            goto cleanup;\n        }\n    }\n\n    /* simulate holdtime by sleeping */\n    if (holdtime > 0)\n        g_usleep(holdtime * 1000);\n\n    /* release the keys */\n    for (i = 0; i < nkeycodes; i++) {\n        g_snprintf(keycodeStr, sizeof(keycodeStr), \"%d\", translatedKeycodes[i]);\n        params = hypervCreateInvokeParamsList(priv, \"ReleaseKey\", selector,\n                Msvm_Keyboard_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create param\"));\n            goto cleanup;\n        }\n\n        if (hypervAddSimpleParam(params, \"keyCode\", keycodeStr) < 0) {\n            hypervFreeInvokeParams(params);\n            goto cleanup;\n        }\n\n        if (hypervInvokeMethod(priv, params, NULL) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not release key %s\"),\n                    keycodeStr);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(translatedKeycodes);\n    VIR_FREE(selector);\n    hypervFreeObject(priv, (hypervObject *)keyboard);\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    virBufferFreeAndReset(&query);\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&query"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "selector"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "translatedKeycodes"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not release key %s\")",
            "keycodeStr"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not release key %s\""
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMethod",
          "args": [
            "priv",
            "params",
            "NULL"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMethod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "765-946",
          "snippet": "int\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HYPERV_JOB_TIMEOUT_MS 300000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define HYPERV_JOB_TIMEOUT_MS 300000\n\nint\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeInvokeParams",
          "args": [
            "params"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeInvokeParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "202-231",
          "snippet": "void\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervAddSimpleParam",
          "args": [
            "params",
            "\"keyCode\"",
            "keycodeStr"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "hypervAddSimpleParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "255-273",
          "snippet": "int\nhypervAddSimpleParam(hypervInvokeParamsListPtr params, const char *name,\n        const char *value)\n{\n    hypervParamPtr p = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_SIMPLE_PARAM;\n\n    p->simple.name = name;\n    p->simple.value = value;\n\n    params->nbParams++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddSimpleParam(hypervInvokeParamsListPtr params, const char *name,\n        const char *value)\n{\n    hypervParamPtr p = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_SIMPLE_PARAM;\n\n    p->simple.name = name;\n    p->simple.value = value;\n\n    params->nbParams++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create param\")"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervCreateInvokeParamsList",
          "args": [
            "priv",
            "\"ReleaseKey\"",
            "selector",
            "Msvm_Keyboard_WmiInfo"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCreateInvokeParamsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "168-195",
          "snippet": "hypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nhypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "keycodeStr",
            "sizeof(keycodeStr)",
            "\"%d\"",
            "translatedKeycodes[i]"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "holdtime * 1000"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not press key %d\")",
            "translatedKeycodes[i]"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create param\")"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "keycodeStr",
            "sizeof(keycodeStr)",
            "\"%d\"",
            "translatedKeycodes[i]"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not translate keycode\")"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKeycodeValueTranslate",
          "args": [
            "codeset",
            "VIR_KEYCODE_SET_WIN32",
            "keycodes[i]"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "virKeycodeValueTranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virkeycode.c",
          "lines": "105-121",
          "snippet": "int virKeycodeValueTranslate(virKeycodeSet from_codeset,\n                             virKeycodeSet to_codeset,\n                             int key_value)\n{\n    size_t i;\n\n    if (key_value < 0)\n        return -1;\n\n\n    for (i = 0; i < VIR_KEYMAP_ENTRY_MAX; i++) {\n        if (virKeymapValues[from_codeset][i] == key_value)\n            return virKeymapValues[to_codeset][i];\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virkeynametable_win32.h\"",
            "#include \"virkeynametable_osx.h\"",
            "#include \"virkeynametable_linux.h\"",
            "#include \"virkeycodetable_xtkbd.h\"",
            "#include \"virkeycodetable_win32.h\"",
            "#include \"virkeycodetable_usb.h\"",
            "#include \"virkeycodetable_qnum.h\"",
            "#include \"virkeycodetable_osx.h\"",
            "#include \"virkeycodetable_linux.h\"",
            "#include \"virkeycodetable_atset3.h\"",
            "#include \"virkeycodetable_atset2.h\"",
            "#include \"virkeycodetable_atset1.h\"",
            "#include <stddef.h>",
            "#include \"virkeycode.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_KEYMAP_ENTRY_MAX G_N_ELEMENTS(virKeyCodeTable_linux)"
          ],
          "globals_used": [
            "static const unsigned short *virKeymapValues[VIR_KEYCODE_SET_LAST] = {\n    [VIR_KEYCODE_SET_LINUX] = virKeyCodeTable_linux,\n    /* XT is same as AT Set1 - it was included by mistake */\n    [VIR_KEYCODE_SET_XT] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET1] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET2] = virKeyCodeTable_atset2,\n    [VIR_KEYCODE_SET_ATSET3] = virKeyCodeTable_atset3,\n    [VIR_KEYCODE_SET_OSX] = virKeyCodeTable_osx,\n    [VIR_KEYCODE_SET_XT_KBD] = virKeyCodeTable_xtkbd,\n    [VIR_KEYCODE_SET_USB] = virKeyCodeTable_usb,\n    [VIR_KEYCODE_SET_WIN32] = virKeyCodeTable_win32,\n    [VIR_KEYCODE_SET_QNUM] = virKeyCodeTable_qnum,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeynametable_win32.h\"\n#include \"virkeynametable_osx.h\"\n#include \"virkeynametable_linux.h\"\n#include \"virkeycodetable_xtkbd.h\"\n#include \"virkeycodetable_win32.h\"\n#include \"virkeycodetable_usb.h\"\n#include \"virkeycodetable_qnum.h\"\n#include \"virkeycodetable_osx.h\"\n#include \"virkeycodetable_linux.h\"\n#include \"virkeycodetable_atset3.h\"\n#include \"virkeycodetable_atset2.h\"\n#include \"virkeycodetable_atset1.h\"\n#include <stddef.h>\n#include \"virkeycode.h\"\n#include <config.h>\n\n#define VIR_KEYMAP_ENTRY_MAX G_N_ELEMENTS(virKeyCodeTable_linux)\n\nstatic const unsigned short *virKeymapValues[VIR_KEYCODE_SET_LAST] = {\n    [VIR_KEYCODE_SET_LINUX] = virKeyCodeTable_linux,\n    /* XT is same as AT Set1 - it was included by mistake */\n    [VIR_KEYCODE_SET_XT] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET1] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET2] = virKeyCodeTable_atset2,\n    [VIR_KEYCODE_SET_ATSET3] = virKeyCodeTable_atset3,\n    [VIR_KEYCODE_SET_OSX] = virKeyCodeTable_osx,\n    [VIR_KEYCODE_SET_XT_KBD] = virKeyCodeTable_xtkbd,\n    [VIR_KEYCODE_SET_USB] = virKeyCodeTable_usb,\n    [VIR_KEYCODE_SET_WIN32] = virKeyCodeTable_win32,\n    [VIR_KEYCODE_SET_QNUM] = virKeyCodeTable_qnum,\n};\n\nint virKeycodeValueTranslate(virKeycodeSet from_codeset,\n                             virKeycodeSet to_codeset,\n                             int key_value)\n{\n    size_t i;\n\n    if (key_value < 0)\n        return -1;\n\n\n    for (i = 0; i < VIR_KEYMAP_ENTRY_MAX; i++) {\n        if (virKeymapValues[from_codeset][i] == key_value)\n            return virKeymapValues[to_codeset][i];\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "translatedKeycodes",
            "nkeycodes"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmKeyboardList",
          "args": [
            "priv",
            "&query",
            "&keyboard"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmKeyboardList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1290-1295",
          "snippet": "int hypervGetMsvmKeyboardList(hypervPrivate *priv, virBufferPtr query,\n                              Msvm_Keyboard **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_Keyboard_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint hypervGetMsvmKeyboardList(hypervPrivate *priv, virBufferPtr query,\n                              Msvm_Keyboard **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_Keyboard_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where ResultClass = Msvm_Keyboard\"",
            "uuid_string"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainSendKey(virDomainPtr domain, unsigned int codeset,\n        unsigned int holdtime, unsigned int *keycodes, int nkeycodes,\n        unsigned int flags)\n{\n    int result = -1;\n    size_t i = 0;\n    int keycode = 0;\n    int *translatedKeycodes = NULL;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    char *selector = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_Keyboard *keyboard = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervInvokeParamsListPtr params = NULL;\n    char keycodeStr[VIR_INT64_STR_BUFLEN];\n\n    virCheckFlags(0, -1);\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    virBufferEscapeSQL(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where ResultClass = Msvm_Keyboard\",\n            uuid_string);\n\n    if (hypervGetMsvmKeyboardList(priv, &query, &keyboard) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(translatedKeycodes, nkeycodes) < 0)\n        goto cleanup;\n\n    /* translate keycodes to win32 and generate keyup scancodes. */\n    for (i = 0; i < nkeycodes; i++) {\n        if (codeset != VIR_KEYCODE_SET_WIN32) {\n            keycode = virKeycodeValueTranslate(codeset, VIR_KEYCODE_SET_WIN32,\n                    keycodes[i]);\n\n            if (keycode < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not translate keycode\"));\n                goto cleanup;\n            }\n            translatedKeycodes[i] = keycode;\n        }\n    }\n\n    selector = g_strdup_printf(\"CreationClassName=Msvm_Keyboard&DeviceID=%s&\"\n                               \"SystemCreationClassName=Msvm_ComputerSystem&\"\n                               \"SystemName=%s\", keyboard->data.common->DeviceID, uuid_string);\n\n    /* press the keys */\n    for (i = 0; i < nkeycodes; i++) {\n        g_snprintf(keycodeStr, sizeof(keycodeStr), \"%d\", translatedKeycodes[i]);\n\n        params = hypervCreateInvokeParamsList(priv, \"PressKey\", selector,\n                Msvm_Keyboard_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create param\"));\n            goto cleanup;\n        }\n\n        if (hypervAddSimpleParam(params, \"keyCode\", keycodeStr) < 0) {\n            hypervFreeInvokeParams(params);\n            goto cleanup;\n        }\n\n        if (hypervInvokeMethod(priv, params, NULL) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not press key %d\"),\n                           translatedKeycodes[i]);\n            goto cleanup;\n        }\n    }\n\n    /* simulate holdtime by sleeping */\n    if (holdtime > 0)\n        g_usleep(holdtime * 1000);\n\n    /* release the keys */\n    for (i = 0; i < nkeycodes; i++) {\n        g_snprintf(keycodeStr, sizeof(keycodeStr), \"%d\", translatedKeycodes[i]);\n        params = hypervCreateInvokeParamsList(priv, \"ReleaseKey\", selector,\n                Msvm_Keyboard_WmiInfo);\n\n        if (!params) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create param\"));\n            goto cleanup;\n        }\n\n        if (hypervAddSimpleParam(params, \"keyCode\", keycodeStr) < 0) {\n            hypervFreeInvokeParams(params);\n            goto cleanup;\n        }\n\n        if (hypervInvokeMethod(priv, params, NULL) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not release key %s\"),\n                    keycodeStr);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(translatedKeycodes);\n    VIR_FREE(selector);\n    hypervFreeObject(priv, (hypervObject *)keyboard);\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    virBufferFreeAndReset(&query);\n    return result;\n}"
  },
  {
    "function_name": "hypervConnectListAllDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1195-1321",
    "snippet": "static int\nhypervConnectListAllDomains(virConnectPtr conn,\n                            virDomainPtr **domains,\n                            unsigned int flags)\n{\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    size_t ndoms;\n    virDomainPtr domain;\n    virDomainPtr *doms = NULL;\n    int count = 0;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* check for filter combinations that return no results:\n     * persistent: all hyperv guests are persistent\n     * snapshot: the driver does not support snapshot management\n     * autostart: the driver does not support autostarting guests\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT))) {\n        if (domains && VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n\n    /* construct query with filter depending on flags */\n    if (!(MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) &&\n          MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE))) {\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE)) {\n            virBufferAddLit(&query, \"and \");\n            virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n        }\n\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE)) {\n            virBufferAddLit(&query, \"and \");\n            virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n        }\n    }\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0)\n        goto cleanup;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, 1) < 0)\n            goto cleanup;\n        ndoms = 1;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n\n        /* filter by domain state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE)) {\n            int st = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n                   st == VIR_DOMAIN_RUNNING) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n                   st == VIR_DOMAIN_PAUSED) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n                   st == VIR_DOMAIN_SHUTOFF) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n                   (st != VIR_DOMAIN_RUNNING &&\n                    st != VIR_DOMAIN_PAUSED &&\n                    st != VIR_DOMAIN_SHUTOFF))))\n                continue;\n        }\n\n        /* managed save filter */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_MANAGEDSAVE)) {\n            bool mansave = computerSystem->data.common->EnabledState ==\n                           MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED;\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) && mansave) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE) && !mansave)))\n                continue;\n        }\n\n        if (!doms) {\n            count++;\n            continue;\n        }\n\n        if (VIR_RESIZE_N(doms, ndoms, count, 2) < 0)\n            goto cleanup;\n\n        domain = NULL;\n\n        if (hypervMsvmComputerSystemToDomain(conn, computerSystem,\n                                             &domain) < 0)\n            goto cleanup;\n\n        doms[count++] = domain;\n    }\n\n    if (doms)\n        *domains = doms;\n    doms = NULL;\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (i = 0; i < count; ++i)\n            virObjectUnref(doms[i]);\n\n        VIR_FREE(doms);\n    }\n\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return ret;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystemList"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "doms"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "doms[i]"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemToDomain",
          "args": [
            "conn",
            "computerSystem",
            "&domain"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemToDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1522-1548",
          "snippet": "int\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "doms",
            "ndoms",
            "count",
            "2"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_MANAGEDSAVE"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_OTHER"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_SHUTOFF"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PAUSED"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_RUNNING"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "args": [
            "computerSystem"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1446-1481",
          "snippet": "int\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "doms",
            "1"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystemList"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_INACTIVE"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_INACTIVE"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_ACTIVE"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_ACTIVE"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_INACTIVE"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_ACTIVE"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*domains",
            "1"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_AUTOSTART"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PERSISTENT"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_TRANSIENT"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL",
            "-1"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectListAllDomains(virConnectPtr conn,\n                            virDomainPtr **domains,\n                            unsigned int flags)\n{\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    size_t ndoms;\n    virDomainPtr domain;\n    virDomainPtr *doms = NULL;\n    int count = 0;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* check for filter combinations that return no results:\n     * persistent: all hyperv guests are persistent\n     * snapshot: the driver does not support snapshot management\n     * autostart: the driver does not support autostarting guests\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT))) {\n        if (domains && VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n\n    /* construct query with filter depending on flags */\n    if (!(MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) &&\n          MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE))) {\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE)) {\n            virBufferAddLit(&query, \"and \");\n            virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n        }\n\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE)) {\n            virBufferAddLit(&query, \"and \");\n            virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n        }\n    }\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0)\n        goto cleanup;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, 1) < 0)\n            goto cleanup;\n        ndoms = 1;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n\n        /* filter by domain state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE)) {\n            int st = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n                   st == VIR_DOMAIN_RUNNING) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n                   st == VIR_DOMAIN_PAUSED) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n                   st == VIR_DOMAIN_SHUTOFF) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n                   (st != VIR_DOMAIN_RUNNING &&\n                    st != VIR_DOMAIN_PAUSED &&\n                    st != VIR_DOMAIN_SHUTOFF))))\n                continue;\n        }\n\n        /* managed save filter */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_MANAGEDSAVE)) {\n            bool mansave = computerSystem->data.common->EnabledState ==\n                           MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED;\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) && mansave) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE) && !mansave)))\n                continue;\n        }\n\n        if (!doms) {\n            count++;\n            continue;\n        }\n\n        if (VIR_RESIZE_N(doms, ndoms, count, 2) < 0)\n            goto cleanup;\n\n        domain = NULL;\n\n        if (hypervMsvmComputerSystemToDomain(conn, computerSystem,\n                                             &domain) < 0)\n            goto cleanup;\n\n        doms[count++] = domain;\n    }\n\n    if (doms)\n        *domains = doms;\n    doms = NULL;\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (i = 0; i < count; ++i)\n            virObjectUnref(doms[i]);\n\n        VIR_FREE(doms);\n    }\n\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return ret;\n}"
  },
  {
    "function_name": "hypervDomainManagedSaveRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1165-1191",
    "snippet": "static int\nhypervDomainManagedSaveRemove(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain has no managed save image\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain has no managed save image\")"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain has no managed save image\""
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainManagedSaveRemove(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain has no managed save image\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainHasManagedSaveImage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1142-1161",
    "snippet": "static int\nhypervDomainHasManagedSaveImage(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    result = computerSystem->data.common->EnabledState ==\n             MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED ? 1 : 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainHasManagedSaveImage(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    result = computerSystem->data.common->EnabledState ==\n             MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED ? 1 : 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainManagedSave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1111-1138",
    "snippet": "static int\nhypervDomainManagedSave(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_SUSPENDED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_SUSPENDED"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not active or is in state transition\")"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not active or is in state transition\""
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "&in_transition"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainManagedSave(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_SUSPENDED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainIsUpdated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1103-1107",
    "snippet": "static int\nhypervDomainIsUpdated(virDomainPtr domain G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainIsUpdated(virDomainPtr domain G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "hypervDomainIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1094-1099",
    "snippet": "static int\nhypervDomainIsPersistent(virDomainPtr domain G_GNUC_UNUSED)\n{\n    /* Hyper-V has no concept of transient domains, so all of them are persistent */\n    return 1;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainIsPersistent(virDomainPtr domain G_GNUC_UNUSED)\n{\n    /* Hyper-V has no concept of transient domains, so all of them are persistent */\n    return 1;\n}"
  },
  {
    "function_name": "hypervDomainIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1074-1090",
    "snippet": "static int\nhypervDomainIsActive(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    result = hypervIsMsvmComputerSystemActive(computerSystem, NULL) ? 1 : 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "NULL"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainIsActive(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    result = hypervIsMsvmComputerSystemActive(computerSystem, NULL) ? 1 : 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1057-1070",
    "snippet": "static int\nhypervConnectIsAlive(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    /* XXX we should be able to do something better than this is simple, safe,\n     * and good enough for now. In worst case, the function will return true\n     * even though the connection is not alive.\n     */\n    if (priv->client)\n        return 1;\n    else\n        return 0;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectIsAlive(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    /* XXX we should be able to do something better than this is simple, safe,\n     * and good enough for now. In worst case, the function will return true\n     * even though the connection is not alive.\n     */\n    if (priv->client)\n        return 1;\n    else\n        return 0;\n}"
  },
  {
    "function_name": "hypervConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1043-1053",
    "snippet": "static int\nhypervConnectIsSecure(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectIsSecure(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n        return 1;\n    } else {\n        return 0;\n    }\n}"
  },
  {
    "function_name": "hypervConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1029-1039",
    "snippet": "static int\nhypervConnectIsEncrypted(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectIsEncrypted(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n        return 1;\n    } else {\n        return 0;\n    }\n}"
  },
  {
    "function_name": "hypervDomainCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "1021-1025",
    "snippet": "static int\nhypervDomainCreate(virDomainPtr domain)\n{\n    return hypervDomainCreateWithFlags(domain, 0);\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervDomainCreateWithFlags",
          "args": [
            "domain",
            "0"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "hypervDomainCreateWithFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "992-1017",
          "snippet": "static int\nhypervDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is already active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is already active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainCreate(virDomainPtr domain)\n{\n    return hypervDomainCreateWithFlags(domain, 0);\n}"
  },
  {
    "function_name": "hypervDomainCreateWithFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "992-1017",
    "snippet": "static int\nhypervDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is already active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is already active or is in state transition\")"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is already active or is in state transition\""
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "NULL"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is already active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervConnectNumOfDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "956-988",
    "snippet": "static int\nhypervConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystemList"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystemList"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_INACTIVE"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "hypervConnectListDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "904-952",
    "snippet": "static int\nhypervConnectListDefinedDomains(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        names[count] = g_strdup(computerSystem->data.common->ElementName);\n\n        ++count;\n\n        if (count >= maxnames)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    if (!success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return count;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystemList"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "computerSystem->data.common->ElementName"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystemList"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_INACTIVE"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectListDefinedDomains(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_INACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        names[count] = g_strdup(computerSystem->data.common->ElementName);\n\n        ++count;\n\n        if (count >= maxnames)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    if (!success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return count;\n}"
  },
  {
    "function_name": "hypervDomainGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "742-900",
    "snippet": "static char *\nhypervDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    char *xml = NULL;\n    hypervPrivate *priv = domain->conn->privateData;\n    virDomainDefPtr def = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_VirtualSystemSettingData *virtualSystemSettingData = NULL;\n    Msvm_ProcessorSettingData *processorSettingData = NULL;\n    Msvm_MemorySettingData *memorySettingData = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    /* Get Msvm_ComputerSystem */\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    /* Get Msvm_VirtualSystemSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n                       \"Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_SettingsDefineState \"\n                       \"ResultClass = Msvm_VirtualSystemSettingData\",\n                       uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataList(priv, &query,\n                                                  &virtualSystemSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualSystemSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_VirtualSystemSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_ProcessorSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_ProcessorSettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmProcessorSettingDataList(priv, &query,\n                                              &processorSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (processorSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_ProcessorSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_MemorySettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmMemorySettingDataList(priv, &query,\n                                           &memorySettingData) < 0) {\n        goto cleanup;\n    }\n\n\n    if (memorySettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_MemorySettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Fill struct */\n    def->virtType = VIR_DOMAIN_VIRT_HYPERV;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        def->id = computerSystem->data.common->ProcessID;\n    } else {\n        def->id = -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return NULL;\n    }\n\n    def->name = g_strdup(computerSystem->data.common->ElementName);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        def->description = g_strdup(virtualSystemSettingData->data.v1->Notes);\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2 &&\n               virtualSystemSettingData->data.v2->Notes.data != NULL) {\n        char **notes = (char **)virtualSystemSettingData->data.v2->Notes.data;\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        size_t i = 0;\n\n        /* in practice Notes has 1 element */\n        for (i = 0; i < virtualSystemSettingData->data.v2->Notes.count; i++) {\n            /* but if there's more than 1, separate by double new line */\n            if (virBufferUse(&buf) > 0)\n                virBufferAddLit(&buf, \"\\n\\n\");\n\n            virBufferAdd(&buf, *notes, -1);\n            notes++;\n        }\n\n        def->description = virBufferContentAndReset(&buf);\n    }\n\n    /* mebibytes to kibibytes */\n    def->mem.max_memory = memorySettingData->data.common->Limit * 1024;\n    def->mem.cur_balloon = memorySettingData->data.common->VirtualQuantity * 1024;\n    virDomainDefSetMemoryTotal(def, memorySettingData->data.common->VirtualQuantity * 1024);\n\n    if (virDomainDefSetVcpusMax(def,\n                                processorSettingData->data.common->VirtualQuantity,\n                                NULL) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def,\n                             processorSettingData->data.common->VirtualQuantity) < 0)\n        goto cleanup;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* FIXME: devices section is totally missing */\n\n    /* XXX xmlopts must be non-NULL */\n    xml = virDomainDefFormat(def, NULL,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n cleanup:\n    virDomainDefFree(def);\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)virtualSystemSettingData);\n    hypervFreeObject(priv, (hypervObject *)processorSettingData);\n    hypervFreeObject(priv, (hypervObject *)memorySettingData);\n\n    return xml;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)memorySettingData"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "NULL",
            "virDomainDefFormatConvertXMLFlags(flags)"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatConvertXMLFlags",
          "args": [
            "flags"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatConvertXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29481-29493",
          "snippet": "unsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "processorSettingData->data.common->VirtualQuantity"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "processorSettingData->data.common->VirtualQuantity",
            "NULL"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memorySettingData->data.common->VirtualQuantity * 1024"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "*notes",
            "-1"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"\\n\\n\""
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "&buf"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virtualSystemSettingData->data.v1->Notes"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse UUID from string '%s'\")",
            "computerSystem->data.common->Name"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "computerSystem->data.common->Name",
            "def->uuid"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "NULL"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_MemorySettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmMemorySettingDataList",
          "args": [
            "priv",
            "&query",
            "&memorySettingData"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmMemorySettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1282-1288",
          "snippet": "int\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\"",
            "virtualSystemSettingData->data.common->InstanceID"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_ProcessorSettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmProcessorSettingDataList",
          "args": [
            "priv",
            "&query",
            "&processorSettingData"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmProcessorSettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1273-1280",
          "snippet": "int\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_VirtualSystemSettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmVirtualSystemSettingDataList",
          "args": [
            "priv",
            "&query",
            "&virtualSystemSettingData"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmVirtualSystemSettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1264-1271",
          "snippet": "int\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_XML_COMMON_FLAGS",
            "NULL"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nhypervDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    char *xml = NULL;\n    hypervPrivate *priv = domain->conn->privateData;\n    virDomainDefPtr def = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_VirtualSystemSettingData *virtualSystemSettingData = NULL;\n    Msvm_ProcessorSettingData *processorSettingData = NULL;\n    Msvm_MemorySettingData *memorySettingData = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    /* Get Msvm_ComputerSystem */\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    /* Get Msvm_VirtualSystemSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n                       \"Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_SettingsDefineState \"\n                       \"ResultClass = Msvm_VirtualSystemSettingData\",\n                       uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataList(priv, &query,\n                                                  &virtualSystemSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualSystemSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_VirtualSystemSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_ProcessorSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_ProcessorSettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmProcessorSettingDataList(priv, &query,\n                                              &processorSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (processorSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_ProcessorSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_MemorySettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmMemorySettingDataList(priv, &query,\n                                           &memorySettingData) < 0) {\n        goto cleanup;\n    }\n\n\n    if (memorySettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_MemorySettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Fill struct */\n    def->virtType = VIR_DOMAIN_VIRT_HYPERV;\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL)) {\n        def->id = computerSystem->data.common->ProcessID;\n    } else {\n        def->id = -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return NULL;\n    }\n\n    def->name = g_strdup(computerSystem->data.common->ElementName);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1) {\n        def->description = g_strdup(virtualSystemSettingData->data.v1->Notes);\n    } else if (priv->wmiVersion == HYPERV_WMI_VERSION_V2 &&\n               virtualSystemSettingData->data.v2->Notes.data != NULL) {\n        char **notes = (char **)virtualSystemSettingData->data.v2->Notes.data;\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        size_t i = 0;\n\n        /* in practice Notes has 1 element */\n        for (i = 0; i < virtualSystemSettingData->data.v2->Notes.count; i++) {\n            /* but if there's more than 1, separate by double new line */\n            if (virBufferUse(&buf) > 0)\n                virBufferAddLit(&buf, \"\\n\\n\");\n\n            virBufferAdd(&buf, *notes, -1);\n            notes++;\n        }\n\n        def->description = virBufferContentAndReset(&buf);\n    }\n\n    /* mebibytes to kibibytes */\n    def->mem.max_memory = memorySettingData->data.common->Limit * 1024;\n    def->mem.cur_balloon = memorySettingData->data.common->VirtualQuantity * 1024;\n    virDomainDefSetMemoryTotal(def, memorySettingData->data.common->VirtualQuantity * 1024);\n\n    if (virDomainDefSetVcpusMax(def,\n                                processorSettingData->data.common->VirtualQuantity,\n                                NULL) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def,\n                             processorSettingData->data.common->VirtualQuantity) < 0)\n        goto cleanup;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* FIXME: devices section is totally missing */\n\n    /* XXX xmlopts must be non-NULL */\n    xml = virDomainDefFormat(def, NULL,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n cleanup:\n    virDomainDefFree(def);\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)virtualSystemSettingData);\n    hypervFreeObject(priv, (hypervObject *)processorSettingData);\n    hypervFreeObject(priv, (hypervObject *)memorySettingData);\n\n    return xml;\n}"
  },
  {
    "function_name": "hypervDomainGetState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "714-738",
    "snippet": "static int\nhypervDomainGetState(virDomainPtr domain, int *state, int *reason,\n                     unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    *state = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n\n    if (reason != NULL)\n        *reason = 0;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "args": [
            "computerSystem"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1446-1481",
          "snippet": "int\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainGetState(virDomainPtr domain, int *state, int *reason,\n                     unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    *state = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n\n    if (reason != NULL)\n        *reason = 0;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "609-710",
    "snippet": "static int\nhypervDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_VirtualSystemSettingData *virtualSystemSettingData = NULL;\n    Msvm_ProcessorSettingData *processorSettingData = NULL;\n    Msvm_MemorySettingData *memorySettingData = NULL;\n\n    memset(info, 0, sizeof(*info));\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    /* Get Msvm_ComputerSystem */\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    /* Get Msvm_VirtualSystemSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n                       \"Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_SettingsDefineState \"\n                       \"ResultClass = Msvm_VirtualSystemSettingData\",\n                       uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataList(priv, &query,\n                                                  &virtualSystemSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualSystemSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_VirtualSystemSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_ProcessorSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_ProcessorSettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmProcessorSettingDataList(priv, &query,\n                                              &processorSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (processorSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_ProcessorSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_MemorySettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmMemorySettingDataList(priv, &query,\n                                           &memorySettingData) < 0) {\n        goto cleanup;\n    }\n\n\n    if (memorySettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_MemorySettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Fill struct */\n    info->state = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n    info->maxMem = memorySettingData->data.common->Limit * 1024; /* megabyte to kilobyte */\n    info->memory = memorySettingData->data.common->VirtualQuantity * 1024; /* megabyte to kilobyte */\n    info->nrVirtCpu = processorSettingData->data.common->VirtualQuantity;\n    info->cpuTime = 0;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)virtualSystemSettingData);\n    hypervFreeObject(priv, (hypervObject *)processorSettingData);\n    hypervFreeObject(priv, (hypervObject *)memorySettingData);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)memorySettingData"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "args": [
            "computerSystem"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemEnabledStateToDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1446-1481",
          "snippet": "int\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_MemorySettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not lookup %s for domain %s\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmMemorySettingDataList",
          "args": [
            "priv",
            "&query",
            "&memorySettingData"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmMemorySettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1282-1288",
          "snippet": "int\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\"",
            "virtualSystemSettingData->data.common->InstanceID"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_ProcessorSettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmProcessorSettingDataList",
          "args": [
            "priv",
            "&query",
            "&processorSettingData"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmProcessorSettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1273-1280",
          "snippet": "int\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for domain %s\")",
            "\"Msvm_VirtualSystemSettingData\"",
            "computerSystem->data.common->ElementName"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmVirtualSystemSettingDataList",
          "args": [
            "priv",
            "&query",
            "&virtualSystemSettingData"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmVirtualSystemSettingDataList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1264-1271",
          "snippet": "int\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    Msvm_VirtualSystemSettingData *virtualSystemSettingData = NULL;\n    Msvm_ProcessorSettingData *processorSettingData = NULL;\n    Msvm_MemorySettingData *memorySettingData = NULL;\n\n    memset(info, 0, sizeof(*info));\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    /* Get Msvm_ComputerSystem */\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    /* Get Msvm_VirtualSystemSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n                       \"Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_SettingsDefineState \"\n                       \"ResultClass = Msvm_VirtualSystemSettingData\",\n                       uuid_string);\n\n    if (hypervGetMsvmVirtualSystemSettingDataList(priv, &query,\n                                                  &virtualSystemSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualSystemSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_VirtualSystemSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_ProcessorSettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_ProcessorSettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmProcessorSettingDataList(priv, &query,\n                                              &processorSettingData) < 0) {\n        goto cleanup;\n    }\n\n    if (processorSettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_ProcessorSettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Get Msvm_MemorySettingData */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n                       \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n                       \"ResultClass = Msvm_MemorySettingData\",\n                       virtualSystemSettingData->data.common->InstanceID);\n\n    if (hypervGetMsvmMemorySettingDataList(priv, &query,\n                                           &memorySettingData) < 0) {\n        goto cleanup;\n    }\n\n\n    if (memorySettingData == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for domain %s\"),\n                       \"Msvm_MemorySettingData\",\n                       computerSystem->data.common->ElementName);\n        goto cleanup;\n    }\n\n    /* Fill struct */\n    info->state = hypervMsvmComputerSystemEnabledStateToDomainState(computerSystem);\n    info->maxMem = memorySettingData->data.common->Limit * 1024; /* megabyte to kilobyte */\n    info->memory = memorySettingData->data.common->VirtualQuantity * 1024; /* megabyte to kilobyte */\n    info->nrVirtCpu = processorSettingData->data.common->VirtualQuantity;\n    info->cpuTime = 0;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)virtualSystemSettingData);\n    hypervFreeObject(priv, (hypervObject *)processorSettingData);\n    hypervFreeObject(priv, (hypervObject *)memorySettingData);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainGetOSType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "598-605",
    "snippet": "static char *\nhypervDomainGetOSType(virDomainPtr domain G_GNUC_UNUSED)\n{\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"hvm\""
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nhypervDomainGetOSType(virDomainPtr domain G_GNUC_UNUSED)\n{\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}"
  },
  {
    "function_name": "hypervDomainDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "590-594",
    "snippet": "static int\nhypervDomainDestroy(virDomainPtr domain)\n{\n    return hypervDomainDestroyFlags(domain, 0);\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervDomainDestroyFlags",
          "args": [
            "domain",
            "0"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "hypervDomainDestroyFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "559-586",
          "snippet": "static int\nhypervDomainDestroyFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainDestroyFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainDestroy(virDomainPtr domain)\n{\n    return hypervDomainDestroyFlags(domain, 0);\n}"
  },
  {
    "function_name": "hypervDomainDestroyFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "559-586",
    "snippet": "static int\nhypervDomainDestroyFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not active or is in state transition\")"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not active or is in state transition\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "&in_transition"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainDestroyFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    bool in_transition = false;\n\n    virCheckFlags(0, -1);\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (!hypervIsMsvmComputerSystemActive(computerSystem, &in_transition) ||\n        in_transition) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active or is in state transition\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_DISABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "531-555",
    "snippet": "static int\nhypervDomainResume(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not paused\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not paused\")"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not paused\""
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainResume(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not paused\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_ENABLED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "503-527",
    "snippet": "static int\nhypervDomainSuspend(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_PAUSED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "args": [
            "domain",
            "MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_PAUSED"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1303-1444",
          "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not active\")"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not active\""
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemFromDomain",
          "args": [
            "domain",
            "&computerSystem"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1550-1580",
          "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervDomainSuspend(virDomainPtr domain)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    if (hypervMsvmComputerSystemFromDomain(domain, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem->data.common->EnabledState !=\n        MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not active\"));\n        goto cleanup;\n    }\n\n    result = hypervInvokeMsvmComputerSystemRequestStateChange\n               (domain, MSVM_COMPUTERSYSTEM_REQUESTEDSTATE_PAUSED);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervDomainLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "471-499",
    "snippet": "static virDomainPtr\nhypervDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferEscapeSQL(&query, \"and ElementName = \\\"%s\\\"\", name);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with name %s\"), name);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemToDomain",
          "args": [
            "conn",
            "computerSystem",
            "&domain"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemToDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1522-1548",
          "snippet": "int\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with name %s\")",
            "name"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No domain with name %s\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystem"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"and ElementName = \\\"%s\\\"\"",
            "name"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainPtr\nhypervDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferEscapeSQL(&query, \"and ElementName = \\\"%s\\\"\", name);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with name %s\"), name);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}"
  },
  {
    "function_name": "hypervDomainLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "436-467",
    "snippet": "static virDomainPtr\nhypervDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virUUIDFormat(uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferEscapeSQL(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemToDomain",
          "args": [
            "conn",
            "computerSystem",
            "&domain"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemToDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1522-1548",
          "snippet": "int\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with UUID %s\")",
            "uuid_string"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No domain with UUID %s\""
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystem"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"and Name = \\\"%s\\\"\"",
            "uuid_string"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuid_string"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainPtr\nhypervDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virUUIDFormat(uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferEscapeSQL(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}"
  },
  {
    "function_name": "hypervDomainLookupByID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "405-432",
    "snippet": "static virDomainPtr\nhypervDomainLookupByID(virConnectPtr conn, int id)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and ProcessID = %d\", id);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN, _(\"No domain with ID %d\"), id);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervMsvmComputerSystemToDomain",
          "args": [
            "conn",
            "computerSystem",
            "&domain"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "hypervMsvmComputerSystemToDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1522-1548",
          "snippet": "int\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with ID %d\")",
            "id"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No domain with ID %d\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystem"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&query",
            "\"and ProcessID = %d\"",
            "id"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainPtr\nhypervDomainLookupByID(virConnectPtr conn, int id)\n{\n    virDomainPtr domain = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and ProcessID = %d\", id);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN, _(\"No domain with ID %d\"), id);\n        goto cleanup;\n    }\n\n    hypervMsvmComputerSystemToDomain(conn, computerSystem, &domain);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return domain;\n}"
  },
  {
    "function_name": "hypervConnectNumOfDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "369-401",
    "snippet": "static int\nhypervConnectNumOfDomains(virConnectPtr conn)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystemList"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystemList"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_ACTIVE"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectNumOfDomains(virConnectPtr conn)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "hypervConnectListDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "327-365",
    "snippet": "static int\nhypervConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    if (maxids == 0)\n        return 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ids[count++] = computerSystem->data.common->ProcessID;\n\n        if (count >= maxids)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystemList"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystemList"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_ACTIVE"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"and \""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    bool success = false;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ComputerSystem *computerSystemList = NULL;\n    Msvm_ComputerSystem *computerSystem = NULL;\n    int count = 0;\n\n    if (maxids == 0)\n        return 0;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAddLit(&query, \"and \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_ACTIVE);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query,\n                                        &computerSystemList) < 0) {\n        goto cleanup;\n    }\n\n    for (computerSystem = computerSystemList; computerSystem != NULL;\n         computerSystem = computerSystem->next) {\n        ids[count++] = computerSystem->data.common->ProcessID;\n\n        if (count >= maxids)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystemList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "hypervNodeGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "232-323",
    "snippet": "static int\nhypervNodeGetInfo(virConnectPtr conn, virNodeInfoPtr info)\n{\n    int result = -1;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Win32_ComputerSystem *computerSystem = NULL;\n    Win32_Processor *processorList = NULL;\n    Win32_Processor *processor = NULL;\n    char *tmp;\n\n    memset(info, 0, sizeof(*info));\n\n    virBufferAddLit(&query, WIN32_COMPUTERSYSTEM_WQL_SELECT);\n\n    /* Get Win32_ComputerSystem */\n    if (hypervGetWin32ComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_ComputerSystem\");\n        goto cleanup;\n    }\n\n    /* Get Win32_Processor list */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Win32_ComputerSystem.Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Win32_ComputerSystemProcessor \"\n                       \"ResultClass = Win32_Processor\",\n                       computerSystem->data.common->Name);\n\n    if (hypervGetWin32ProcessorList(priv, &query, &processorList) < 0)\n        goto cleanup;\n\n    if (processorList == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_Processor\");\n        goto cleanup;\n    }\n\n    /* Strip the string to fit more relevant information in 32 chars */\n    tmp = processorList->data.common->Name;\n\n    while (*tmp != '\\0') {\n        if (STRPREFIX(tmp, \"  \")) {\n            memmove(tmp, tmp + 1, strlen(tmp + 1) + 1);\n            continue;\n        } else if (STRPREFIX(tmp, \"(R)\") || STRPREFIX(tmp, \"(C)\")) {\n            memmove(tmp, tmp + 3, strlen(tmp + 3) + 1);\n            continue;\n        } else if (STRPREFIX(tmp, \"(TM)\")) {\n            memmove(tmp, tmp + 4, strlen(tmp + 4) + 1);\n            continue;\n        }\n\n        ++tmp;\n    }\n\n    /* Fill struct */\n    if (virStrcpyStatic(info->model, processorList->data.common->Name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU model %s too long for destination\"),\n                       processorList->data.common->Name);\n        goto cleanup;\n    }\n\n    info->memory = computerSystem->data.common->TotalPhysicalMemory / 1024; /* byte to kilobyte */\n    info->mhz = processorList->data.common->MaxClockSpeed;\n    info->nodes = 1;\n    info->sockets = 0;\n\n    for (processor = processorList; processor != NULL;\n         processor = processor->next) {\n        ++info->sockets;\n    }\n\n    info->cores = processorList->data.common->NumberOfCores;\n    info->threads = info->cores / processorList->data.common->NumberOfLogicalProcessors;\n    info->cpus = info->sockets * info->cores;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)processorList);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)processorList"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU model %s too long for destination\")",
            "processorList->data.common->Name"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU model %s too long for destination\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "info->model",
            "processorList->data.common->Name"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp + 4",
            "strlen(tmp + 4) + 1"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp + 4"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "tmp",
            "\"(TM)\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp + 3",
            "strlen(tmp + 3) + 1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp + 3"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "tmp",
            "\"(C)\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "tmp",
            "\"(R)\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp + 1",
            "strlen(tmp + 1) + 1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp + 1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "tmp",
            "\"  \""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s\")",
            "\"Win32_Processor\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetWin32ProcessorList",
          "args": [
            "priv",
            "&query",
            "&processorList"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWin32ProcessorList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1256-1262",
          "snippet": "int\nhypervGetWin32ProcessorList(hypervPrivate *priv, virBufferPtr query,\n                            Win32_Processor **list)\n{\n    return hypervGetWmiClassList(priv, Win32_Processor_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetWin32ProcessorList(hypervPrivate *priv, virBufferPtr query,\n                            Win32_Processor **list)\n{\n    return hypervGetWmiClassList(priv, Win32_Processor_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"associators of \"\n                       \"{Win32_ComputerSystem.Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Win32_ComputerSystemProcessor \"\n                       \"ResultClass = Win32_Processor\"",
            "computerSystem->data.common->Name"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s\")",
            "\"Win32_ComputerSystem\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetWin32ComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystem"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWin32ComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1248-1254",
          "snippet": "int\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "WIN32_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervNodeGetInfo(virConnectPtr conn, virNodeInfoPtr info)\n{\n    int result = -1;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Win32_ComputerSystem *computerSystem = NULL;\n    Win32_Processor *processorList = NULL;\n    Win32_Processor *processor = NULL;\n    char *tmp;\n\n    memset(info, 0, sizeof(*info));\n\n    virBufferAddLit(&query, WIN32_COMPUTERSYSTEM_WQL_SELECT);\n\n    /* Get Win32_ComputerSystem */\n    if (hypervGetWin32ComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_ComputerSystem\");\n        goto cleanup;\n    }\n\n    /* Get Win32_Processor list */\n    virBufferEscapeSQL(&query,\n                       \"associators of \"\n                       \"{Win32_ComputerSystem.Name=\\\"%s\\\"} \"\n                       \"where AssocClass = Win32_ComputerSystemProcessor \"\n                       \"ResultClass = Win32_Processor\",\n                       computerSystem->data.common->Name);\n\n    if (hypervGetWin32ProcessorList(priv, &query, &processorList) < 0)\n        goto cleanup;\n\n    if (processorList == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_Processor\");\n        goto cleanup;\n    }\n\n    /* Strip the string to fit more relevant information in 32 chars */\n    tmp = processorList->data.common->Name;\n\n    while (*tmp != '\\0') {\n        if (STRPREFIX(tmp, \"  \")) {\n            memmove(tmp, tmp + 1, strlen(tmp + 1) + 1);\n            continue;\n        } else if (STRPREFIX(tmp, \"(R)\") || STRPREFIX(tmp, \"(C)\")) {\n            memmove(tmp, tmp + 3, strlen(tmp + 3) + 1);\n            continue;\n        } else if (STRPREFIX(tmp, \"(TM)\")) {\n            memmove(tmp, tmp + 4, strlen(tmp + 4) + 1);\n            continue;\n        }\n\n        ++tmp;\n    }\n\n    /* Fill struct */\n    if (virStrcpyStatic(info->model, processorList->data.common->Name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU model %s too long for destination\"),\n                       processorList->data.common->Name);\n        goto cleanup;\n    }\n\n    info->memory = computerSystem->data.common->TotalPhysicalMemory / 1024; /* byte to kilobyte */\n    info->mhz = processorList->data.common->MaxClockSpeed;\n    info->nodes = 1;\n    info->sockets = 0;\n\n    for (processor = processorList; processor != NULL;\n         processor = processor->next) {\n        ++info->sockets;\n    }\n\n    info->cores = processorList->data.common->NumberOfCores;\n    info->threads = info->cores / processorList->data.common->NumberOfLogicalProcessors;\n    info->cpus = info->sockets * info->cores;\n\n    result = 0;\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n    hypervFreeObject(priv, (hypervObject *)processorList);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervConnectGetHostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "202-228",
    "snippet": "static char *\nhypervConnectGetHostname(virConnectPtr conn)\n{\n    char *hostname = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Win32_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, WIN32_COMPUTERSYSTEM_WQL_SELECT);\n\n    if (hypervGetWin32ComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_ComputerSystem\");\n        goto cleanup;\n    }\n\n    hostname = g_strdup(computerSystem->data.common->DNSHostName);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return hostname;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)computerSystem"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "computerSystem->data.common->DNSHostName"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s\")",
            "\"Win32_ComputerSystem\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetWin32ComputerSystemList",
          "args": [
            "priv",
            "&query",
            "&computerSystem"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWin32ComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1248-1254",
          "snippet": "int\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "WIN32_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nhypervConnectGetHostname(virConnectPtr conn)\n{\n    char *hostname = NULL;\n    hypervPrivate *priv = conn->privateData;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Win32_ComputerSystem *computerSystem = NULL;\n\n    virBufferAddLit(&query, WIN32_COMPUTERSYSTEM_WQL_SELECT);\n\n    if (hypervGetWin32ComputerSystemList(priv, &query, &computerSystem) < 0)\n        goto cleanup;\n\n    if (computerSystem == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s\"),\n                       \"Win32_ComputerSystem\");\n        goto cleanup;\n    }\n\n    hostname = g_strdup(computerSystem->data.common->DNSHostName);\n\n cleanup:\n    hypervFreeObject(priv, (hypervObject *)computerSystem);\n\n    return hostname;\n}"
  },
  {
    "function_name": "hypervConnectGetType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "194-198",
    "snippet": "static const char *\nhypervConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"Hyper-V\";\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic const char *\nhypervConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"Hyper-V\";\n}"
  },
  {
    "function_name": "hypervConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "180-190",
    "snippet": "static int\nhypervConnectClose(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    hypervFreePrivate(&priv);\n\n    conn->privateData = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreePrivate",
          "args": [
            "&priv"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "44-57",
          "snippet": "static void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervConnectClose(virConnectPtr conn)\n{\n    hypervPrivate *priv = conn->privateData;\n\n    hypervFreePrivate(&priv);\n\n    conn->privateData = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "118-176",
    "snippet": "static virDrvOpenStatus\nhypervConnectOpen(virConnectPtr conn, virConnectAuthPtr auth,\n                  virConfPtr conf G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    virDrvOpenStatus result = VIR_DRV_OPEN_ERROR;\n    hypervPrivate *priv = NULL;\n    char *username = NULL;\n    char *password = NULL;\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    /* Allocate per-connection private data */\n    if (VIR_ALLOC(priv) < 0)\n        goto cleanup;\n\n    if (hypervParseUri(&priv->parsedUri, conn->uri) < 0)\n        goto cleanup;\n\n    /* Set the port dependent on the transport protocol if no port is\n     * specified. This allows us to rely on the port parameter being\n     * correctly set when building URIs later on, without the need to\n     * distinguish between the situations port == 0 and port != 0 */\n    if (conn->uri->port == 0) {\n        if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n            conn->uri->port = 5986;\n        } else {\n            conn->uri->port = 5985;\n        }\n    }\n\n    /* Request credentials */\n    if (conn->uri->user != NULL) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"hyperv\",\n                                            \"administrator\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"hyperv\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    if (hypervInitConnection(conn, priv, username, password) < 0)\n        goto cleanup;\n\n    conn->privateData = priv;\n    priv = NULL;\n    result = VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    hypervFreePrivate(&priv);\n    VIR_FREE(username);\n    VIR_FREE(password);\n\n    return result;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "password"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "username"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervFreePrivate",
          "args": [
            "&priv"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "44-57",
          "snippet": "static void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervInitConnection",
          "args": [
            "conn",
            "priv",
            "username",
            "password"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "hypervInitConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "59-116",
          "snippet": "static int\nhypervInitConnection(virConnectPtr conn, hypervPrivate *priv,\n                     char *username, char *password)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n    hypervObject *computerSystem = NULL;\n    int ret = -1;\n\n    /* Initialize the openwsman connection */\n    priv->client = wsmc_create(conn->uri->server, conn->uri->port, \"/wsman\",\n                               priv->parsedUri->transport, username, password);\n\n    if (priv->client == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create openwsman client\"));\n        goto cleanup;\n    }\n\n    if (wsmc_transport_init(priv->client, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize openwsman transport\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Currently only basic authentication is supported  */\n    wsman_transport_set_auth_method(priv->client, \"basic\");\n\n    wqlQuery.info = Msvm_ComputerSystem_WmiInfo;\n    wqlQuery.query = &query;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"WHERE \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n    /* try query using V2 namespace (for Hyper-V 2012+) */\n    priv->wmiVersion = HYPERV_WMI_VERSION_V2;\n\n    if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0) {\n        /* rebuild query because hypervEnumAndPull consumes it */\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferAddLit(&query, \"WHERE \");\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n        /* fall back to V1 namespace (for Hyper-V 2008) */\n        priv->wmiVersion = HYPERV_WMI_VERSION_V1;\n\n        if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    hypervFreeObject(priv, computerSystem);\n\n    return ret;\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervInitConnection(virConnectPtr conn, hypervPrivate *priv,\n                     char *username, char *password)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n    hypervObject *computerSystem = NULL;\n    int ret = -1;\n\n    /* Initialize the openwsman connection */\n    priv->client = wsmc_create(conn->uri->server, conn->uri->port, \"/wsman\",\n                               priv->parsedUri->transport, username, password);\n\n    if (priv->client == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create openwsman client\"));\n        goto cleanup;\n    }\n\n    if (wsmc_transport_init(priv->client, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize openwsman transport\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Currently only basic authentication is supported  */\n    wsman_transport_set_auth_method(priv->client, \"basic\");\n\n    wqlQuery.info = Msvm_ComputerSystem_WmiInfo;\n    wqlQuery.query = &query;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"WHERE \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n    /* try query using V2 namespace (for Hyper-V 2012+) */\n    priv->wmiVersion = HYPERV_WMI_VERSION_V2;\n\n    if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0) {\n        /* rebuild query because hypervEnumAndPull consumes it */\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferAddLit(&query, \"WHERE \");\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n        /* fall back to V1 namespace (for Hyper-V 2008) */\n        priv->wmiVersion = HYPERV_WMI_VERSION_V1;\n\n        if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    hypervFreeObject(priv, computerSystem);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetPassword",
          "args": [
            "conn",
            "auth",
            "\"hyperv\"",
            "username",
            "conn->uri->server"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetPassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "276-289",
          "snippet": "char *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetUsername",
          "args": [
            "conn",
            "auth",
            "\"hyperv\"",
            "\"administrator\"",
            "conn->uri->server"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetUsername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "197-211",
          "snippet": "char *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "conn->uri->user"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervParseUri",
          "args": [
            "&priv->parsedUri",
            "conn->uri"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "hypervParseUri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_util.c",
          "lines": "37-83",
          "snippet": "int\nhypervParseUri(hypervParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n\n    if (parsedUri == NULL || *parsedUri != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        hypervFreeParsedUri(parsedUri);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nhypervParseUri(hypervParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n\n    if (parsedUri == NULL || *parsedUri != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        hypervFreeParsedUri(parsedUri);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDrvOpenStatus\nhypervConnectOpen(virConnectPtr conn, virConnectAuthPtr auth,\n                  virConfPtr conf G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    virDrvOpenStatus result = VIR_DRV_OPEN_ERROR;\n    hypervPrivate *priv = NULL;\n    char *username = NULL;\n    char *password = NULL;\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    /* Allocate per-connection private data */\n    if (VIR_ALLOC(priv) < 0)\n        goto cleanup;\n\n    if (hypervParseUri(&priv->parsedUri, conn->uri) < 0)\n        goto cleanup;\n\n    /* Set the port dependent on the transport protocol if no port is\n     * specified. This allows us to rely on the port parameter being\n     * correctly set when building URIs later on, without the need to\n     * distinguish between the situations port == 0 and port != 0 */\n    if (conn->uri->port == 0) {\n        if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n            conn->uri->port = 5986;\n        } else {\n            conn->uri->port = 5985;\n        }\n    }\n\n    /* Request credentials */\n    if (conn->uri->user != NULL) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"hyperv\",\n                                            \"administrator\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"hyperv\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    if (hypervInitConnection(conn, priv, username, password) < 0)\n        goto cleanup;\n\n    conn->privateData = priv;\n    priv = NULL;\n    result = VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    hypervFreePrivate(&priv);\n    VIR_FREE(username);\n    VIR_FREE(password);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervInitConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "59-116",
    "snippet": "static int\nhypervInitConnection(virConnectPtr conn, hypervPrivate *priv,\n                     char *username, char *password)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n    hypervObject *computerSystem = NULL;\n    int ret = -1;\n\n    /* Initialize the openwsman connection */\n    priv->client = wsmc_create(conn->uri->server, conn->uri->port, \"/wsman\",\n                               priv->parsedUri->transport, username, password);\n\n    if (priv->client == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create openwsman client\"));\n        goto cleanup;\n    }\n\n    if (wsmc_transport_init(priv->client, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize openwsman transport\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Currently only basic authentication is supported  */\n    wsman_transport_set_auth_method(priv->client, \"basic\");\n\n    wqlQuery.info = Msvm_ComputerSystem_WmiInfo;\n    wqlQuery.query = &query;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"WHERE \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n    /* try query using V2 namespace (for Hyper-V 2012+) */\n    priv->wmiVersion = HYPERV_WMI_VERSION_V2;\n\n    if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0) {\n        /* rebuild query because hypervEnumAndPull consumes it */\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferAddLit(&query, \"WHERE \");\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n        /* fall back to V1 namespace (for Hyper-V 2008) */\n        priv->wmiVersion = HYPERV_WMI_VERSION_V1;\n\n        if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    hypervFreeObject(priv, computerSystem);\n\n    return ret;\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "computerSystem"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervEnumAndPull",
          "args": [
            "priv",
            "&wqlQuery",
            "&computerSystem"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "hypervEnumAndPull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "953-1107",
          "snippet": "int\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nint\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_PHYSICAL"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"WHERE \""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_PHYSICAL"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"WHERE \""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsman_transport_set_auth_method",
          "args": [
            "priv->client",
            "\"basic\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize openwsman transport\")"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not initialize openwsman transport\""
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_transport_init",
          "args": [
            "priv->client",
            "NULL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create openwsman client\")"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_create",
          "args": [
            "conn->uri->server",
            "conn->uri->port",
            "\"/wsman\"",
            "priv->parsedUri->transport",
            "username",
            "password"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nhypervInitConnection(virConnectPtr conn, hypervPrivate *priv,\n                     char *username, char *password)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n    hypervObject *computerSystem = NULL;\n    int ret = -1;\n\n    /* Initialize the openwsman connection */\n    priv->client = wsmc_create(conn->uri->server, conn->uri->port, \"/wsman\",\n                               priv->parsedUri->transport, username, password);\n\n    if (priv->client == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create openwsman client\"));\n        goto cleanup;\n    }\n\n    if (wsmc_transport_init(priv->client, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize openwsman transport\"));\n        goto cleanup;\n    }\n\n    /* FIXME: Currently only basic authentication is supported  */\n    wsman_transport_set_auth_method(priv->client, \"basic\");\n\n    wqlQuery.info = Msvm_ComputerSystem_WmiInfo;\n    wqlQuery.query = &query;\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"WHERE \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n    /* try query using V2 namespace (for Hyper-V 2012+) */\n    priv->wmiVersion = HYPERV_WMI_VERSION_V2;\n\n    if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0) {\n        /* rebuild query because hypervEnumAndPull consumes it */\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n        virBufferAddLit(&query, \"WHERE \");\n        virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_PHYSICAL);\n\n        /* fall back to V1 namespace (for Hyper-V 2008) */\n        priv->wmiVersion = HYPERV_WMI_VERSION_V1;\n\n        if (hypervEnumAndPull(priv, &wqlQuery, &computerSystem) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    hypervFreeObject(priv, computerSystem);\n\n    return ret;\n}"
  },
  {
    "function_name": "hypervFreePrivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
    "lines": "44-57",
    "snippet": "static void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}",
    "includes": [
      "#include \"virkeycode.h\"",
      "#include \"virstring.h\"",
      "#include \"openwsman.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_util.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"hyperv_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*priv"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervFreeParsedUri",
          "args": [
            "&(*priv)->parsedUri"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeParsedUri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_util.c",
          "lines": "87-96",
          "snippet": "void\nhypervFreeParsedUri(hypervParsedUri **parsedUri)\n{\n    if (parsedUri == NULL || *parsedUri == NULL)\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n\n    VIR_FREE(*parsedUri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nhypervFreeParsedUri(hypervParsedUri **parsedUri)\n{\n    if (parsedUri == NULL || *parsedUri == NULL)\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n\n    VIR_FREE(*parsedUri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_release",
          "args": [
            "(*priv)->client"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nhypervFreePrivate(hypervPrivate **priv)\n{\n    if (priv == NULL || *priv == NULL)\n        return;\n\n    if ((*priv)->client != NULL) {\n        /* FIXME: This leaks memory due to bugs in openwsman <= 2.2.6 */\n        wsmc_release((*priv)->client);\n    }\n\n    hypervFreeParsedUri(&(*priv)->parsedUri);\n    VIR_FREE(*priv);\n}"
  }
]