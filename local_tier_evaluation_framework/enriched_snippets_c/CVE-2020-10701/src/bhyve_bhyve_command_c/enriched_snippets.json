[
  {
    "function_name": "virBhyveProcessBuildLoadCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "954-973",
    "snippet": "virCommandPtr\nvirBhyveProcessBuildLoadCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                            const char *devmap_file, char **devicesmap_out)\n{\n    virDomainDiskDefPtr disk = NULL;\n\n    if (def->os.bootloader == NULL) {\n        disk = virBhyveGetBootDisk(def);\n\n        if (disk == NULL)\n            return NULL;\n\n        return virBhyveProcessBuildBhyveloadCmd(def, disk);\n    } else if (strstr(def->os.bootloader, \"grub-bhyve\") != NULL) {\n        return virBhyveProcessBuildGrubbhyveCmd(def, driver, devmap_file,\n                                                devicesmap_out);\n    } else {\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n    }\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBhyveProcessBuildCustomLoaderCmd",
          "args": [
            "def"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildCustomLoaderCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "708-725",
          "snippet": "static virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildGrubbhyveCmd",
          "args": [
            "def",
            "driver",
            "devmap_file",
            "devicesmap_out"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildGrubbhyveCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "761-866",
          "snippet": "static virCommandPtr\nvirBhyveProcessBuildGrubbhyveCmd(virDomainDefPtr def,\n                                 bhyveConnPtr driver,\n                                 const char *devmap_file,\n                                 char **devicesmap_out)\n{\n    virDomainDiskDefPtr hdd, cd, userdef, diskdef;\n    virBuffer devicemap;\n    virCommandPtr cmd;\n    unsigned int best_idx = UINT_MAX;\n    size_t i;\n\n    if (def->os.bootloaderArgs != NULL)\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n\n    devicemap = (virBuffer)VIR_BUFFER_INITIALIZER;\n\n    /* Search disk list for CD or HDD device. We'll respect <boot order=''> if\n     * present and otherwise pick the first CD or failing that HDD we come\n     * across. */\n    cd = hdd = userdef = NULL;\n    for (i = 0; i < def->ndisks; i++) {\n        if (!virBhyveUsableDisk(def->disks[i]))\n            continue;\n\n        diskdef = def->disks[i];\n\n        if (diskdef->info.bootIndex && diskdef->info.bootIndex < best_idx) {\n            userdef = diskdef;\n            best_idx = userdef->info.bootIndex;\n            continue;\n        }\n\n        if (cd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            cd = diskdef;\n            VIR_INFO(\"Picking %s as CD\", virDomainDiskGetSource(cd));\n        }\n\n        if (hdd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            hdd = diskdef;\n            VIR_INFO(\"Picking %s as HDD\", virDomainDiskGetSource(hdd));\n        }\n    }\n\n    cmd = virCommandNew(def->os.bootloader);\n\n    VIR_DEBUG(\"grub-bhyve with default arguments\");\n\n    if (devicesmap_out != NULL) {\n        /* Grub device.map (just for boot) */\n        if (userdef != NULL) {\n            virBhyveFormatGrubDevice(&devicemap, userdef);\n        } else {\n            if (hdd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, hdd);\n\n            if (cd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, cd);\n        }\n\n        *devicesmap_out = virBufferContentAndReset(&devicemap);\n    }\n\n    virCommandAddArg(cmd, \"--root\");\n    if (userdef != NULL) {\n        if (userdef->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n            virCommandAddArg(cmd, \"cd\");\n        else\n            virCommandAddArg(cmd, \"hd0,msdos1\");\n    } else if (cd != NULL) {\n        virCommandAddArg(cmd, \"cd\");\n    } else {\n        virCommandAddArg(cmd, \"hd0,msdos1\");\n    }\n\n    virCommandAddArg(cmd, \"--device-map\");\n    virCommandAddArg(cmd, devmap_file);\n\n    /* Memory in MB */\n    virCommandAddArg(cmd, \"--memory\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if ((bhyveDriverGetGrubCaps(driver) & BHYVE_GRUB_CAP_CONSDEV) != 0 &&\n        def->nserials > 0) {\n        virDomainChrDefPtr chr;\n\n        chr = def->serials[0];\n\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only nmdm console types are supported\"));\n            return NULL;\n        }\n\n        virCommandAddArg(cmd, \"--cons-dev\");\n        virCommandAddArg(cmd, chr->source->data.file.path);\n    }\n\n    /* VM name */\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildGrubbhyveCmd(virDomainDefPtr def,\n                                 bhyveConnPtr driver,\n                                 const char *devmap_file,\n                                 char **devicesmap_out)\n{\n    virDomainDiskDefPtr hdd, cd, userdef, diskdef;\n    virBuffer devicemap;\n    virCommandPtr cmd;\n    unsigned int best_idx = UINT_MAX;\n    size_t i;\n\n    if (def->os.bootloaderArgs != NULL)\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n\n    devicemap = (virBuffer)VIR_BUFFER_INITIALIZER;\n\n    /* Search disk list for CD or HDD device. We'll respect <boot order=''> if\n     * present and otherwise pick the first CD or failing that HDD we come\n     * across. */\n    cd = hdd = userdef = NULL;\n    for (i = 0; i < def->ndisks; i++) {\n        if (!virBhyveUsableDisk(def->disks[i]))\n            continue;\n\n        diskdef = def->disks[i];\n\n        if (diskdef->info.bootIndex && diskdef->info.bootIndex < best_idx) {\n            userdef = diskdef;\n            best_idx = userdef->info.bootIndex;\n            continue;\n        }\n\n        if (cd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            cd = diskdef;\n            VIR_INFO(\"Picking %s as CD\", virDomainDiskGetSource(cd));\n        }\n\n        if (hdd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            hdd = diskdef;\n            VIR_INFO(\"Picking %s as HDD\", virDomainDiskGetSource(hdd));\n        }\n    }\n\n    cmd = virCommandNew(def->os.bootloader);\n\n    VIR_DEBUG(\"grub-bhyve with default arguments\");\n\n    if (devicesmap_out != NULL) {\n        /* Grub device.map (just for boot) */\n        if (userdef != NULL) {\n            virBhyveFormatGrubDevice(&devicemap, userdef);\n        } else {\n            if (hdd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, hdd);\n\n            if (cd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, cd);\n        }\n\n        *devicesmap_out = virBufferContentAndReset(&devicemap);\n    }\n\n    virCommandAddArg(cmd, \"--root\");\n    if (userdef != NULL) {\n        if (userdef->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n            virCommandAddArg(cmd, \"cd\");\n        else\n            virCommandAddArg(cmd, \"hd0,msdos1\");\n    } else if (cd != NULL) {\n        virCommandAddArg(cmd, \"cd\");\n    } else {\n        virCommandAddArg(cmd, \"hd0,msdos1\");\n    }\n\n    virCommandAddArg(cmd, \"--device-map\");\n    virCommandAddArg(cmd, devmap_file);\n\n    /* Memory in MB */\n    virCommandAddArg(cmd, \"--memory\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if ((bhyveDriverGetGrubCaps(driver) & BHYVE_GRUB_CAP_CONSDEV) != 0 &&\n        def->nserials > 0) {\n        virDomainChrDefPtr chr;\n\n        chr = def->serials[0];\n\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only nmdm console types are supported\"));\n            return NULL;\n        }\n\n        virCommandAddArg(cmd, \"--cons-dev\");\n        virCommandAddArg(cmd, chr->source->data.file.path);\n    }\n\n    /* VM name */\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "def->os.bootloader",
            "\"grub-bhyve\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildBhyveloadCmd",
          "args": [
            "def",
            "disk"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildBhyveloadCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "679-706",
          "snippet": "static virCommandPtr\nvirBhyveProcessBuildBhyveloadCmd(virDomainDefPtr def, virDomainDiskDefPtr disk)\n{\n    virCommandPtr cmd;\n\n    cmd = virCommandNew(BHYVELOAD);\n\n    if (def->os.bootloaderArgs == NULL) {\n        VIR_DEBUG(\"bhyveload with default arguments\");\n\n        /* Memory (MB) */\n        virCommandAddArg(cmd, \"-m\");\n        virCommandAddArgFormat(cmd, \"%llu\",\n                               VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n        /* Image path */\n        virCommandAddArg(cmd, \"-d\");\n        virCommandAddArg(cmd, virDomainDiskGetSource(disk));\n\n        /* VM name */\n        virCommandAddArg(cmd, def->name);\n    } else {\n        VIR_DEBUG(\"bhyveload with arguments\");\n        virAppendBootloaderArgs(cmd, def);\n    }\n\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildBhyveloadCmd(virDomainDefPtr def, virDomainDiskDefPtr disk)\n{\n    virCommandPtr cmd;\n\n    cmd = virCommandNew(BHYVELOAD);\n\n    if (def->os.bootloaderArgs == NULL) {\n        VIR_DEBUG(\"bhyveload with default arguments\");\n\n        /* Memory (MB) */\n        virCommandAddArg(cmd, \"-m\");\n        virCommandAddArgFormat(cmd, \"%llu\",\n                               VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n        /* Image path */\n        virCommandAddArg(cmd, \"-d\");\n        virCommandAddArg(cmd, virDomainDiskGetSource(disk));\n\n        /* VM name */\n        virCommandAddArg(cmd, def->name);\n    } else {\n        VIR_DEBUG(\"bhyveload with arguments\");\n        virAppendBootloaderArgs(cmd, def);\n    }\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveGetBootDisk",
          "args": [
            "def"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveGetBootDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "868-952",
          "snippet": "static virDomainDiskDefPtr\nvirBhyveGetBootDisk(virDomainDefPtr def)\n{\n    size_t i;\n    virDomainDiskDefPtr match = NULL;\n    int boot_dev = -1;\n\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Domain should have at least one disk defined\"));\n        return NULL;\n    }\n\n    if (def->os.nBootDevs > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only one boot device is supported\"));\n        return NULL;\n    } else if (def->os.nBootDevs == 1) {\n        switch (def->os.bootDevs[0]) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot boot from device %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    }\n\n    if (boot_dev != -1) {\n        /* If boot_dev is set, we return the first device of\n         * the request type */\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n\n            if (def->disks[i]->device == boot_dev) {\n                match = def->disks[i];\n                break;\n            }\n        }\n\n        if (match == NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot find boot device of requested type %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    } else {\n        /* Otherwise, if boot_dev is not set, we try to find if bootIndex\n         * is set for individual device. However, as bhyve does not support\n         * specifying real boot priority for devices, we allow only single\n         * device with boot priority set.\n         */\n        int first_usable_disk_index = -1;\n\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n            else\n                first_usable_disk_index = i;\n\n            if (def->disks[i]->info.bootIndex > 0) {\n                if (match == NULL) {\n                    match = def->disks[i];\n                } else {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Only one boot device is supported\"));\n                    return NULL;\n                }\n            }\n        }\n\n        /* If user didn't explicitly specify boot priority,\n         * just return the first usable disk */\n        if ((match == NULL) && (first_usable_disk_index >= 0))\n            return def->disks[first_usable_disk_index];\n    }\n\n    return match;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nvirBhyveGetBootDisk(virDomainDefPtr def)\n{\n    size_t i;\n    virDomainDiskDefPtr match = NULL;\n    int boot_dev = -1;\n\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Domain should have at least one disk defined\"));\n        return NULL;\n    }\n\n    if (def->os.nBootDevs > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only one boot device is supported\"));\n        return NULL;\n    } else if (def->os.nBootDevs == 1) {\n        switch (def->os.bootDevs[0]) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot boot from device %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    }\n\n    if (boot_dev != -1) {\n        /* If boot_dev is set, we return the first device of\n         * the request type */\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n\n            if (def->disks[i]->device == boot_dev) {\n                match = def->disks[i];\n                break;\n            }\n        }\n\n        if (match == NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot find boot device of requested type %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    } else {\n        /* Otherwise, if boot_dev is not set, we try to find if bootIndex\n         * is set for individual device. However, as bhyve does not support\n         * specifying real boot priority for devices, we allow only single\n         * device with boot priority set.\n         */\n        int first_usable_disk_index = -1;\n\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n            else\n                first_usable_disk_index = i;\n\n            if (def->disks[i]->info.bootIndex > 0) {\n                if (match == NULL) {\n                    match = def->disks[i];\n                } else {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Only one boot device is supported\"));\n                    return NULL;\n                }\n            }\n        }\n\n        /* If user didn't explicitly specify boot priority,\n         * just return the first usable disk */\n        if ((match == NULL) && (first_usable_disk_index >= 0))\n            return def->disks[first_usable_disk_index];\n    }\n\n    return match;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildLoadCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                            const char *devmap_file, char **devicesmap_out)\n{\n    virDomainDiskDefPtr disk = NULL;\n\n    if (def->os.bootloader == NULL) {\n        disk = virBhyveGetBootDisk(def);\n\n        if (disk == NULL)\n            return NULL;\n\n        return virBhyveProcessBuildBhyveloadCmd(def, disk);\n    } else if (strstr(def->os.bootloader, \"grub-bhyve\") != NULL) {\n        return virBhyveProcessBuildGrubbhyveCmd(def, driver, devmap_file,\n                                                devicesmap_out);\n    } else {\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n    }\n}"
  },
  {
    "function_name": "virBhyveGetBootDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "868-952",
    "snippet": "static virDomainDiskDefPtr\nvirBhyveGetBootDisk(virDomainDefPtr def)\n{\n    size_t i;\n    virDomainDiskDefPtr match = NULL;\n    int boot_dev = -1;\n\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Domain should have at least one disk defined\"));\n        return NULL;\n    }\n\n    if (def->os.nBootDevs > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only one boot device is supported\"));\n        return NULL;\n    } else if (def->os.nBootDevs == 1) {\n        switch (def->os.bootDevs[0]) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot boot from device %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    }\n\n    if (boot_dev != -1) {\n        /* If boot_dev is set, we return the first device of\n         * the request type */\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n\n            if (def->disks[i]->device == boot_dev) {\n                match = def->disks[i];\n                break;\n            }\n        }\n\n        if (match == NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot find boot device of requested type %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    } else {\n        /* Otherwise, if boot_dev is not set, we try to find if bootIndex\n         * is set for individual device. However, as bhyve does not support\n         * specifying real boot priority for devices, we allow only single\n         * device with boot priority set.\n         */\n        int first_usable_disk_index = -1;\n\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n            else\n                first_usable_disk_index = i;\n\n            if (def->disks[i]->info.bootIndex > 0) {\n                if (match == NULL) {\n                    match = def->disks[i];\n                } else {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Only one boot device is supported\"));\n                    return NULL;\n                }\n            }\n        }\n\n        /* If user didn't explicitly specify boot priority,\n         * just return the first usable disk */\n        if ((match == NULL) && (first_usable_disk_index >= 0))\n            return def->disks[first_usable_disk_index];\n    }\n\n    return match;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only one boot device is supported\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Only one boot device is supported\""
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveUsableDisk",
          "args": [
            "def->disks[i]"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveUsableDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "727-748",
          "snippet": "static bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cannot find boot device of requested type %s\")",
            "virDomainBootTypeToString(def->os.bootDevs[0])"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBootTypeToString",
          "args": [
            "def->os.bootDevs[0]"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Cannot boot from device %s\")",
            "virDomainBootTypeToString(def->os.bootDevs[0])"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBootTypeToString",
          "args": [
            "def->os.bootDevs[0]"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only one boot device is supported\")"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Domain should have at least one disk defined\")"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nvirBhyveGetBootDisk(virDomainDefPtr def)\n{\n    size_t i;\n    virDomainDiskDefPtr match = NULL;\n    int boot_dev = -1;\n\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Domain should have at least one disk defined\"));\n        return NULL;\n    }\n\n    if (def->os.nBootDevs > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only one boot device is supported\"));\n        return NULL;\n    } else if (def->os.nBootDevs == 1) {\n        switch (def->os.bootDevs[0]) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            boot_dev = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot boot from device %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    }\n\n    if (boot_dev != -1) {\n        /* If boot_dev is set, we return the first device of\n         * the request type */\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n\n            if (def->disks[i]->device == boot_dev) {\n                match = def->disks[i];\n                break;\n            }\n        }\n\n        if (match == NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Cannot find boot device of requested type %s\"),\n                           virDomainBootTypeToString(def->os.bootDevs[0]));\n            return NULL;\n        }\n    } else {\n        /* Otherwise, if boot_dev is not set, we try to find if bootIndex\n         * is set for individual device. However, as bhyve does not support\n         * specifying real boot priority for devices, we allow only single\n         * device with boot priority set.\n         */\n        int first_usable_disk_index = -1;\n\n        for (i = 0; i < def->ndisks; i++) {\n            if (!virBhyveUsableDisk(def->disks[i]))\n                continue;\n            else\n                first_usable_disk_index = i;\n\n            if (def->disks[i]->info.bootIndex > 0) {\n                if (match == NULL) {\n                    match = def->disks[i];\n                } else {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Only one boot device is supported\"));\n                    return NULL;\n                }\n            }\n        }\n\n        /* If user didn't explicitly specify boot priority,\n         * just return the first usable disk */\n        if ((match == NULL) && (first_usable_disk_index >= 0))\n            return def->disks[first_usable_disk_index];\n    }\n\n    return match;\n}"
  },
  {
    "function_name": "virBhyveProcessBuildGrubbhyveCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "761-866",
    "snippet": "static virCommandPtr\nvirBhyveProcessBuildGrubbhyveCmd(virDomainDefPtr def,\n                                 bhyveConnPtr driver,\n                                 const char *devmap_file,\n                                 char **devicesmap_out)\n{\n    virDomainDiskDefPtr hdd, cd, userdef, diskdef;\n    virBuffer devicemap;\n    virCommandPtr cmd;\n    unsigned int best_idx = UINT_MAX;\n    size_t i;\n\n    if (def->os.bootloaderArgs != NULL)\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n\n    devicemap = (virBuffer)VIR_BUFFER_INITIALIZER;\n\n    /* Search disk list for CD or HDD device. We'll respect <boot order=''> if\n     * present and otherwise pick the first CD or failing that HDD we come\n     * across. */\n    cd = hdd = userdef = NULL;\n    for (i = 0; i < def->ndisks; i++) {\n        if (!virBhyveUsableDisk(def->disks[i]))\n            continue;\n\n        diskdef = def->disks[i];\n\n        if (diskdef->info.bootIndex && diskdef->info.bootIndex < best_idx) {\n            userdef = diskdef;\n            best_idx = userdef->info.bootIndex;\n            continue;\n        }\n\n        if (cd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            cd = diskdef;\n            VIR_INFO(\"Picking %s as CD\", virDomainDiskGetSource(cd));\n        }\n\n        if (hdd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            hdd = diskdef;\n            VIR_INFO(\"Picking %s as HDD\", virDomainDiskGetSource(hdd));\n        }\n    }\n\n    cmd = virCommandNew(def->os.bootloader);\n\n    VIR_DEBUG(\"grub-bhyve with default arguments\");\n\n    if (devicesmap_out != NULL) {\n        /* Grub device.map (just for boot) */\n        if (userdef != NULL) {\n            virBhyveFormatGrubDevice(&devicemap, userdef);\n        } else {\n            if (hdd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, hdd);\n\n            if (cd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, cd);\n        }\n\n        *devicesmap_out = virBufferContentAndReset(&devicemap);\n    }\n\n    virCommandAddArg(cmd, \"--root\");\n    if (userdef != NULL) {\n        if (userdef->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n            virCommandAddArg(cmd, \"cd\");\n        else\n            virCommandAddArg(cmd, \"hd0,msdos1\");\n    } else if (cd != NULL) {\n        virCommandAddArg(cmd, \"cd\");\n    } else {\n        virCommandAddArg(cmd, \"hd0,msdos1\");\n    }\n\n    virCommandAddArg(cmd, \"--device-map\");\n    virCommandAddArg(cmd, devmap_file);\n\n    /* Memory in MB */\n    virCommandAddArg(cmd, \"--memory\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if ((bhyveDriverGetGrubCaps(driver) & BHYVE_GRUB_CAP_CONSDEV) != 0 &&\n        def->nserials > 0) {\n        virDomainChrDefPtr chr;\n\n        chr = def->serials[0];\n\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only nmdm console types are supported\"));\n            return NULL;\n        }\n\n        virCommandAddArg(cmd, \"--cons-dev\");\n        virCommandAddArg(cmd, chr->source->data.file.path);\n    }\n\n    /* VM name */\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "def->name"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only nmdm console types are supported\")"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"only nmdm console types are supported\""
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDriverGetGrubCaps",
          "args": [
            "driver"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDriverGetGrubCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_driver.c",
          "lines": "1324-1330",
          "snippet": "unsigned\nbhyveDriverGetGrubCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->grubcaps;\n    return 0;\n}",
          "includes": [
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"conf/domain_capabilities.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_audit.h\"",
            "#include \"interface_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bhyve_capabilities.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"virutil.h\"\n#include \"conf/domain_capabilities.h\"\n#include \"virportallocator.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"viraccessapicheck.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"virdomainobjlist.h\"\n#include \"node_device_conf.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_event.h\"\n#include \"domain_audit.h\"\n#include \"interface_conf.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned\nbhyveDriverGetGrubCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->grubcaps;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%llu\"",
            "VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024)"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "virDomainDefGetMemoryInitial(def)",
            "1024"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryInitial",
          "args": [
            "def"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryInitial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10910-10920",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&devicemap"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveFormatGrubDevice",
          "args": [
            "&devicemap",
            "cd"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveFormatGrubDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "750-759",
          "snippet": "static void\nvirBhyveFormatGrubDevice(virBufferPtr devicemap, virDomainDiskDefPtr def)\n{\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAsprintf(devicemap, \"(cd) %s\\n\",\n                          virDomainDiskGetSource(def));\n    else\n        virBufferAsprintf(devicemap, \"(hd0) %s\\n\",\n                          virDomainDiskGetSource(def));\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirBhyveFormatGrubDevice(virBufferPtr devicemap, virDomainDiskDefPtr def)\n{\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAsprintf(devicemap, \"(cd) %s\\n\",\n                          virDomainDiskGetSource(def));\n    else\n        virBufferAsprintf(devicemap, \"(hd0) %s\\n\",\n                          virDomainDiskGetSource(def));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"grub-bhyve with default arguments\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "def->os.bootloader"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Picking %s as HDD\"",
            "virDomainDiskGetSource(hdd)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "hdd"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Picking %s as CD\"",
            "virDomainDiskGetSource(cd)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBhyveUsableDisk",
          "args": [
            "def->disks[i]"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveUsableDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "727-748",
          "snippet": "static bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBhyveProcessBuildCustomLoaderCmd",
          "args": [
            "def"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessBuildCustomLoaderCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "708-725",
          "snippet": "static virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildGrubbhyveCmd(virDomainDefPtr def,\n                                 bhyveConnPtr driver,\n                                 const char *devmap_file,\n                                 char **devicesmap_out)\n{\n    virDomainDiskDefPtr hdd, cd, userdef, diskdef;\n    virBuffer devicemap;\n    virCommandPtr cmd;\n    unsigned int best_idx = UINT_MAX;\n    size_t i;\n\n    if (def->os.bootloaderArgs != NULL)\n        return virBhyveProcessBuildCustomLoaderCmd(def);\n\n    devicemap = (virBuffer)VIR_BUFFER_INITIALIZER;\n\n    /* Search disk list for CD or HDD device. We'll respect <boot order=''> if\n     * present and otherwise pick the first CD or failing that HDD we come\n     * across. */\n    cd = hdd = userdef = NULL;\n    for (i = 0; i < def->ndisks; i++) {\n        if (!virBhyveUsableDisk(def->disks[i]))\n            continue;\n\n        diskdef = def->disks[i];\n\n        if (diskdef->info.bootIndex && diskdef->info.bootIndex < best_idx) {\n            userdef = diskdef;\n            best_idx = userdef->info.bootIndex;\n            continue;\n        }\n\n        if (cd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            cd = diskdef;\n            VIR_INFO(\"Picking %s as CD\", virDomainDiskGetSource(cd));\n        }\n\n        if (hdd == NULL &&\n            def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            hdd = diskdef;\n            VIR_INFO(\"Picking %s as HDD\", virDomainDiskGetSource(hdd));\n        }\n    }\n\n    cmd = virCommandNew(def->os.bootloader);\n\n    VIR_DEBUG(\"grub-bhyve with default arguments\");\n\n    if (devicesmap_out != NULL) {\n        /* Grub device.map (just for boot) */\n        if (userdef != NULL) {\n            virBhyveFormatGrubDevice(&devicemap, userdef);\n        } else {\n            if (hdd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, hdd);\n\n            if (cd != NULL)\n                virBhyveFormatGrubDevice(&devicemap, cd);\n        }\n\n        *devicesmap_out = virBufferContentAndReset(&devicemap);\n    }\n\n    virCommandAddArg(cmd, \"--root\");\n    if (userdef != NULL) {\n        if (userdef->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n            virCommandAddArg(cmd, \"cd\");\n        else\n            virCommandAddArg(cmd, \"hd0,msdos1\");\n    } else if (cd != NULL) {\n        virCommandAddArg(cmd, \"cd\");\n    } else {\n        virCommandAddArg(cmd, \"hd0,msdos1\");\n    }\n\n    virCommandAddArg(cmd, \"--device-map\");\n    virCommandAddArg(cmd, devmap_file);\n\n    /* Memory in MB */\n    virCommandAddArg(cmd, \"--memory\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if ((bhyveDriverGetGrubCaps(driver) & BHYVE_GRUB_CAP_CONSDEV) != 0 &&\n        def->nserials > 0) {\n        virDomainChrDefPtr chr;\n\n        chr = def->serials[0];\n\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only nmdm console types are supported\"));\n            return NULL;\n        }\n\n        virCommandAddArg(cmd, \"--cons-dev\");\n        virCommandAddArg(cmd, chr->source->data.file.path);\n    }\n\n    /* VM name */\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n}"
  },
  {
    "function_name": "virBhyveFormatGrubDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "750-759",
    "snippet": "static void\nvirBhyveFormatGrubDevice(virBufferPtr devicemap, virDomainDiskDefPtr def)\n{\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAsprintf(devicemap, \"(cd) %s\\n\",\n                          virDomainDiskGetSource(def));\n    else\n        virBufferAsprintf(devicemap, \"(hd0) %s\\n\",\n                          virDomainDiskGetSource(def));\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "devicemap",
            "\"(hd0) %s\\n\"",
            "virDomainDiskGetSource(def)"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirBhyveFormatGrubDevice(virBufferPtr devicemap, virDomainDiskDefPtr def)\n{\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAsprintf(devicemap, \"(cd) %s\\n\",\n                          virDomainDiskGetSource(def));\n    else\n        virBufferAsprintf(devicemap, \"(hd0) %s\\n\",\n                          virDomainDiskGetSource(def));\n}"
  },
  {
    "function_name": "virBhyveUsableDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "727-748",
    "snippet": "static bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk type\")"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported disk type\""
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "disk"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk device\")"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskTranslateSourcePool",
          "args": [
            "disk"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskTranslateSourcePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31966-31994",
          "snippet": "int\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirBhyveUsableDisk(virDomainDiskDefPtr disk)\n{\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return false;\n\n    if ((disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) &&\n        (disk->device != VIR_DOMAIN_DISK_DEVICE_CDROM)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return false;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virBhyveProcessBuildCustomLoaderCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "708-725",
    "snippet": "static virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virAppendBootloaderArgs",
          "args": [
            "cmd",
            "def"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virAppendBootloaderArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "668-677",
          "snippet": "static void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "def->os.bootloader"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"custom loader '%s' with arguments\"",
            "def->os.bootloader"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Custom loader requires explicit %s configuration\")",
            "\"bootloader_args\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Custom loader requires explicit %s configuration\""
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildCustomLoaderCmd(virDomainDefPtr def)\n{\n    virCommandPtr cmd;\n\n    if (def->os.bootloaderArgs == NULL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Custom loader requires explicit %s configuration\"),\n                       \"bootloader_args\");\n        return NULL;\n    }\n\n    VIR_DEBUG(\"custom loader '%s' with arguments\", def->os.bootloader);\n\n    cmd = virCommandNew(def->os.bootloader);\n    virAppendBootloaderArgs(cmd, def);\n    return cmd;\n}"
  },
  {
    "function_name": "virBhyveProcessBuildBhyveloadCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "679-706",
    "snippet": "static virCommandPtr\nvirBhyveProcessBuildBhyveloadCmd(virDomainDefPtr def, virDomainDiskDefPtr disk)\n{\n    virCommandPtr cmd;\n\n    cmd = virCommandNew(BHYVELOAD);\n\n    if (def->os.bootloaderArgs == NULL) {\n        VIR_DEBUG(\"bhyveload with default arguments\");\n\n        /* Memory (MB) */\n        virCommandAddArg(cmd, \"-m\");\n        virCommandAddArgFormat(cmd, \"%llu\",\n                               VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n        /* Image path */\n        virCommandAddArg(cmd, \"-d\");\n        virCommandAddArg(cmd, virDomainDiskGetSource(disk));\n\n        /* VM name */\n        virCommandAddArg(cmd, def->name);\n    } else {\n        VIR_DEBUG(\"bhyveload with arguments\");\n        virAppendBootloaderArgs(cmd, def);\n    }\n\n    return cmd;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virAppendBootloaderArgs",
          "args": [
            "cmd",
            "def"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "virAppendBootloaderArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "668-677",
          "snippet": "static void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"bhyveload with arguments\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "def->name"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%llu\"",
            "VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024)"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "virDomainDefGetMemoryInitial(def)",
            "1024"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryInitial",
          "args": [
            "def"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryInitial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10910-10920",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"bhyveload with default arguments\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "BHYVELOAD"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic virCommandPtr\nvirBhyveProcessBuildBhyveloadCmd(virDomainDefPtr def, virDomainDiskDefPtr disk)\n{\n    virCommandPtr cmd;\n\n    cmd = virCommandNew(BHYVELOAD);\n\n    if (def->os.bootloaderArgs == NULL) {\n        VIR_DEBUG(\"bhyveload with default arguments\");\n\n        /* Memory (MB) */\n        virCommandAddArg(cmd, \"-m\");\n        virCommandAddArgFormat(cmd, \"%llu\",\n                               VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n        /* Image path */\n        virCommandAddArg(cmd, \"-d\");\n        virCommandAddArg(cmd, virDomainDiskGetSource(disk));\n\n        /* VM name */\n        virCommandAddArg(cmd, def->name);\n    } else {\n        VIR_DEBUG(\"bhyveload with arguments\");\n        virAppendBootloaderArgs(cmd, def);\n    }\n\n    return cmd;\n}"
  },
  {
    "function_name": "virAppendBootloaderArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "668-677",
    "snippet": "static void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "blargs"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgSet",
          "args": [
            "cmd",
            "(const char * const *)blargs"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1617-1646",
          "snippet": "void\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "def->os.bootloaderArgs",
            "\" \"",
            "0"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirAppendBootloaderArgs(virCommandPtr cmd, virDomainDefPtr def)\n{\n    char **blargs;\n\n    /* XXX: Handle quoted? */\n    blargs = virStringSplit(def->os.bootloaderArgs, \" \", 0);\n    virCommandAddArgSet(cmd, (const char * const *)blargs);\n    virStringListFree(blargs);\n}"
  },
  {
    "function_name": "virBhyveProcessBuildDestroyCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "656-666",
    "snippet": "virCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgPair",
          "args": [
            "cmd",
            "\"--vm\"",
            "def->name"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1600-1608",
          "snippet": "void\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"--destroy\""
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "BHYVECTL"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildDestroyCmd(bhyveConnPtr driver G_GNUC_UNUSED,\n                               virDomainDefPtr def)\n{\n    virCommandPtr cmd = virCommandNew(BHYVECTL);\n\n    virCommandAddArg(cmd, \"--destroy\");\n    virCommandAddArgPair(cmd, \"--vm\", def->name);\n\n    return cmd;\n}"
  },
  {
    "function_name": "virBhyveProcessBuildBhyveCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "485-654",
    "snippet": "virCommandPtr\nvirBhyveProcessBuildBhyveCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                             bool dryRun)\n{\n    /*\n     * /usr/sbin/bhyve -c 2 -m 256 -AI -H -P \\\n     *            -s 0:0,hostbridge \\\n     *            -s 1:0,virtio-net,tap0 \\\n     *            -s 2:0,ahci-hd,${IMG} \\\n     *            -S 31,uart,stdio \\\n     *            vm0\n     */\n    virCommandPtr cmd = virCommandNew(BHYVE);\n    size_t i;\n    unsigned nusbcontrollers = 0;\n    unsigned nvcpus = virDomainDefGetVcpus(def);\n\n    /* CPUs */\n    virCommandAddArg(cmd, \"-c\");\n    if (def->cpu && def->cpu->sockets) {\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto error;\n        }\n        if (nvcpus != def->cpu->sockets * def->cpu->cores * def->cpu->threads) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Invalid CPU topology: total number of vCPUs \"\n                             \"must equal the product of sockets, cores, \"\n                             \"and threads\"));\n            goto error;\n        }\n\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_CPUTOPOLOGY) != 0) {\n            virCommandAddArgFormat(cmd, \"cpus=%d,sockets=%d,cores=%d,threads=%d\",\n                                   nvcpus,\n                                   def->cpu->sockets,\n                                   def->cpu->cores,\n                                   def->cpu->threads);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"defining CPU topology\"));\n            goto error;\n        }\n    } else {\n        virCommandAddArgFormat(cmd, \"%d\", nvcpus);\n    }\n\n    /* Memory */\n    virCommandAddArg(cmd, \"-m\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if (def->mem.locked)\n        virCommandAddArg(cmd, \"-S\"); /* Wire guest memory */\n\n    /* Options */\n    if (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-A\"); /* Create an ACPI table */\n    if (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-I\"); /* Present ioapic to the guest */\n    if (def->features[VIR_DOMAIN_FEATURE_MSRS] == VIR_TRISTATE_SWITCH_ON) {\n        if (def->msrs_features[VIR_DOMAIN_MSRS_UNKNOWN] == VIR_DOMAIN_MSRS_UNKNOWN_IGNORE)\n            virCommandAddArg(cmd, \"-w\");\n    }\n\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        /* used by default in bhyve */\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_RTC_UTC) != 0) {\n            virCommandAddArg(cmd, \"-u\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                          \"UTC clock\"));\n            goto error;\n        }\n        break;\n    default:\n         virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported clock offset '%s'\"),\n                        virDomainClockOffsetTypeToString(def->clock.offset));\n         goto error;\n    }\n\n    /* Clarification about -H and -P flags from Peter Grehan:\n     * -H and -P flags force the guest to exit when it executes IA32 HLT and PAUSE\n     * instructions respectively.\n     *\n     * For the HLT exit, bhyve uses that to infer that the guest is idling and can\n     * be put to sleep until an external event arrives. If this option is not used,\n     * the guest will always use 100% of CPU on the host.\n     *\n     * The PAUSE exit is most useful when there are large numbers of guest VMs running,\n     * since it forces the guest to exit when it spins on a lock acquisition.\n     */\n    virCommandAddArg(cmd, \"-H\"); /* vmexit from guest on hlt */\n    virCommandAddArg(cmd, \"-P\"); /* vmexit from guest on pause */\n\n    virCommandAddArgList(cmd, \"-s\", \"0:0,hostbridge\", NULL);\n\n    if (def->os.bootloader == NULL &&\n        def->os.loader) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM)) {\n            virCommandAddArg(cmd, \"-l\");\n            virCommandAddArgFormat(cmd, \"bootrom,%s\", def->os.loader->path);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"UEFI loader\"));\n            goto error;\n        }\n    }\n\n    /* Devices */\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (bhyveBuildControllerArgStr(def, def->controllers[i], driver, cmd,\n                                       &nusbcontrollers) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->nnets; i++) {\n        if (bhyveBuildNetArgStr(def, def->nets[i], driver, cmd, dryRun) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->ndisks; i++) {\n        if (bhyveBuildDiskArgStr(def, def->disks[i], cmd) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics && def->nvideos) {\n        if (def->ngraphics == 1 && def->nvideos == 1) {\n            if (bhyveBuildGraphicsArgStr(def, def->graphics[0], def->videos[0],\n                                         driver, cmd, dryRun) < 0)\n                goto error;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Multiple graphics devices are not supported\"));\n             goto error;\n        }\n    }\n\n    if (bhyveDomainDefNeedsISAController(def))\n        bhyveBuildLPCArgStr(def, cmd);\n\n    if (bhyveBuildConsoleArgStr(def, cmd) < 0)\n        goto error;\n\n    if (def->namespaceData) {\n        bhyveDomainCmdlineDefPtr bhyvecmd;\n\n        VIR_WARN(\"Booting the guest using command line pass-through feature, \"\n                 \"which could potentially cause inconsistent state and \"\n                 \"upgrade issues\");\n\n        bhyvecmd = def->namespaceData;\n        for (i = 0; i < bhyvecmd->num_args; i++)\n            virCommandAddArg(cmd, bhyvecmd->args[i]);\n    }\n\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n\n error:\n    virCommandFree(cmd);\n    return NULL;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "def->name"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Booting the guest using command line pass-through feature, \"\n                 \"which could potentially cause inconsistent state and \"\n                 \"upgrade issues\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveBuildConsoleArgStr",
          "args": [
            "def",
            "cmd"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildConsoleArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "133-161",
          "snippet": "static int\nbhyveBuildConsoleArgStr(const virDomainDef *def, virCommandPtr cmd)\n{\n    virDomainChrDefPtr chr = NULL;\n\n    if (!def->nserials)\n        return 0;\n\n    chr = def->serials[0];\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only nmdm console types are supported\"));\n        return -1;\n    }\n\n    /* bhyve supports only two ports: com1 and com2 */\n    if (chr->target.port > 2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only two serial ports are supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-l\");\n    virCommandAddArgFormat(cmd, \"com%d,%s\",\n                           chr->target.port + 1, chr->source->data.file.path);\n\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildConsoleArgStr(const virDomainDef *def, virCommandPtr cmd)\n{\n    virDomainChrDefPtr chr = NULL;\n\n    if (!def->nserials)\n        return 0;\n\n    chr = def->serials[0];\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only nmdm console types are supported\"));\n        return -1;\n    }\n\n    /* bhyve supports only two ports: com1 and com2 */\n    if (chr->target.port > 2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only two serial ports are supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-l\");\n    virCommandAddArgFormat(cmd, \"com%d,%s\",\n                           chr->target.port + 1, chr->source->data.file.path);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildLPCArgStr",
          "args": [
            "def",
            "cmd"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildLPCArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "365-371",
          "snippet": "static int\nbhyveBuildLPCArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                    virCommandPtr cmd)\n{\n    virCommandAddArgList(cmd, \"-s\", \"1,lpc\", NULL);\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildLPCArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                    virCommandPtr cmd)\n{\n    virCommandAddArgList(cmd, \"-s\", \"1,lpc\", NULL);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDomainDefNeedsISAController",
          "args": [
            "def"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDomainDefNeedsISAController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_domain.c",
          "lines": "62-75",
          "snippet": "bool\nbhyveDomainDefNeedsISAController(virDomainDefPtr def)\n{\n    if (def->os.bootloader == NULL && def->os.loader)\n        return true;\n\n    if (def->nserials)\n        return true;\n\n    if (def->ngraphics && def->nvideos)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_driver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_capabilities.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_driver.h\"\n#include <config.h>\n\nbool\nbhyveDomainDefNeedsISAController(virDomainDefPtr def)\n{\n    if (def->os.bootloader == NULL && def->os.loader)\n        return true;\n\n    if (def->nserials)\n        return true;\n\n    if (def->ngraphics && def->nvideos)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multiple graphics devices are not supported\")"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Multiple graphics devices are not supported\""
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildGraphicsArgStr",
          "args": [
            "def",
            "def->graphics[0]",
            "def->videos[0]",
            "driver",
            "cmd",
            "dryRun"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildGraphicsArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "373-483",
          "snippet": "static int\nbhyveBuildGraphicsArgStr(const virDomainDef *def,\n                         virDomainGraphicsDefPtr graphics,\n                         virDomainVideoDefPtr video,\n                         bhyveConnPtr driver,\n                         virCommandPtr cmd,\n                         bool dryRun)\n{\n    virBuffer opt = VIR_BUFFER_INITIALIZER;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n    bool escapeAddr;\n    unsigned short port;\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM) ||\n        def->os.bootloader ||\n        !def->os.loader) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Graphics are only supported\"\n                         \" when booting using UEFI\"));\n        return -1;\n    }\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_FBUF)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Bhyve version does not support framebuffer\"));\n        return -1;\n    }\n\n    if (graphics->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only VNC supported\"));\n        return -1;\n    }\n\n    if (!(glisten = virDomainGraphicsGetListen(graphics, 0))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing listen element\"));\n        goto error;\n    }\n\n    virBufferAsprintf(&opt, \"%d:%d,fbuf\", video->info.addr.pci.slot, video->info.addr.pci.function);\n\n    switch (glisten->type) {\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n        virBufferAddLit(&opt, \",tcp=\");\n\n        if (!graphics->data.vnc.autoport &&\n            (graphics->data.vnc.port < 5900 ||\n             graphics->data.vnc.port > 65535)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc port must be in range [5900,65535]\"));\n            goto error;\n        }\n\n        if (graphics->data.vnc.auth.passwd) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc password auth not supported\"));\n            goto error;\n        } else {\n             /* Bhyve doesn't support VNC Auth yet, so print a warning about\n              * unauthenticated VNC sessions */\n             VIR_WARN(\"%s\", _(\"Security warning: currently VNC auth is not\"\n                              \" supported.\"));\n        }\n\n        if (glisten->address) {\n            escapeAddr = strchr(glisten->address, ':') != NULL;\n            if (escapeAddr)\n                virBufferAsprintf(&opt, \"[%s]\", glisten->address);\n            else\n                virBufferAdd(&opt, glisten->address, -1);\n        }\n\n        if (!dryRun) {\n            if (graphics->data.vnc.autoport) {\n                if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n                    return -1;\n                graphics->data.vnc.port = port;\n            } else {\n                if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                    VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                             graphics->data.vnc.port, def->name);\n            }\n        }\n\n        virBufferAsprintf(&opt, \":%d\", graphics->data.vnc.port);\n        break;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unsupported listen type\"));\n        goto error;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainGraphicsListenType, glisten->type);\n        goto error;\n    }\n\n    if (video->driver)\n        virBufferAsprintf(&opt, \",vga=%s\",\n                          virDomainVideoVGAConfTypeToString(video->driver->vgaconf));\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgBuffer(cmd, &opt);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&opt);\n    return -1;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildGraphicsArgStr(const virDomainDef *def,\n                         virDomainGraphicsDefPtr graphics,\n                         virDomainVideoDefPtr video,\n                         bhyveConnPtr driver,\n                         virCommandPtr cmd,\n                         bool dryRun)\n{\n    virBuffer opt = VIR_BUFFER_INITIALIZER;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n    bool escapeAddr;\n    unsigned short port;\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM) ||\n        def->os.bootloader ||\n        !def->os.loader) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Graphics are only supported\"\n                         \" when booting using UEFI\"));\n        return -1;\n    }\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_FBUF)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Bhyve version does not support framebuffer\"));\n        return -1;\n    }\n\n    if (graphics->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only VNC supported\"));\n        return -1;\n    }\n\n    if (!(glisten = virDomainGraphicsGetListen(graphics, 0))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing listen element\"));\n        goto error;\n    }\n\n    virBufferAsprintf(&opt, \"%d:%d,fbuf\", video->info.addr.pci.slot, video->info.addr.pci.function);\n\n    switch (glisten->type) {\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n        virBufferAddLit(&opt, \",tcp=\");\n\n        if (!graphics->data.vnc.autoport &&\n            (graphics->data.vnc.port < 5900 ||\n             graphics->data.vnc.port > 65535)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc port must be in range [5900,65535]\"));\n            goto error;\n        }\n\n        if (graphics->data.vnc.auth.passwd) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc password auth not supported\"));\n            goto error;\n        } else {\n             /* Bhyve doesn't support VNC Auth yet, so print a warning about\n              * unauthenticated VNC sessions */\n             VIR_WARN(\"%s\", _(\"Security warning: currently VNC auth is not\"\n                              \" supported.\"));\n        }\n\n        if (glisten->address) {\n            escapeAddr = strchr(glisten->address, ':') != NULL;\n            if (escapeAddr)\n                virBufferAsprintf(&opt, \"[%s]\", glisten->address);\n            else\n                virBufferAdd(&opt, glisten->address, -1);\n        }\n\n        if (!dryRun) {\n            if (graphics->data.vnc.autoport) {\n                if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n                    return -1;\n                graphics->data.vnc.port = port;\n            } else {\n                if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                    VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                             graphics->data.vnc.port, def->name);\n            }\n        }\n\n        virBufferAsprintf(&opt, \":%d\", graphics->data.vnc.port);\n        break;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unsupported listen type\"));\n        goto error;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainGraphicsListenType, glisten->type);\n        goto error;\n    }\n\n    if (video->driver)\n        virBufferAsprintf(&opt, \",vga=%s\",\n                          virDomainVideoVGAConfTypeToString(video->driver->vgaconf));\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgBuffer(cmd, &opt);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&opt);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildDiskArgStr",
          "args": [
            "def",
            "def->disks[i]",
            "cmd"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildDiskArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "310-329",
          "snippet": "static int\nbhyveBuildDiskArgStr(const virDomainDef *def,\n                     virDomainDiskDefPtr disk,\n                     virCommandPtr cmd)\n{\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* Handled by bhyveBuildAHCIControllerArgStr() */\n        break;\n    case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        if (bhyveBuildVirtIODiskArgStr(def, disk, cmd) < 0)\n            return -1;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildDiskArgStr(const virDomainDef *def,\n                     virDomainDiskDefPtr disk,\n                     virCommandPtr cmd)\n{\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* Handled by bhyveBuildAHCIControllerArgStr() */\n        break;\n    case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        if (bhyveBuildVirtIODiskArgStr(def, disk, cmd) < 0)\n            return -1;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildNetArgStr",
          "args": [
            "def",
            "def->nets[i]",
            "driver",
            "cmd",
            "dryRun"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildNetArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "42-131",
          "snippet": "static int\nbhyveBuildNetArgStr(const virDomainDef *def,\n                    virDomainNetDefPtr net,\n                    bhyveConnPtr driver,\n                    virCommandPtr cmd,\n                    bool dryRun)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char *realifname = NULL;\n    char *brname = NULL;\n    char *nic_model = NULL;\n    int ret = -1;\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n\n    if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n        nic_model = g_strdup(\"virtio-net\");\n    } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_NET_E1000) != 0) {\n            nic_model = g_strdup(\"e1000\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NIC model 'e1000' is not supported \"\n                             \"by given bhyve binary\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"NIC model is not supported\"));\n        return -1;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        brname = g_strdup(virDomainNetGetActualBridgeName(net));\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Network type %d is not supported\"),\n                       virDomainNetGetActualType(net));\n        goto cleanup;\n    }\n\n    if (!net->ifname ||\n        STRPREFIX(net->ifname, VIR_NET_GENERATED_TAP_PREFIX) ||\n        strchr(net->ifname, '%')) {\n        VIR_FREE(net->ifname);\n        net->ifname = g_strdup(VIR_NET_GENERATED_TAP_PREFIX \"%d\");\n    }\n\n    if (!dryRun) {\n        if (virNetDevTapCreateInBridgePort(brname, &net->ifname, &net->mac,\n                                           def->uuid, NULL, NULL, 0,\n                                           virDomainNetGetActualVirtPortProfile(net),\n                                           virDomainNetGetActualVlan(net),\n                                           virDomainNetGetActualPortOptionsIsolated(net),\n                                           NULL, 0, NULL,\n                                           VIR_NETDEV_TAP_CREATE_IFUP | VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            goto cleanup;\n        }\n\n        realifname = virNetDevTapGetRealDeviceName(net->ifname);\n\n        if (realifname == NULL)\n            goto cleanup;\n\n        VIR_DEBUG(\"%s -> %s\", net->ifname, realifname);\n        /* hack on top of other hack: we need to set\n         * interface to 'UP' again after re-opening to find its\n         * name\n         */\n        if (virNetDevSetOnline(net->ifname, true) != 0)\n            goto cleanup;\n    } else {\n        realifname = g_strdup(\"tap0\");\n    }\n\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,%s,%s,mac=%s\",\n                           net->info.addr.pci.slot, nic_model,\n                           realifname, virMacAddrFormat(&net->mac, macaddr));\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(net->ifname);\n    VIR_FREE(brname);\n    VIR_FREE(realifname);\n    VIR_FREE(nic_model);\n\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildNetArgStr(const virDomainDef *def,\n                    virDomainNetDefPtr net,\n                    bhyveConnPtr driver,\n                    virCommandPtr cmd,\n                    bool dryRun)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char *realifname = NULL;\n    char *brname = NULL;\n    char *nic_model = NULL;\n    int ret = -1;\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n\n    if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n        nic_model = g_strdup(\"virtio-net\");\n    } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_NET_E1000) != 0) {\n            nic_model = g_strdup(\"e1000\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NIC model 'e1000' is not supported \"\n                             \"by given bhyve binary\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"NIC model is not supported\"));\n        return -1;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        brname = g_strdup(virDomainNetGetActualBridgeName(net));\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Network type %d is not supported\"),\n                       virDomainNetGetActualType(net));\n        goto cleanup;\n    }\n\n    if (!net->ifname ||\n        STRPREFIX(net->ifname, VIR_NET_GENERATED_TAP_PREFIX) ||\n        strchr(net->ifname, '%')) {\n        VIR_FREE(net->ifname);\n        net->ifname = g_strdup(VIR_NET_GENERATED_TAP_PREFIX \"%d\");\n    }\n\n    if (!dryRun) {\n        if (virNetDevTapCreateInBridgePort(brname, &net->ifname, &net->mac,\n                                           def->uuid, NULL, NULL, 0,\n                                           virDomainNetGetActualVirtPortProfile(net),\n                                           virDomainNetGetActualVlan(net),\n                                           virDomainNetGetActualPortOptionsIsolated(net),\n                                           NULL, 0, NULL,\n                                           VIR_NETDEV_TAP_CREATE_IFUP | VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            goto cleanup;\n        }\n\n        realifname = virNetDevTapGetRealDeviceName(net->ifname);\n\n        if (realifname == NULL)\n            goto cleanup;\n\n        VIR_DEBUG(\"%s -> %s\", net->ifname, realifname);\n        /* hack on top of other hack: we need to set\n         * interface to 'UP' again after re-opening to find its\n         * name\n         */\n        if (virNetDevSetOnline(net->ifname, true) != 0)\n            goto cleanup;\n    } else {\n        realifname = g_strdup(\"tap0\");\n    }\n\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,%s,%s,mac=%s\",\n                           net->info.addr.pci.slot, nic_model,\n                           realifname, virMacAddrFormat(&net->mac, macaddr));\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(net->ifname);\n    VIR_FREE(brname);\n    VIR_FREE(realifname);\n    VIR_FREE(nic_model);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildControllerArgStr",
          "args": [
            "def",
            "def->controllers[i]",
            "driver",
            "cmd",
            "&nusbcontrollers"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildControllerArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "331-363",
          "snippet": "static int\nbhyveBuildControllerArgStr(const virDomainDef *def,\n                           virDomainControllerDefPtr controller,\n                           bhyveConnPtr driver,\n                           virCommandPtr cmd,\n                           unsigned *nusbcontrollers)\n{\n    switch (controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        if (controller->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported PCI controller model: \"\n                             \"only PCI root supported\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        if (bhyveBuildAHCIControllerArgStr(def, controller, driver, cmd) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        if (++*nusbcontrollers > 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only single USB controller is supported\"));\n            return -1;\n        }\n\n        if (bhyveBuildUSBControllerArgStr(def, controller, cmd) < 0)\n            return -1;\n        break;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildControllerArgStr(const virDomainDef *def,\n                           virDomainControllerDefPtr controller,\n                           bhyveConnPtr driver,\n                           virCommandPtr cmd,\n                           unsigned *nusbcontrollers)\n{\n    switch (controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        if (controller->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported PCI controller model: \"\n                             \"only PCI root supported\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        if (bhyveBuildAHCIControllerArgStr(def, controller, driver, cmd) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        if (++*nusbcontrollers > 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only single USB controller is supported\"));\n            return -1;\n        }\n\n        if (bhyveBuildUSBControllerArgStr(def, controller, cmd) < 0)\n            return -1;\n        break;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Installed bhyve binary does not support \"\n                             \"UEFI loader\")"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"bootrom,%s\"",
            "def->os.loader->path"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDriverGetBhyveCaps",
          "args": [
            "driver"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDriverGetBhyveCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_driver.c",
          "lines": "1316-1322",
          "snippet": "unsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}",
          "includes": [
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"conf/domain_capabilities.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_audit.h\"",
            "#include \"interface_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bhyve_capabilities.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"virutil.h\"\n#include \"conf/domain_capabilities.h\"\n#include \"virportallocator.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"viraccessapicheck.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"virdomainobjlist.h\"\n#include \"node_device_conf.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_event.h\"\n#include \"domain_audit.h\"\n#include \"interface_conf.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported clock offset '%s'\")",
            "virDomainClockOffsetTypeToString(def->clock.offset)"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainClockOffsetTypeToString",
          "args": [
            "def->clock.offset"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Installed bhyve binary does not support \"\n                          \"UTC clock\")"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "virDomainDefGetMemoryInitial(def)",
            "1024"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryInitial",
          "args": [
            "def"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryInitial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10910-10920",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Installed bhyve binary does not support \"\n                             \"defining CPU topology\")"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid CPU topology: total number of vCPUs \"\n                             \"must equal the product of sockets, cores, \"\n                             \"and threads\")"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only 1 die per socket is supported\")"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "BHYVE"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nvirCommandPtr\nvirBhyveProcessBuildBhyveCmd(bhyveConnPtr driver, virDomainDefPtr def,\n                             bool dryRun)\n{\n    /*\n     * /usr/sbin/bhyve -c 2 -m 256 -AI -H -P \\\n     *            -s 0:0,hostbridge \\\n     *            -s 1:0,virtio-net,tap0 \\\n     *            -s 2:0,ahci-hd,${IMG} \\\n     *            -S 31,uart,stdio \\\n     *            vm0\n     */\n    virCommandPtr cmd = virCommandNew(BHYVE);\n    size_t i;\n    unsigned nusbcontrollers = 0;\n    unsigned nvcpus = virDomainDefGetVcpus(def);\n\n    /* CPUs */\n    virCommandAddArg(cmd, \"-c\");\n    if (def->cpu && def->cpu->sockets) {\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto error;\n        }\n        if (nvcpus != def->cpu->sockets * def->cpu->cores * def->cpu->threads) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Invalid CPU topology: total number of vCPUs \"\n                             \"must equal the product of sockets, cores, \"\n                             \"and threads\"));\n            goto error;\n        }\n\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_CPUTOPOLOGY) != 0) {\n            virCommandAddArgFormat(cmd, \"cpus=%d,sockets=%d,cores=%d,threads=%d\",\n                                   nvcpus,\n                                   def->cpu->sockets,\n                                   def->cpu->cores,\n                                   def->cpu->threads);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"defining CPU topology\"));\n            goto error;\n        }\n    } else {\n        virCommandAddArgFormat(cmd, \"%d\", nvcpus);\n    }\n\n    /* Memory */\n    virCommandAddArg(cmd, \"-m\");\n    virCommandAddArgFormat(cmd, \"%llu\",\n                           VIR_DIV_UP(virDomainDefGetMemoryInitial(def), 1024));\n\n    if (def->mem.locked)\n        virCommandAddArg(cmd, \"-S\"); /* Wire guest memory */\n\n    /* Options */\n    if (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-A\"); /* Create an ACPI table */\n    if (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n        virCommandAddArg(cmd, \"-I\"); /* Present ioapic to the guest */\n    if (def->features[VIR_DOMAIN_FEATURE_MSRS] == VIR_TRISTATE_SWITCH_ON) {\n        if (def->msrs_features[VIR_DOMAIN_MSRS_UNKNOWN] == VIR_DOMAIN_MSRS_UNKNOWN_IGNORE)\n            virCommandAddArg(cmd, \"-w\");\n    }\n\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        /* used by default in bhyve */\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_RTC_UTC) != 0) {\n            virCommandAddArg(cmd, \"-u\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                          \"UTC clock\"));\n            goto error;\n        }\n        break;\n    default:\n         virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported clock offset '%s'\"),\n                        virDomainClockOffsetTypeToString(def->clock.offset));\n         goto error;\n    }\n\n    /* Clarification about -H and -P flags from Peter Grehan:\n     * -H and -P flags force the guest to exit when it executes IA32 HLT and PAUSE\n     * instructions respectively.\n     *\n     * For the HLT exit, bhyve uses that to infer that the guest is idling and can\n     * be put to sleep until an external event arrives. If this option is not used,\n     * the guest will always use 100% of CPU on the host.\n     *\n     * The PAUSE exit is most useful when there are large numbers of guest VMs running,\n     * since it forces the guest to exit when it spins on a lock acquisition.\n     */\n    virCommandAddArg(cmd, \"-H\"); /* vmexit from guest on hlt */\n    virCommandAddArg(cmd, \"-P\"); /* vmexit from guest on pause */\n\n    virCommandAddArgList(cmd, \"-s\", \"0:0,hostbridge\", NULL);\n\n    if (def->os.bootloader == NULL &&\n        def->os.loader) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM)) {\n            virCommandAddArg(cmd, \"-l\");\n            virCommandAddArgFormat(cmd, \"bootrom,%s\", def->os.loader->path);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Installed bhyve binary does not support \"\n                             \"UEFI loader\"));\n            goto error;\n        }\n    }\n\n    /* Devices */\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (bhyveBuildControllerArgStr(def, def->controllers[i], driver, cmd,\n                                       &nusbcontrollers) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->nnets; i++) {\n        if (bhyveBuildNetArgStr(def, def->nets[i], driver, cmd, dryRun) < 0)\n            goto error;\n    }\n    for (i = 0; i < def->ndisks; i++) {\n        if (bhyveBuildDiskArgStr(def, def->disks[i], cmd) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics && def->nvideos) {\n        if (def->ngraphics == 1 && def->nvideos == 1) {\n            if (bhyveBuildGraphicsArgStr(def, def->graphics[0], def->videos[0],\n                                         driver, cmd, dryRun) < 0)\n                goto error;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Multiple graphics devices are not supported\"));\n             goto error;\n        }\n    }\n\n    if (bhyveDomainDefNeedsISAController(def))\n        bhyveBuildLPCArgStr(def, cmd);\n\n    if (bhyveBuildConsoleArgStr(def, cmd) < 0)\n        goto error;\n\n    if (def->namespaceData) {\n        bhyveDomainCmdlineDefPtr bhyvecmd;\n\n        VIR_WARN(\"Booting the guest using command line pass-through feature, \"\n                 \"which could potentially cause inconsistent state and \"\n                 \"upgrade issues\");\n\n        bhyvecmd = def->namespaceData;\n        for (i = 0; i < bhyvecmd->num_args; i++)\n            virCommandAddArg(cmd, bhyvecmd->args[i]);\n    }\n\n    virCommandAddArg(cmd, def->name);\n\n    return cmd;\n\n error:\n    virCommandFree(cmd);\n    return NULL;\n}"
  },
  {
    "function_name": "bhyveBuildGraphicsArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "373-483",
    "snippet": "static int\nbhyveBuildGraphicsArgStr(const virDomainDef *def,\n                         virDomainGraphicsDefPtr graphics,\n                         virDomainVideoDefPtr video,\n                         bhyveConnPtr driver,\n                         virCommandPtr cmd,\n                         bool dryRun)\n{\n    virBuffer opt = VIR_BUFFER_INITIALIZER;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n    bool escapeAddr;\n    unsigned short port;\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM) ||\n        def->os.bootloader ||\n        !def->os.loader) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Graphics are only supported\"\n                         \" when booting using UEFI\"));\n        return -1;\n    }\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_FBUF)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Bhyve version does not support framebuffer\"));\n        return -1;\n    }\n\n    if (graphics->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only VNC supported\"));\n        return -1;\n    }\n\n    if (!(glisten = virDomainGraphicsGetListen(graphics, 0))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing listen element\"));\n        goto error;\n    }\n\n    virBufferAsprintf(&opt, \"%d:%d,fbuf\", video->info.addr.pci.slot, video->info.addr.pci.function);\n\n    switch (glisten->type) {\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n        virBufferAddLit(&opt, \",tcp=\");\n\n        if (!graphics->data.vnc.autoport &&\n            (graphics->data.vnc.port < 5900 ||\n             graphics->data.vnc.port > 65535)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc port must be in range [5900,65535]\"));\n            goto error;\n        }\n\n        if (graphics->data.vnc.auth.passwd) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc password auth not supported\"));\n            goto error;\n        } else {\n             /* Bhyve doesn't support VNC Auth yet, so print a warning about\n              * unauthenticated VNC sessions */\n             VIR_WARN(\"%s\", _(\"Security warning: currently VNC auth is not\"\n                              \" supported.\"));\n        }\n\n        if (glisten->address) {\n            escapeAddr = strchr(glisten->address, ':') != NULL;\n            if (escapeAddr)\n                virBufferAsprintf(&opt, \"[%s]\", glisten->address);\n            else\n                virBufferAdd(&opt, glisten->address, -1);\n        }\n\n        if (!dryRun) {\n            if (graphics->data.vnc.autoport) {\n                if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n                    return -1;\n                graphics->data.vnc.port = port;\n            } else {\n                if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                    VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                             graphics->data.vnc.port, def->name);\n            }\n        }\n\n        virBufferAsprintf(&opt, \":%d\", graphics->data.vnc.port);\n        break;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unsupported listen type\"));\n        goto error;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainGraphicsListenType, glisten->type);\n        goto error;\n    }\n\n    if (video->driver)\n        virBufferAsprintf(&opt, \",vga=%s\",\n                          virDomainVideoVGAConfTypeToString(video->driver->vgaconf));\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgBuffer(cmd, &opt);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&opt);\n    return -1;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&opt"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgBuffer",
          "args": [
            "cmd",
            "&opt"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1539-1558",
          "snippet": "void\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-s\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&opt",
            "\",vga=%s\"",
            "virDomainVideoVGAConfTypeToString(video->driver->vgaconf)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVideoVGAConfTypeToString",
          "args": [
            "video->driver->vgaconf"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainGraphicsListenType",
            "glisten->type"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unsupported listen type\")"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported listen type\""
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to mark VNC port '%d' as used by '%s'\"",
            "graphics->data.vnc.port",
            "def->name"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortAllocatorSetUsed",
          "args": [
            "graphics->data.vnc.port"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorSetUsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "283-308",
          "snippet": "int\nvirPortAllocatorSetUsed(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapIsBitSet(pa->bitmap, port) ||\n        virBitmapSetBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve port %d\"), port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorSetUsed(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapIsBitSet(pa->bitmap, port) ||\n        virBitmapSetBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve port %d\"), port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "driver->remotePorts",
            "&port"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&opt",
            "glisten->address",
            "-1"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "glisten->address",
            "':'"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"%s\"",
            "_(\"Security warning: currently VNC auth is not\"\n                              \" supported.\")"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vnc password auth not supported\")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vnc port must be in range [5900,65535]\")"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opt",
            "\",tcp=\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing listen element\")"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "graphics",
            "0"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only VNC supported\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Bhyve version does not support framebuffer\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveDriverGetBhyveCaps",
          "args": [
            "driver"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDriverGetBhyveCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_driver.c",
          "lines": "1316-1322",
          "snippet": "unsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}",
          "includes": [
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"conf/domain_capabilities.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_audit.h\"",
            "#include \"interface_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bhyve_capabilities.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"virutil.h\"\n#include \"conf/domain_capabilities.h\"\n#include \"virportallocator.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"viraccessapicheck.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"virdomainobjlist.h\"\n#include \"node_device_conf.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_event.h\"\n#include \"domain_audit.h\"\n#include \"interface_conf.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Graphics are only supported\"\n                         \" when booting using UEFI\")"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildGraphicsArgStr(const virDomainDef *def,\n                         virDomainGraphicsDefPtr graphics,\n                         virDomainVideoDefPtr video,\n                         bhyveConnPtr driver,\n                         virCommandPtr cmd,\n                         bool dryRun)\n{\n    virBuffer opt = VIR_BUFFER_INITIALIZER;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n    bool escapeAddr;\n    unsigned short port;\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_LPC_BOOTROM) ||\n        def->os.bootloader ||\n        !def->os.loader) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Graphics are only supported\"\n                         \" when booting using UEFI\"));\n        return -1;\n    }\n\n    if (!(bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_FBUF)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Bhyve version does not support framebuffer\"));\n        return -1;\n    }\n\n    if (graphics->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only VNC supported\"));\n        return -1;\n    }\n\n    if (!(glisten = virDomainGraphicsGetListen(graphics, 0))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing listen element\"));\n        goto error;\n    }\n\n    virBufferAsprintf(&opt, \"%d:%d,fbuf\", video->info.addr.pci.slot, video->info.addr.pci.function);\n\n    switch (glisten->type) {\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n        virBufferAddLit(&opt, \",tcp=\");\n\n        if (!graphics->data.vnc.autoport &&\n            (graphics->data.vnc.port < 5900 ||\n             graphics->data.vnc.port > 65535)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc port must be in range [5900,65535]\"));\n            goto error;\n        }\n\n        if (graphics->data.vnc.auth.passwd) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vnc password auth not supported\"));\n            goto error;\n        } else {\n             /* Bhyve doesn't support VNC Auth yet, so print a warning about\n              * unauthenticated VNC sessions */\n             VIR_WARN(\"%s\", _(\"Security warning: currently VNC auth is not\"\n                              \" supported.\"));\n        }\n\n        if (glisten->address) {\n            escapeAddr = strchr(glisten->address, ':') != NULL;\n            if (escapeAddr)\n                virBufferAsprintf(&opt, \"[%s]\", glisten->address);\n            else\n                virBufferAdd(&opt, glisten->address, -1);\n        }\n\n        if (!dryRun) {\n            if (graphics->data.vnc.autoport) {\n                if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n                    return -1;\n                graphics->data.vnc.port = port;\n            } else {\n                if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                    VIR_WARN(\"Failed to mark VNC port '%d' as used by '%s'\",\n                             graphics->data.vnc.port, def->name);\n            }\n        }\n\n        virBufferAsprintf(&opt, \":%d\", graphics->data.vnc.port);\n        break;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unsupported listen type\"));\n        goto error;\n    case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainGraphicsListenType, glisten->type);\n        goto error;\n    }\n\n    if (video->driver)\n        virBufferAsprintf(&opt, \",vga=%s\",\n                          virDomainVideoVGAConfTypeToString(video->driver->vgaconf));\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgBuffer(cmd, &opt);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&opt);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveBuildLPCArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "365-371",
    "snippet": "static int\nbhyveBuildLPCArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                    virCommandPtr cmd)\n{\n    virCommandAddArgList(cmd, \"-s\", \"1,lpc\", NULL);\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-s\"",
            "\"1,lpc\"",
            "NULL"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildLPCArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                    virCommandPtr cmd)\n{\n    virCommandAddArgList(cmd, \"-s\", \"1,lpc\", NULL);\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildControllerArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "331-363",
    "snippet": "static int\nbhyveBuildControllerArgStr(const virDomainDef *def,\n                           virDomainControllerDefPtr controller,\n                           bhyveConnPtr driver,\n                           virCommandPtr cmd,\n                           unsigned *nusbcontrollers)\n{\n    switch (controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        if (controller->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported PCI controller model: \"\n                             \"only PCI root supported\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        if (bhyveBuildAHCIControllerArgStr(def, controller, driver, cmd) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        if (++*nusbcontrollers > 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only single USB controller is supported\"));\n            return -1;\n        }\n\n        if (bhyveBuildUSBControllerArgStr(def, controller, cmd) < 0)\n            return -1;\n        break;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bhyveBuildUSBControllerArgStr",
          "args": [
            "def",
            "controller",
            "cmd"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildUSBControllerArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "238-275",
          "snippet": "static int\nbhyveBuildUSBControllerArgStr(const virDomainDef *def,\n                              virDomainControllerDefPtr controller,\n                              virCommandPtr cmd)\n{\n    size_t i;\n    int ndevices = 0;\n\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus != VIR_DOMAIN_INPUT_BUS_USB) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only USB input devices are supported\"));\n            return -1;\n        }\n\n        if (input->type != VIR_DOMAIN_INPUT_TYPE_TABLET) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only tablet input devices are supported\"));\n            return -1;\n        }\n        ndevices++;\n    }\n\n    if (ndevices != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only single input device is supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:%d,xhci,tablet\",\n                           controller->info.addr.pci.slot,\n                           controller->info.addr.pci.function);\n\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildUSBControllerArgStr(const virDomainDef *def,\n                              virDomainControllerDefPtr controller,\n                              virCommandPtr cmd)\n{\n    size_t i;\n    int ndevices = 0;\n\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus != VIR_DOMAIN_INPUT_BUS_USB) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only USB input devices are supported\"));\n            return -1;\n        }\n\n        if (input->type != VIR_DOMAIN_INPUT_TYPE_TABLET) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only tablet input devices are supported\"));\n            return -1;\n        }\n        ndevices++;\n    }\n\n    if (ndevices != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only single input device is supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:%d,xhci,tablet\",\n                           controller->info.addr.pci.slot,\n                           controller->info.addr.pci.function);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only single USB controller is supported\")"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"only single USB controller is supported\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildAHCIControllerArgStr",
          "args": [
            "def",
            "controller",
            "driver",
            "cmd"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildAHCIControllerArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "163-236",
          "snippet": "static int\nbhyveBuildAHCIControllerArgStr(const virDomainDef *def,\n                               virDomainControllerDefPtr controller,\n                               bhyveConnPtr driver,\n                               virCommandPtr cmd)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virBuffer device = VIR_BUFFER_INITIALIZER;\n    const char *disk_source;\n    size_t i;\n    int ret = -1;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus != VIR_DOMAIN_DISK_BUS_SATA)\n            continue;\n\n        if (disk->info.addr.drive.controller != controller->idx)\n            continue;\n\n        VIR_DEBUG(\"disk %zu controller %d\", i, controller->idx);\n\n        if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n            (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk type\"));\n            goto error;\n        }\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        disk_source = virDomainDiskGetSource(disk);\n\n        if ((disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM) &&\n            (disk_source == NULL)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cdrom device without source path \"\n                             \"not supported\"));\n            goto error;\n        }\n\n        switch (disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",hd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-hd,%s\", disk_source);\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",cd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-cd,%s\", disk_source);\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk device\"));\n            goto error;\n        }\n        virBufferAddBuffer(&buf, &device);\n        virBufferFreeAndReset(&device);\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,ahci%s\",\n                           controller->info.addr.pci.slot,\n                           virBufferCurrentContent(&buf));\n\n    ret = 0;\n error:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildAHCIControllerArgStr(const virDomainDef *def,\n                               virDomainControllerDefPtr controller,\n                               bhyveConnPtr driver,\n                               virCommandPtr cmd)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virBuffer device = VIR_BUFFER_INITIALIZER;\n    const char *disk_source;\n    size_t i;\n    int ret = -1;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus != VIR_DOMAIN_DISK_BUS_SATA)\n            continue;\n\n        if (disk->info.addr.drive.controller != controller->idx)\n            continue;\n\n        VIR_DEBUG(\"disk %zu controller %d\", i, controller->idx);\n\n        if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n            (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk type\"));\n            goto error;\n        }\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        disk_source = virDomainDiskGetSource(disk);\n\n        if ((disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM) &&\n            (disk_source == NULL)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cdrom device without source path \"\n                             \"not supported\"));\n            goto error;\n        }\n\n        switch (disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",hd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-hd,%s\", disk_source);\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",cd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-cd,%s\", disk_source);\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk device\"));\n            goto error;\n        }\n        virBufferAddBuffer(&buf, &device);\n        virBufferFreeAndReset(&device);\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,ahci%s\",\n                           controller->info.addr.pci.slot,\n                           virBufferCurrentContent(&buf));\n\n    ret = 0;\n error:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported PCI controller model: \"\n                             \"only PCI root supported\")"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildControllerArgStr(const virDomainDef *def,\n                           virDomainControllerDefPtr controller,\n                           bhyveConnPtr driver,\n                           virCommandPtr cmd,\n                           unsigned *nusbcontrollers)\n{\n    switch (controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        if (controller->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported PCI controller model: \"\n                             \"only PCI root supported\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        if (bhyveBuildAHCIControllerArgStr(def, controller, driver, cmd) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        if (++*nusbcontrollers > 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only single USB controller is supported\"));\n            return -1;\n        }\n\n        if (bhyveBuildUSBControllerArgStr(def, controller, cmd) < 0)\n            return -1;\n        break;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildDiskArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "310-329",
    "snippet": "static int\nbhyveBuildDiskArgStr(const virDomainDef *def,\n                     virDomainDiskDefPtr disk,\n                     virCommandPtr cmd)\n{\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* Handled by bhyveBuildAHCIControllerArgStr() */\n        break;\n    case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        if (bhyveBuildVirtIODiskArgStr(def, disk, cmd) < 0)\n            return -1;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk device\")"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported disk device\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveBuildVirtIODiskArgStr",
          "args": [
            "def",
            "disk",
            "cmd"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveBuildVirtIODiskArgStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
          "lines": "277-308",
          "snippet": "static int\nbhyveBuildVirtIODiskArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                           virDomainDiskDefPtr disk,\n                           virCommandPtr cmd)\n{\n    const char *disk_source;\n\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return -1;\n\n    if (disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return -1;\n    }\n\n    disk_source = virDomainDiskGetSource(disk);\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,virtio-blk,%s\",\n                           disk->info.addr.pci.slot,\n                           disk_source);\n\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildVirtIODiskArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                           virDomainDiskDefPtr disk,\n                           virCommandPtr cmd)\n{\n    const char *disk_source;\n\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return -1;\n\n    if (disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return -1;\n    }\n\n    disk_source = virDomainDiskGetSource(disk);\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,virtio-blk,%s\",\n                           disk->info.addr.pci.slot,\n                           disk_source);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildDiskArgStr(const virDomainDef *def,\n                     virDomainDiskDefPtr disk,\n                     virCommandPtr cmd)\n{\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* Handled by bhyveBuildAHCIControllerArgStr() */\n        break;\n    case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        if (bhyveBuildVirtIODiskArgStr(def, disk, cmd) < 0)\n            return -1;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildVirtIODiskArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "277-308",
    "snippet": "static int\nbhyveBuildVirtIODiskArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                           virDomainDiskDefPtr disk,\n                           virCommandPtr cmd)\n{\n    const char *disk_source;\n\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return -1;\n\n    if (disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return -1;\n    }\n\n    disk_source = virDomainDiskGetSource(disk);\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,virtio-blk,%s\",\n                           disk->info.addr.pci.slot,\n                           disk_source);\n\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d:0,virtio-blk,%s\"",
            "disk->info.addr.pci.slot",
            "disk_source"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-s\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk type\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported disk type\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "disk"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk device\")"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskTranslateSourcePool",
          "args": [
            "disk"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskTranslateSourcePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31966-31994",
          "snippet": "int\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildVirtIODiskArgStr(const virDomainDef *def G_GNUC_UNUSED,\n                           virDomainDiskDefPtr disk,\n                           virCommandPtr cmd)\n{\n    const char *disk_source;\n\n    if (virDomainDiskTranslateSourcePool(disk) < 0)\n        return -1;\n\n    if (disk->device != VIR_DOMAIN_DISK_DEVICE_DISK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk device\"));\n        return -1;\n    }\n\n    if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n        (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unsupported disk type\"));\n        return -1;\n    }\n\n    disk_source = virDomainDiskGetSource(disk);\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,virtio-blk,%s\",\n                           disk->info.addr.pci.slot,\n                           disk_source);\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildUSBControllerArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "238-275",
    "snippet": "static int\nbhyveBuildUSBControllerArgStr(const virDomainDef *def,\n                              virDomainControllerDefPtr controller,\n                              virCommandPtr cmd)\n{\n    size_t i;\n    int ndevices = 0;\n\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus != VIR_DOMAIN_INPUT_BUS_USB) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only USB input devices are supported\"));\n            return -1;\n        }\n\n        if (input->type != VIR_DOMAIN_INPUT_TYPE_TABLET) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only tablet input devices are supported\"));\n            return -1;\n        }\n        ndevices++;\n    }\n\n    if (ndevices != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only single input device is supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:%d,xhci,tablet\",\n                           controller->info.addr.pci.slot,\n                           controller->info.addr.pci.function);\n\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d:%d,xhci,tablet\"",
            "controller->info.addr.pci.slot",
            "controller->info.addr.pci.function"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-s\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only single input device is supported\")"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"only single input device is supported\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only tablet input devices are supported\")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only USB input devices are supported\")"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildUSBControllerArgStr(const virDomainDef *def,\n                              virDomainControllerDefPtr controller,\n                              virCommandPtr cmd)\n{\n    size_t i;\n    int ndevices = 0;\n\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus != VIR_DOMAIN_INPUT_BUS_USB) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only USB input devices are supported\"));\n            return -1;\n        }\n\n        if (input->type != VIR_DOMAIN_INPUT_TYPE_TABLET) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only tablet input devices are supported\"));\n            return -1;\n        }\n        ndevices++;\n    }\n\n    if (ndevices != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only single input device is supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:%d,xhci,tablet\",\n                           controller->info.addr.pci.slot,\n                           controller->info.addr.pci.function);\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildAHCIControllerArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "163-236",
    "snippet": "static int\nbhyveBuildAHCIControllerArgStr(const virDomainDef *def,\n                               virDomainControllerDefPtr controller,\n                               bhyveConnPtr driver,\n                               virCommandPtr cmd)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virBuffer device = VIR_BUFFER_INITIALIZER;\n    const char *disk_source;\n    size_t i;\n    int ret = -1;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus != VIR_DOMAIN_DISK_BUS_SATA)\n            continue;\n\n        if (disk->info.addr.drive.controller != controller->idx)\n            continue;\n\n        VIR_DEBUG(\"disk %zu controller %d\", i, controller->idx);\n\n        if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n            (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk type\"));\n            goto error;\n        }\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        disk_source = virDomainDiskGetSource(disk);\n\n        if ((disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM) &&\n            (disk_source == NULL)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cdrom device without source path \"\n                             \"not supported\"));\n            goto error;\n        }\n\n        switch (disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",hd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-hd,%s\", disk_source);\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",cd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-cd,%s\", disk_source);\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk device\"));\n            goto error;\n        }\n        virBufferAddBuffer(&buf, &device);\n        virBufferFreeAndReset(&device);\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,ahci%s\",\n                           controller->info.addr.pci.slot,\n                           virBufferCurrentContent(&buf));\n\n    ret = 0;\n error:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d:0,ahci%s\"",
            "controller->info.addr.pci.slot",
            "virBufferCurrentContent(&buf)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "&buf"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-s\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddBuffer",
          "args": [
            "&buf",
            "&device"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "182-196",
          "snippet": "void\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk device\")"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported disk device\""
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&device",
            "\"-cd,%s\"",
            "disk_source"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDriverGetBhyveCaps",
          "args": [
            "driver"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDriverGetBhyveCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_driver.c",
          "lines": "1316-1322",
          "snippet": "unsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}",
          "includes": [
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"conf/domain_capabilities.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_audit.h\"",
            "#include \"interface_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bhyve_capabilities.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"virutil.h\"\n#include \"conf/domain_capabilities.h\"\n#include \"virportallocator.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"viraccessapicheck.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"virdomainobjlist.h\"\n#include \"node_device_conf.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_event.h\"\n#include \"domain_audit.h\"\n#include \"interface_conf.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"cdrom device without source path \"\n                             \"not supported\")"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskTranslateSourcePool",
          "args": [
            "disk"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskTranslateSourcePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31966-31994",
          "snippet": "int\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskTranslateSourcePool(virDomainDiskDefPtr def)\n{\n    g_autoptr(virConnect) conn = NULL;\n    virStorageSourcePtr n;\n\n    for (n = def->src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (n->type != VIR_STORAGE_TYPE_VOLUME || !n->srcpool)\n            continue;\n\n        if (!conn) {\n            if (!(conn = virGetConnectStorage()))\n                return -1;\n        }\n\n        if (virDomainStorageSourceTranslateSourcePool(n, conn) < 0)\n            return -1;\n    }\n\n    if (def->startupPolicy != 0 &&\n        virStorageSourceGetActualType(def->src) != VIR_STORAGE_TYPE_FILE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"'startupPolicy' is only valid for \"\n                         \"'file' type volume\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported disk type\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "disk"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"disk %zu controller %d\"",
            "i",
            "controller->idx"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildAHCIControllerArgStr(const virDomainDef *def,\n                               virDomainControllerDefPtr controller,\n                               bhyveConnPtr driver,\n                               virCommandPtr cmd)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virBuffer device = VIR_BUFFER_INITIALIZER;\n    const char *disk_source;\n    size_t i;\n    int ret = -1;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus != VIR_DOMAIN_DISK_BUS_SATA)\n            continue;\n\n        if (disk->info.addr.drive.controller != controller->idx)\n            continue;\n\n        VIR_DEBUG(\"disk %zu controller %d\", i, controller->idx);\n\n        if ((virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_FILE) &&\n            (virDomainDiskGetType(disk) != VIR_STORAGE_TYPE_VOLUME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk type\"));\n            goto error;\n        }\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        disk_source = virDomainDiskGetSource(disk);\n\n        if ((disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM) &&\n            (disk_source == NULL)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cdrom device without source path \"\n                             \"not supported\"));\n            goto error;\n        }\n\n        switch (disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",hd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-hd,%s\", disk_source);\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_AHCI32SLOT))\n                virBufferAsprintf(&device, \",cd:%s\", disk_source);\n            else\n                virBufferAsprintf(&device, \"-cd,%s\", disk_source);\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported disk device\"));\n            goto error;\n        }\n        virBufferAddBuffer(&buf, &device);\n        virBufferFreeAndReset(&device);\n    }\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,ahci%s\",\n                           controller->info.addr.pci.slot,\n                           virBufferCurrentContent(&buf));\n\n    ret = 0;\n error:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
  },
  {
    "function_name": "bhyveBuildConsoleArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "133-161",
    "snippet": "static int\nbhyveBuildConsoleArgStr(const virDomainDef *def, virCommandPtr cmd)\n{\n    virDomainChrDefPtr chr = NULL;\n\n    if (!def->nserials)\n        return 0;\n\n    chr = def->serials[0];\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only nmdm console types are supported\"));\n        return -1;\n    }\n\n    /* bhyve supports only two ports: com1 and com2 */\n    if (chr->target.port > 2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only two serial ports are supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-l\");\n    virCommandAddArgFormat(cmd, \"com%d,%s\",\n                           chr->target.port + 1, chr->source->data.file.path);\n\n    return 0;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"com%d,%s\"",
            "chr->target.port + 1",
            "chr->source->data.file.path"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-l\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only two serial ports are supported\")"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"only two serial ports are supported\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only nmdm console types are supported\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildConsoleArgStr(const virDomainDef *def, virCommandPtr cmd)\n{\n    virDomainChrDefPtr chr = NULL;\n\n    if (!def->nserials)\n        return 0;\n\n    chr = def->serials[0];\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_NMDM) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only nmdm console types are supported\"));\n        return -1;\n    }\n\n    /* bhyve supports only two ports: com1 and com2 */\n    if (chr->target.port > 2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"only two serial ports are supported\"));\n        return -1;\n    }\n\n    virCommandAddArg(cmd, \"-l\");\n    virCommandAddArgFormat(cmd, \"com%d,%s\",\n                           chr->target.port + 1, chr->source->data.file.path);\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveBuildNetArgStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_command.c",
    "lines": "42-131",
    "snippet": "static int\nbhyveBuildNetArgStr(const virDomainDef *def,\n                    virDomainNetDefPtr net,\n                    bhyveConnPtr driver,\n                    virCommandPtr cmd,\n                    bool dryRun)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char *realifname = NULL;\n    char *brname = NULL;\n    char *nic_model = NULL;\n    int ret = -1;\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n\n    if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n        nic_model = g_strdup(\"virtio-net\");\n    } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_NET_E1000) != 0) {\n            nic_model = g_strdup(\"e1000\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NIC model 'e1000' is not supported \"\n                             \"by given bhyve binary\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"NIC model is not supported\"));\n        return -1;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        brname = g_strdup(virDomainNetGetActualBridgeName(net));\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Network type %d is not supported\"),\n                       virDomainNetGetActualType(net));\n        goto cleanup;\n    }\n\n    if (!net->ifname ||\n        STRPREFIX(net->ifname, VIR_NET_GENERATED_TAP_PREFIX) ||\n        strchr(net->ifname, '%')) {\n        VIR_FREE(net->ifname);\n        net->ifname = g_strdup(VIR_NET_GENERATED_TAP_PREFIX \"%d\");\n    }\n\n    if (!dryRun) {\n        if (virNetDevTapCreateInBridgePort(brname, &net->ifname, &net->mac,\n                                           def->uuid, NULL, NULL, 0,\n                                           virDomainNetGetActualVirtPortProfile(net),\n                                           virDomainNetGetActualVlan(net),\n                                           virDomainNetGetActualPortOptionsIsolated(net),\n                                           NULL, 0, NULL,\n                                           VIR_NETDEV_TAP_CREATE_IFUP | VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            goto cleanup;\n        }\n\n        realifname = virNetDevTapGetRealDeviceName(net->ifname);\n\n        if (realifname == NULL)\n            goto cleanup;\n\n        VIR_DEBUG(\"%s -> %s\", net->ifname, realifname);\n        /* hack on top of other hack: we need to set\n         * interface to 'UP' again after re-opening to find its\n         * name\n         */\n        if (virNetDevSetOnline(net->ifname, true) != 0)\n            goto cleanup;\n    } else {\n        realifname = g_strdup(\"tap0\");\n    }\n\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,%s,%s,mac=%s\",\n                           net->info.addr.pci.slot, nic_model,\n                           realifname, virMacAddrFormat(&net->mac, macaddr));\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(net->ifname);\n    VIR_FREE(brname);\n    VIR_FREE(realifname);\n    VIR_FREE(nic_model);\n\n    return ret;\n}",
    "includes": [
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"bhyve_driver.h\"",
      "#include \"bhyve_conf.h\"",
      "#include \"bhyve_domain.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nic_model"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "realifname"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "brname"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "net->ifname"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d:0,%s,%s,mac=%s\"",
            "net->info.addr.pci.slot",
            "nic_model",
            "realifname",
            "virMacAddrFormat(&net->mac, macaddr)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&net->mac",
            "macaddr"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-s\""
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"tap0\""
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "net->ifname",
            "true"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s -> %s\"",
            "net->ifname",
            "realifname"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevTapGetRealDeviceName",
          "args": [
            "net->ifname"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapGetRealDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "98-143",
          "snippet": "char*\nvirNetDevTapGetRealDeviceName(char *ifname G_GNUC_UNUSED)\n{\n#ifdef IFDATA_DRIVERNAME\n    int ifindex = 0;\n    int name[6];\n    size_t len = 0;\n    char *ret = NULL;\n\n    if ((ifindex = if_nametoindex(ifname)) == 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get interface index for '%s'\"),\n                             ifname);\n        return NULL;\n    }\n\n    name[0] = CTL_NET;\n    name[1] = PF_LINK;\n    name[2] = NETLINK_GENERIC;\n    name[3] = IFMIB_IFDATA;\n    name[4] = ifindex;\n    name[5] = IFDATA_DRIVERNAME;\n\n    if (sysctl(name, 6, NULL, &len, 0, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get driver name for '%s'\"),\n                             ifname);\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(ret, len) < 0)\n        return NULL;\n\n    if (sysctl(name, 6, ret, &len, 0, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get driver name for '%s'\"),\n                             ifname);\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n#else\n    return NULL;\n#endif\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nchar*\nvirNetDevTapGetRealDeviceName(char *ifname G_GNUC_UNUSED)\n{\n#ifdef IFDATA_DRIVERNAME\n    int ifindex = 0;\n    int name[6];\n    size_t len = 0;\n    char *ret = NULL;\n\n    if ((ifindex = if_nametoindex(ifname)) == 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get interface index for '%s'\"),\n                             ifname);\n        return NULL;\n    }\n\n    name[0] = CTL_NET;\n    name[1] = PF_LINK;\n    name[2] = NETLINK_GENERIC;\n    name[3] = IFMIB_IFDATA;\n    name[4] = ifindex;\n    name[5] = IFDATA_DRIVERNAME;\n\n    if (sysctl(name, 6, NULL, &len, 0, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get driver name for '%s'\"),\n                             ifname);\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(ret, len) < 0)\n        return NULL;\n\n    if (sysctl(name, 6, ret, &len, 0, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get driver name for '%s'\"),\n                             ifname);\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n#else\n    return NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevTapCreateInBridgePort",
          "args": [
            "brname",
            "&net->ifname",
            "&net->mac",
            "def->uuid",
            "NULL",
            "NULL",
            "0",
            "virDomainNetGetActualVirtPortProfile(net)",
            "virDomainNetGetActualVlan(net)",
            "virDomainNetGetActualPortOptionsIsolated(net)",
            "NULL",
            "0",
            "NULL",
            "VIR_NETDEV_TAP_CREATE_IFUP | VIR_NETDEV_TAP_CREATE_PERSIST"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapCreateInBridgePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "667-732",
          "snippet": "int virNetDevTapCreateInBridgePort(const char *brname,\n                                   char **ifname,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *vmuuid,\n                                   const char *tunpath,\n                                   int *tapfd,\n                                   size_t tapfdSize,\n                                   const virNetDevVPortProfile *virtPortProfile,\n                                   const virNetDevVlan *virtVlan,\n                                   virTristateBool isolatedPort,\n                                   virNetDevCoalescePtr coalesce,\n                                   unsigned int mtu,\n                                   unsigned int *actualMTU,\n                                   unsigned int flags)\n{\n    virMacAddr tapmac;\n    size_t i;\n\n    if (virNetDevTapCreate(ifname, tunpath, tapfd, tapfdSize, flags) < 0)\n        return -1;\n\n    /* We need to set the interface MAC before adding it\n     * to the bridge, because the bridge assumes the lowest\n     * MAC of all enslaved interfaces & we don't want it\n     * seeing the kernel allocate random MAC for the TAP\n     * device before we set our static MAC.\n     */\n    virMacAddrSet(&tapmac, macaddr);\n    if (!(flags & VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE)) {\n        /* The tap device's MAC address cannot match the MAC address\n         * used by the guest. This results in \"received packet on\n         * vnetX with own address as source address\" error logs from\n         * the kernel. Making the tap address as high as possible\n         * discourages the bridge from using this tap's MAC as its own\n         * (a Linux host bridge will take on the lowest numbered MAC\n         * of all devices attached to it).\n         */\n        if (tapmac.addr[0] == 0xFE)\n            tapmac.addr[0] = 0xFA;\n        else\n            tapmac.addr[0] = 0xFE;\n    }\n\n    if (virNetDevSetMAC(*ifname, &tapmac) < 0)\n        goto error;\n\n    if (virNetDevTapAttachBridge(*ifname, brname, macaddr, vmuuid,\n                                 virtPortProfile, virtVlan,\n                                 isolatedPort, mtu, actualMTU) < 0) {\n        goto error;\n    }\n\n    if (virNetDevSetOnline(*ifname, !!(flags & VIR_NETDEV_TAP_CREATE_IFUP)) < 0)\n        goto error;\n\n    if (virNetDevSetCoalesce(*ifname, coalesce, false) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    for (i = 0; i < tapfdSize && tapfd[i] >= 0; i++)\n        VIR_FORCE_CLOSE(tapfd[i]);\n\n    return -1;\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint virNetDevTapCreateInBridgePort(const char *brname,\n                                   char **ifname,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *vmuuid,\n                                   const char *tunpath,\n                                   int *tapfd,\n                                   size_t tapfdSize,\n                                   const virNetDevVPortProfile *virtPortProfile,\n                                   const virNetDevVlan *virtVlan,\n                                   virTristateBool isolatedPort,\n                                   virNetDevCoalescePtr coalesce,\n                                   unsigned int mtu,\n                                   unsigned int *actualMTU,\n                                   unsigned int flags)\n{\n    virMacAddr tapmac;\n    size_t i;\n\n    if (virNetDevTapCreate(ifname, tunpath, tapfd, tapfdSize, flags) < 0)\n        return -1;\n\n    /* We need to set the interface MAC before adding it\n     * to the bridge, because the bridge assumes the lowest\n     * MAC of all enslaved interfaces & we don't want it\n     * seeing the kernel allocate random MAC for the TAP\n     * device before we set our static MAC.\n     */\n    virMacAddrSet(&tapmac, macaddr);\n    if (!(flags & VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE)) {\n        /* The tap device's MAC address cannot match the MAC address\n         * used by the guest. This results in \"received packet on\n         * vnetX with own address as source address\" error logs from\n         * the kernel. Making the tap address as high as possible\n         * discourages the bridge from using this tap's MAC as its own\n         * (a Linux host bridge will take on the lowest numbered MAC\n         * of all devices attached to it).\n         */\n        if (tapmac.addr[0] == 0xFE)\n            tapmac.addr[0] = 0xFA;\n        else\n            tapmac.addr[0] = 0xFE;\n    }\n\n    if (virNetDevSetMAC(*ifname, &tapmac) < 0)\n        goto error;\n\n    if (virNetDevTapAttachBridge(*ifname, brname, macaddr, vmuuid,\n                                 virtPortProfile, virtVlan,\n                                 isolatedPort, mtu, actualMTU) < 0) {\n        goto error;\n    }\n\n    if (virNetDevSetOnline(*ifname, !!(flags & VIR_NETDEV_TAP_CREATE_IFUP)) < 0)\n        goto error;\n\n    if (virNetDevSetCoalesce(*ifname, coalesce, false) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    for (i = 0; i < tapfdSize && tapfd[i] >= 0; i++)\n        VIR_FORCE_CLOSE(tapfd[i]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualPortOptionsIsolated",
          "args": [
            "net"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualPortOptionsIsolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30287-30295",
          "snippet": "virTristateBool\nvirDomainNetGetActualPortOptionsIsolated(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual) {\n        return iface->data.network.actual->isolatedPort;\n    }\n    return iface->isolatedPort;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirTristateBool\nvirDomainNetGetActualPortOptionsIsolated(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual) {\n        return iface->data.network.actual->isolatedPort;\n    }\n    return iface->isolatedPort;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "net"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "net"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "net->ifname"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "net->ifname",
            "'%'"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "net->ifname",
            "VIR_NET_GENERATED_TAP_PREFIX"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Network type %d is not supported\")",
            "virDomainNetGetActualType(net)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBridgeName",
          "args": [
            "net"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30164-30175",
          "snippet": "const char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"NIC model is not supported\")"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"NIC model 'e1000' is not supported \"\n                             \"by given bhyve binary\")"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveDriverGetBhyveCaps",
          "args": [
            "driver"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDriverGetBhyveCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_driver.c",
          "lines": "1316-1322",
          "snippet": "unsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}",
          "includes": [
            "#include \"bhyve_capabilities.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_domain.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include \"bhyve_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"conf/domain_capabilities.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_audit.h\"",
            "#include \"interface_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bhyve_capabilities.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include \"bhyve_conf.h\"\n#include \"virutil.h\"\n#include \"conf/domain_capabilities.h\"\n#include \"virportallocator.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"viraccessapicheck.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"virdomainobjlist.h\"\n#include \"node_device_conf.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_event.h\"\n#include \"domain_audit.h\"\n#include \"interface_conf.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned\nbhyveDriverGetBhyveCaps(bhyveConnPtr driver)\n{\n    if (driver != NULL)\n        return driver->bhyvecaps;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_conf.h\"\n#include \"bhyve_domain.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <config.h>\n\nstatic int\nbhyveBuildNetArgStr(const virDomainDef *def,\n                    virDomainNetDefPtr net,\n                    bhyveConnPtr driver,\n                    virCommandPtr cmd,\n                    bool dryRun)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char *realifname = NULL;\n    char *brname = NULL;\n    char *nic_model = NULL;\n    int ret = -1;\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n\n    if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n        nic_model = g_strdup(\"virtio-net\");\n    } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n        if ((bhyveDriverGetBhyveCaps(driver) & BHYVE_CAP_NET_E1000) != 0) {\n            nic_model = g_strdup(\"e1000\");\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NIC model 'e1000' is not supported \"\n                             \"by given bhyve binary\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"NIC model is not supported\"));\n        return -1;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        brname = g_strdup(virDomainNetGetActualBridgeName(net));\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Network type %d is not supported\"),\n                       virDomainNetGetActualType(net));\n        goto cleanup;\n    }\n\n    if (!net->ifname ||\n        STRPREFIX(net->ifname, VIR_NET_GENERATED_TAP_PREFIX) ||\n        strchr(net->ifname, '%')) {\n        VIR_FREE(net->ifname);\n        net->ifname = g_strdup(VIR_NET_GENERATED_TAP_PREFIX \"%d\");\n    }\n\n    if (!dryRun) {\n        if (virNetDevTapCreateInBridgePort(brname, &net->ifname, &net->mac,\n                                           def->uuid, NULL, NULL, 0,\n                                           virDomainNetGetActualVirtPortProfile(net),\n                                           virDomainNetGetActualVlan(net),\n                                           virDomainNetGetActualPortOptionsIsolated(net),\n                                           NULL, 0, NULL,\n                                           VIR_NETDEV_TAP_CREATE_IFUP | VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            goto cleanup;\n        }\n\n        realifname = virNetDevTapGetRealDeviceName(net->ifname);\n\n        if (realifname == NULL)\n            goto cleanup;\n\n        VIR_DEBUG(\"%s -> %s\", net->ifname, realifname);\n        /* hack on top of other hack: we need to set\n         * interface to 'UP' again after re-opening to find its\n         * name\n         */\n        if (virNetDevSetOnline(net->ifname, true) != 0)\n            goto cleanup;\n    } else {\n        realifname = g_strdup(\"tap0\");\n    }\n\n\n    virCommandAddArg(cmd, \"-s\");\n    virCommandAddArgFormat(cmd, \"%d:0,%s,%s,mac=%s\",\n                           net->info.addr.pci.slot, nic_model,\n                           realifname, virMacAddrFormat(&net->mac, macaddr));\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(net->ifname);\n    VIR_FREE(brname);\n    VIR_FREE(realifname);\n    VIR_FREE(nic_model);\n\n    return ret;\n}"
  }
]