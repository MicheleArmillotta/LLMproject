[
  {
    "function_name": "virStorageBackendLogicalChangeCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4177-4186",
    "snippet": "virCommandPtr\nvirStorageBackendLogicalChangeCmd(const char *cmdstr,\n                                  virStoragePoolDefPtr def,\n                                  bool on)\n{\n    return virCommandNewArgList(cmdstr,\n                                on ? \"-aly\" : \"-aln\",\n                                def->source.name,\n                                NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "cmdstr",
            "on ? \"-aly\" : \"-aln\"",
            "def->source.name",
            "NULL"
          ],
          "line": 4182
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirCommandPtr\nvirStorageBackendLogicalChangeCmd(const char *cmdstr,\n                                  virStoragePoolDefPtr def,\n                                  bool on)\n{\n    return virCommandNewArgList(cmdstr,\n                                on ? \"-aly\" : \"-aln\",\n                                def->source.name,\n                                NULL);\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4144-4174",
    "snippet": "virCommandPtr\nvirStorageBackendFileSystemMountCmd(const char *cmdstr,\n                                    virStoragePoolDefPtr def,\n                                    const char *src)\n{\n    /* 'mount -t auto' doesn't seem to auto determine nfs (or cifs),\n     *  while plain 'mount' does. We have to craft separate argvs to\n     *  accommodate this */\n    bool netauto = (def->type == VIR_STORAGE_POOL_NETFS &&\n                    def->source.format == VIR_STORAGE_POOL_NETFS_AUTO);\n    bool glusterfs = (def->type == VIR_STORAGE_POOL_NETFS &&\n                      def->source.format == VIR_STORAGE_POOL_NETFS_GLUSTERFS);\n    bool cifsfs = (def->type == VIR_STORAGE_POOL_NETFS &&\n                   def->source.format == VIR_STORAGE_POOL_NETFS_CIFS);\n    virCommandPtr cmd = NULL;\n    g_autofree char *nfsVers = NULL;\n\n    if (def->type == VIR_STORAGE_POOL_NETFS && def->source.protocolVer > 0)\n        nfsVers = g_strdup_printf(\"nfsvers=%u\", def->source.protocolVer);\n\n    cmd = virCommandNew(cmdstr);\n    if (netauto)\n        virStorageBackendFileSystemMountNFSArgs(cmd, src, def, nfsVers);\n    else if (glusterfs)\n        virStorageBackendFileSystemMountGlusterArgs(cmd, src, def);\n    else if (cifsfs)\n        virStorageBackendFileSystemMountCIFSArgs(cmd, src, def);\n    else\n        virStorageBackendFileSystemMountDefaultArgs(cmd, src, def, nfsVers);\n    return cmd;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountDefaultArgs",
          "args": [
            "cmd",
            "src",
            "def",
            "nfsVers"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountDefaultArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4127-4141",
          "snippet": "static void\nvirStorageBackendFileSystemMountDefaultArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def,\n                                            const char *nfsVers)\n{\n    const char *fmt;\n\n    if (def->type == VIR_STORAGE_POOL_FS)\n        fmt = virStoragePoolFormatFileSystemTypeToString(def->source.format);\n    else\n        fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountDefaultArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def,\n                                            const char *nfsVers)\n{\n    const char *fmt;\n\n    if (def->type == VIR_STORAGE_POOL_FS)\n        fmt = virStoragePoolFormatFileSystemTypeToString(def->source.format);\n    else\n        fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountCIFSArgs",
          "args": [
            "cmd",
            "src",
            "def"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountCIFSArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4114-4124",
          "snippet": "static void\nvirStorageBackendFileSystemMountCIFSArgs(virCommandPtr cmd,\n                                         const char *src,\n                                         virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"guest\");\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountCIFSArgs(virCommandPtr cmd,\n                                         const char *src,\n                                         virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"guest\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountGlusterArgs",
          "args": [
            "cmd",
            "src",
            "def"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountGlusterArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4101-4111",
          "snippet": "static void\nvirStorageBackendFileSystemMountGlusterArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"direct-io-mode=1\");\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountGlusterArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"direct-io-mode=1\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountNFSArgs",
          "args": [
            "cmd",
            "src",
            "def",
            "nfsVers"
          ],
          "line": 4166
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountNFSArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4090-4098",
          "snippet": "static void\nvirStorageBackendFileSystemMountNFSArgs(virCommandPtr cmd,\n                                        const char *src,\n                                        virStoragePoolDefPtr def,\n                                        const char *nfsVers)\n{\n    virCommandAddArgList(cmd, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountNFSArgs(virCommandPtr cmd,\n                                        const char *src,\n                                        virStoragePoolDefPtr def,\n                                        const char *nfsVers)\n{\n    virCommandAddArgList(cmd, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "cmdstr"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"nfsvers=%u\"",
            "def->source.protocolVer"
          ],
          "line": 4162
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirCommandPtr\nvirStorageBackendFileSystemMountCmd(const char *cmdstr,\n                                    virStoragePoolDefPtr def,\n                                    const char *src)\n{\n    /* 'mount -t auto' doesn't seem to auto determine nfs (or cifs),\n     *  while plain 'mount' does. We have to craft separate argvs to\n     *  accommodate this */\n    bool netauto = (def->type == VIR_STORAGE_POOL_NETFS &&\n                    def->source.format == VIR_STORAGE_POOL_NETFS_AUTO);\n    bool glusterfs = (def->type == VIR_STORAGE_POOL_NETFS &&\n                      def->source.format == VIR_STORAGE_POOL_NETFS_GLUSTERFS);\n    bool cifsfs = (def->type == VIR_STORAGE_POOL_NETFS &&\n                   def->source.format == VIR_STORAGE_POOL_NETFS_CIFS);\n    virCommandPtr cmd = NULL;\n    g_autofree char *nfsVers = NULL;\n\n    if (def->type == VIR_STORAGE_POOL_NETFS && def->source.protocolVer > 0)\n        nfsVers = g_strdup_printf(\"nfsvers=%u\", def->source.protocolVer);\n\n    cmd = virCommandNew(cmdstr);\n    if (netauto)\n        virStorageBackendFileSystemMountNFSArgs(cmd, src, def, nfsVers);\n    else if (glusterfs)\n        virStorageBackendFileSystemMountGlusterArgs(cmd, src, def);\n    else if (cifsfs)\n        virStorageBackendFileSystemMountCIFSArgs(cmd, src, def);\n    else\n        virStorageBackendFileSystemMountDefaultArgs(cmd, src, def, nfsVers);\n    return cmd;\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountDefaultArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4127-4141",
    "snippet": "static void\nvirStorageBackendFileSystemMountDefaultArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def,\n                                            const char *nfsVers)\n{\n    const char *fmt;\n\n    if (def->type == VIR_STORAGE_POOL_FS)\n        fmt = virStoragePoolFormatFileSystemTypeToString(def->source.format);\n    else\n        fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountAddOptions",
          "args": [
            "cmd",
            "def",
            "nfsVers"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountAddOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4055-4087",
          "snippet": "static void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-t\"",
            "fmt",
            "src",
            "def->target.path",
            "NULL"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatFileSystemNetTypeToString",
          "args": [
            "def->source.format"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatFileSystemTypeToString",
          "args": [
            "def->source.format"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountDefaultArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def,\n                                            const char *nfsVers)\n{\n    const char *fmt;\n\n    if (def->type == VIR_STORAGE_POOL_FS)\n        fmt = virStoragePoolFormatFileSystemTypeToString(def->source.format);\n    else\n        fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountCIFSArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4114-4124",
    "snippet": "static void\nvirStorageBackendFileSystemMountCIFSArgs(virCommandPtr cmd,\n                                         const char *src,\n                                         virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"guest\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountAddOptions",
          "args": [
            "cmd",
            "def",
            "\"guest\""
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountAddOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4055-4087",
          "snippet": "static void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-t\"",
            "fmt",
            "src",
            "def->target.path",
            "NULL"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatFileSystemNetTypeToString",
          "args": [
            "def->source.format"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountCIFSArgs(virCommandPtr cmd,\n                                         const char *src,\n                                         virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"guest\");\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountGlusterArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4101-4111",
    "snippet": "static void\nvirStorageBackendFileSystemMountGlusterArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"direct-io-mode=1\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountAddOptions",
          "args": [
            "cmd",
            "def",
            "\"direct-io-mode=1\""
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountAddOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4055-4087",
          "snippet": "static void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-t\"",
            "fmt",
            "src",
            "def->target.path",
            "NULL"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatFileSystemNetTypeToString",
          "args": [
            "def->source.format"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountGlusterArgs(virCommandPtr cmd,\n                                            const char *src,\n                                            virStoragePoolDefPtr def)\n{\n    const char *fmt;\n\n    fmt = virStoragePoolFormatFileSystemNetTypeToString(def->source.format);\n    virCommandAddArgList(cmd, \"-t\", fmt, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, \"direct-io-mode=1\");\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountNFSArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4090-4098",
    "snippet": "static void\nvirStorageBackendFileSystemMountNFSArgs(virCommandPtr cmd,\n                                        const char *src,\n                                        virStoragePoolDefPtr def,\n                                        const char *nfsVers)\n{\n    virCommandAddArgList(cmd, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendFileSystemMountAddOptions",
          "args": [
            "cmd",
            "def",
            "nfsVers"
          ],
          "line": 4097
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFileSystemMountAddOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4055-4087",
          "snippet": "static void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "src",
            "def->target.path",
            "NULL"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountNFSArgs(virCommandPtr cmd,\n                                        const char *src,\n                                        virStoragePoolDefPtr def,\n                                        const char *nfsVers)\n{\n    virCommandAddArgList(cmd, src, def->target.path, NULL);\n    virStorageBackendFileSystemMountAddOptions(cmd, def, nfsVers);\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemMountAddOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4055-4087",
    "snippet": "static void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-o\"",
            "mountOpts",
            "NULL"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\"",
            "def->name",
            "uuidstr"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%s,\"",
            "opts->options[i]"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendFileSystemMountAddOptions(virCommandPtr cmd,\n                                           virStoragePoolDefPtr def,\n                                           const char *providedOpts)\n{\n    g_autofree char *mountOpts = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (*default_mount_opts != '\\0')\n        virBufferAsprintf(&buf, \"%s,\", default_mount_opts);\n\n    if (providedOpts)\n        virBufferAsprintf(&buf, \"%s,\", providedOpts);\n\n    if (def->namespaceData) {\n        size_t i;\n        virStoragePoolFSMountOptionsDefPtr opts = def->namespaceData;\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        for (i = 0; i < opts->noptions; i++)\n            virBufferAsprintf(&buf, \"%s,\", opts->options[i]);\n\n        virUUIDFormat(def->uuid, uuidstr);\n        VIR_WARN(\"Storage Pool name='%s' uuid='%s' is tainted by custom \"\n                 \"mount_opts from XML\", def->name, uuidstr);\n    }\n\n    virBufferTrim(&buf, \",\");\n    mountOpts = virBufferContentAndReset(&buf);\n\n    if (mountOpts)\n        virCommandAddArgList(cmd, \"-o\", mountOpts, NULL);\n}"
  },
  {
    "function_name": "virStorageBackendFileSystemGetPoolSource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4034-4052",
    "snippet": "char *\nvirStorageBackendFileSystemGetPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src = NULL;\n\n    if (def->type == VIR_STORAGE_POOL_NETFS) {\n        if (def->source.format == VIR_STORAGE_POOL_NETFS_CIFS) {\n            src = g_strdup_printf(\"//%s/%s\", def->source.hosts[0].name,\n                                  def->source.dir);\n        } else {\n            src = g_strdup_printf(\"%s:%s\", def->source.hosts[0].name,\n                                  def->source.dir);\n        }\n    } else {\n        src = g_strdup(def->source.devices[0].path);\n    }\n    return src;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->source.devices[0].path"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageBackendFileSystemGetPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src = NULL;\n\n    if (def->type == VIR_STORAGE_POOL_NETFS) {\n        if (def->source.format == VIR_STORAGE_POOL_NETFS_CIFS) {\n            src = g_strdup_printf(\"//%s/%s\", def->source.hosts[0].name,\n                                  def->source.dir);\n        } else {\n            src = g_strdup_printf(\"%s:%s\", def->source.hosts[0].name,\n                                  def->source.dir);\n        }\n    } else {\n        src = g_strdup(def->source.devices[0].path);\n    }\n    return src;\n}"
  },
  {
    "function_name": "virStorageBackendZeroPartitionTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "4014-4024",
    "snippet": "int\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendVolWipeLocalFile",
          "args": [
            "path",
            "VIR_STORAGE_VOL_WIPE_ALG_ZERO",
            "size",
            "true"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolWipeLocalFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2568-2647",
          "snippet": "static int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}"
  },
  {
    "function_name": "virStorageBackendSCSIFindLUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3953-4002",
    "snippet": "int\nvirStorageBackendSCSIFindLUs(virStoragePoolObjPtr pool,\n                              uint32_t scanhost)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = 0;\n    uint32_t bus, target, lun;\n    const char *device_path = \"/sys/bus/scsi/devices\";\n    DIR *devicedir = NULL;\n    struct dirent *lun_dirent = NULL;\n    char devicepattern[64];\n    int found = 0;\n\n    VIR_DEBUG(\"Discovering LUs on host %u\", scanhost);\n\n    virWaitForDevices();\n\n    if (virDirOpen(&devicedir, device_path) < 0)\n        return -1;\n\n    g_snprintf(devicepattern, sizeof(devicepattern), \"%u:%%u:%%u:%%u\\n\", scanhost);\n\n    while ((retval = virDirRead(devicedir, &lun_dirent, device_path)) > 0) {\n        int rc;\n\n        if (sscanf(lun_dirent->d_name, devicepattern,\n                   &bus, &target, &lun) != 3) {\n            continue;\n        }\n\n        VIR_DEBUG(\"Found possible LU '%s'\", lun_dirent->d_name);\n\n        rc = processLU(pool, scanhost, bus, target, lun);\n        if (rc == -1) {\n            retval = -1;\n            break;\n        }\n        if (rc == 0)\n            found++;\n    }\n\n    VIR_DIR_CLOSE(devicedir);\n\n    if (retval < 0)\n        return -1;\n\n    VIR_DEBUG(\"Found %d LUs for pool %s\", found, def->name);\n\n    return found;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found %d LUs for pool %s\"",
            "found",
            "def->name"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "devicedir"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processLU",
          "args": [
            "pool",
            "scanhost",
            "bus",
            "target",
            "lun"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "processLU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3902-3950",
          "snippet": "static int\nprocessLU(virStoragePoolObjPtr pool,\n          uint32_t host,\n          uint32_t bus,\n          uint32_t target,\n          uint32_t lun)\n{\n    int retval = -1;\n    int device_type;\n    g_autofree char *block_device = NULL;\n\n    VIR_DEBUG(\"Processing LU %u:%u:%u:%u\",\n              host, bus, target, lun);\n\n    if (getDeviceType(host, bus, target, lun, &device_type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\"),\n                       host, bus, target, lun);\n        return -1;\n    }\n\n    /* We don't create volumes for devices other than disk and cdrom\n     * devices, but finding a device that isn't one of those types\n     * isn't an error, either. */\n    if (!(device_type == VIR_STORAGE_DEVICE_TYPE_DISK ||\n          device_type == VIR_STORAGE_DEVICE_TYPE_ROM))\n        return -2;\n\n    VIR_DEBUG(\"%u:%u:%u:%u is a Direct-Access LUN\",\n              host, bus, target, lun);\n\n    if ((retval = getBlockDevice(host, bus, target, lun, &block_device)) < 0) {\n        VIR_DEBUG(\"Failed to find block device for this LUN\");\n        return retval;\n    }\n\n    retval = virStorageBackendSCSINewLun(pool, host, bus, target, lun,\n                                         block_device);\n    if (retval < 0) {\n        VIR_DEBUG(\"Failed to create new storage volume for %u:%u:%u:%u\",\n                  host, bus, target, lun);\n        return retval;\n    }\n\n    VIR_DEBUG(\"Created new storage volume for %u:%u:%u:%u successfully\",\n              host, bus, target, lun);\n\n    return retval;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprocessLU(virStoragePoolObjPtr pool,\n          uint32_t host,\n          uint32_t bus,\n          uint32_t target,\n          uint32_t lun)\n{\n    int retval = -1;\n    int device_type;\n    g_autofree char *block_device = NULL;\n\n    VIR_DEBUG(\"Processing LU %u:%u:%u:%u\",\n              host, bus, target, lun);\n\n    if (getDeviceType(host, bus, target, lun, &device_type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\"),\n                       host, bus, target, lun);\n        return -1;\n    }\n\n    /* We don't create volumes for devices other than disk and cdrom\n     * devices, but finding a device that isn't one of those types\n     * isn't an error, either. */\n    if (!(device_type == VIR_STORAGE_DEVICE_TYPE_DISK ||\n          device_type == VIR_STORAGE_DEVICE_TYPE_ROM))\n        return -2;\n\n    VIR_DEBUG(\"%u:%u:%u:%u is a Direct-Access LUN\",\n              host, bus, target, lun);\n\n    if ((retval = getBlockDevice(host, bus, target, lun, &block_device)) < 0) {\n        VIR_DEBUG(\"Failed to find block device for this LUN\");\n        return retval;\n    }\n\n    retval = virStorageBackendSCSINewLun(pool, host, bus, target, lun,\n                                         block_device);\n    if (retval < 0) {\n        VIR_DEBUG(\"Failed to create new storage volume for %u:%u:%u:%u\",\n                  host, bus, target, lun);\n        return retval;\n    }\n\n    VIR_DEBUG(\"Created new storage volume for %u:%u:%u:%u successfully\",\n              host, bus, target, lun);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found possible LU '%s'\"",
            "lun_dirent->d_name"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "lun_dirent->d_name",
            "devicepattern",
            "&bus",
            "&target",
            "&lun"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "devicedir",
            "&lun_dirent",
            "device_path"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "devicepattern",
            "sizeof(devicepattern)",
            "\"%u:%%u:%%u:%%u\\n\"",
            "scanhost"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&devicedir",
            "device_path"
          ],
          "line": 3970
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 3968
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Discovering LUs on host %u\"",
            "scanhost"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendSCSIFindLUs(virStoragePoolObjPtr pool,\n                              uint32_t scanhost)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = 0;\n    uint32_t bus, target, lun;\n    const char *device_path = \"/sys/bus/scsi/devices\";\n    DIR *devicedir = NULL;\n    struct dirent *lun_dirent = NULL;\n    char devicepattern[64];\n    int found = 0;\n\n    VIR_DEBUG(\"Discovering LUs on host %u\", scanhost);\n\n    virWaitForDevices();\n\n    if (virDirOpen(&devicedir, device_path) < 0)\n        return -1;\n\n    g_snprintf(devicepattern, sizeof(devicepattern), \"%u:%%u:%%u:%%u\\n\", scanhost);\n\n    while ((retval = virDirRead(devicedir, &lun_dirent, device_path)) > 0) {\n        int rc;\n\n        if (sscanf(lun_dirent->d_name, devicepattern,\n                   &bus, &target, &lun) != 3) {\n            continue;\n        }\n\n        VIR_DEBUG(\"Found possible LU '%s'\", lun_dirent->d_name);\n\n        rc = processLU(pool, scanhost, bus, target, lun);\n        if (rc == -1) {\n            retval = -1;\n            break;\n        }\n        if (rc == 0)\n            found++;\n    }\n\n    VIR_DIR_CLOSE(devicedir);\n\n    if (retval < 0)\n        return -1;\n\n    VIR_DEBUG(\"Found %d LUs for pool %s\", found, def->name);\n\n    return found;\n}"
  },
  {
    "function_name": "processLU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3902-3950",
    "snippet": "static int\nprocessLU(virStoragePoolObjPtr pool,\n          uint32_t host,\n          uint32_t bus,\n          uint32_t target,\n          uint32_t lun)\n{\n    int retval = -1;\n    int device_type;\n    g_autofree char *block_device = NULL;\n\n    VIR_DEBUG(\"Processing LU %u:%u:%u:%u\",\n              host, bus, target, lun);\n\n    if (getDeviceType(host, bus, target, lun, &device_type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\"),\n                       host, bus, target, lun);\n        return -1;\n    }\n\n    /* We don't create volumes for devices other than disk and cdrom\n     * devices, but finding a device that isn't one of those types\n     * isn't an error, either. */\n    if (!(device_type == VIR_STORAGE_DEVICE_TYPE_DISK ||\n          device_type == VIR_STORAGE_DEVICE_TYPE_ROM))\n        return -2;\n\n    VIR_DEBUG(\"%u:%u:%u:%u is a Direct-Access LUN\",\n              host, bus, target, lun);\n\n    if ((retval = getBlockDevice(host, bus, target, lun, &block_device)) < 0) {\n        VIR_DEBUG(\"Failed to find block device for this LUN\");\n        return retval;\n    }\n\n    retval = virStorageBackendSCSINewLun(pool, host, bus, target, lun,\n                                         block_device);\n    if (retval < 0) {\n        VIR_DEBUG(\"Failed to create new storage volume for %u:%u:%u:%u\",\n                  host, bus, target, lun);\n        return retval;\n    }\n\n    VIR_DEBUG(\"Created new storage volume for %u:%u:%u:%u successfully\",\n              host, bus, target, lun);\n\n    return retval;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Created new storage volume for %u:%u:%u:%u successfully\"",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to create new storage volume for %u:%u:%u:%u\"",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendSCSINewLun",
          "args": [
            "pool",
            "host",
            "bus",
            "target",
            "lun",
            "block_device"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendSCSINewLun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3624-3710",
          "snippet": "static int\nvirStorageBackendSCSINewLun(virStoragePoolObjPtr pool,\n                            uint32_t host G_GNUC_UNUSED,\n                            uint32_t bus,\n                            uint32_t target,\n                            uint32_t lun,\n                            const char *dev)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autofree char *devpath = NULL;\n\n    /* Check if the pool is using a stable target path. The call to\n     * virStorageBackendStablePath will fail if the pool target path\n     * isn't stable and just return the strdup'd 'devpath' anyway.\n     * This would be indistinguishable to failing to find the stable\n     * path to the device if the virDirRead loop to search the\n     * target pool path for our devpath had failed.\n     */\n    if (!virStorageBackendPoolPathIsStable(def->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unable to use target path '%s' for dev '%s'\"),\n                       NULLSTR(def->target.path), dev);\n        return -1;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* 'host' is dynamically allocated by the kernel, first come,\n     * first served, per HBA. As such it isn't suitable for use\n     * in the volume name. We only need uniqueness per-pool, so\n     * just leave 'host' out\n     */\n    vol->name = g_strdup_printf(\"unit:%u:%u:%u\", bus, target, lun);\n\n    devpath = g_strdup_printf(\"/dev/%s\", dev);\n\n    VIR_DEBUG(\"Trying to create volume for '%s'\", devpath);\n\n    /* Now figure out the stable path\n     *\n     * XXX this method is O(N) because it scans the pool target\n     * dir every time its run. Should figure out a more efficient\n     * way of doing this...\n     */\n    if ((vol->target.path = virStorageBackendStablePath(pool,\n                                                        devpath,\n                                                        true)) == NULL)\n        return -1;\n\n    if (STREQ(devpath, vol->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n\n        VIR_DEBUG(\"No stable path found for '%s' in '%s'\",\n                  devpath, def->target.path);\n\n        return -2;\n    }\n\n    /* Allow a volume read failure to ignore or skip this block file */\n    if ((retval = virStorageBackendUpdateVolInfo(vol, true,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT,\n                                                 VIR_STORAGE_VOL_READ_NOERROR)) < 0)\n        return retval;\n\n    vol->key = virStorageBackendSCSISerial(vol->target.path,\n                                           (def->source.adapter.type ==\n                                            VIR_STORAGE_ADAPTER_TYPE_FC_HOST));\n    if (!vol->key)\n        return -1;\n\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendSCSINewLun(virStoragePoolObjPtr pool,\n                            uint32_t host G_GNUC_UNUSED,\n                            uint32_t bus,\n                            uint32_t target,\n                            uint32_t lun,\n                            const char *dev)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autofree char *devpath = NULL;\n\n    /* Check if the pool is using a stable target path. The call to\n     * virStorageBackendStablePath will fail if the pool target path\n     * isn't stable and just return the strdup'd 'devpath' anyway.\n     * This would be indistinguishable to failing to find the stable\n     * path to the device if the virDirRead loop to search the\n     * target pool path for our devpath had failed.\n     */\n    if (!virStorageBackendPoolPathIsStable(def->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unable to use target path '%s' for dev '%s'\"),\n                       NULLSTR(def->target.path), dev);\n        return -1;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* 'host' is dynamically allocated by the kernel, first come,\n     * first served, per HBA. As such it isn't suitable for use\n     * in the volume name. We only need uniqueness per-pool, so\n     * just leave 'host' out\n     */\n    vol->name = g_strdup_printf(\"unit:%u:%u:%u\", bus, target, lun);\n\n    devpath = g_strdup_printf(\"/dev/%s\", dev);\n\n    VIR_DEBUG(\"Trying to create volume for '%s'\", devpath);\n\n    /* Now figure out the stable path\n     *\n     * XXX this method is O(N) because it scans the pool target\n     * dir every time its run. Should figure out a more efficient\n     * way of doing this...\n     */\n    if ((vol->target.path = virStorageBackendStablePath(pool,\n                                                        devpath,\n                                                        true)) == NULL)\n        return -1;\n\n    if (STREQ(devpath, vol->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n\n        VIR_DEBUG(\"No stable path found for '%s' in '%s'\",\n                  devpath, def->target.path);\n\n        return -2;\n    }\n\n    /* Allow a volume read failure to ignore or skip this block file */\n    if ((retval = virStorageBackendUpdateVolInfo(vol, true,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT,\n                                                 VIR_STORAGE_VOL_READ_NOERROR)) < 0)\n        return retval;\n\n    vol->key = virStorageBackendSCSISerial(vol->target.path,\n                                           (def->source.adapter.type ==\n                                            VIR_STORAGE_ADAPTER_TYPE_FC_HOST));\n    if (!vol->key)\n        return -1;\n\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to find block device for this LUN\""
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getBlockDevice",
          "args": [
            "host",
            "bus",
            "target",
            "lun",
            "&block_device"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "getBlockDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3785-3834",
          "snippet": "static int\ngetBlockDevice(uint32_t host,\n               uint32_t bus,\n               uint32_t target,\n               uint32_t lun,\n               char **block_device)\n{\n    DIR *lun_dir = NULL;\n    struct dirent *lun_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *lun_path = NULL;\n\n    *block_device = NULL;\n\n    lun_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u\", host, bus,\n                               target, lun);\n\n    if (virDirOpen(&lun_dir, lun_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(lun_dir, &lun_dirent, lun_path)) > 0) {\n        if (STRPREFIX(lun_dirent->d_name, \"block\")) {\n            if (strlen(lun_dirent->d_name) == 5) {\n                if (getNewStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            } else {\n                if (getOldStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            }\n            break;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n    if (!*block_device) {\n        retval = -2;\n        goto cleanup;\n    }\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(lun_dir);\n    return retval;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetBlockDevice(uint32_t host,\n               uint32_t bus,\n               uint32_t target,\n               uint32_t lun,\n               char **block_device)\n{\n    DIR *lun_dir = NULL;\n    struct dirent *lun_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *lun_path = NULL;\n\n    *block_device = NULL;\n\n    lun_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u\", host, bus,\n                               target, lun);\n\n    if (virDirOpen(&lun_dir, lun_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(lun_dir, &lun_dirent, lun_path)) > 0) {\n        if (STRPREFIX(lun_dirent->d_name, \"block\")) {\n            if (strlen(lun_dirent->d_name) == 5) {\n                if (getNewStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            } else {\n                if (getOldStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            }\n            break;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n    if (!*block_device) {\n        retval = -2;\n        goto cleanup;\n    }\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(lun_dir);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%u:%u:%u:%u is a Direct-Access LUN\"",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\")",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\""
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getDeviceType",
          "args": [
            "host",
            "bus",
            "target",
            "lun",
            "&device_type"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "getDeviceType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3841-3890",
          "snippet": "static int\ngetDeviceType(uint32_t host,\n              uint32_t bus,\n              uint32_t target,\n              uint32_t lun,\n              int *type)\n{\n    char typestr[3];\n    char *gottype, *p;\n    FILE *typefile;\n    g_autofree char *type_path = NULL;\n\n    type_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u/type\", host,\n                                bus, target, lun);\n\n    typefile = fopen(type_path, \"r\");\n    if (typefile == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not find typefile '%s'\"),\n                             type_path);\n        /* there was no type file; that doesn't seem right */\n        return -1;\n    }\n\n    gottype = fgets(typestr, 3, typefile);\n    VIR_FORCE_FCLOSE(typefile);\n\n    if (gottype == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not read typefile '%s'\"),\n                             type_path);\n        /* we couldn't read the type file; have to give up */\n        return -1;\n    }\n\n    /* we don't actually care about p, but if you pass NULL and the last\n     * character is not \\0, virStrToLong_i complains\n     */\n    if (virStrToLong_i(typestr, &p, 10, type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device type '%s' is not an integer\"),\n                       typestr);\n        /* Hm, type wasn't an integer; seems strange */\n        return -1;\n    }\n\n    VIR_DEBUG(\"Device type is %d\", *type);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetDeviceType(uint32_t host,\n              uint32_t bus,\n              uint32_t target,\n              uint32_t lun,\n              int *type)\n{\n    char typestr[3];\n    char *gottype, *p;\n    FILE *typefile;\n    g_autofree char *type_path = NULL;\n\n    type_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u/type\", host,\n                                bus, target, lun);\n\n    typefile = fopen(type_path, \"r\");\n    if (typefile == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not find typefile '%s'\"),\n                             type_path);\n        /* there was no type file; that doesn't seem right */\n        return -1;\n    }\n\n    gottype = fgets(typestr, 3, typefile);\n    VIR_FORCE_FCLOSE(typefile);\n\n    if (gottype == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not read typefile '%s'\"),\n                             type_path);\n        /* we couldn't read the type file; have to give up */\n        return -1;\n    }\n\n    /* we don't actually care about p, but if you pass NULL and the last\n     * character is not \\0, virStrToLong_i complains\n     */\n    if (virStrToLong_i(typestr, &p, 10, type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device type '%s' is not an integer\"),\n                       typestr);\n        /* Hm, type wasn't an integer; seems strange */\n        return -1;\n    }\n\n    VIR_DEBUG(\"Device type is %d\", *type);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Processing LU %u:%u:%u:%u\"",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprocessLU(virStoragePoolObjPtr pool,\n          uint32_t host,\n          uint32_t bus,\n          uint32_t target,\n          uint32_t lun)\n{\n    int retval = -1;\n    int device_type;\n    g_autofree char *block_device = NULL;\n\n    VIR_DEBUG(\"Processing LU %u:%u:%u:%u\",\n              host, bus, target, lun);\n\n    if (getDeviceType(host, bus, target, lun, &device_type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to determine if %u:%u:%u:%u is a Direct-Access LUN\"),\n                       host, bus, target, lun);\n        return -1;\n    }\n\n    /* We don't create volumes for devices other than disk and cdrom\n     * devices, but finding a device that isn't one of those types\n     * isn't an error, either. */\n    if (!(device_type == VIR_STORAGE_DEVICE_TYPE_DISK ||\n          device_type == VIR_STORAGE_DEVICE_TYPE_ROM))\n        return -2;\n\n    VIR_DEBUG(\"%u:%u:%u:%u is a Direct-Access LUN\",\n              host, bus, target, lun);\n\n    if ((retval = getBlockDevice(host, bus, target, lun, &block_device)) < 0) {\n        VIR_DEBUG(\"Failed to find block device for this LUN\");\n        return retval;\n    }\n\n    retval = virStorageBackendSCSINewLun(pool, host, bus, target, lun,\n                                         block_device);\n    if (retval < 0) {\n        VIR_DEBUG(\"Failed to create new storage volume for %u:%u:%u:%u\",\n                  host, bus, target, lun);\n        return retval;\n    }\n\n    VIR_DEBUG(\"Created new storage volume for %u:%u:%u:%u successfully\",\n              host, bus, target, lun);\n\n    return retval;\n}"
  },
  {
    "function_name": "getDeviceType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3841-3890",
    "snippet": "static int\ngetDeviceType(uint32_t host,\n              uint32_t bus,\n              uint32_t target,\n              uint32_t lun,\n              int *type)\n{\n    char typestr[3];\n    char *gottype, *p;\n    FILE *typefile;\n    g_autofree char *type_path = NULL;\n\n    type_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u/type\", host,\n                                bus, target, lun);\n\n    typefile = fopen(type_path, \"r\");\n    if (typefile == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not find typefile '%s'\"),\n                             type_path);\n        /* there was no type file; that doesn't seem right */\n        return -1;\n    }\n\n    gottype = fgets(typestr, 3, typefile);\n    VIR_FORCE_FCLOSE(typefile);\n\n    if (gottype == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not read typefile '%s'\"),\n                             type_path);\n        /* we couldn't read the type file; have to give up */\n        return -1;\n    }\n\n    /* we don't actually care about p, but if you pass NULL and the last\n     * character is not \\0, virStrToLong_i complains\n     */\n    if (virStrToLong_i(typestr, &p, 10, type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device type '%s' is not an integer\"),\n                       typestr);\n        /* Hm, type wasn't an integer; seems strange */\n        return -1;\n    }\n\n    VIR_DEBUG(\"Device type is %d\", *type);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Device type is %d\"",
            "*type"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Device type '%s' is not an integer\")",
            "typestr"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Device type '%s' is not an integer\""
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "typestr",
            "&p",
            "10",
            "type"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not read typefile '%s'\")",
            "type_path"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "typefile"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "typestr",
            "3",
            "typefile"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not find typefile '%s'\")",
            "type_path"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "type_path",
            "\"r\""
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetDeviceType(uint32_t host,\n              uint32_t bus,\n              uint32_t target,\n              uint32_t lun,\n              int *type)\n{\n    char typestr[3];\n    char *gottype, *p;\n    FILE *typefile;\n    g_autofree char *type_path = NULL;\n\n    type_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u/type\", host,\n                                bus, target, lun);\n\n    typefile = fopen(type_path, \"r\");\n    if (typefile == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not find typefile '%s'\"),\n                             type_path);\n        /* there was no type file; that doesn't seem right */\n        return -1;\n    }\n\n    gottype = fgets(typestr, 3, typefile);\n    VIR_FORCE_FCLOSE(typefile);\n\n    if (gottype == NULL) {\n        virReportSystemError(errno,\n                             _(\"Could not read typefile '%s'\"),\n                             type_path);\n        /* we couldn't read the type file; have to give up */\n        return -1;\n    }\n\n    /* we don't actually care about p, but if you pass NULL and the last\n     * character is not \\0, virStrToLong_i complains\n     */\n    if (virStrToLong_i(typestr, &p, 10, type) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device type '%s' is not an integer\"),\n                       typestr);\n        /* Hm, type wasn't an integer; seems strange */\n        return -1;\n    }\n\n    VIR_DEBUG(\"Device type is %d\", *type);\n\n    return 0;\n}"
  },
  {
    "function_name": "getBlockDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3785-3834",
    "snippet": "static int\ngetBlockDevice(uint32_t host,\n               uint32_t bus,\n               uint32_t target,\n               uint32_t lun,\n               char **block_device)\n{\n    DIR *lun_dir = NULL;\n    struct dirent *lun_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *lun_path = NULL;\n\n    *block_device = NULL;\n\n    lun_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u\", host, bus,\n                               target, lun);\n\n    if (virDirOpen(&lun_dir, lun_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(lun_dir, &lun_dirent, lun_path)) > 0) {\n        if (STRPREFIX(lun_dirent->d_name, \"block\")) {\n            if (strlen(lun_dirent->d_name) == 5) {\n                if (getNewStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            } else {\n                if (getOldStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            }\n            break;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n    if (!*block_device) {\n        retval = -2;\n        goto cleanup;\n    }\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(lun_dir);\n    return retval;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "lun_dir"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getOldStyleBlockDevice",
          "args": [
            "lun_path",
            "lun_dirent->d_name",
            "block_device"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "getOldStyleBlockDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3751-3773",
          "snippet": "static int\ngetOldStyleBlockDevice(const char *lun_path G_GNUC_UNUSED,\n                       const char *block_name,\n                       char **block_device)\n{\n    char *blockp = NULL;\n\n    /* old-style; just parse out the sd */\n    if (!(blockp = strrchr(block_name, ':'))) {\n        /* Hm, wasn't what we were expecting; have to give up */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse block name %s\"),\n                       block_name);\n        return -1;\n    } else {\n        blockp++;\n        *block_device = g_strdup(blockp);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetOldStyleBlockDevice(const char *lun_path G_GNUC_UNUSED,\n                       const char *block_name,\n                       char **block_device)\n{\n    char *blockp = NULL;\n\n    /* old-style; just parse out the sd */\n    if (!(blockp = strrchr(block_name, ':'))) {\n        /* Hm, wasn't what we were expecting; have to give up */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse block name %s\"),\n                       block_name);\n        return -1;\n    } else {\n        blockp++;\n        *block_device = g_strdup(blockp);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getNewStyleBlockDevice",
          "args": [
            "lun_path",
            "lun_dirent->d_name",
            "block_device"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "getNewStyleBlockDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3714-3748",
          "snippet": "static int\ngetNewStyleBlockDevice(const char *lun_path,\n                       const char *block_name G_GNUC_UNUSED,\n                       char **block_device)\n{\n    DIR *block_dir = NULL;\n    struct dirent *block_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *block_path = NULL;\n\n    block_path = g_strdup_printf(\"%s/block\", lun_path);\n\n    VIR_DEBUG(\"Looking for block device in '%s'\", block_path);\n\n    if (virDirOpen(&block_dir, block_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(block_dir, &block_dirent, block_path)) > 0) {\n        *block_device = g_strdup(block_dirent->d_name);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n\n        break;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(block_dir);\n    return retval;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetNewStyleBlockDevice(const char *lun_path,\n                       const char *block_name G_GNUC_UNUSED,\n                       char **block_device)\n{\n    DIR *block_dir = NULL;\n    struct dirent *block_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *block_path = NULL;\n\n    block_path = g_strdup_printf(\"%s/block\", lun_path);\n\n    VIR_DEBUG(\"Looking for block device in '%s'\", block_path);\n\n    if (virDirOpen(&block_dir, block_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(block_dir, &block_dirent, block_path)) > 0) {\n        *block_device = g_strdup(block_dirent->d_name);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n\n        break;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(block_dir);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lun_dirent->d_name"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "lun_dirent->d_name",
            "\"block\""
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "lun_dir",
            "&lun_dirent",
            "lun_path"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&lun_dir",
            "lun_path"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/sys/bus/scsi/devices/%u:%u:%u:%u\"",
            "host",
            "bus",
            "target",
            "lun"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetBlockDevice(uint32_t host,\n               uint32_t bus,\n               uint32_t target,\n               uint32_t lun,\n               char **block_device)\n{\n    DIR *lun_dir = NULL;\n    struct dirent *lun_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *lun_path = NULL;\n\n    *block_device = NULL;\n\n    lun_path = g_strdup_printf(\"/sys/bus/scsi/devices/%u:%u:%u:%u\", host, bus,\n                               target, lun);\n\n    if (virDirOpen(&lun_dir, lun_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(lun_dir, &lun_dirent, lun_path)) > 0) {\n        if (STRPREFIX(lun_dirent->d_name, \"block\")) {\n            if (strlen(lun_dirent->d_name) == 5) {\n                if (getNewStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            } else {\n                if (getOldStyleBlockDevice(lun_path,\n                                           lun_dirent->d_name,\n                                           block_device) < 0)\n                    goto cleanup;\n            }\n            break;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n    if (!*block_device) {\n        retval = -2;\n        goto cleanup;\n    }\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(lun_dir);\n    return retval;\n}"
  },
  {
    "function_name": "getOldStyleBlockDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3751-3773",
    "snippet": "static int\ngetOldStyleBlockDevice(const char *lun_path G_GNUC_UNUSED,\n                       const char *block_name,\n                       char **block_device)\n{\n    char *blockp = NULL;\n\n    /* old-style; just parse out the sd */\n    if (!(blockp = strrchr(block_name, ':'))) {\n        /* Hm, wasn't what we were expecting; have to give up */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse block name %s\"),\n                       block_name);\n        return -1;\n    } else {\n        blockp++;\n        *block_device = g_strdup(blockp);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Block device is '%s'\"",
            "*block_device"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "blockp"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to parse block name %s\")",
            "block_name"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "block_name",
            "':'"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetOldStyleBlockDevice(const char *lun_path G_GNUC_UNUSED,\n                       const char *block_name,\n                       char **block_device)\n{\n    char *blockp = NULL;\n\n    /* old-style; just parse out the sd */\n    if (!(blockp = strrchr(block_name, ':'))) {\n        /* Hm, wasn't what we were expecting; have to give up */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse block name %s\"),\n                       block_name);\n        return -1;\n    } else {\n        blockp++;\n        *block_device = g_strdup(blockp);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "getNewStyleBlockDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3714-3748",
    "snippet": "static int\ngetNewStyleBlockDevice(const char *lun_path,\n                       const char *block_name G_GNUC_UNUSED,\n                       char **block_device)\n{\n    DIR *block_dir = NULL;\n    struct dirent *block_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *block_path = NULL;\n\n    block_path = g_strdup_printf(\"%s/block\", lun_path);\n\n    VIR_DEBUG(\"Looking for block device in '%s'\", block_path);\n\n    if (virDirOpen(&block_dir, block_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(block_dir, &block_dirent, block_path)) > 0) {\n        *block_device = g_strdup(block_dirent->d_name);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n\n        break;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(block_dir);\n    return retval;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "block_dir"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Block device is '%s'\"",
            "*block_device"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "block_dirent->d_name"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "block_dir",
            "&block_dirent",
            "block_path"
          ],
          "line": 3732
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&block_dir",
            "block_path"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Looking for block device in '%s'\"",
            "block_path"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ngetNewStyleBlockDevice(const char *lun_path,\n                       const char *block_name G_GNUC_UNUSED,\n                       char **block_device)\n{\n    DIR *block_dir = NULL;\n    struct dirent *block_dirent = NULL;\n    int retval = -1;\n    int direrr;\n    g_autofree char *block_path = NULL;\n\n    block_path = g_strdup_printf(\"%s/block\", lun_path);\n\n    VIR_DEBUG(\"Looking for block device in '%s'\", block_path);\n\n    if (virDirOpen(&block_dir, block_path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(block_dir, &block_dirent, block_path)) > 0) {\n        *block_device = g_strdup(block_dirent->d_name);\n\n        VIR_DEBUG(\"Block device is '%s'\", *block_device);\n\n        break;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    retval = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(block_dir);\n    return retval;\n}"
  },
  {
    "function_name": "virStorageBackendSCSINewLun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3624-3710",
    "snippet": "static int\nvirStorageBackendSCSINewLun(virStoragePoolObjPtr pool,\n                            uint32_t host G_GNUC_UNUSED,\n                            uint32_t bus,\n                            uint32_t target,\n                            uint32_t lun,\n                            const char *dev)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autofree char *devpath = NULL;\n\n    /* Check if the pool is using a stable target path. The call to\n     * virStorageBackendStablePath will fail if the pool target path\n     * isn't stable and just return the strdup'd 'devpath' anyway.\n     * This would be indistinguishable to failing to find the stable\n     * path to the device if the virDirRead loop to search the\n     * target pool path for our devpath had failed.\n     */\n    if (!virStorageBackendPoolPathIsStable(def->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unable to use target path '%s' for dev '%s'\"),\n                       NULLSTR(def->target.path), dev);\n        return -1;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* 'host' is dynamically allocated by the kernel, first come,\n     * first served, per HBA. As such it isn't suitable for use\n     * in the volume name. We only need uniqueness per-pool, so\n     * just leave 'host' out\n     */\n    vol->name = g_strdup_printf(\"unit:%u:%u:%u\", bus, target, lun);\n\n    devpath = g_strdup_printf(\"/dev/%s\", dev);\n\n    VIR_DEBUG(\"Trying to create volume for '%s'\", devpath);\n\n    /* Now figure out the stable path\n     *\n     * XXX this method is O(N) because it scans the pool target\n     * dir every time its run. Should figure out a more efficient\n     * way of doing this...\n     */\n    if ((vol->target.path = virStorageBackendStablePath(pool,\n                                                        devpath,\n                                                        true)) == NULL)\n        return -1;\n\n    if (STREQ(devpath, vol->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n\n        VIR_DEBUG(\"No stable path found for '%s' in '%s'\",\n                  devpath, def->target.path);\n\n        return -2;\n    }\n\n    /* Allow a volume read failure to ignore or skip this block file */\n    if ((retval = virStorageBackendUpdateVolInfo(vol, true,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT,\n                                                 VIR_STORAGE_VOL_READ_NOERROR)) < 0)\n        return retval;\n\n    vol->key = virStorageBackendSCSISerial(vol->target.path,\n                                           (def->source.adapter.type ==\n                                            VIR_STORAGE_ADAPTER_TYPE_FC_HOST));\n    if (!vol->key)\n        return -1;\n\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendSCSISerial",
          "args": [
            "vol->target.path",
            "(def->source.adapter.type ==\n                                            VIR_STORAGE_ADAPTER_TYPE_FC_HOST)"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendSCSISerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3592-3611",
          "snippet": "static char *\nvirStorageBackendSCSISerial(const char *dev,\n                            bool isNPIV)\n{\n    int rc;\n    char *serial = NULL;\n\n    if (isNPIV)\n        rc = virStorageFileGetNPIVKey(dev, &serial);\n    else\n        rc = virStorageFileGetSCSIKey(dev, &serial, true);\n    if (rc == 0 && serial)\n        return serial;\n\n    if (rc == -2)\n        return NULL;\n\n    serial = g_strdup(dev);\n    return serial;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nvirStorageBackendSCSISerial(const char *dev,\n                            bool isNPIV)\n{\n    int rc;\n    char *serial = NULL;\n\n    if (isNPIV)\n        rc = virStorageFileGetNPIVKey(dev, &serial);\n    else\n        rc = virStorageFileGetSCSIKey(dev, &serial, true);\n    if (rc == 0 && serial)\n        return serial;\n\n    if (rc == -2)\n        return NULL;\n\n    serial = g_strdup(dev);\n    return serial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolInfo",
          "args": [
            "vol",
            "true",
            "VIR_STORAGE_VOL_OPEN_DEFAULT",
            "VIR_STORAGE_VOL_READ_NOERROR"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1781-1805",
          "snippet": "int\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No stable path found for '%s' in '%s'\"",
            "devpath",
            "def->target.path"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->target.path",
            "\"/dev/\""
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->target.path",
            "\"/dev\""
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devpath",
            "vol->target.path"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendStablePath",
          "args": [
            "pool",
            "devpath",
            "true"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendStablePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1904-1975",
          "snippet": "char *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Trying to create volume for '%s'\"",
            "devpath"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/dev/%s\"",
            "dev"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unable to use target path '%s' for dev '%s'\")",
            "NULLSTR(def->target.path)",
            "dev"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "def->target.path"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->target.path",
            "\"/dev/\""
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->target.path",
            "\"/dev\""
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendPoolPathIsStable",
          "args": [
            "def->target.path"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendPoolPathIsStable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1876-1886",
          "snippet": "bool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendSCSINewLun(virStoragePoolObjPtr pool,\n                            uint32_t host G_GNUC_UNUSED,\n                            uint32_t bus,\n                            uint32_t target,\n                            uint32_t lun,\n                            const char *dev)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int retval = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autofree char *devpath = NULL;\n\n    /* Check if the pool is using a stable target path. The call to\n     * virStorageBackendStablePath will fail if the pool target path\n     * isn't stable and just return the strdup'd 'devpath' anyway.\n     * This would be indistinguishable to failing to find the stable\n     * path to the device if the virDirRead loop to search the\n     * target pool path for our devpath had failed.\n     */\n    if (!virStorageBackendPoolPathIsStable(def->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unable to use target path '%s' for dev '%s'\"),\n                       NULLSTR(def->target.path), dev);\n        return -1;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* 'host' is dynamically allocated by the kernel, first come,\n     * first served, per HBA. As such it isn't suitable for use\n     * in the volume name. We only need uniqueness per-pool, so\n     * just leave 'host' out\n     */\n    vol->name = g_strdup_printf(\"unit:%u:%u:%u\", bus, target, lun);\n\n    devpath = g_strdup_printf(\"/dev/%s\", dev);\n\n    VIR_DEBUG(\"Trying to create volume for '%s'\", devpath);\n\n    /* Now figure out the stable path\n     *\n     * XXX this method is O(N) because it scans the pool target\n     * dir every time its run. Should figure out a more efficient\n     * way of doing this...\n     */\n    if ((vol->target.path = virStorageBackendStablePath(pool,\n                                                        devpath,\n                                                        true)) == NULL)\n        return -1;\n\n    if (STREQ(devpath, vol->target.path) &&\n        !(STREQ(def->target.path, \"/dev\") ||\n          STREQ(def->target.path, \"/dev/\"))) {\n\n        VIR_DEBUG(\"No stable path found for '%s' in '%s'\",\n                  devpath, def->target.path);\n\n        return -2;\n    }\n\n    /* Allow a volume read failure to ignore or skip this block file */\n    if ((retval = virStorageBackendUpdateVolInfo(vol, true,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT,\n                                                 VIR_STORAGE_VOL_READ_NOERROR)) < 0)\n        return retval;\n\n    vol->key = virStorageBackendSCSISerial(vol->target.path,\n                                           (def->source.adapter.type ==\n                                            VIR_STORAGE_ADAPTER_TYPE_FC_HOST));\n    if (!vol->key)\n        return -1;\n\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendSCSISerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3592-3611",
    "snippet": "static char *\nvirStorageBackendSCSISerial(const char *dev,\n                            bool isNPIV)\n{\n    int rc;\n    char *serial = NULL;\n\n    if (isNPIV)\n        rc = virStorageFileGetNPIVKey(dev, &serial);\n    else\n        rc = virStorageFileGetSCSIKey(dev, &serial, true);\n    if (rc == 0 && serial)\n        return serial;\n\n    if (rc == -2)\n        return NULL;\n\n    serial = g_strdup(dev);\n    return serial;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dev"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetSCSIKey",
          "args": [
            "dev",
            "&serial",
            "true"
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetSCSIKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1416-1423",
          "snippet": "int virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetSCSIKey(const char *path,\n                             char **key G_GNUC_UNUSED,\n                             bool ignoreError)\n{\n    if (!ignoreError)\n        virReportSystemError(ENOSYS, _(\"Unable to get SCSI key for %s\"), path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetNPIVKey",
          "args": [
            "dev",
            "&serial"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetNPIVKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1494-1498",
          "snippet": "int virStorageFileGetNPIVKey(const char *path G_GNUC_UNUSED,\n                             char **key G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileGetNPIVKey(const char *path G_GNUC_UNUSED,\n                             char **key G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nvirStorageBackendSCSISerial(const char *dev,\n                            bool isNPIV)\n{\n    int rc;\n    char *serial = NULL;\n\n    if (isNPIV)\n        rc = virStorageFileGetNPIVKey(dev, &serial);\n    else\n        rc = virStorageFileGetSCSIKey(dev, &serial, true);\n    if (rc == 0 && serial)\n        return serial;\n\n    if (rc == -2)\n        return NULL;\n\n    serial = g_strdup(dev);\n    return serial;\n}"
  },
  {
    "function_name": "virStorageBackendRefreshLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3490-3589",
    "snippet": "int\nvirStorageBackendRefreshLocal(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dir;\n    struct dirent *ent;\n    struct statvfs sb;\n    struct stat statbuf;\n    int direrr;\n    int ret = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virStorageSource) target = NULL;\n\n    if (virDirOpen(&dir, def->target.path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, def->target.path)) > 0) {\n        int err;\n\n        if (virStringHasControlChars(ent->d_name)) {\n            VIR_WARN(\"Ignoring file '%s' with control characters under '%s'\",\n                     ent->d_name, def->target.path);\n            continue;\n        }\n\n        if (VIR_ALLOC(vol) < 0)\n            goto cleanup;\n\n        vol->name = g_strdup(ent->d_name);\n\n        vol->type = VIR_STORAGE_VOL_FILE;\n        vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n        vol->key = g_strdup(vol->target.path);\n\n        if ((err = virStorageBackendRefreshVolTargetUpdate(vol)) < 0) {\n            if (err == -2) {\n                /* Silently ignore non-regular files,\n                 * eg 'lost+found', dangling symbolic link */\n                virStorageVolDefFree(vol);\n                vol = NULL;\n                continue;\n            }\n            goto cleanup;\n        }\n\n        if (virStoragePoolObjAddVol(pool, vol) < 0)\n            goto cleanup;\n        vol = NULL;\n    }\n    if (direrr < 0)\n        goto cleanup;\n    VIR_DIR_CLOSE(dir);\n\n    if (!(target = virStorageSourceNew()))\n        goto cleanup;\n\n    if ((fd = open(def->target.path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    if (fstat(fd, &statbuf) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &statbuf) < 0)\n        goto cleanup;\n\n    /* VolTargetInfoFD doesn't update capacity correctly for the pool case */\n    if (statvfs(def->target.path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot statvfs path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    def->capacity = ((unsigned long long)sb.f_frsize *\n                     (unsigned long long)sb.f_blocks);\n    def->available = ((unsigned long long)sb.f_bfree *\n                      (unsigned long long)sb.f_frsize);\n    def->allocation = def->capacity - def->available;\n\n    def->target.perms.mode = target->perms->mode;\n    def->target.perms.uid = target->perms->uid;\n    def->target.perms.gid = target->perms->gid;\n    VIR_FREE(def->target.perms.label);\n    def->target.perms.label = g_strdup(target->perms->label);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "target->perms->label"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->target.perms.label"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot statvfs path '%s'\")",
            "def->target.path"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statvfs",
          "args": [
            "def->target.path",
            "&sb"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolTargetInfoFD",
          "args": [
            "target",
            "fd",
            "&statbuf"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolTargetInfoFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1815-1874",
          "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat path '%s'\")",
            "def->target.path"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&statbuf"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open path '%s'\")",
            "def->target.path"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "def->target.path",
            "O_RDONLY"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 3537
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFree",
          "args": [
            "vol"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "443-460",
          "snippet": "void\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendRefreshVolTargetUpdate",
          "args": [
            "vol"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendRefreshVolTargetUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3442-3483",
          "snippet": "int\nvirStorageBackendRefreshVolTargetUpdate(virStorageVolDefPtr vol)\n{\n    int err;\n\n    /* Real value is filled in during probe */\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if ((err = storageBackendProbeTarget(&vol->target,\n                                         &vol->target.encryption)) < 0) {\n        if (err == -2) {\n            return -2;\n        } else if (err == -3) {\n            /* The backing file is currently unavailable, its format is not\n             * explicitly specified, the probe to auto detect the format\n             * failed: continue with faked RAW format, since AUTO will\n             * break virStorageVolTargetDefFormat() generating the line\n             * <format type='...'/>. */\n        } else {\n            return -1;\n        }\n    }\n\n    /* directory based volume */\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        ignore_value(storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                       vol->target.backingStore,\n                                                       false,\n                                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0));\n        /* If this failed, the backing file is currently unavailable,\n         * the capacity, allocation, owner, group and mode are unknown.\n         * An error message was raised, but we just continue. */\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendRefreshVolTargetUpdate(virStorageVolDefPtr vol)\n{\n    int err;\n\n    /* Real value is filled in during probe */\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if ((err = storageBackendProbeTarget(&vol->target,\n                                         &vol->target.encryption)) < 0) {\n        if (err == -2) {\n            return -2;\n        } else if (err == -3) {\n            /* The backing file is currently unavailable, its format is not\n             * explicitly specified, the probe to auto detect the format\n             * failed: continue with faked RAW format, since AUTO will\n             * break virStorageVolTargetDefFormat() generating the line\n             * <format type='...'/>. */\n        } else {\n            return -1;\n        }\n    }\n\n    /* directory based volume */\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        ignore_value(storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                       vol->target.backingStore,\n                                                       false,\n                                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0));\n        /* If this failed, the backing file is currently unavailable,\n         * the capacity, allocation, owner, group and mode are unknown.\n         * An error message was raised, but we just continue. */\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring file '%s' with control characters under '%s'\"",
            "ent->d_name",
            "def->target.path"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasControlChars",
          "args": [
            "ent->d_name"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasControlChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1205-1209",
          "snippet": "bool\nvirStringHasControlChars(const char *str)\n{\n    return virStringHasChars(str, control_chars);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char control_chars[] =\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n    \"\\x08\" /* \\t \\n */ \"\\x0B\\x0C\" /* \\r */ \"\\x0E\\x0F\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n    \"\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nstatic const char control_chars[] =\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n    \"\\x08\" /* \\t \\n */ \"\\x0B\\x0C\" /* \\r */ \"\\x0E\\x0F\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n    \"\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\";\n\nbool\nvirStringHasControlChars(const char *str)\n{\n    return virStringHasChars(str, control_chars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&ent",
            "def->target.path"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dir",
            "def->target.path"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendRefreshLocal(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dir;\n    struct dirent *ent;\n    struct statvfs sb;\n    struct stat statbuf;\n    int direrr;\n    int ret = -1;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virStorageSource) target = NULL;\n\n    if (virDirOpen(&dir, def->target.path) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, def->target.path)) > 0) {\n        int err;\n\n        if (virStringHasControlChars(ent->d_name)) {\n            VIR_WARN(\"Ignoring file '%s' with control characters under '%s'\",\n                     ent->d_name, def->target.path);\n            continue;\n        }\n\n        if (VIR_ALLOC(vol) < 0)\n            goto cleanup;\n\n        vol->name = g_strdup(ent->d_name);\n\n        vol->type = VIR_STORAGE_VOL_FILE;\n        vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n        vol->key = g_strdup(vol->target.path);\n\n        if ((err = virStorageBackendRefreshVolTargetUpdate(vol)) < 0) {\n            if (err == -2) {\n                /* Silently ignore non-regular files,\n                 * eg 'lost+found', dangling symbolic link */\n                virStorageVolDefFree(vol);\n                vol = NULL;\n                continue;\n            }\n            goto cleanup;\n        }\n\n        if (virStoragePoolObjAddVol(pool, vol) < 0)\n            goto cleanup;\n        vol = NULL;\n    }\n    if (direrr < 0)\n        goto cleanup;\n    VIR_DIR_CLOSE(dir);\n\n    if (!(target = virStorageSourceNew()))\n        goto cleanup;\n\n    if ((fd = open(def->target.path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    if (fstat(fd, &statbuf) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &statbuf) < 0)\n        goto cleanup;\n\n    /* VolTargetInfoFD doesn't update capacity correctly for the pool case */\n    if (statvfs(def->target.path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot statvfs path '%s'\"),\n                             def->target.path);\n        goto cleanup;\n    }\n\n    def->capacity = ((unsigned long long)sb.f_frsize *\n                     (unsigned long long)sb.f_blocks);\n    def->available = ((unsigned long long)sb.f_bfree *\n                      (unsigned long long)sb.f_frsize);\n    def->allocation = def->capacity - def->available;\n\n    def->target.perms.mode = target->perms->mode;\n    def->target.perms.uid = target->perms->uid;\n    def->target.perms.gid = target->perms->gid;\n    VIR_FREE(def->target.perms.label);\n    def->target.perms.label = g_strdup(target->perms->label);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendRefreshVolTargetUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3442-3483",
    "snippet": "int\nvirStorageBackendRefreshVolTargetUpdate(virStorageVolDefPtr vol)\n{\n    int err;\n\n    /* Real value is filled in during probe */\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if ((err = storageBackendProbeTarget(&vol->target,\n                                         &vol->target.encryption)) < 0) {\n        if (err == -2) {\n            return -2;\n        } else if (err == -3) {\n            /* The backing file is currently unavailable, its format is not\n             * explicitly specified, the probe to auto detect the format\n             * failed: continue with faked RAW format, since AUTO will\n             * break virStorageVolTargetDefFormat() generating the line\n             * <format type='...'/>. */\n        } else {\n            return -1;\n        }\n    }\n\n    /* directory based volume */\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        ignore_value(storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                       vol->target.backingStore,\n                                                       false,\n                                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0));\n        /* If this failed, the backing file is currently unavailable,\n         * the capacity, allocation, owner, group and mode are unknown.\n         * An error message was raised, but we just continue. */\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                       vol->target.backingStore,\n                                                       false,\n                                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0)"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendUpdateVolTargetInfo",
          "args": [
            "VIR_STORAGE_VOL_FILE",
            "vol->target.backingStore",
            "false",
            "VIR_STORAGE_VOL_OPEN_DEFAULT",
            "0"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendUpdateVolTargetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1709-1768",
          "snippet": "static int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendProbeTarget",
          "args": [
            "&vol->target",
            "&vol->target.encryption"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendProbeTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3329-3431",
          "snippet": "static int\nstorageBackendProbeTarget(virStorageSourcePtr target,\n                          virStorageEncryptionPtr *encryption)\n{\n    int rc;\n    struct stat sb;\n    g_autoptr(virStorageSource) meta = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (encryption)\n        *encryption = NULL;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb,\n                                       VIR_STORAGE_VOL_FS_PROBE_FLAGS)) < 0)\n        return rc; /* Take care to propagate rc, it is not always -1 */\n    fd = rc;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb) < 0)\n        return -1;\n\n    if (S_ISDIR(sb.st_mode)) {\n        if (storageBackendIsPloopDir(target->path)) {\n            if (storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                              VIR_STORAGE_VOL_FS_PROBE_FLAGS) < 0)\n                return -1;\n        } else {\n            target->format = VIR_STORAGE_FILE_DIR;\n            return 0;\n        }\n    }\n\n    if (!(meta = virStorageFileGetMetadataFromFD(target->path,\n                                                 fd,\n                                                 VIR_STORAGE_FILE_AUTO)))\n        return -1;\n\n    if (meta->backingStoreRaw) {\n        if (virStorageSourceNewFromBacking(meta, &target->backingStore) < 0)\n            return -1;\n\n        /* XXX: Remote storage doesn't play nicely with volumes backed by\n         * remote storage. To avoid trouble, just fake the backing store is RAW\n         * and put the string from the metadata as the path of the target. */\n        if (!virStorageSourceIsLocalStorage(target->backingStore)) {\n            virObjectUnref(target->backingStore);\n\n            if (!(target->backingStore = virStorageSourceNew()))\n                return -1;\n\n            target->backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n            target->backingStore->path = meta->backingStoreRaw;\n            meta->backingStoreRaw = NULL;\n            target->backingStore->format = VIR_STORAGE_FILE_RAW;\n        }\n\n        if (target->backingStore->format == VIR_STORAGE_FILE_AUTO) {\n            if ((rc = virStorageFileProbeFormat(target->backingStore->path,\n                                                -1, -1)) < 0) {\n                /* If the backing file is currently unavailable or is\n                 * accessed via remote protocol only log an error, fake the\n                 * format as RAW and continue. Returning -1 here would\n                 * disable the whole storage pool, making it unavailable for\n                 * even maintenance. */\n                target->backingStore->format = VIR_STORAGE_FILE_RAW;\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot probe backing volume format: %s\"),\n                               target->backingStore->path);\n            } else {\n                target->backingStore->format = rc;\n            }\n        }\n    }\n\n    target->format = meta->format;\n\n    /* Default to success below this point */\n    if (meta->capacity)\n        target->capacity = meta->capacity;\n\n    if (encryption && meta->encryption) {\n        if (meta->encryption->payload_offset != -1)\n            target->capacity -= meta->encryption->payload_offset * 512;\n\n        *encryption = meta->encryption;\n        meta->encryption = NULL;\n\n        /* XXX ideally we'd fill in secret UUID here\n         * but we cannot guarantee 'conn' is non-NULL\n         * at this point in time :-(  So we only fill\n         * in secrets when someone first queries a vol\n         */\n    }\n\n    virBitmapFree(target->features);\n    target->features = g_steal_pointer(&meta->features);\n\n    if (meta->compat) {\n        VIR_FREE(target->compat);\n        target->compat = g_steal_pointer(&meta->compat);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendProbeTarget(virStorageSourcePtr target,\n                          virStorageEncryptionPtr *encryption)\n{\n    int rc;\n    struct stat sb;\n    g_autoptr(virStorageSource) meta = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (encryption)\n        *encryption = NULL;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb,\n                                       VIR_STORAGE_VOL_FS_PROBE_FLAGS)) < 0)\n        return rc; /* Take care to propagate rc, it is not always -1 */\n    fd = rc;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb) < 0)\n        return -1;\n\n    if (S_ISDIR(sb.st_mode)) {\n        if (storageBackendIsPloopDir(target->path)) {\n            if (storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                              VIR_STORAGE_VOL_FS_PROBE_FLAGS) < 0)\n                return -1;\n        } else {\n            target->format = VIR_STORAGE_FILE_DIR;\n            return 0;\n        }\n    }\n\n    if (!(meta = virStorageFileGetMetadataFromFD(target->path,\n                                                 fd,\n                                                 VIR_STORAGE_FILE_AUTO)))\n        return -1;\n\n    if (meta->backingStoreRaw) {\n        if (virStorageSourceNewFromBacking(meta, &target->backingStore) < 0)\n            return -1;\n\n        /* XXX: Remote storage doesn't play nicely with volumes backed by\n         * remote storage. To avoid trouble, just fake the backing store is RAW\n         * and put the string from the metadata as the path of the target. */\n        if (!virStorageSourceIsLocalStorage(target->backingStore)) {\n            virObjectUnref(target->backingStore);\n\n            if (!(target->backingStore = virStorageSourceNew()))\n                return -1;\n\n            target->backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n            target->backingStore->path = meta->backingStoreRaw;\n            meta->backingStoreRaw = NULL;\n            target->backingStore->format = VIR_STORAGE_FILE_RAW;\n        }\n\n        if (target->backingStore->format == VIR_STORAGE_FILE_AUTO) {\n            if ((rc = virStorageFileProbeFormat(target->backingStore->path,\n                                                -1, -1)) < 0) {\n                /* If the backing file is currently unavailable or is\n                 * accessed via remote protocol only log an error, fake the\n                 * format as RAW and continue. Returning -1 here would\n                 * disable the whole storage pool, making it unavailable for\n                 * even maintenance. */\n                target->backingStore->format = VIR_STORAGE_FILE_RAW;\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot probe backing volume format: %s\"),\n                               target->backingStore->path);\n            } else {\n                target->backingStore->format = rc;\n            }\n        }\n    }\n\n    target->format = meta->format;\n\n    /* Default to success below this point */\n    if (meta->capacity)\n        target->capacity = meta->capacity;\n\n    if (encryption && meta->encryption) {\n        if (meta->encryption->payload_offset != -1)\n            target->capacity -= meta->encryption->payload_offset * 512;\n\n        *encryption = meta->encryption;\n        meta->encryption = NULL;\n\n        /* XXX ideally we'd fill in secret UUID here\n         * but we cannot guarantee 'conn' is non-NULL\n         * at this point in time :-(  So we only fill\n         * in secrets when someone first queries a vol\n         */\n    }\n\n    virBitmapFree(target->features);\n    target->features = g_steal_pointer(&meta->features);\n\n    if (meta->compat) {\n        VIR_FREE(target->compat);\n        target->compat = g_steal_pointer(&meta->compat);\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendRefreshVolTargetUpdate(virStorageVolDefPtr vol)\n{\n    int err;\n\n    /* Real value is filled in during probe */\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if ((err = storageBackendProbeTarget(&vol->target,\n                                         &vol->target.encryption)) < 0) {\n        if (err == -2) {\n            return -2;\n        } else if (err == -3) {\n            /* The backing file is currently unavailable, its format is not\n             * explicitly specified, the probe to auto detect the format\n             * failed: continue with faked RAW format, since AUTO will\n             * break virStorageVolTargetDefFormat() generating the line\n             * <format type='...'/>. */\n        } else {\n            return -1;\n        }\n    }\n\n    /* directory based volume */\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        ignore_value(storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                       vol->target.backingStore,\n                                                       false,\n                                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0));\n        /* If this failed, the backing file is currently unavailable,\n         * the capacity, allocation, owner, group and mode are unknown.\n         * An error message was raised, but we just continue. */\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendProbeTarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3329-3431",
    "snippet": "static int\nstorageBackendProbeTarget(virStorageSourcePtr target,\n                          virStorageEncryptionPtr *encryption)\n{\n    int rc;\n    struct stat sb;\n    g_autoptr(virStorageSource) meta = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (encryption)\n        *encryption = NULL;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb,\n                                       VIR_STORAGE_VOL_FS_PROBE_FLAGS)) < 0)\n        return rc; /* Take care to propagate rc, it is not always -1 */\n    fd = rc;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb) < 0)\n        return -1;\n\n    if (S_ISDIR(sb.st_mode)) {\n        if (storageBackendIsPloopDir(target->path)) {\n            if (storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                              VIR_STORAGE_VOL_FS_PROBE_FLAGS) < 0)\n                return -1;\n        } else {\n            target->format = VIR_STORAGE_FILE_DIR;\n            return 0;\n        }\n    }\n\n    if (!(meta = virStorageFileGetMetadataFromFD(target->path,\n                                                 fd,\n                                                 VIR_STORAGE_FILE_AUTO)))\n        return -1;\n\n    if (meta->backingStoreRaw) {\n        if (virStorageSourceNewFromBacking(meta, &target->backingStore) < 0)\n            return -1;\n\n        /* XXX: Remote storage doesn't play nicely with volumes backed by\n         * remote storage. To avoid trouble, just fake the backing store is RAW\n         * and put the string from the metadata as the path of the target. */\n        if (!virStorageSourceIsLocalStorage(target->backingStore)) {\n            virObjectUnref(target->backingStore);\n\n            if (!(target->backingStore = virStorageSourceNew()))\n                return -1;\n\n            target->backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n            target->backingStore->path = meta->backingStoreRaw;\n            meta->backingStoreRaw = NULL;\n            target->backingStore->format = VIR_STORAGE_FILE_RAW;\n        }\n\n        if (target->backingStore->format == VIR_STORAGE_FILE_AUTO) {\n            if ((rc = virStorageFileProbeFormat(target->backingStore->path,\n                                                -1, -1)) < 0) {\n                /* If the backing file is currently unavailable or is\n                 * accessed via remote protocol only log an error, fake the\n                 * format as RAW and continue. Returning -1 here would\n                 * disable the whole storage pool, making it unavailable for\n                 * even maintenance. */\n                target->backingStore->format = VIR_STORAGE_FILE_RAW;\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot probe backing volume format: %s\"),\n                               target->backingStore->path);\n            } else {\n                target->backingStore->format = rc;\n            }\n        }\n    }\n\n    target->format = meta->format;\n\n    /* Default to success below this point */\n    if (meta->capacity)\n        target->capacity = meta->capacity;\n\n    if (encryption && meta->encryption) {\n        if (meta->encryption->payload_offset != -1)\n            target->capacity -= meta->encryption->payload_offset * 512;\n\n        *encryption = meta->encryption;\n        meta->encryption = NULL;\n\n        /* XXX ideally we'd fill in secret UUID here\n         * but we cannot guarantee 'conn' is non-NULL\n         * at this point in time :-(  So we only fill\n         * in secrets when someone first queries a vol\n         */\n    }\n\n    virBitmapFree(target->features);\n    target->features = g_steal_pointer(&meta->features);\n\n    if (meta->compat) {\n        VIR_FREE(target->compat);\n        target->compat = g_steal_pointer(&meta->compat);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&meta->compat"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "target->compat"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&meta->features"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "target->features"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot probe backing volume format: %s\")",
            "target->backingStore->path"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot probe backing volume format: %s\""
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileProbeFormat",
          "args": [
            "target->backingStore->path",
            "-1",
            "-1"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileProbeFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1052-1085",
          "snippet": "int\nvirStorageFileProbeFormat(const char *path, uid_t uid, gid_t gid)\n{\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    VIR_AUTOCLOSE fd = -1;\n    g_autofree char *header = NULL;\n\n    if ((fd = virFileOpenAs(path, O_RDONLY, 0, uid, gid, 0)) < 0) {\n        virReportSystemError(-fd, _(\"Failed to open file '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        return -1;\n    }\n\n    /* No header to probe for directories */\n    if (S_ISDIR(sb.st_mode))\n        return VIR_STORAGE_FILE_DIR;\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot set to start of '%s'\"), path);\n        return -1;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &header)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), path);\n        return -1;\n    }\n\n    return virStorageFileProbeFormatFromBuf(path, header, len);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nint\nvirStorageFileProbeFormat(const char *path, uid_t uid, gid_t gid)\n{\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    VIR_AUTOCLOSE fd = -1;\n    g_autofree char *header = NULL;\n\n    if ((fd = virFileOpenAs(path, O_RDONLY, 0, uid, gid, 0)) < 0) {\n        virReportSystemError(-fd, _(\"Failed to open file '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        return -1;\n    }\n\n    /* No header to probe for directories */\n    if (S_ISDIR(sb.st_mode))\n        return VIR_STORAGE_FILE_DIR;\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot set to start of '%s'\"), path);\n        return -1;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &header)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), path);\n        return -1;\n    }\n\n    return virStorageFileProbeFormatFromBuf(path, header, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "target->backingStore"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "target->backingStore"
          ],
          "line": 3372
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNewFromBacking",
          "args": [
            "meta",
            "&target->backingStore"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNewFromBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4028-4042",
          "snippet": "int\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceNewFromBacking(virStorageSourcePtr parent,\n                               virStorageSourcePtr *backing)\n{\n    int rc;\n\n    if ((rc = virStorageSourceNewFromChild(parent,\n                                           parent->backingStoreRaw,\n                                           backing)) < 0)\n        return rc;\n\n    (*backing)->format = parent->backingStoreRawFormat;\n    (*backing)->readonly = true;\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataFromFD",
          "args": [
            "target->path",
            "fd",
            "VIR_STORAGE_FILE_AUTO"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataFromFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1161-1208",
          "snippet": "virStorageSourcePtr\nvirStorageFileGetMetadataFromFD(const char *path,\n                                int fd,\n                                int format)\n\n{\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    struct stat sb;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"), path);\n        return NULL;\n    }\n\n    if (!(meta = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (S_ISDIR(sb.st_mode)) {\n        /* No header to probe for directories, but also no backing file. Just\n         * update the metadata.*/\n        meta->type = VIR_STORAGE_TYPE_DIR;\n        meta->format = VIR_STORAGE_FILE_DIR;\n        return g_steal_pointer(&meta);\n    }\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if (virStorageFileGetMetadataInternal(meta, buf, len) < 0)\n        return NULL;\n\n    if (S_ISREG(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_FILE;\n    else if (S_ISBLK(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_BLOCK;\n\n    return g_steal_pointer(&meta);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nvirStorageSourcePtr\nvirStorageFileGetMetadataFromFD(const char *path,\n                                int fd,\n                                int format)\n\n{\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    struct stat sb;\n    g_autofree char *buf = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"), path);\n        return NULL;\n    }\n\n    if (!(meta = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (S_ISDIR(sb.st_mode)) {\n        /* No header to probe for directories, but also no backing file. Just\n         * update the metadata.*/\n        meta->type = VIR_STORAGE_TYPE_DIR;\n        meta->format = VIR_STORAGE_FILE_DIR;\n        return g_steal_pointer(&meta);\n    }\n\n    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n        virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n        virReportSystemError(errno, _(\"cannot read header '%s'\"), meta->path);\n        return NULL;\n    }\n\n    if (virStorageFileGetMetadataInternal(meta, buf, len) < 0)\n        return NULL;\n\n    if (S_ISREG(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_FILE;\n    else if (S_ISBLK(sb.st_mode))\n        meta->type = VIR_STORAGE_TYPE_BLOCK;\n\n    return g_steal_pointer(&meta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendRedoPloopUpdate",
          "args": [
            "target",
            "&sb",
            "&fd",
            "VIR_STORAGE_VOL_FS_PROBE_FLAGS"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendRedoPloopUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1682-1693",
          "snippet": "static int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendIsPloopDir",
          "args": [
            "target->path"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendIsPloopDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1661-1675",
          "snippet": "static bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolTargetInfoFD",
          "args": [
            "target",
            "fd",
            "&sb"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolTargetInfoFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1815-1874",
          "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolOpen",
          "args": [
            "target->path",
            "&sb",
            "VIR_STORAGE_VOL_FS_PROBE_FLAGS"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1518-1656",
          "snippet": "int\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendProbeTarget(virStorageSourcePtr target,\n                          virStorageEncryptionPtr *encryption)\n{\n    int rc;\n    struct stat sb;\n    g_autoptr(virStorageSource) meta = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (encryption)\n        *encryption = NULL;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb,\n                                       VIR_STORAGE_VOL_FS_PROBE_FLAGS)) < 0)\n        return rc; /* Take care to propagate rc, it is not always -1 */\n    fd = rc;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb) < 0)\n        return -1;\n\n    if (S_ISDIR(sb.st_mode)) {\n        if (storageBackendIsPloopDir(target->path)) {\n            if (storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                              VIR_STORAGE_VOL_FS_PROBE_FLAGS) < 0)\n                return -1;\n        } else {\n            target->format = VIR_STORAGE_FILE_DIR;\n            return 0;\n        }\n    }\n\n    if (!(meta = virStorageFileGetMetadataFromFD(target->path,\n                                                 fd,\n                                                 VIR_STORAGE_FILE_AUTO)))\n        return -1;\n\n    if (meta->backingStoreRaw) {\n        if (virStorageSourceNewFromBacking(meta, &target->backingStore) < 0)\n            return -1;\n\n        /* XXX: Remote storage doesn't play nicely with volumes backed by\n         * remote storage. To avoid trouble, just fake the backing store is RAW\n         * and put the string from the metadata as the path of the target. */\n        if (!virStorageSourceIsLocalStorage(target->backingStore)) {\n            virObjectUnref(target->backingStore);\n\n            if (!(target->backingStore = virStorageSourceNew()))\n                return -1;\n\n            target->backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n            target->backingStore->path = meta->backingStoreRaw;\n            meta->backingStoreRaw = NULL;\n            target->backingStore->format = VIR_STORAGE_FILE_RAW;\n        }\n\n        if (target->backingStore->format == VIR_STORAGE_FILE_AUTO) {\n            if ((rc = virStorageFileProbeFormat(target->backingStore->path,\n                                                -1, -1)) < 0) {\n                /* If the backing file is currently unavailable or is\n                 * accessed via remote protocol only log an error, fake the\n                 * format as RAW and continue. Returning -1 here would\n                 * disable the whole storage pool, making it unavailable for\n                 * even maintenance. */\n                target->backingStore->format = VIR_STORAGE_FILE_RAW;\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot probe backing volume format: %s\"),\n                               target->backingStore->path);\n            } else {\n                target->backingStore->format = rc;\n            }\n        }\n    }\n\n    target->format = meta->format;\n\n    /* Default to success below this point */\n    if (meta->capacity)\n        target->capacity = meta->capacity;\n\n    if (encryption && meta->encryption) {\n        if (meta->encryption->payload_offset != -1)\n            target->capacity -= meta->encryption->payload_offset * 512;\n\n        *encryption = meta->encryption;\n        meta->encryption = NULL;\n\n        /* XXX ideally we'd fill in secret UUID here\n         * but we cannot guarantee 'conn' is non-NULL\n         * at this point in time :-(  So we only fill\n         * in secrets when someone first queries a vol\n         */\n    }\n\n    virBitmapFree(target->features);\n    target->features = g_steal_pointer(&meta->features);\n\n    if (meta->compat) {\n        VIR_FREE(target->compat);\n        target->compat = g_steal_pointer(&meta->compat);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDeviceIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3304-3326",
    "snippet": "bool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\")",
            "devpath"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\""
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendPARTEDValidLabel",
          "args": [
            "devpath",
            "format",
            "writelabel"
          ],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendPARTEDValidLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3279-3285",
          "snippet": "static int\nvirStorageBackendPARTEDValidLabel(const char *device G_GNUC_UNUSED,\n                                  const char *format G_GNUC_UNUSED,\n                                  bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendPARTEDValidLabel(const char *device G_GNUC_UNUSED,\n                                  const char *format G_GNUC_UNUSED,\n                                  bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendBLKIDFindEmpty",
          "args": [
            "devpath",
            "format",
            "writelabel"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendBLKIDFindEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3121-3127",
          "snippet": "static int\nvirStorageBackendBLKIDFindEmpty(const char *device G_GNUC_UNUSED,\n                                const char *format G_GNUC_UNUSED,\n                                bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendBLKIDFindEmpty(const char *device G_GNUC_UNUSED,\n                                const char *format G_GNUC_UNUSED,\n                                bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}"
  },
  {
    "function_name": "virStorageBackendPARTEDValidLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3279-3285",
    "snippet": "static int\nvirStorageBackendPARTEDValidLabel(const char *device G_GNUC_UNUSED,\n                                  const char *format G_GNUC_UNUSED,\n                                  bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendPARTEDValidLabel(const char *device G_GNUC_UNUSED,\n                                  const char *format G_GNUC_UNUSED,\n                                  bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}"
  },
  {
    "function_name": "virStorageBackendPARTEDValidLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3223-3275",
    "snippet": "static int\nvirStorageBackendPARTEDValidLabel(const char *device,\n                                  const char *format,\n                                  bool writelabel)\n{\n    int ret = -1;\n    virStorageBackendPARTEDResult check;\n\n    check = virStorageBackendPARTEDFindLabel(device, format);\n    switch (check) {\n    case VIR_STORAGE_PARTED_ERROR:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Error checking for disk label, failed to get \"\n                         \"disk partition information\"));\n        break;\n\n    case VIR_STORAGE_PARTED_MATCH:\n        if (writelabel)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Disk label already formatted using '%s'\"),\n                           format);\n        else\n            ret = 0;\n        break;\n\n    case VIR_STORAGE_PARTED_DIFFERENT:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Known, but different label format present, \"\n                         \"requires build --overwrite\"));\n        break;\n\n    case VIR_STORAGE_PARTED_UNKNOWN:\n        if (writelabel)\n            ret = 0;\n        else\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unrecognized disk label found, requires build\"));\n        break;\n\n    case VIR_STORAGE_PARTED_NOPTTYPE:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to determine Partition Type, \"\n                         \"requires build --overwrite\"));\n        break;\n\n    case VIR_STORAGE_PARTED_PTTYPE_UNK:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unknown Partition Type, requires build --overwrite\"));\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Unknown Partition Type, requires build --overwrite\")"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown Partition Type, requires build --overwrite\""
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Unable to determine Partition Type, \"\n                         \"requires build --overwrite\")"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Unrecognized disk label found, requires build\")"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Known, but different label format present, \"\n                         \"requires build --overwrite\")"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Disk label already formatted using '%s'\")",
            "format"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Error checking for disk label, failed to get \"\n                         \"disk partition information\")"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendPARTEDFindLabel",
          "args": [
            "device",
            "format"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendPARTEDFindLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3149-3202",
          "snippet": "static virStorageBackendPARTEDResult\nvirStorageBackendPARTEDFindLabel(const char *device,\n                                 const char *format)\n{\n    const char *const args[] = {\n        device, \"print\", \"--script\", NULL,\n    };\n    char *start, *end;\n    int ret = VIR_STORAGE_PARTED_ERROR;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autofree char *error = NULL;\n\n    cmd = virCommandNew(PARTED);\n    virCommandAddArgSet(cmd, args);\n    virCommandAddEnvString(cmd, \"LC_ALL=C\");\n    virCommandSetOutputBuffer(cmd, &output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    /* if parted succeeds we have a valid partition table */\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        if ((output && strstr(output, \"unrecognised disk label\")) ||\n            (error && strstr(error, \"unrecognised disk label\"))) {\n            ret = VIR_STORAGE_PARTED_UNKNOWN;\n        }\n        return ret;\n    }\n\n    /* Search for \"Partition Table:\" in the output. If not present,\n     * then we cannot validate the partition table type.\n     */\n    if (!(start = strstr(output, \"Partition Table: \")) ||\n        !(end = strstr(start, \"\\n\"))) {\n        VIR_DEBUG(\"Unable to find tag in output: %s\", output);\n        return VIR_STORAGE_PARTED_NOPTTYPE;\n    }\n    start += strlen(\"Partition Table: \");\n    *end = '\\0';\n\n    /* on disk it's \"msdos\", but we document/use \"dos\" so deal with it here */\n    if (STREQ(start, \"msdos\"))\n        start += 2;\n\n    /* Make sure we know about this type */\n    if (virStoragePoolFormatDiskTypeFromString(start) < 0)\n        return VIR_STORAGE_PARTED_PTTYPE_UNK;\n\n    /*  Does the on disk match what the pool desired? */\n    if (STREQ(start, format))\n        return VIR_STORAGE_PARTED_MATCH;\n\n    return VIR_STORAGE_PARTED_DIFFERENT;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendPARTEDResult\nvirStorageBackendPARTEDFindLabel(const char *device,\n                                 const char *format)\n{\n    const char *const args[] = {\n        device, \"print\", \"--script\", NULL,\n    };\n    char *start, *end;\n    int ret = VIR_STORAGE_PARTED_ERROR;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autofree char *error = NULL;\n\n    cmd = virCommandNew(PARTED);\n    virCommandAddArgSet(cmd, args);\n    virCommandAddEnvString(cmd, \"LC_ALL=C\");\n    virCommandSetOutputBuffer(cmd, &output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    /* if parted succeeds we have a valid partition table */\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        if ((output && strstr(output, \"unrecognised disk label\")) ||\n            (error && strstr(error, \"unrecognised disk label\"))) {\n            ret = VIR_STORAGE_PARTED_UNKNOWN;\n        }\n        return ret;\n    }\n\n    /* Search for \"Partition Table:\" in the output. If not present,\n     * then we cannot validate the partition table type.\n     */\n    if (!(start = strstr(output, \"Partition Table: \")) ||\n        !(end = strstr(start, \"\\n\"))) {\n        VIR_DEBUG(\"Unable to find tag in output: %s\", output);\n        return VIR_STORAGE_PARTED_NOPTTYPE;\n    }\n    start += strlen(\"Partition Table: \");\n    *end = '\\0';\n\n    /* on disk it's \"msdos\", but we document/use \"dos\" so deal with it here */\n    if (STREQ(start, \"msdos\"))\n        start += 2;\n\n    /* Make sure we know about this type */\n    if (virStoragePoolFormatDiskTypeFromString(start) < 0)\n        return VIR_STORAGE_PARTED_PTTYPE_UNK;\n\n    /*  Does the on disk match what the pool desired? */\n    if (STREQ(start, format))\n        return VIR_STORAGE_PARTED_MATCH;\n\n    return VIR_STORAGE_PARTED_DIFFERENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendPARTEDValidLabel(const char *device,\n                                  const char *format,\n                                  bool writelabel)\n{\n    int ret = -1;\n    virStorageBackendPARTEDResult check;\n\n    check = virStorageBackendPARTEDFindLabel(device, format);\n    switch (check) {\n    case VIR_STORAGE_PARTED_ERROR:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Error checking for disk label, failed to get \"\n                         \"disk partition information\"));\n        break;\n\n    case VIR_STORAGE_PARTED_MATCH:\n        if (writelabel)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Disk label already formatted using '%s'\"),\n                           format);\n        else\n            ret = 0;\n        break;\n\n    case VIR_STORAGE_PARTED_DIFFERENT:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Known, but different label format present, \"\n                         \"requires build --overwrite\"));\n        break;\n\n    case VIR_STORAGE_PARTED_UNKNOWN:\n        if (writelabel)\n            ret = 0;\n        else\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unrecognized disk label found, requires build\"));\n        break;\n\n    case VIR_STORAGE_PARTED_NOPTTYPE:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to determine Partition Type, \"\n                         \"requires build --overwrite\"));\n        break;\n\n    case VIR_STORAGE_PARTED_PTTYPE_UNK:\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unknown Partition Type, requires build --overwrite\"));\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendPARTEDFindLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3149-3202",
    "snippet": "static virStorageBackendPARTEDResult\nvirStorageBackendPARTEDFindLabel(const char *device,\n                                 const char *format)\n{\n    const char *const args[] = {\n        device, \"print\", \"--script\", NULL,\n    };\n    char *start, *end;\n    int ret = VIR_STORAGE_PARTED_ERROR;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autofree char *error = NULL;\n\n    cmd = virCommandNew(PARTED);\n    virCommandAddArgSet(cmd, args);\n    virCommandAddEnvString(cmd, \"LC_ALL=C\");\n    virCommandSetOutputBuffer(cmd, &output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    /* if parted succeeds we have a valid partition table */\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        if ((output && strstr(output, \"unrecognised disk label\")) ||\n            (error && strstr(error, \"unrecognised disk label\"))) {\n            ret = VIR_STORAGE_PARTED_UNKNOWN;\n        }\n        return ret;\n    }\n\n    /* Search for \"Partition Table:\" in the output. If not present,\n     * then we cannot validate the partition table type.\n     */\n    if (!(start = strstr(output, \"Partition Table: \")) ||\n        !(end = strstr(start, \"\\n\"))) {\n        VIR_DEBUG(\"Unable to find tag in output: %s\", output);\n        return VIR_STORAGE_PARTED_NOPTTYPE;\n    }\n    start += strlen(\"Partition Table: \");\n    *end = '\\0';\n\n    /* on disk it's \"msdos\", but we document/use \"dos\" so deal with it here */\n    if (STREQ(start, \"msdos\"))\n        start += 2;\n\n    /* Make sure we know about this type */\n    if (virStoragePoolFormatDiskTypeFromString(start) < 0)\n        return VIR_STORAGE_PARTED_PTTYPE_UNK;\n\n    /*  Does the on disk match what the pool desired? */\n    if (STREQ(start, format))\n        return VIR_STORAGE_PARTED_MATCH;\n\n    return VIR_STORAGE_PARTED_DIFFERENT;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "start",
            "format"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatDiskTypeFromString",
          "args": [
            "start"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "start",
            "\"msdos\""
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"Partition Table: \""
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to find tag in output: %s\"",
            "output"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "start",
            "\"\\n\""
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "output",
            "\"Partition Table: \""
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "error",
            "\"unrecognised disk label\""
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "output",
            "\"unrecognised disk label\""
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorBuffer",
          "args": [
            "cmd",
            "&error"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1903-1918",
          "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&output"
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvString",
          "args": [
            "cmd",
            "\"LC_ALL=C\""
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1386-1397",
          "snippet": "void\nvirCommandAddEnvString(virCommandPtr cmd, const char *str)\n{\n    char *env;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    env = g_strdup(str);\n\n    virCommandAddEnv(cmd, env);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvString(virCommandPtr cmd, const char *str)\n{\n    char *env;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    env = g_strdup(str);\n\n    virCommandAddEnv(cmd, env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgSet",
          "args": [
            "cmd",
            "args"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1617-1646",
          "snippet": "void\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "PARTED"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendPARTEDResult\nvirStorageBackendPARTEDFindLabel(const char *device,\n                                 const char *format)\n{\n    const char *const args[] = {\n        device, \"print\", \"--script\", NULL,\n    };\n    char *start, *end;\n    int ret = VIR_STORAGE_PARTED_ERROR;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autofree char *error = NULL;\n\n    cmd = virCommandNew(PARTED);\n    virCommandAddArgSet(cmd, args);\n    virCommandAddEnvString(cmd, \"LC_ALL=C\");\n    virCommandSetOutputBuffer(cmd, &output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    /* if parted succeeds we have a valid partition table */\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        if ((output && strstr(output, \"unrecognised disk label\")) ||\n            (error && strstr(error, \"unrecognised disk label\"))) {\n            ret = VIR_STORAGE_PARTED_UNKNOWN;\n        }\n        return ret;\n    }\n\n    /* Search for \"Partition Table:\" in the output. If not present,\n     * then we cannot validate the partition table type.\n     */\n    if (!(start = strstr(output, \"Partition Table: \")) ||\n        !(end = strstr(start, \"\\n\"))) {\n        VIR_DEBUG(\"Unable to find tag in output: %s\", output);\n        return VIR_STORAGE_PARTED_NOPTTYPE;\n    }\n    start += strlen(\"Partition Table: \");\n    *end = '\\0';\n\n    /* on disk it's \"msdos\", but we document/use \"dos\" so deal with it here */\n    if (STREQ(start, \"msdos\"))\n        start += 2;\n\n    /* Make sure we know about this type */\n    if (virStoragePoolFormatDiskTypeFromString(start) < 0)\n        return VIR_STORAGE_PARTED_PTTYPE_UNK;\n\n    /*  Does the on disk match what the pool desired? */\n    if (STREQ(start, format))\n        return VIR_STORAGE_PARTED_MATCH;\n\n    return VIR_STORAGE_PARTED_DIFFERENT;\n}"
  },
  {
    "function_name": "virStorageBackendBLKIDFindEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3121-3127",
    "snippet": "static int\nvirStorageBackendBLKIDFindEmpty(const char *device G_GNUC_UNUSED,\n                                const char *format G_GNUC_UNUSED,\n                                bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendBLKIDFindEmpty(const char *device G_GNUC_UNUSED,\n                                const char *format G_GNUC_UNUSED,\n                                bool writelabel G_GNUC_UNUSED)\n{\n    return -2;\n}"
  },
  {
    "function_name": "virStorageBackendBLKIDFindEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "3034-3117",
    "snippet": "static int\nvirStorageBackendBLKIDFindEmpty(const char *device,\n                                const char *format,\n                                bool writelabel)\n{\n    int ret = -1;\n    int rc;\n    blkid_probe probe = NULL;\n\n    VIR_DEBUG(\"Probe for existing filesystem/partition format %s on device %s\",\n              format, device);\n\n    if (!(probe = blkid_new_probe_from_filename(device))) {\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                       _(\"Failed to create filesystem probe for device %s\"),\n                       device);\n        return -1;\n    }\n\n    /* Look for something on FS, if it either doesn't recognize the\n     * format type as a valid FS format type or it doesn't find a valid\n     * format type on the device, then perform the same check using\n     * partition probing. */\n    rc = virStorageBackendBLKIDFindFS(probe, device, format);\n    if (rc == VIR_STORAGE_BLKID_PROBE_UNDEFINED ||\n        rc == VIR_STORAGE_BLKID_PROBE_UNKNOWN) {\n\n        rc = virStorageBackendBLKIDFindPart(probe, device, format);\n    }\n\n    switch (rc) {\n    case VIR_STORAGE_BLKID_PROBE_UNDEFINED:\n        if (writelabel)\n            ret = 0;\n        else\n            virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                           _(\"Device '%s' is unrecognized, requires build\"),\n                           device);\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_ERROR:\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                       _(\"Failed to probe for format type '%s'\"), format);\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_UNKNOWN:\n        ret = -2;\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_MATCH:\n        if (writelabel)\n            virReportError(VIR_ERR_STORAGE_POOL_BUILT,\n                           _(\"Device '%s' already formatted using '%s'\"),\n                           device, format);\n        else\n            ret = 0;\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_DIFFERENT:\n        if (writelabel)\n            virReportError(VIR_ERR_STORAGE_POOL_BUILT,\n                           _(\"Format of device '%s' does not match the \"\n                             \"expected format '%s', forced overwrite is \"\n                             \"necessary\"),\n                           device, format);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Format of device '%s' does not match the \"\n                             \"expected format '%s'\"),\n                           device, format);\n        break;\n    }\n\n    if (ret == 0 && blkid_do_probe(probe) != 1) {\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED, \"%s\",\n                       _(\"Found additional probes to run, probing may \"\n                         \"be incorrect\"));\n        ret = -1;\n    }\n\n    blkid_free_probe(probe);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkid_free_probe",
          "args": [
            "probe"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_PROBE_FAILED",
            "\"%s\"",
            "_(\"Found additional probes to run, probing may \"\n                         \"be incorrect\")"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Found additional probes to run, probing may \"\n                         \"be incorrect\""
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkid_do_probe",
          "args": [
            "probe"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Format of device '%s' does not match the \"\n                             \"expected format '%s'\")",
            "device",
            "format"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_POOL_BUILT",
            "_(\"Format of device '%s' does not match the \"\n                             \"expected format '%s', forced overwrite is \"\n                             \"necessary\")",
            "device",
            "format"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_POOL_BUILT",
            "_(\"Device '%s' already formatted using '%s'\")",
            "device",
            "format"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_PROBE_FAILED",
            "_(\"Failed to probe for format type '%s'\")",
            "format"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_PROBE_FAILED",
            "_(\"Device '%s' is unrecognized, requires build\")",
            "device"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendBLKIDFindPart",
          "args": [
            "probe",
            "device",
            "format"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendBLKIDFindPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2981-3018",
          "snippet": "static virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindPart(blkid_probe probe,\n                               const char *device,\n                               const char *format)\n{\n    const char *pttype = NULL;\n\n    /* A blkid_known_pttype on \"dvh\" and \"pc98\" returns a failure;\n     * however, the blkid_do_probe for \"dvh\" returns \"sgi\" and\n     * for \"pc98\" it returns \"dos\". Although \"bsd\" is recognized,\n     * it seems that the parted created partition table is not being\n     * properly recogized. Since each of these will cause problems\n     * with startup comparison, let's just treat them as UNKNOWN causing\n     * the caller to fallback to using PARTED */\n    if (STREQ(format, \"dvh\") || STREQ(format, \"pc98\") || STREQ(format, \"bsd\"))\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    /* Make sure we're doing a partitions probe from the start */\n    blkid_probe_enable_partitions(probe, true);\n    blkid_probe_reset_partitions_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No partition found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"PTTYPE\", &pttype, NULL) == 0) {\n        if (STREQ(pttype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_pttype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindPart(blkid_probe probe,\n                               const char *device,\n                               const char *format)\n{\n    const char *pttype = NULL;\n\n    /* A blkid_known_pttype on \"dvh\" and \"pc98\" returns a failure;\n     * however, the blkid_do_probe for \"dvh\" returns \"sgi\" and\n     * for \"pc98\" it returns \"dos\". Although \"bsd\" is recognized,\n     * it seems that the parted created partition table is not being\n     * properly recogized. Since each of these will cause problems\n     * with startup comparison, let's just treat them as UNKNOWN causing\n     * the caller to fallback to using PARTED */\n    if (STREQ(format, \"dvh\") || STREQ(format, \"pc98\") || STREQ(format, \"bsd\"))\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    /* Make sure we're doing a partitions probe from the start */\n    blkid_probe_enable_partitions(probe, true);\n    blkid_probe_reset_partitions_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No partition found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"PTTYPE\", &pttype, NULL) == 0) {\n        if (STREQ(pttype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_pttype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendBLKIDFindFS",
          "args": [
            "probe",
            "device",
            "format"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendBLKIDFindFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2942-2969",
          "snippet": "static virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindFS(blkid_probe probe,\n                             const char *device,\n                             const char *format)\n{\n    const char *fstype = NULL;\n\n    /* Make sure we're doing a superblock probe from the start */\n    blkid_probe_enable_superblocks(probe, true);\n    blkid_probe_reset_superblocks_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No filesystem found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"TYPE\", &fstype, NULL) == 0) {\n        if (STREQ(fstype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_fstype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindFS(blkid_probe probe,\n                             const char *device,\n                             const char *format)\n{\n    const char *fstype = NULL;\n\n    /* Make sure we're doing a superblock probe from the start */\n    blkid_probe_enable_superblocks(probe, true);\n    blkid_probe_reset_superblocks_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No filesystem found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"TYPE\", &fstype, NULL) == 0) {\n        if (STREQ(fstype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_fstype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_STORAGE_PROBE_FAILED",
            "_(\"Failed to create filesystem probe for device %s\")",
            "device"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_new_probe_from_filename",
          "args": [
            "device"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Probe for existing filesystem/partition format %s on device %s\"",
            "format",
            "device"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendBLKIDFindEmpty(const char *device,\n                                const char *format,\n                                bool writelabel)\n{\n    int ret = -1;\n    int rc;\n    blkid_probe probe = NULL;\n\n    VIR_DEBUG(\"Probe for existing filesystem/partition format %s on device %s\",\n              format, device);\n\n    if (!(probe = blkid_new_probe_from_filename(device))) {\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                       _(\"Failed to create filesystem probe for device %s\"),\n                       device);\n        return -1;\n    }\n\n    /* Look for something on FS, if it either doesn't recognize the\n     * format type as a valid FS format type or it doesn't find a valid\n     * format type on the device, then perform the same check using\n     * partition probing. */\n    rc = virStorageBackendBLKIDFindFS(probe, device, format);\n    if (rc == VIR_STORAGE_BLKID_PROBE_UNDEFINED ||\n        rc == VIR_STORAGE_BLKID_PROBE_UNKNOWN) {\n\n        rc = virStorageBackendBLKIDFindPart(probe, device, format);\n    }\n\n    switch (rc) {\n    case VIR_STORAGE_BLKID_PROBE_UNDEFINED:\n        if (writelabel)\n            ret = 0;\n        else\n            virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                           _(\"Device '%s' is unrecognized, requires build\"),\n                           device);\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_ERROR:\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED,\n                       _(\"Failed to probe for format type '%s'\"), format);\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_UNKNOWN:\n        ret = -2;\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_MATCH:\n        if (writelabel)\n            virReportError(VIR_ERR_STORAGE_POOL_BUILT,\n                           _(\"Device '%s' already formatted using '%s'\"),\n                           device, format);\n        else\n            ret = 0;\n        break;\n\n    case VIR_STORAGE_BLKID_PROBE_DIFFERENT:\n        if (writelabel)\n            virReportError(VIR_ERR_STORAGE_POOL_BUILT,\n                           _(\"Format of device '%s' does not match the \"\n                             \"expected format '%s', forced overwrite is \"\n                             \"necessary\"),\n                           device, format);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Format of device '%s' does not match the \"\n                             \"expected format '%s'\"),\n                           device, format);\n        break;\n    }\n\n    if (ret == 0 && blkid_do_probe(probe) != 1) {\n        virReportError(VIR_ERR_STORAGE_PROBE_FAILED, \"%s\",\n                       _(\"Found additional probes to run, probing may \"\n                         \"be incorrect\"));\n        ret = -1;\n    }\n\n    blkid_free_probe(probe);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendBLKIDFindPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2981-3018",
    "snippet": "static virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindPart(blkid_probe probe,\n                               const char *device,\n                               const char *format)\n{\n    const char *pttype = NULL;\n\n    /* A blkid_known_pttype on \"dvh\" and \"pc98\" returns a failure;\n     * however, the blkid_do_probe for \"dvh\" returns \"sgi\" and\n     * for \"pc98\" it returns \"dos\". Although \"bsd\" is recognized,\n     * it seems that the parted created partition table is not being\n     * properly recogized. Since each of these will cause problems\n     * with startup comparison, let's just treat them as UNKNOWN causing\n     * the caller to fallback to using PARTED */\n    if (STREQ(format, \"dvh\") || STREQ(format, \"pc98\") || STREQ(format, \"bsd\"))\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    /* Make sure we're doing a partitions probe from the start */\n    blkid_probe_enable_partitions(probe, true);\n    blkid_probe_reset_partitions_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No partition found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"PTTYPE\", &pttype, NULL) == 0) {\n        if (STREQ(pttype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_pttype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkid_known_pttype",
          "args": [
            "format"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "pttype",
            "format"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_lookup_value",
          "args": [
            "probe",
            "\"PTTYPE\"",
            "&pttype",
            "NULL"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"No partition found on device '%s'\"",
            "device"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_do_probe",
          "args": [
            "probe"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_reset_partitions_filter",
          "args": [
            "probe"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_enable_partitions",
          "args": [
            "probe",
            "true"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "format",
            "\"bsd\""
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "format",
            "\"pc98\""
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "format",
            "\"dvh\""
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindPart(blkid_probe probe,\n                               const char *device,\n                               const char *format)\n{\n    const char *pttype = NULL;\n\n    /* A blkid_known_pttype on \"dvh\" and \"pc98\" returns a failure;\n     * however, the blkid_do_probe for \"dvh\" returns \"sgi\" and\n     * for \"pc98\" it returns \"dos\". Although \"bsd\" is recognized,\n     * it seems that the parted created partition table is not being\n     * properly recogized. Since each of these will cause problems\n     * with startup comparison, let's just treat them as UNKNOWN causing\n     * the caller to fallback to using PARTED */\n    if (STREQ(format, \"dvh\") || STREQ(format, \"pc98\") || STREQ(format, \"bsd\"))\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    /* Make sure we're doing a partitions probe from the start */\n    blkid_probe_enable_partitions(probe, true);\n    blkid_probe_reset_partitions_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No partition found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"PTTYPE\", &pttype, NULL) == 0) {\n        if (STREQ(pttype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_pttype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}"
  },
  {
    "function_name": "virStorageBackendBLKIDFindFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2942-2969",
    "snippet": "static virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindFS(blkid_probe probe,\n                             const char *device,\n                             const char *format)\n{\n    const char *fstype = NULL;\n\n    /* Make sure we're doing a superblock probe from the start */\n    blkid_probe_enable_superblocks(probe, true);\n    blkid_probe_reset_superblocks_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No filesystem found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"TYPE\", &fstype, NULL) == 0) {\n        if (STREQ(fstype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_fstype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkid_known_fstype",
          "args": [
            "format"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "fstype",
            "format"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_lookup_value",
          "args": [
            "probe",
            "\"TYPE\"",
            "&fstype",
            "NULL"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"No filesystem found on device '%s'\"",
            "device"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_do_probe",
          "args": [
            "probe"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_reset_superblocks_filter",
          "args": [
            "probe"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkid_probe_enable_superblocks",
          "args": [
            "probe",
            "true"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageBackendBLKIDProbeResult\nvirStorageBackendBLKIDFindFS(blkid_probe probe,\n                             const char *device,\n                             const char *format)\n{\n    const char *fstype = NULL;\n\n    /* Make sure we're doing a superblock probe from the start */\n    blkid_probe_enable_superblocks(probe, true);\n    blkid_probe_reset_superblocks_filter(probe);\n\n    if (blkid_do_probe(probe) != 0) {\n        VIR_INFO(\"No filesystem found on device '%s'\", device);\n        return VIR_STORAGE_BLKID_PROBE_UNDEFINED;\n    }\n\n    if (blkid_probe_lookup_value(probe, \"TYPE\", &fstype, NULL) == 0) {\n        if (STREQ(fstype, format))\n            return VIR_STORAGE_BLKID_PROBE_MATCH;\n\n        return VIR_STORAGE_BLKID_PROBE_DIFFERENT;\n    }\n\n    if (blkid_known_fstype(format) == 0)\n        return VIR_STORAGE_BLKID_PROBE_UNKNOWN;\n\n    return VIR_STORAGE_BLKID_PROBE_ERROR;\n}"
  },
  {
    "function_name": "virStorageBackendFindGlusterPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2883-2919",
    "snippet": "int\nvirStorageBackendFindGlusterPoolSources(const char *host,\n                                        virStoragePoolType pooltype,\n                                        virStoragePoolSourceListPtr list,\n                                        bool report)\n{\n    int rc;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *glusterpath = NULL;\n    g_autofree char *outbuf = NULL;\n\n    if (!(glusterpath = virFindFileInPath(\"gluster\"))) {\n        if (report) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'gluster' command line tool not found\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    cmd = virCommandNewArgList(glusterpath,\n                               \"--xml\",\n                               \"--log-file=/dev/null\",\n                               \"volume\", \"info\", \"all\", NULL);\n\n    virCommandAddArgFormat(cmd, \"--remote-host=%s\", host);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, &rc) < 0)\n        return -1;\n\n    if (rc != 0)\n        return 0;\n\n    return virStorageUtilGlusterExtractPoolSources(host, outbuf, list, pooltype);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageUtilGlusterExtractPoolSources",
          "args": [
            "host",
            "outbuf",
            "list",
            "pooltype"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageUtilGlusterExtractPoolSources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2806-2865",
          "snippet": "int\nvirStorageUtilGlusterExtractPoolSources(const char *host,\n                                        const char *xml,\n                                        virStoragePoolSourceListPtr list,\n                                        virStoragePoolType pooltype)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virStoragePoolSource *src = NULL;\n    size_t i;\n    int nnodes;\n    int ret = -1;\n    g_autofree xmlNodePtr *nodes = NULL;\n    g_autofree char *volname = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(gluster_cli_output)\"), &ctxt)))\n        goto cleanup;\n\n    if ((nnodes = virXPathNodeSet(\"//volumes/volume\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nnodes; i++) {\n        ctxt->node = nodes[i];\n\n        if (!(src = virStoragePoolSourceListNewSource(list)))\n            goto cleanup;\n\n        if (!(volname = virXPathString(\"string(./name)\", ctxt))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to extract gluster volume name\"));\n            goto cleanup;\n        }\n\n        if (pooltype == VIR_STORAGE_POOL_NETFS) {\n            src->format = VIR_STORAGE_POOL_NETFS_GLUSTERFS;\n            src->dir = g_steal_pointer(&volname);\n        } else if (pooltype == VIR_STORAGE_POOL_GLUSTER) {\n            src->dir = g_strdup(\"/\");\n            src->name = g_steal_pointer(&volname);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unsupported gluster lookup\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(src->hosts, 1) < 0)\n            goto cleanup;\n        src->nhost = 1;\n\n        src->hosts[0].name = g_strdup(host);\n    }\n\n    ret = nnodes;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageUtilGlusterExtractPoolSources(const char *host,\n                                        const char *xml,\n                                        virStoragePoolSourceListPtr list,\n                                        virStoragePoolType pooltype)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virStoragePoolSource *src = NULL;\n    size_t i;\n    int nnodes;\n    int ret = -1;\n    g_autofree xmlNodePtr *nodes = NULL;\n    g_autofree char *volname = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(gluster_cli_output)\"), &ctxt)))\n        goto cleanup;\n\n    if ((nnodes = virXPathNodeSet(\"//volumes/volume\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nnodes; i++) {\n        ctxt->node = nodes[i];\n\n        if (!(src = virStoragePoolSourceListNewSource(list)))\n            goto cleanup;\n\n        if (!(volname = virXPathString(\"string(./name)\", ctxt))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to extract gluster volume name\"));\n            goto cleanup;\n        }\n\n        if (pooltype == VIR_STORAGE_POOL_NETFS) {\n            src->format = VIR_STORAGE_POOL_NETFS_GLUSTERFS;\n            src->dir = g_steal_pointer(&volname);\n        } else if (pooltype == VIR_STORAGE_POOL_GLUSTER) {\n            src->dir = g_strdup(\"/\");\n            src->name = g_steal_pointer(&volname);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unsupported gluster lookup\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(src->hosts, 1) < 0)\n            goto cleanup;\n        src->nhost = 1;\n\n        src->hosts[0].name = g_strdup(host);\n    }\n\n    ret = nnodes;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&rc"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"--remote-host=%s\"",
            "host"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "glusterpath",
            "\"--xml\"",
            "\"--log-file=/dev/null\"",
            "\"volume\"",
            "\"info\"",
            "\"all\"",
            "NULL"
          ],
          "line": 2904
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"'gluster' command line tool not found\")"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"'gluster' command line tool not found\""
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"gluster\""
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendFindGlusterPoolSources(const char *host,\n                                        virStoragePoolType pooltype,\n                                        virStoragePoolSourceListPtr list,\n                                        bool report)\n{\n    int rc;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *glusterpath = NULL;\n    g_autofree char *outbuf = NULL;\n\n    if (!(glusterpath = virFindFileInPath(\"gluster\"))) {\n        if (report) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'gluster' command line tool not found\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    cmd = virCommandNewArgList(glusterpath,\n                               \"--xml\",\n                               \"--log-file=/dev/null\",\n                               \"volume\", \"info\", \"all\", NULL);\n\n    virCommandAddArgFormat(cmd, \"--remote-host=%s\", host);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, &rc) < 0)\n        return -1;\n\n    if (rc != 0)\n        return 0;\n\n    return virStorageUtilGlusterExtractPoolSources(host, outbuf, list, pooltype);\n}"
  },
  {
    "function_name": "virStorageUtilGlusterExtractPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2806-2865",
    "snippet": "int\nvirStorageUtilGlusterExtractPoolSources(const char *host,\n                                        const char *xml,\n                                        virStoragePoolSourceListPtr list,\n                                        virStoragePoolType pooltype)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virStoragePoolSource *src = NULL;\n    size_t i;\n    int nnodes;\n    int ret = -1;\n    g_autofree xmlNodePtr *nodes = NULL;\n    g_autofree char *volname = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(gluster_cli_output)\"), &ctxt)))\n        goto cleanup;\n\n    if ((nnodes = virXPathNodeSet(\"//volumes/volume\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nnodes; i++) {\n        ctxt->node = nodes[i];\n\n        if (!(src = virStoragePoolSourceListNewSource(list)))\n            goto cleanup;\n\n        if (!(volname = virXPathString(\"string(./name)\", ctxt))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to extract gluster volume name\"));\n            goto cleanup;\n        }\n\n        if (pooltype == VIR_STORAGE_POOL_NETFS) {\n            src->format = VIR_STORAGE_POOL_NETFS_GLUSTERFS;\n            src->dir = g_steal_pointer(&volname);\n        } else if (pooltype == VIR_STORAGE_POOL_GLUSTER) {\n            src->dir = g_strdup(\"/\");\n            src->name = g_steal_pointer(&volname);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unsupported gluster lookup\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(src->hosts, 1) < 0)\n            goto cleanup;\n        src->nhost = 1;\n\n        src->hosts[0].name = g_strdup(host);\n    }\n\n    ret = nnodes;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "host"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "src->hosts",
            "1"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unsupported gluster lookup\")"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&volname"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&volname"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to extract gluster volume name\")"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./name)\"",
            "ctxt"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceListNewSource",
          "args": [
            "list"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceListNewSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1729-1741",
          "snippet": "virStoragePoolSourcePtr\nvirStoragePoolSourceListNewSource(virStoragePoolSourceListPtr list)\n{\n    virStoragePoolSourcePtr source;\n\n    if (VIR_REALLOC_N(list->sources, list->nsources + 1) < 0)\n        return NULL;\n\n    source = &list->sources[list->nsources++];\n    memset(source, 0, sizeof(*source));\n\n    return source;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStoragePoolSourcePtr\nvirStoragePoolSourceListNewSource(virStoragePoolSourceListPtr list)\n{\n    virStoragePoolSourcePtr source;\n\n    if (VIR_REALLOC_N(list->sources, list->nsources + 1) < 0)\n        return NULL;\n\n    source = &list->sources[list->nsources++];\n    memset(source, 0, sizeof(*source));\n\n    return source;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"//volumes/volume\"",
            "ctxt",
            "&nodes"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xml",
            "_(\"(gluster_cli_output)\")",
            "&ctxt"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageUtilGlusterExtractPoolSources(const char *host,\n                                        const char *xml,\n                                        virStoragePoolSourceListPtr list,\n                                        virStoragePoolType pooltype)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virStoragePoolSource *src = NULL;\n    size_t i;\n    int nnodes;\n    int ret = -1;\n    g_autofree xmlNodePtr *nodes = NULL;\n    g_autofree char *volname = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(gluster_cli_output)\"), &ctxt)))\n        goto cleanup;\n\n    if ((nnodes = virXPathNodeSet(\"//volumes/volume\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nnodes; i++) {\n        ctxt->node = nodes[i];\n\n        if (!(src = virStoragePoolSourceListNewSource(list)))\n            goto cleanup;\n\n        if (!(volname = virXPathString(\"string(./name)\", ctxt))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to extract gluster volume name\"));\n            goto cleanup;\n        }\n\n        if (pooltype == VIR_STORAGE_POOL_NETFS) {\n            src->format = VIR_STORAGE_POOL_NETFS_GLUSTERFS;\n            src->dir = g_steal_pointer(&volname);\n        } else if (pooltype == VIR_STORAGE_POOL_GLUSTER) {\n            src->dir = g_strdup(\"/\");\n            src->name = g_steal_pointer(&volname);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unsupported gluster lookup\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(src->hosts, 1) < 0)\n            goto cleanup;\n        src->nhost = 1;\n\n        src->hosts[0].name = g_strdup(host);\n    }\n\n    ret = nnodes;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendDeleteLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2785-2803",
    "snippet": "int\nvirStorageBackendDeleteLocal(virStoragePoolObjPtr pool,\n                             unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    virCheckFlags(0, -1);\n\n    /* XXX delete all vols first ? */\n\n    if (rmdir(def->target.path) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to remove pool '%s'\"),\n                             def->target.path);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to remove pool '%s'\")",
            "def->target.path"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to remove pool '%s'\""
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "def->target.path"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendDeleteLocal(virStoragePoolObjPtr pool,\n                             unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    virCheckFlags(0, -1);\n\n    /* XXX delete all vols first ? */\n\n    if (rmdir(def->target.path) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to remove pool '%s'\"),\n                             def->target.path);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendBuildLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2727-2774",
    "snippet": "int\nvirStorageBackendBuildLocal(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *p = NULL;\n    mode_t mode;\n    bool needs_create_as_uid;\n    unsigned int dir_create_flags;\n    g_autofree char *parent = NULL;\n\n    parent = g_strdup(def->target.path);\n    if (!(p = strrchr(parent, '/'))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"path '%s' is not absolute\"),\n                       def->target.path);\n        return -1;\n    }\n\n    if (p != parent) {\n        /* assure all directories in the path prior to the final dir\n         * exist, with default uid/gid/mode. */\n        *p = '\\0';\n        if (virFileMakePath(parent) < 0) {\n            virReportSystemError(errno, _(\"cannot create path '%s'\"),\n                                 parent);\n            return -1;\n        }\n    }\n\n    dir_create_flags = VIR_DIR_CREATE_ALLOW_EXIST;\n    needs_create_as_uid = (def->type == VIR_STORAGE_POOL_NETFS);\n    mode = def->target.perms.mode;\n\n    if (mode == (mode_t)-1 &&\n        (needs_create_as_uid || !virFileExists(def->target.path)))\n        mode = VIR_STORAGE_DEFAULT_POOL_PERM_MODE;\n    if (needs_create_as_uid)\n        dir_create_flags |= VIR_DIR_CREATE_AS_UID;\n\n    /* Now create the final dir in the path with the uid/gid/mode\n     * requested in the config. If the dir already exists, just set\n     * the perms. */\n    return virDirCreate(def->target.path,\n                        mode,\n                        def->target.perms.uid,\n                        def->target.perms.gid,\n                        dir_create_flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDirCreate",
          "args": [
            "def->target.path",
            "mode",
            "def->target.perms.uid",
            "def->target.perms.gid",
            "dir_create_flags"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "virDirCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2831-2842",
          "snippet": "int\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->target.path"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create path '%s'\")",
            "parent"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create path '%s'\""
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "parent"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"path '%s' is not absolute\")",
            "def->target.path"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "parent",
            "'/'"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendBuildLocal(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *p = NULL;\n    mode_t mode;\n    bool needs_create_as_uid;\n    unsigned int dir_create_flags;\n    g_autofree char *parent = NULL;\n\n    parent = g_strdup(def->target.path);\n    if (!(p = strrchr(parent, '/'))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"path '%s' is not absolute\"),\n                       def->target.path);\n        return -1;\n    }\n\n    if (p != parent) {\n        /* assure all directories in the path prior to the final dir\n         * exist, with default uid/gid/mode. */\n        *p = '\\0';\n        if (virFileMakePath(parent) < 0) {\n            virReportSystemError(errno, _(\"cannot create path '%s'\"),\n                                 parent);\n            return -1;\n        }\n    }\n\n    dir_create_flags = VIR_DIR_CREATE_ALLOW_EXIST;\n    needs_create_as_uid = (def->type == VIR_STORAGE_POOL_NETFS);\n    mode = def->target.perms.mode;\n\n    if (mode == (mode_t)-1 &&\n        (needs_create_as_uid || !virFileExists(def->target.path)))\n        mode = VIR_STORAGE_DEFAULT_POOL_PERM_MODE;\n    if (needs_create_as_uid)\n        dir_create_flags |= VIR_DIR_CREATE_AS_UID;\n\n    /* Now create the final dir in the path with the uid/gid/mode\n     * requested in the config. If the dir already exists, just set\n     * the perms. */\n    return virDirCreate(def->target.path,\n                        mode,\n                        def->target.perms.uid,\n                        def->target.perms.gid,\n                        dir_create_flags);\n}"
  },
  {
    "function_name": "virStorageBackendVolWipeLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2695-2716",
    "snippet": "int\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendVolWipeLocalFile",
          "args": [
            "vol->target.path",
            "algorithm",
            "vol->target.allocation",
            "false"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolWipeLocalFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2568-2647",
          "snippet": "static int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendVolWipePloop",
          "args": [
            "vol",
            "algorithm"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolWipePloop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2650-2692",
          "snippet": "static int\nstorageBackendVolWipePloop(virStorageVolDefPtr vol,\n                           unsigned int algorithm)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *target_path = NULL;\n    g_autofree char *disk_desc = NULL;\n    g_autofree char *create_tool = NULL;\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop tools, please install them\"));\n        return -1;\n    }\n\n    target_path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n\n    disk_desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", vol->target.path);\n\n    if (storageBackendVolWipeLocalFile(target_path, algorithm,\n                                       vol->target.allocation, false) < 0)\n        return -1;\n\n    if (virFileRemove(disk_desc, 0, 0) < 0) {\n        virReportError(errno, _(\"Failed to delete DiskDescriptor.xml of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n    if (virFileRemove(target_path, 0, 0) < 0) {\n        virReportError(errno, _(\"failed to delete root.hds of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                    (1024 * 1024)));\n    virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n    virCommandAddArg(cmd, target_path);\n    return virCommandRun(cmd, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipePloop(virStorageVolDefPtr vol,\n                           unsigned int algorithm)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *target_path = NULL;\n    g_autofree char *disk_desc = NULL;\n    g_autofree char *create_tool = NULL;\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop tools, please install them\"));\n        return -1;\n    }\n\n    target_path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n\n    disk_desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", vol->target.path);\n\n    if (storageBackendVolWipeLocalFile(target_path, algorithm,\n                                       vol->target.allocation, false) < 0)\n        return -1;\n\n    if (virFileRemove(disk_desc, 0, 0) < 0) {\n        virReportError(errno, _(\"Failed to delete DiskDescriptor.xml of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n    if (virFileRemove(target_path, 0, 0) < 0) {\n        virReportError(errno, _(\"failed to delete root.hds of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                    (1024 * 1024)));\n    virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n    virCommandAddArg(cmd, target_path);\n    return virCommandRun(cmd, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Wiping volume with path '%s' and algorithm %u\"",
            "vol->target.path",
            "algorithm"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "storageBackendVolWipePloop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2650-2692",
    "snippet": "static int\nstorageBackendVolWipePloop(virStorageVolDefPtr vol,\n                           unsigned int algorithm)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *target_path = NULL;\n    g_autofree char *disk_desc = NULL;\n    g_autofree char *create_tool = NULL;\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop tools, please install them\"));\n        return -1;\n    }\n\n    target_path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n\n    disk_desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", vol->target.path);\n\n    if (storageBackendVolWipeLocalFile(target_path, algorithm,\n                                       vol->target.allocation, false) < 0)\n        return -1;\n\n    if (virFileRemove(disk_desc, 0, 0) < 0) {\n        virReportError(errno, _(\"Failed to delete DiskDescriptor.xml of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n    if (virFileRemove(target_path, 0, 0) < 0) {\n        virReportError(errno, _(\"failed to delete root.hds of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                    (1024 * 1024)));\n    virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n    virCommandAddArg(cmd, target_path);\n    return virCommandRun(cmd, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "target_path"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%lluM\"",
            "VIR_DIV_UP(vol->target.capacity,\n                                                    (1024 * 1024))"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "vol->target.capacity",
            "(1024 * 1024)"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "create_tool",
            "\"init\"",
            "\"-s\"",
            "NULL"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errno",
            "_(\"failed to delete root.hds of volume '%s'\")",
            "vol->target.path"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to delete root.hds of volume '%s'\""
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "target_path",
            "0",
            "0"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errno",
            "_(\"Failed to delete DiskDescriptor.xml of volume '%s'\")",
            "vol->target.path"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendVolWipeLocalFile",
          "args": [
            "target_path",
            "algorithm",
            "vol->target.allocation",
            "false"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolWipeLocalFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2568-2647",
          "snippet": "static int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to find ploop tools, please install them\")"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"ploop\""
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipePloop(virStorageVolDefPtr vol,\n                           unsigned int algorithm)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *target_path = NULL;\n    g_autofree char *disk_desc = NULL;\n    g_autofree char *create_tool = NULL;\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop tools, please install them\"));\n        return -1;\n    }\n\n    target_path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n\n    disk_desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", vol->target.path);\n\n    if (storageBackendVolWipeLocalFile(target_path, algorithm,\n                                       vol->target.allocation, false) < 0)\n        return -1;\n\n    if (virFileRemove(disk_desc, 0, 0) < 0) {\n        virReportError(errno, _(\"Failed to delete DiskDescriptor.xml of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n    if (virFileRemove(target_path, 0, 0) < 0) {\n        virReportError(errno, _(\"failed to delete root.hds of volume '%s'\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                    (1024 * 1024)));\n    virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n    virCommandAddArg(cmd, target_path);\n    return virCommandRun(cmd, NULL);\n}"
  },
  {
    "function_name": "storageBackendVolWipeLocalFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2568-2647",
    "snippet": "static int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendWipeLocal",
          "args": [
            "path",
            "fd",
            "allocation",
            "st.st_blksize",
            "zero_end"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendWipeLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2502-2565",
          "snippet": "static int\nstorageBackendWipeLocal(const char *path,\n                        int fd,\n                        unsigned long long wipe_len,\n                        size_t writebuf_length,\n                        bool zero_end)\n{\n    int written = 0;\n    unsigned long long remaining = 0;\n    off_t size;\n    size_t write_size = 0;\n    g_autofree char *writebuf = NULL;\n\n    if (VIR_ALLOC_N(writebuf, writebuf_length) < 0)\n        return -1;\n\n    if (!zero_end) {\n        if ((size = lseek(fd, 0, SEEK_SET)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to the start in volume \"\n                                   \"with path '%s'\"),\n                                 path);\n            return -1;\n        }\n    } else {\n        if ((size = lseek(fd, -wipe_len, SEEK_END)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to %llu bytes to the end \"\n                                   \"in volume with path '%s'\"),\n                                 wipe_len, path);\n            return -1;\n        }\n    }\n\n    VIR_DEBUG(\"wiping start: %zd len: %llu\", (ssize_t)size, wipe_len);\n\n    remaining = wipe_len;\n    while (remaining > 0) {\n\n        write_size = (writebuf_length < remaining) ? writebuf_length : remaining;\n        written = safewrite(fd, writebuf, write_size);\n        if (written < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to write %zu bytes to \"\n                                   \"storage volume with path '%s'\"),\n                                 write_size, path);\n\n            return -1;\n        }\n\n        remaining -= written;\n    }\n\n    if (virFileDataSync(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot sync data to volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wrote %llu bytes to volume with path '%s'\", wipe_len, path);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendWipeLocal(const char *path,\n                        int fd,\n                        unsigned long long wipe_len,\n                        size_t writebuf_length,\n                        bool zero_end)\n{\n    int written = 0;\n    unsigned long long remaining = 0;\n    off_t size;\n    size_t write_size = 0;\n    g_autofree char *writebuf = NULL;\n\n    if (VIR_ALLOC_N(writebuf, writebuf_length) < 0)\n        return -1;\n\n    if (!zero_end) {\n        if ((size = lseek(fd, 0, SEEK_SET)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to the start in volume \"\n                                   \"with path '%s'\"),\n                                 path);\n            return -1;\n        }\n    } else {\n        if ((size = lseek(fd, -wipe_len, SEEK_END)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to %llu bytes to the end \"\n                                   \"in volume with path '%s'\"),\n                                 wipe_len, path);\n            return -1;\n        }\n    }\n\n    VIR_DEBUG(\"wiping start: %zd len: %llu\", (ssize_t)size, wipe_len);\n\n    remaining = wipe_len;\n    while (remaining > 0) {\n\n        write_size = (writebuf_length < remaining) ? writebuf_length : remaining;\n        written = safewrite(fd, writebuf, write_size);\n        if (written < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to write %zu bytes to \"\n                                   \"storage volume with path '%s'\"),\n                                 write_size, path);\n\n            return -1;\n        }\n\n        remaining -= written;\n    }\n\n    if (virFileDataSync(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot sync data to volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wrote %llu bytes to volume with path '%s'\", wipe_len, path);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendVolZeroSparseFileLocal",
          "args": [
            "path",
            "st.st_size",
            "fd"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolZeroSparseFileLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2477-2499",
          "snippet": "static int\nstorageBackendVolZeroSparseFileLocal(const char *path,\n                                     off_t size,\n                                     int fd)\n{\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to 0 bytes\"),\n                             path);\n        return -1;\n    }\n\n    if (ftruncate(fd, size) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\"),\n                             path, (uintmax_t)size);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolZeroSparseFileLocal(const char *path,\n                                     off_t size,\n                                     int fd)\n{\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to 0 bytes\"),\n                             path);\n        return -1;\n    }\n\n    if (ftruncate(fd, size) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\"),\n                             path, (uintmax_t)size);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-f\"",
            "\"-p\"",
            "alg_char",
            "path",
            "NULL"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "SCRUB"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Wiping file '%s' with algorithm '%s'\"",
            "path",
            "alg_char"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported algorithm %d\")",
            "algorithm"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported algorithm %d\""
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"'trim' algorithm not supported\")"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to stat storage volume with path '%s'\")",
            "path"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open storage volume with path '%s'\")",
            "path"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDWR"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolWipeLocalFile(const char *path,\n                               unsigned int algorithm,\n                               unsigned long long allocation,\n                               bool zero_end)\n{\n    const char *alg_char = NULL;\n    struct stat st;\n    VIR_AUTOCLOSE fd = -1;\n    g_autoptr(virCommand) cmd = NULL;\n\n    fd = open(path, O_RDWR);\n    if (fd == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to open storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno,\n                             _(\"Failed to stat storage volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        alg_char = \"zero\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n        alg_char = \"nnsa\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n        alg_char = \"dod\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n        alg_char = \"bsi\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n        alg_char = \"gutmann\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n        alg_char = \"schneier\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n        alg_char = \"pfitzner7\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n        alg_char = \"pfitzner33\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n        alg_char = \"random\";\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"'trim' algorithm not supported\"));\n        return -1;\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported algorithm %d\"),\n                       algorithm);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wiping file '%s' with algorithm '%s'\", path, alg_char);\n\n    if (algorithm != VIR_STORAGE_VOL_WIPE_ALG_ZERO) {\n        cmd = virCommandNew(SCRUB);\n        virCommandAddArgList(cmd, \"-f\", \"-p\", alg_char, path, NULL);\n\n        return virCommandRun(cmd, NULL);\n    }\n\n    if (S_ISREG(st.st_mode) && st.st_blocks < (st.st_size / DEV_BSIZE))\n        return storageBackendVolZeroSparseFileLocal(path, st.st_size, fd);\n\n    return storageBackendWipeLocal(path, fd, allocation, st.st_blksize,\n                                   zero_end);\n}"
  },
  {
    "function_name": "storageBackendWipeLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2502-2565",
    "snippet": "static int\nstorageBackendWipeLocal(const char *path,\n                        int fd,\n                        unsigned long long wipe_len,\n                        size_t writebuf_length,\n                        bool zero_end)\n{\n    int written = 0;\n    unsigned long long remaining = 0;\n    off_t size;\n    size_t write_size = 0;\n    g_autofree char *writebuf = NULL;\n\n    if (VIR_ALLOC_N(writebuf, writebuf_length) < 0)\n        return -1;\n\n    if (!zero_end) {\n        if ((size = lseek(fd, 0, SEEK_SET)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to the start in volume \"\n                                   \"with path '%s'\"),\n                                 path);\n            return -1;\n        }\n    } else {\n        if ((size = lseek(fd, -wipe_len, SEEK_END)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to %llu bytes to the end \"\n                                   \"in volume with path '%s'\"),\n                                 wipe_len, path);\n            return -1;\n        }\n    }\n\n    VIR_DEBUG(\"wiping start: %zd len: %llu\", (ssize_t)size, wipe_len);\n\n    remaining = wipe_len;\n    while (remaining > 0) {\n\n        write_size = (writebuf_length < remaining) ? writebuf_length : remaining;\n        written = safewrite(fd, writebuf, write_size);\n        if (written < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to write %zu bytes to \"\n                                   \"storage volume with path '%s'\"),\n                                 write_size, path);\n\n            return -1;\n        }\n\n        remaining -= written;\n    }\n\n    if (virFileDataSync(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot sync data to volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wrote %llu bytes to volume with path '%s'\", wipe_len, path);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Wrote %llu bytes to volume with path '%s'\"",
            "wipe_len",
            "path"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot sync data to volume with path '%s'\")",
            "path"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot sync data to volume with path '%s'\""
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileDataSync",
          "args": [
            "fd"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "virFileDataSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4498-4506",
          "snippet": "int\nvirFileDataSync(int fd)\n{\n#if defined(__APPLE__) || defined(WIN32)\n    return g_fsync(fd);\n#else\n    return fdatasync(fd);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileDataSync(int fd)\n{\n#if defined(__APPLE__) || defined(WIN32)\n    return g_fsync(fd);\n#else\n    return fdatasync(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to write %zu bytes to \"\n                                   \"storage volume with path '%s'\")",
            "write_size",
            "path"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "writebuf",
            "write_size"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"wiping start: %zd len: %llu\"",
            "(ssize_t)size",
            "wipe_len"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to seek to %llu bytes to the end \"\n                                   \"in volume with path '%s'\")",
            "wipe_len",
            "path"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "-wipe_len",
            "SEEK_END"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to seek to the start in volume \"\n                                   \"with path '%s'\")",
            "path"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "writebuf",
            "writebuf_length"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendWipeLocal(const char *path,\n                        int fd,\n                        unsigned long long wipe_len,\n                        size_t writebuf_length,\n                        bool zero_end)\n{\n    int written = 0;\n    unsigned long long remaining = 0;\n    off_t size;\n    size_t write_size = 0;\n    g_autofree char *writebuf = NULL;\n\n    if (VIR_ALLOC_N(writebuf, writebuf_length) < 0)\n        return -1;\n\n    if (!zero_end) {\n        if ((size = lseek(fd, 0, SEEK_SET)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to the start in volume \"\n                                   \"with path '%s'\"),\n                                 path);\n            return -1;\n        }\n    } else {\n        if ((size = lseek(fd, -wipe_len, SEEK_END)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to seek to %llu bytes to the end \"\n                                   \"in volume with path '%s'\"),\n                                 wipe_len, path);\n            return -1;\n        }\n    }\n\n    VIR_DEBUG(\"wiping start: %zd len: %llu\", (ssize_t)size, wipe_len);\n\n    remaining = wipe_len;\n    while (remaining > 0) {\n\n        write_size = (writebuf_length < remaining) ? writebuf_length : remaining;\n        written = safewrite(fd, writebuf, write_size);\n        if (written < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to write %zu bytes to \"\n                                   \"storage volume with path '%s'\"),\n                                 write_size, path);\n\n            return -1;\n        }\n\n        remaining -= written;\n    }\n\n    if (virFileDataSync(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot sync data to volume with path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wrote %llu bytes to volume with path '%s'\", wipe_len, path);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendVolZeroSparseFileLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2477-2499",
    "snippet": "static int\nstorageBackendVolZeroSparseFileLocal(const char *path,\n                                     off_t size,\n                                     int fd)\n{\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to 0 bytes\"),\n                             path);\n        return -1;\n    }\n\n    if (ftruncate(fd, size) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\"),\n                             path, (uintmax_t)size);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\")",
            "path",
            "(uintmax_t)size"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\""
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "size"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to truncate volume with \"\n                               \"path '%s' to 0 bytes\")",
            "path"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "0"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolZeroSparseFileLocal(const char *path,\n                                     off_t size,\n                                     int fd)\n{\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to 0 bytes\"),\n                             path);\n        return -1;\n    }\n\n    if (ftruncate(fd, size) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate volume with \"\n                               \"path '%s' to %ju bytes\"),\n                             path, (uintmax_t)size);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendVolDownloadLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2430-2460",
    "snippet": "int\nvirStorageBackendVolDownloadLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  virStreamPtr stream,\n                                  unsigned long long offset,\n                                  unsigned long long len,\n                                  unsigned int flags)\n{\n    char *target_path = vol->target.path;\n    int has_snap = 0;\n    bool sparse = flags & VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM;\n    g_autofree char *path = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM, -1);\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        has_snap = storageBackendPloopHasSnapshots(vol->target.path);\n        if (has_snap < 0) {\n            return -1;\n        } else if (!has_snap) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"can't download volume, all existing snapshots\"\n                             \" will be lost\"));\n            return -1;\n        }\n        path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n        target_path = path;\n    }\n\n    return virFDStreamOpenBlockDevice(stream, target_path,\n                                      offset, len, sparse, O_RDONLY);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenBlockDevice",
          "args": [
            "stream",
            "target_path",
            "offset",
            "len",
            "sparse",
            "O_RDONLY"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenBlockDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1486-1497",
          "snippet": "int\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/root.hds\"",
            "vol->target.path"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"can't download volume, all existing snapshots\"\n                             \" will be lost\")"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendPloopHasSnapshots",
          "args": [
            "vol->target.path"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendPloopHasSnapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2361-2387",
          "snippet": "static int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM",
            "-1"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolDownloadLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  virStreamPtr stream,\n                                  unsigned long long offset,\n                                  unsigned long long len,\n                                  unsigned int flags)\n{\n    char *target_path = vol->target.path;\n    int has_snap = 0;\n    bool sparse = flags & VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM;\n    g_autofree char *path = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM, -1);\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        has_snap = storageBackendPloopHasSnapshots(vol->target.path);\n        if (has_snap < 0) {\n            return -1;\n        } else if (!has_snap) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"can't download volume, all existing snapshots\"\n                             \" will be lost\"));\n            return -1;\n        }\n        path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n        target_path = path;\n    }\n\n    return virFDStreamOpenBlockDevice(stream, target_path,\n                                      offset, len, sparse, O_RDONLY);\n}"
  },
  {
    "function_name": "virStorageBackendVolUploadLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2390-2428",
    "snippet": "int\nvirStorageBackendVolUploadLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                virStorageVolDefPtr vol,\n                                virStreamPtr stream,\n                                unsigned long long offset,\n                                unsigned long long len,\n                                unsigned int flags)\n{\n    char *target_path = vol->target.path;\n    int has_snap = 0;\n    bool sparse = flags & VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM;\n    g_autofree char *path = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM, -1);\n    /* if volume has target format VIR_STORAGE_FILE_PLOOP\n     * we need to restore DiskDescriptor.xml, according to\n     * new contents of volume. This operation will be perfomed\n     * when volUpload is fully finished. */\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        /* Fail if the volume contains snapshots or we failed to check it.*/\n        has_snap = storageBackendPloopHasSnapshots(vol->target.path);\n        if (has_snap < 0) {\n            return -1;\n        } else if (!has_snap) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"can't upload volume, all existing snapshots\"\n                             \" will be lost\"));\n            return -1;\n        }\n\n        path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n        target_path = path;\n    }\n\n    /* Not using O_CREAT because the file is required to already exist at\n     * this point */\n    return virFDStreamOpenBlockDevice(stream, target_path,\n                                      offset, len, sparse, O_WRONLY);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenBlockDevice",
          "args": [
            "stream",
            "target_path",
            "offset",
            "len",
            "sparse",
            "O_WRONLY"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenBlockDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1486-1497",
          "snippet": "int\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/root.hds\"",
            "vol->target.path"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"can't upload volume, all existing snapshots\"\n                             \" will be lost\")"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendPloopHasSnapshots",
          "args": [
            "vol->target.path"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendPloopHasSnapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2361-2387",
          "snippet": "static int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM",
            "-1"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolUploadLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                virStorageVolDefPtr vol,\n                                virStreamPtr stream,\n                                unsigned long long offset,\n                                unsigned long long len,\n                                unsigned int flags)\n{\n    char *target_path = vol->target.path;\n    int has_snap = 0;\n    bool sparse = flags & VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM;\n    g_autofree char *path = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM, -1);\n    /* if volume has target format VIR_STORAGE_FILE_PLOOP\n     * we need to restore DiskDescriptor.xml, according to\n     * new contents of volume. This operation will be perfomed\n     * when volUpload is fully finished. */\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        /* Fail if the volume contains snapshots or we failed to check it.*/\n        has_snap = storageBackendPloopHasSnapshots(vol->target.path);\n        if (has_snap < 0) {\n            return -1;\n        } else if (!has_snap) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"can't upload volume, all existing snapshots\"\n                             \" will be lost\"));\n            return -1;\n        }\n\n        path = g_strdup_printf(\"%s/root.hds\", vol->target.path);\n        target_path = path;\n    }\n\n    /* Not using O_CREAT because the file is required to already exist at\n     * this point */\n    return virFDStreamOpenBlockDevice(stream, target_path,\n                                      offset, len, sparse, O_WRONLY);\n}"
  },
  {
    "function_name": "storageBackendPloopHasSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2361-2387",
    "snippet": "static int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "output",
            "\"root.hds.\""
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&output"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s/DiskDescriptor.xml\"",
            "path"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "snap_tool",
            "\"snapshot-list\"",
            "NULL"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to find ploop, please install \"\n                               \"ploop tools\")"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to find ploop, please install \"\n                               \"ploop tools\""
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"ploop\""
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendPloopHasSnapshots(char *path)\n{\n    char *snap_tool = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n\n    snap_tool = virFindFileInPath(\"ploop\");\n    if (!snap_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(snap_tool, \"snapshot-list\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", path);\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    if (!strstr(output, \"root.hds.\"))\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendVolResizeLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2318-2352",
    "snippet": "int\nvirStorageBackendVolResizeLocal(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                unsigned long long capacity,\n                                unsigned int flags)\n{\n    bool pre_allocate = flags & VIR_STORAGE_VOL_RESIZE_ALLOCATE;\n\n    virCheckFlags(VIR_STORAGE_VOL_RESIZE_ALLOCATE |\n                  VIR_STORAGE_VOL_RESIZE_SHRINK, -1);\n\n    if (vol->target.format == VIR_STORAGE_FILE_RAW && !vol->target.encryption) {\n        return virStorageFileResize(vol->target.path, capacity, pre_allocate);\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (pre_allocate) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"preallocate is only supported for an \"\n                             \"unencrypted raw volume\"));\n            return -1;\n        }\n\n        return storageBackendResizeQemuImg(pool, vol, capacity);\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        return storagePloopResize(vol, capacity);\n    } else {\n        if (pre_allocate) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"preallocate is only supported for raw \"\n                             \"type volume\"));\n            return -1;\n        }\n\n        return storageBackendResizeQemuImg(pool, vol, capacity);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendResizeQemuImg",
          "args": [
            "pool",
            "vol",
            "capacity"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendResizeQemuImg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2238-2312",
          "snippet": "static int\nstorageBackendResizeQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            unsigned long long capacity)\n{\n    int ret = -1;\n    const char *type;\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *img_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *secretAlias = NULL;\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"resize of qcow2 encrypted image is not supported\"));\n        return -1;\n    }\n\n    img_tool = virFindFileInPath(\"qemu-img\");\n    if (!img_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find qemu-img\"));\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        if (vol->target.format == VIR_STORAGE_FILE_RAW)\n            type = \"luks\";\n        else\n            type = virStorageFileFormatTypeToString(vol->target.format);\n\n        storageBackendLoadDefaultSecrets(vol);\n\n        if (storageBackendCreateQemuImgCheckEncryption(vol->target.format,\n                                                       type, vol) < 0)\n            goto cleanup;\n\n        if (!(secretPath =\n              storageBackendCreateQemuImgSecretPath(pool, vol)))\n            goto cleanup;\n\n        secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n    }\n\n    /* Round capacity as qemu-img resize errors out on sizes which are not\n     * a multiple of 512 */\n    capacity = VIR_ROUND_UP(capacity, 512);\n\n    cmd = virCommandNewArgList(img_tool, \"resize\", NULL);\n    if (capacity < vol->target.capacity)\n        virCommandAddArg(cmd, \"--shrink\");\n    if (!vol->target.encryption) {\n        virCommandAddArg(cmd, vol->target.path);\n    } else {\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    secretAlias) < 0)\n            goto cleanup;\n\n        if (storageBackendResizeQemuImgImageOpts(cmd, vol->target.path,\n                                                 secretAlias) < 0)\n            goto cleanup;\n    }\n    virCommandAddArgFormat(cmd, \"%llu\", capacity);\n\n    ret = virCommandRun(cmd, NULL);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendResizeQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            unsigned long long capacity)\n{\n    int ret = -1;\n    const char *type;\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *img_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *secretAlias = NULL;\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"resize of qcow2 encrypted image is not supported\"));\n        return -1;\n    }\n\n    img_tool = virFindFileInPath(\"qemu-img\");\n    if (!img_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find qemu-img\"));\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        if (vol->target.format == VIR_STORAGE_FILE_RAW)\n            type = \"luks\";\n        else\n            type = virStorageFileFormatTypeToString(vol->target.format);\n\n        storageBackendLoadDefaultSecrets(vol);\n\n        if (storageBackendCreateQemuImgCheckEncryption(vol->target.format,\n                                                       type, vol) < 0)\n            goto cleanup;\n\n        if (!(secretPath =\n              storageBackendCreateQemuImgSecretPath(pool, vol)))\n            goto cleanup;\n\n        secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n    }\n\n    /* Round capacity as qemu-img resize errors out on sizes which are not\n     * a multiple of 512 */\n    capacity = VIR_ROUND_UP(capacity, 512);\n\n    cmd = virCommandNewArgList(img_tool, \"resize\", NULL);\n    if (capacity < vol->target.capacity)\n        virCommandAddArg(cmd, \"--shrink\");\n    if (!vol->target.encryption) {\n        virCommandAddArg(cmd, vol->target.path);\n    } else {\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    secretAlias) < 0)\n            goto cleanup;\n\n        if (storageBackendResizeQemuImgImageOpts(cmd, vol->target.path,\n                                                 secretAlias) < 0)\n            goto cleanup;\n    }\n    virCommandAddArgFormat(cmd, \"%llu\", capacity);\n\n    ret = virCommandRun(cmd, NULL);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"preallocate is only supported for raw \"\n                             \"type volume\")"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"preallocate is only supported for raw \"\n                             \"type volume\""
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storagePloopResize",
          "args": [
            "vol",
            "capacity"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "storagePloopResize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "665-684",
          "snippet": "static int\nstoragePloopResize(virStorageVolDefPtr vol,\n                   unsigned long long capacity)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *resize_tool = NULL;\n\n    resize_tool = virFindFileInPath(\"ploop\");\n    if (!resize_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop, please install ploop tools\"));\n        return -1;\n    }\n    cmd = virCommandNewArgList(resize_tool, \"resize\", \"-s\", NULL);\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(capacity, (1024 * 1024)));\n\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", vol->target.path);\n\n    return virCommandRun(cmd, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstoragePloopResize(virStorageVolDefPtr vol,\n                   unsigned long long capacity)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *resize_tool = NULL;\n\n    resize_tool = virFindFileInPath(\"ploop\");\n    if (!resize_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop, please install ploop tools\"));\n        return -1;\n    }\n    cmd = virCommandNewArgList(resize_tool, \"resize\", \"-s\", NULL);\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(capacity, (1024 * 1024)));\n\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", vol->target.path);\n\n    return virCommandRun(cmd, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"preallocate is only supported for an \"\n                             \"unencrypted raw volume\")"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileResize",
          "args": [
            "vol->target.path",
            "capacity",
            "pre_allocate"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileResize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1249-1288",
          "snippet": "int\nvirStorageFileResize(const char *path,\n                     unsigned long long capacity,\n                     bool pre_allocate)\n{\n    int rc;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((fd = open(path, O_RDWR)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open '%s'\"), path);\n        return -1;\n    }\n\n    if (pre_allocate) {\n        if ((rc = virFileAllocate(fd, 0, capacity)) != 0) {\n            if (rc == -2) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"preallocate is not supported on this platform\"));\n            } else {\n                virReportSystemError(errno,\n                                     _(\"Failed to pre-allocate space for \"\n                                       \"file '%s'\"), path);\n            }\n            return -1;\n        }\n    }\n\n    if (ftruncate(fd, capacity) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate file '%s'\"), path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"Unable to save '%s'\"), path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileResize(const char *path,\n                     unsigned long long capacity,\n                     bool pre_allocate)\n{\n    int rc;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((fd = open(path, O_RDWR)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open '%s'\"), path);\n        return -1;\n    }\n\n    if (pre_allocate) {\n        if ((rc = virFileAllocate(fd, 0, capacity)) != 0) {\n            if (rc == -2) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"preallocate is not supported on this platform\"));\n            } else {\n                virReportSystemError(errno,\n                                     _(\"Failed to pre-allocate space for \"\n                                       \"file '%s'\"), path);\n            }\n            return -1;\n        }\n    }\n\n    if (ftruncate(fd, capacity) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate file '%s'\"), path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"Unable to save '%s'\"), path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_RESIZE_ALLOCATE |\n                  VIR_STORAGE_VOL_RESIZE_SHRINK",
            "-1"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolResizeLocal(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                unsigned long long capacity,\n                                unsigned int flags)\n{\n    bool pre_allocate = flags & VIR_STORAGE_VOL_RESIZE_ALLOCATE;\n\n    virCheckFlags(VIR_STORAGE_VOL_RESIZE_ALLOCATE |\n                  VIR_STORAGE_VOL_RESIZE_SHRINK, -1);\n\n    if (vol->target.format == VIR_STORAGE_FILE_RAW && !vol->target.encryption) {\n        return virStorageFileResize(vol->target.path, capacity, pre_allocate);\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (pre_allocate) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"preallocate is only supported for an \"\n                             \"unencrypted raw volume\"));\n            return -1;\n        }\n\n        return storageBackendResizeQemuImg(pool, vol, capacity);\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        return storagePloopResize(vol, capacity);\n    } else {\n        if (pre_allocate) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"preallocate is only supported for raw \"\n                             \"type volume\"));\n            return -1;\n        }\n\n        return storageBackendResizeQemuImg(pool, vol, capacity);\n    }\n}"
  },
  {
    "function_name": "storageBackendResizeQemuImg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2238-2312",
    "snippet": "static int\nstorageBackendResizeQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            unsigned long long capacity)\n{\n    int ret = -1;\n    const char *type;\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *img_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *secretAlias = NULL;\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"resize of qcow2 encrypted image is not supported\"));\n        return -1;\n    }\n\n    img_tool = virFindFileInPath(\"qemu-img\");\n    if (!img_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find qemu-img\"));\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        if (vol->target.format == VIR_STORAGE_FILE_RAW)\n            type = \"luks\";\n        else\n            type = virStorageFileFormatTypeToString(vol->target.format);\n\n        storageBackendLoadDefaultSecrets(vol);\n\n        if (storageBackendCreateQemuImgCheckEncryption(vol->target.format,\n                                                       type, vol) < 0)\n            goto cleanup;\n\n        if (!(secretPath =\n              storageBackendCreateQemuImgSecretPath(pool, vol)))\n            goto cleanup;\n\n        secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n    }\n\n    /* Round capacity as qemu-img resize errors out on sizes which are not\n     * a multiple of 512 */\n    capacity = VIR_ROUND_UP(capacity, 512);\n\n    cmd = virCommandNewArgList(img_tool, \"resize\", NULL);\n    if (capacity < vol->target.capacity)\n        virCommandAddArg(cmd, \"--shrink\");\n    if (!vol->target.encryption) {\n        virCommandAddArg(cmd, vol->target.path);\n    } else {\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    secretAlias) < 0)\n            goto cleanup;\n\n        if (storageBackendResizeQemuImgImageOpts(cmd, vol->target.path,\n                                                 secretAlias) < 0)\n            goto cleanup;\n    }\n    virCommandAddArgFormat(cmd, \"%llu\", capacity);\n\n    ret = virCommandRun(cmd, NULL);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "secretPath"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%llu\"",
            "capacity"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendResizeQemuImgImageOpts",
          "args": [
            "cmd",
            "vol->target.path",
            "secretAlias"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendResizeQemuImgImageOpts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "956-973",
          "snippet": "static int\nstorageBackendResizeQemuImgImageOpts(virCommandPtr cmd,\n                                     const char *path,\n                                     const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"driver=luks,key-secret=%s,file.filename=\",\n                      secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, path);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--image-opts\", commandStr, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendResizeQemuImgImageOpts(virCommandPtr cmd,\n                                     const char *path,\n                                     const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"driver=luks,key-secret=%s,file.filename=\",\n                      secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, path);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--image-opts\", commandStr, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSecretObject",
          "args": [
            "cmd",
            "secretPath",
            "secretAlias"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSecretObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "932-948",
          "snippet": "static int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "vol->target.path"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "img_tool",
            "\"resize\"",
            "NULL"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ROUND_UP",
          "args": [
            "capacity",
            "512"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s_encrypt0\"",
            "vol->name"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSecretPath",
          "args": [
            "pool",
            "vol"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSecretPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1188-1256",
          "snippet": "static char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgCheckEncryption",
          "args": [
            "vol->target.format",
            "type",
            "vol"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgCheckEncryption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "778-815",
          "snippet": "static int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendLoadDefaultSecrets",
          "args": [
            "vol"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendLoadDefaultSecrets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2172-2215",
          "snippet": "static int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "vol->target.format"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to find qemu-img\")"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"qemu-img\""
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"resize of qcow2 encrypted image is not supported\")"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendResizeQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            unsigned long long capacity)\n{\n    int ret = -1;\n    const char *type;\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *img_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *secretAlias = NULL;\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"resize of qcow2 encrypted image is not supported\"));\n        return -1;\n    }\n\n    img_tool = virFindFileInPath(\"qemu-img\");\n    if (!img_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find qemu-img\"));\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        if (vol->target.format == VIR_STORAGE_FILE_RAW)\n            type = \"luks\";\n        else\n            type = virStorageFileFormatTypeToString(vol->target.format);\n\n        storageBackendLoadDefaultSecrets(vol);\n\n        if (storageBackendCreateQemuImgCheckEncryption(vol->target.format,\n                                                       type, vol) < 0)\n            goto cleanup;\n\n        if (!(secretPath =\n              storageBackendCreateQemuImgSecretPath(pool, vol)))\n            goto cleanup;\n\n        secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n    }\n\n    /* Round capacity as qemu-img resize errors out on sizes which are not\n     * a multiple of 512 */\n    capacity = VIR_ROUND_UP(capacity, 512);\n\n    cmd = virCommandNewArgList(img_tool, \"resize\", NULL);\n    if (capacity < vol->target.capacity)\n        virCommandAddArg(cmd, \"--shrink\");\n    if (!vol->target.encryption) {\n        virCommandAddArg(cmd, vol->target.path);\n    } else {\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    secretAlias) < 0)\n            goto cleanup;\n\n        if (storageBackendResizeQemuImgImageOpts(cmd, vol->target.path,\n                                                 secretAlias) < 0)\n            goto cleanup;\n    }\n    virCommandAddArgFormat(cmd, \"%llu\", capacity);\n\n    ret = virCommandRun(cmd, NULL);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendVolRefreshLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2221-2235",
    "snippet": "int\nvirStorageBackendVolRefreshLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                 virStorageVolDefPtr vol)\n{\n    int ret;\n\n    /* Refresh allocation / capacity / permissions info in case its changed */\n    if ((ret = virStorageBackendUpdateVolInfo(vol, false,\n                                              VIR_STORAGE_VOL_FS_OPEN_FLAGS,\n                                              0)) < 0)\n        return ret;\n\n    /* Load any secrets if possible */\n    return storageBackendLoadDefaultSecrets(vol);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendLoadDefaultSecrets",
          "args": [
            "vol"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendLoadDefaultSecrets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2172-2215",
          "snippet": "static int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolInfo",
          "args": [
            "vol",
            "false",
            "VIR_STORAGE_VOL_FS_OPEN_FLAGS",
            "0"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1781-1805",
          "snippet": "int\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolRefreshLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                 virStorageVolDefPtr vol)\n{\n    int ret;\n\n    /* Refresh allocation / capacity / permissions info in case its changed */\n    if ((ret = virStorageBackendUpdateVolInfo(vol, false,\n                                              VIR_STORAGE_VOL_FS_OPEN_FLAGS,\n                                              0)) < 0)\n        return ret;\n\n    /* Load any secrets if possible */\n    return storageBackendLoadDefaultSecrets(vol);\n}"
  },
  {
    "function_name": "storageBackendLoadDefaultSecrets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2172-2215",
    "snippet": "static int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sec"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecretGetUUID",
          "args": [
            "sec",
            "encsec->seclookupdef.u.uuid"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretGetUUIDString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-secret.c",
          "lines": "401-417",
          "snippet": "int\nvirSecretGetUUIDString(virSecretPtr secret, char *buf)\n{\n    VIR_DEBUG(\"secret=%p, buf=%p\", secret, buf);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n    virCheckNonNullArgGoto(buf, error);\n\n    virUUIDFormat(secret->uuid, buf);\n    return 0;\n\n error:\n    virDispatchError(secret->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretGetUUIDString(virSecretPtr secret, char *buf)\n{\n    VIR_DEBUG(\"secret=%p, buf=%p\", secret, buf);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n    virCheckNonNullArgGoto(buf, error);\n\n    virUUIDFormat(secret->uuid, buf);\n    return 0;\n\n error:\n    virDispatchError(secret->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->target.encryption->secrets"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "encsec"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "vol->target.encryption->secrets",
            "1"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretLookupByUsage",
          "args": [
            "conn",
            "VIR_SECRET_USAGE_TYPE_VOLUME",
            "vol->target.path"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretLookupByUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-secret.c",
          "lines": "286-312",
          "snippet": "virSecretPtr\nvirSecretLookupByUsage(virConnectPtr conn,\n                       int usageType,\n                       const char *usageID)\n{\n    VIR_DEBUG(\"conn=%p, usageType=%d usageID=%s\", conn, usageType, NULLSTR(usageID));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(usageID, error);\n\n    if (conn->secretDriver &&\n        conn->secretDriver->secretLookupByUsage) {\n        virSecretPtr ret;\n        ret = conn->secretDriver->secretLookupByUsage(conn, usageType, usageID);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirSecretPtr\nvirSecretLookupByUsage(virConnectPtr conn,\n                       int usageType,\n                       const char *usageID)\n{\n    VIR_DEBUG(\"conn=%p, usageType=%d usageID=%s\", conn, usageType, NULLSTR(usageID));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(usageID, error);\n\n    if (conn->secretDriver &&\n        conn->secretDriver->secretLookupByUsage) {\n        virSecretPtr ret;\n        ret = conn->secretDriver->secretLookupByUsage(conn, usageType, usageID);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectSecret",
          "args": [],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectSecret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "184-187",
          "snippet": "virConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectSecret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectSecret;\n\nvirConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendLoadDefaultSecrets(virStorageVolDefPtr vol)\n{\n    virSecretPtr sec;\n    virStorageEncryptionSecretPtr encsec = NULL;\n    virConnectPtr conn = NULL;\n\n    if (!vol->target.encryption || vol->target.encryption->nsecrets != 0)\n        return 0;\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return -1;\n\n    /* The encryption secret for qcow2 and luks volumes use the path\n     * to the volume, so look for a secret with the path. If not found,\n     * then we cannot generate the secret after a refresh (or restart).\n     * This may be the case if someone didn't follow instructions and created\n     * a usage string that although matched with the secret usage string,\n     * didn't contain the path to the volume. We won't error in that case,\n     * but we also cannot find the secret. */\n    sec = virSecretLookupByUsage(conn, VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 vol->target.path);\n    virObjectUnref(conn);\n    if (!sec)\n        return 0;\n\n    if (VIR_ALLOC_N(vol->target.encryption->secrets, 1) < 0 ||\n        VIR_ALLOC(encsec) < 0) {\n        VIR_FREE(vol->target.encryption->secrets);\n        virObjectUnref(sec);\n        return -1;\n    }\n\n    vol->target.encryption->nsecrets = 1;\n    vol->target.encryption->secrets[0] = encsec;\n\n    encsec->type = VIR_STORAGE_ENCRYPTION_SECRET_TYPE_PASSPHRASE;\n    encsec->seclookupdef.type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    virSecretGetUUID(sec, encsec->seclookupdef.u.uuid);\n    virObjectUnref(sec);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendVolDeleteLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2120-2160",
    "snippet": "int\nvirStorageBackendVolDeleteLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                virStorageVolDefPtr vol,\n                                unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    switch ((virStorageVolType)vol->type) {\n    case VIR_STORAGE_VOL_FILE:\n    case VIR_STORAGE_VOL_DIR:\n        if (virFileRemove(vol->target.path, vol->target.perms->uid,\n                          vol->target.perms->gid) < 0) {\n            /* Silently ignore failures where the vol has already gone away */\n            if (errno != ENOENT) {\n                if (vol->type == VIR_STORAGE_VOL_FILE)\n                    virReportSystemError(errno,\n                                         _(\"cannot unlink file '%s'\"),\n                                         vol->target.path);\n                else\n                    virReportSystemError(errno,\n                                         _(\"cannot remove directory '%s'\"),\n                                         vol->target.path);\n                return -1;\n            }\n        }\n        break;\n    case VIR_STORAGE_VOL_PLOOP:\n        if (virFileDeleteTree(vol->target.path) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_VOL_BLOCK:\n    case VIR_STORAGE_VOL_NETWORK:\n    case VIR_STORAGE_VOL_NETDIR:\n    case VIR_STORAGE_VOL_LAST:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"removing block or network volumes is not supported: %s\"),\n                       vol->target.path);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"removing block or network volumes is not supported: %s\")",
            "vol->target.path"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"removing block or network volumes is not supported: %s\""
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileDeleteTree",
          "args": [
            "vol->target.path"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "virFileDeleteTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1009-1062",
          "snippet": "int virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot remove directory '%s'\")",
            "vol->target.path"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot unlink file '%s'\")",
            "vol->target.path"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "vol->target.path",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolDeleteLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                virStorageVolDefPtr vol,\n                                unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    switch ((virStorageVolType)vol->type) {\n    case VIR_STORAGE_VOL_FILE:\n    case VIR_STORAGE_VOL_DIR:\n        if (virFileRemove(vol->target.path, vol->target.perms->uid,\n                          vol->target.perms->gid) < 0) {\n            /* Silently ignore failures where the vol has already gone away */\n            if (errno != ENOENT) {\n                if (vol->type == VIR_STORAGE_VOL_FILE)\n                    virReportSystemError(errno,\n                                         _(\"cannot unlink file '%s'\"),\n                                         vol->target.path);\n                else\n                    virReportSystemError(errno,\n                                         _(\"cannot remove directory '%s'\"),\n                                         vol->target.path);\n                return -1;\n            }\n        }\n        break;\n    case VIR_STORAGE_VOL_PLOOP:\n        if (virFileDeleteTree(vol->target.path) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_VOL_BLOCK:\n    case VIR_STORAGE_VOL_NETWORK:\n    case VIR_STORAGE_VOL_NETDIR:\n    case VIR_STORAGE_VOL_LAST:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"removing block or network volumes is not supported: %s\"),\n                       vol->target.path);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendVolBuildFromLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2107-2114",
    "snippet": "int\nvirStorageBackendVolBuildFromLocal(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virStorageVolDefPtr inputvol,\n                                   unsigned int flags)\n{\n    return storageBackendVolBuildLocal(pool, vol, inputvol, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendVolBuildLocal",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolBuildLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2061-2087",
          "snippet": "static int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolBuildFromLocal(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virStorageVolDefPtr inputvol,\n                                   unsigned int flags)\n{\n    return storageBackendVolBuildLocal(pool, vol, inputvol, flags);\n}"
  },
  {
    "function_name": "virStorageBackendVolBuildLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2095-2101",
    "snippet": "int\nvirStorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    return storageBackendVolBuildLocal(pool, vol, NULL, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendVolBuildLocal",
          "args": [
            "pool",
            "vol",
            "NULL",
            "flags"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendVolBuildLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2061-2087",
          "snippet": "static int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    return storageBackendVolBuildLocal(pool, vol, NULL, flags);\n}"
  },
  {
    "function_name": "storageBackendVolBuildLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2061-2087",
    "snippet": "static int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_func",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGetBuildVolFromFunction",
          "args": [
            "vol",
            "inputvol"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGetBuildVolFromFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1387-1412",
          "snippet": "virStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendVolBuildLocal(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    virStorageBackendBuildVolFrom create_func;\n\n    if (inputvol) {\n        if (!(create_func =\n              virStorageBackendGetBuildVolFromFunction(vol, inputvol)))\n            return -1;\n    } else if (vol->target.format == VIR_STORAGE_FILE_RAW &&\n               vol->target.encryption == NULL) {\n        create_func = storageBackendCreateRaw;\n    } else if (vol->target.format == VIR_STORAGE_FILE_DIR) {\n        create_func = createFileDir;\n    } else if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        create_func = storageBackendCreatePloop;\n    } else {\n        create_func = storageBackendCreateQemuImg;\n    }\n\n    if (create_func(pool, vol, inputvol, flags) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendVolCreateLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "2024-2058",
    "snippet": "int\nvirStorageBackendVolCreateLocal(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n    else if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n    else\n        vol->type = VIR_STORAGE_VOL_FILE;\n\n    /* Volumes within a directory pools are not recursive; do not\n     * allow escape to ../ or a subdir */\n    if (strchr(vol->name, '/')) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume name '%s' cannot contain '/'\"), vol->name);\n        return -1;\n    }\n\n    VIR_FREE(vol->target.path);\n    vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    if (virFileExists(vol->target.path)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume target path '%s' already exists\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    VIR_FREE(vol->key);\n    vol->key = g_strdup(vol->target.path);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vol->target.path"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->key"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"volume target path '%s' already exists\")",
            "vol->target.path"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "vol->target.path"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->target.path"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"volume name '%s' cannot contain '/'\")",
            "vol->name"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "vol->name",
            "'/'"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolCreateLocal(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (vol->target.format == VIR_STORAGE_FILE_DIR)\n        vol->type = VIR_STORAGE_VOL_DIR;\n    else if (vol->target.format == VIR_STORAGE_FILE_PLOOP)\n        vol->type = VIR_STORAGE_VOL_PLOOP;\n    else\n        vol->type = VIR_STORAGE_VOL_FILE;\n\n    /* Volumes within a directory pools are not recursive; do not\n     * allow escape to ../ or a subdir */\n    if (strchr(vol->name, '/')) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume name '%s' cannot contain '/'\"), vol->name);\n        return -1;\n    }\n\n    VIR_FREE(vol->target.path);\n    vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    if (virFileExists(vol->target.path)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume target path '%s' already exists\"),\n                       vol->target.path);\n        return -1;\n    }\n\n    VIR_FREE(vol->key);\n    vol->key = g_strdup(vol->target.path);\n    return 0;\n}"
  },
  {
    "function_name": "createFileDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1978-2015",
    "snippet": "static int\ncreateFileDir(virStoragePoolObjPtr pool,\n              virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int err;\n\n    virCheckFlags(0, -1);\n\n    if (inputvol) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"cannot copy from volume to a directory volume\"));\n        return -1;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                       _(\"backing storage not supported for directories volumes\"));\n        return -1;\n    }\n\n\n    if ((err = virDirCreate(vol->target.path,\n                            (vol->target.perms->mode == (mode_t)-1 ?\n                             VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                             vol->target.perms->mode),\n                            vol->target.perms->uid,\n                            vol->target.perms->gid,\n                            (def->type == VIR_STORAGE_POOL_NETFS\n                             ? VIR_DIR_CREATE_AS_UID : 0))) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDirCreate",
          "args": [
            "vol->target.path",
            "(vol->target.perms->mode == (mode_t)-1 ?\n                             VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                             vol->target.perms->mode)",
            "vol->target.perms->uid",
            "vol->target.perms->gid",
            "(def->type == VIR_STORAGE_POOL_NETFS\n                             ? VIR_DIR_CREATE_AS_UID : 0)"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "virDirCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2831-2842",
          "snippet": "int\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"backing storage not supported for directories volumes\")"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"backing storage not supported for directories volumes\""
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot copy from volume to a directory volume\")"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ncreateFileDir(virStoragePoolObjPtr pool,\n              virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int err;\n\n    virCheckFlags(0, -1);\n\n    if (inputvol) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"cannot copy from volume to a directory volume\"));\n        return -1;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                       _(\"backing storage not supported for directories volumes\"));\n        return -1;\n    }\n\n\n    if ((err = virDirCreate(vol->target.path,\n                            (vol->target.perms->mode == (mode_t)-1 ?\n                             VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                             vol->target.perms->mode),\n                            vol->target.perms->uid,\n                            vol->target.perms->gid,\n                            (def->type == VIR_STORAGE_POOL_NETFS\n                             ? VIR_DIR_CREATE_AS_UID : 0))) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendStablePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1904-1975",
    "snippet": "char *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "devpath"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dh"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stablepath"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dh"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLinkPointsTo",
          "args": [
            "stablepath",
            "devpath"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLinkPointsTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1533-1543",
          "snippet": "int\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dh",
            "&dent",
            "NULL"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read dir '%s'\")",
            "def->target.path"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirOpenQuiet",
          "args": [
            "&dh",
            "def->target.path"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendPoolPathIsStable",
          "args": [
            "def->target.path"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendPoolPathIsStable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1876-1886",
          "snippet": "bool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}"
  },
  {
    "function_name": "virStorageBackendPoolPathIsStable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1876-1886",
    "snippet": "bool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "path",
            "\"/dev/\""
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "path",
            "\"/dev/\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "path",
            "\"/dev\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendPoolPathIsStable(const char *path)\n{\n    if (path == NULL || STREQ(path, \"/dev\") || STREQ(path, \"/dev/\"))\n        return false;\n\n    if (!STRPREFIX(path, \"/dev/\"))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStorageBackendUpdateVolTargetInfoFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1815-1874",
    "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "filecon"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "filecon"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot get file context of '%s'\")",
            "target->path"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetfilecon_raw",
          "args": [
            "fd",
            "&filecon"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "target->perms->label"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "target->timestamps"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "target->perms"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceUpdateBackingSizes",
          "args": [
            "target",
            "fd",
            "sb"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceUpdateBackingSizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4122-4173",
          "snippet": "int\nvirStorageSourceUpdateBackingSizes(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    /* Get info for normal formats */\n    if (S_ISREG(sb->st_mode) || fd == -1) {\n#ifndef WIN32\n        src->allocation = (unsigned long long)sb->st_blocks *\n            (unsigned long long)DEV_BSIZE;\n#else\n        src->allocation = sb->st_size;\n#endif\n        /* Regular files may be sparse, so logical size (capacity) is not same\n         * as actual allocation above\n         */\n        src->capacity = sb->st_size;\n\n        /* Allocation tracks when the file is sparse, physical is the\n         * last offset of the file. */\n        src->physical = sb->st_size;\n    } else if (S_ISDIR(sb->st_mode)) {\n        src->allocation = 0;\n        src->capacity = 0;\n        src->physical = 0;\n    } else if (fd >= 0) {\n        off_t end;\n\n        /* XXX this is POSIX compliant, but doesn't work for CHAR files,\n         * only BLOCK. There is a Linux specific ioctl() for getting\n         * size of both CHAR / BLOCK devices we should check for in\n         * configure\n         *\n         * NB. Because we configure with AC_SYS_LARGEFILE, off_t\n         * should be 64 bits on all platforms.  For block devices, we\n         * have to seek (safe even if someone else is writing) to\n         * determine physical size, and assume that allocation is the\n         * same as physical (but can refine that assumption later if\n         * qemu is still running).\n         */\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t)-1) {\n            virReportSystemError(errno,\n                                 _(\"failed to seek to end of %s\"), src->path);\n            return -1;\n        }\n        src->physical = end;\n        src->allocation = end;\n        src->capacity = end;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceUpdateBackingSizes(virStorageSourcePtr src,\n                                   int fd,\n                                   struct stat const *sb)\n{\n    /* Get info for normal formats */\n    if (S_ISREG(sb->st_mode) || fd == -1) {\n#ifndef WIN32\n        src->allocation = (unsigned long long)sb->st_blocks *\n            (unsigned long long)DEV_BSIZE;\n#else\n        src->allocation = sb->st_size;\n#endif\n        /* Regular files may be sparse, so logical size (capacity) is not same\n         * as actual allocation above\n         */\n        src->capacity = sb->st_size;\n\n        /* Allocation tracks when the file is sparse, physical is the\n         * last offset of the file. */\n        src->physical = sb->st_size;\n    } else if (S_ISDIR(sb->st_mode)) {\n        src->allocation = 0;\n        src->capacity = 0;\n        src->physical = 0;\n    } else if (fd >= 0) {\n        off_t end;\n\n        /* XXX this is POSIX compliant, but doesn't work for CHAR files,\n         * only BLOCK. There is a Linux specific ioctl() for getting\n         * size of both CHAR / BLOCK devices we should check for in\n         * configure\n         *\n         * NB. Because we configure with AC_SYS_LARGEFILE, off_t\n         * should be 64 bits on all platforms.  For block devices, we\n         * have to seek (safe even if someone else is writing) to\n         * determine physical size, and assume that allocation is the\n         * same as physical (but can refine that assumption later if\n         * qemu is still running).\n         */\n        if ((end = lseek(fd, 0, SEEK_END)) == (off_t)-1) {\n            virReportSystemError(errno,\n                                 _(\"failed to seek to end of %s\"), src->path);\n            return -1;\n        }\n        src->physical = end;\n        src->allocation = end;\n        src->capacity = end;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendUpdateVolInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1781-1805",
    "snippet": "int\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendUpdateVolTargetInfo",
          "args": [
            "VIR_STORAGE_VOL_FILE",
            "vol->target.backingStore",
            "withBlockVolFormat",
            "VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR",
            "readflags"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendUpdateVolTargetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1709-1768",
          "snippet": "static int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendUpdateVolTargetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1709-1768",
    "snippet": "static int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendDetectBlockVolFormatFD",
          "args": [
            "target",
            "fd",
            "readflags"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDetectBlockVolFormatFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1459-1508",
          "snippet": "static int\nvirStorageBackendDetectBlockVolFormatFD(virStorageSourcePtr target,\n                                        int fd,\n                                        unsigned int readflags)\n{\n    size_t i;\n    off_t start;\n    unsigned char buffer[1024];\n    ssize_t bytes;\n\n    /* make sure to set the target format \"unknown\" to begin with */\n    target->format = VIR_STORAGE_POOL_DISK_UNKNOWN;\n\n    start = lseek(fd, 0, SEEK_SET);\n    if (start < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot seek to beginning of file '%s'\"),\n                             target->path);\n        return -1;\n    }\n    bytes = saferead(fd, buffer, sizeof(buffer));\n    if (bytes < 0) {\n        if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n            VIR_WARN(\"ignoring failed saferead of file '%s'\",\n                     target->path);\n            return -2;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"cannot read beginning of file '%s'\"),\n                                 target->path);\n            return -1;\n        }\n    }\n\n    for (i = 0; disk_types[i].part_table_type != -1; i++) {\n        if (disk_types[i].offset + disk_types[i].length > bytes)\n            continue;\n        if (memcmp(buffer+disk_types[i].offset, &disk_types[i].magic,\n            disk_types[i].length) == 0) {\n            target->format = disk_types[i].part_table_type;\n            break;\n        }\n    }\n\n    if (target->format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        VIR_DEBUG(\"cannot determine the target format for '%s'\",\n                  target->path);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct diskType const disk_types[] = {\n    { VIR_STORAGE_POOL_DISK_LVM2, 0x218, 8, 0x31303020324D564CULL },\n    { VIR_STORAGE_POOL_DISK_GPT,  0x200, 8, 0x5452415020494645ULL },\n    { VIR_STORAGE_POOL_DISK_DVH,  0x0,   4, 0x41A9E50BULL },\n    { VIR_STORAGE_POOL_DISK_MAC,  0x0,   2, 0x5245ULL },\n    { VIR_STORAGE_POOL_DISK_BSD,  0x40,  4, 0x82564557ULL },\n    { VIR_STORAGE_POOL_DISK_SUN,  0x1fc, 2, 0xBEDAULL },\n    /*\n     * NOTE: pc98 is funky; the actual signature is 0x55AA (just like dos), so\n     * we can't use that.  At the moment I'm relying on the \"dummy\" IPL\n     * bootloader data that comes from parted.  Luckily, the chances of running\n     * into a pc98 machine running libvirt are approximately nil.\n     */\n    /*{ 0x1fe, 2, 0xAA55UL },*/\n    { VIR_STORAGE_POOL_DISK_PC98, 0x0,   8, 0x314C5049000000CBULL },\n    /*\n     * NOTE: the order is important here; some other disk types (like GPT and\n     * and PC98) also have 0x55AA at this offset.  For that reason, the DOS\n     * one must be the last one.\n     */\n    { VIR_STORAGE_POOL_DISK_DOS,  0x1fe, 2, 0xAA55ULL },\n    { -1,                         0x0,   0, 0x0ULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic struct diskType const disk_types[] = {\n    { VIR_STORAGE_POOL_DISK_LVM2, 0x218, 8, 0x31303020324D564CULL },\n    { VIR_STORAGE_POOL_DISK_GPT,  0x200, 8, 0x5452415020494645ULL },\n    { VIR_STORAGE_POOL_DISK_DVH,  0x0,   4, 0x41A9E50BULL },\n    { VIR_STORAGE_POOL_DISK_MAC,  0x0,   2, 0x5245ULL },\n    { VIR_STORAGE_POOL_DISK_BSD,  0x40,  4, 0x82564557ULL },\n    { VIR_STORAGE_POOL_DISK_SUN,  0x1fc, 2, 0xBEDAULL },\n    /*\n     * NOTE: pc98 is funky; the actual signature is 0x55AA (just like dos), so\n     * we can't use that.  At the moment I'm relying on the \"dummy\" IPL\n     * bootloader data that comes from parted.  Luckily, the chances of running\n     * into a pc98 machine running libvirt are approximately nil.\n     */\n    /*{ 0x1fe, 2, 0xAA55UL },*/\n    { VIR_STORAGE_POOL_DISK_PC98, 0x0,   8, 0x314C5049000000CBULL },\n    /*\n     * NOTE: the order is important here; some other disk types (like GPT and\n     * and PC98) also have 0x55AA at this offset.  For that reason, the DOS\n     * one must be the last one.\n     */\n    { VIR_STORAGE_POOL_DISK_DOS,  0x1fe, 2, 0xAA55ULL },\n    { -1,                         0x0,   0, 0x0ULL },\n};\n\nstatic int\nvirStorageBackendDetectBlockVolFormatFD(virStorageSourcePtr target,\n                                        int fd,\n                                        unsigned int readflags)\n{\n    size_t i;\n    off_t start;\n    unsigned char buffer[1024];\n    ssize_t bytes;\n\n    /* make sure to set the target format \"unknown\" to begin with */\n    target->format = VIR_STORAGE_POOL_DISK_UNKNOWN;\n\n    start = lseek(fd, 0, SEEK_SET);\n    if (start < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot seek to beginning of file '%s'\"),\n                             target->path);\n        return -1;\n    }\n    bytes = saferead(fd, buffer, sizeof(buffer));\n    if (bytes < 0) {\n        if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n            VIR_WARN(\"ignoring failed saferead of file '%s'\",\n                     target->path);\n            return -2;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"cannot read beginning of file '%s'\"),\n                                 target->path);\n            return -1;\n        }\n    }\n\n    for (i = 0; disk_types[i].part_table_type != -1; i++) {\n        if (disk_types[i].offset + disk_types[i].length > bytes)\n            continue;\n        if (memcmp(buffer+disk_types[i].offset, &disk_types[i].magic,\n            disk_types[i].length) == 0) {\n            target->format = disk_types[i].part_table_type;\n            break;\n        }\n    }\n\n    if (target->format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        VIR_DEBUG(\"cannot determine the target format for '%s'\",\n                  target->path);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceUpdateCapacity",
          "args": [
            "target",
            "buf",
            "len"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceUpdateCapacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4185-4218",
          "snippet": "int\nvirStorageSourceUpdateCapacity(virStorageSourcePtr src,\n                               char *buf,\n                               ssize_t len)\n{\n    int format = src->format;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    /* Raw files: capacity is physical size.  For all other files: if\n     * the metadata has a capacity, use that, otherwise fall back to\n     * physical size.  */\n    if (format == VIR_STORAGE_FILE_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no disk format for %s was specified\"),\n                       src->path);\n        return -1;\n    }\n\n    if (format == VIR_STORAGE_FILE_RAW && !src->encryption) {\n        src->capacity = src->physical;\n    } else if ((meta = virStorageFileGetMetadataFromBuf(src->path, buf,\n                                                        len, format))) {\n        src->capacity = meta->capacity ? meta->capacity : src->physical;\n        if (src->encryption && meta->encryption)\n            src->encryption->payload_offset = meta->encryption->payload_offset;\n    } else {\n        return -1;\n    }\n\n    if (src->encryption && src->encryption->payload_offset != -1)\n        src->capacity -= src->encryption->payload_offset * 512;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\n\nint\nvirStorageSourceUpdateCapacity(virStorageSourcePtr src,\n                               char *buf,\n                               ssize_t len)\n{\n    int format = src->format;\n    g_autoptr(virStorageSource) meta = NULL;\n\n    /* Raw files: capacity is physical size.  For all other files: if\n     * the metadata has a capacity, use that, otherwise fall back to\n     * physical size.  */\n    if (format == VIR_STORAGE_FILE_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no disk format for %s was specified\"),\n                       src->path);\n        return -1;\n    }\n\n    if (format == VIR_STORAGE_FILE_RAW && !src->encryption) {\n        src->capacity = src->physical;\n    } else if ((meta = virStorageFileGetMetadataFromBuf(src->path, buf,\n                                                        len, format))) {\n        src->capacity = meta->capacity ? meta->capacity : src->physical;\n        if (src->encryption && meta->encryption)\n            src->encryption->payload_offset = meta->encryption->payload_offset;\n    } else {\n        return -1;\n    }\n\n    if (src->encryption && src->encryption->payload_offset != -1)\n        src->capacity -= src->encryption->payload_offset * 512;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read header '%s'\")",
            "target->path"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read header '%s'\""
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring failed header read for '%s'\"",
            "target->path"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadHeaderFD",
          "args": [
            "fd",
            "len",
            "&buf"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadHeaderFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1377-1392",
          "snippet": "int\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadHeaderFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen, &len);\n    if (s == NULL)\n        return -1;\n    *buf = s;\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot seek to start of '%s'\")",
            "target->path"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendRedoPloopUpdate",
          "args": [
            "target",
            "&sb",
            "&fd",
            "openflags"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendRedoPloopUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1682-1693",
          "snippet": "static int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendIsPloopDir",
          "args": [
            "target->path"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendIsPloopDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1661-1675",
          "snippet": "static bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolTargetInfoFD",
          "args": [
            "target",
            "fd",
            "&sb"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolTargetInfoFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1815-1874",
          "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolOpen",
          "args": [
            "target->path",
            "&sb",
            "openflags"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1518-1656",
          "snippet": "int\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendUpdateVolTargetInfo(virStorageVolType voltype,\n                                  virStorageSourcePtr target,\n                                  bool withBlockVolFormat,\n                                  unsigned int openflags,\n                                  unsigned int readflags)\n{\n    int rc;\n    struct stat sb;\n    ssize_t len = VIR_STORAGE_MAX_HEADER;\n    g_autofree char *buf = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if ((rc = virStorageBackendVolOpen(target->path, &sb, openflags)) < 0)\n        return rc;\n    fd = rc;\n\n    if ((virStorageBackendUpdateVolTargetInfoFD(target, fd, &sb)) < 0)\n        return -1;\n\n    if ((voltype == VIR_STORAGE_VOL_FILE || voltype == VIR_STORAGE_VOL_BLOCK) &&\n        target->format != VIR_STORAGE_FILE_NONE) {\n        if (S_ISDIR(sb.st_mode)) {\n            if (storageBackendIsPloopDir(target->path)) {\n                if ((storageBackendRedoPloopUpdate(target, &sb, &fd,\n                                                   openflags)) < 0)\n                    return -1;\n                target->format = VIR_STORAGE_FILE_PLOOP;\n            } else {\n                return 0;\n            }\n        }\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n            virReportSystemError(errno, _(\"cannot seek to start of '%s'\"), target->path);\n            return -1;\n        }\n\n        if ((len = virFileReadHeaderFD(fd, len, &buf)) < 0) {\n            if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n                VIR_WARN(\"ignoring failed header read for '%s'\",\n                         target->path);\n                return -2;\n            } else {\n                virReportSystemError(errno,\n                                     _(\"cannot read header '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        }\n\n        if (virStorageSourceUpdateCapacity(target, buf, len) < 0)\n            return -1;\n    }\n\n    if (withBlockVolFormat)\n        return virStorageBackendDetectBlockVolFormatFD(target, fd, readflags);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendRedoPloopUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1682-1693",
    "snippet": "static int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolTargetInfoFD",
          "args": [
            "target",
            "*fd",
            "sb"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolTargetInfoFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1815-1874",
          "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolOpen",
          "args": [
            "path",
            "sb",
            "flags"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1518-1656",
          "snippet": "int\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "*fd"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/root.hds\"",
            "target->path"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendRedoPloopUpdate(virStorageSourcePtr target, struct stat *sb,\n                              int *fd, unsigned int flags)\n{\n    g_autofree char *path = NULL;\n\n    path = g_strdup_printf(\"%s/root.hds\", target->path);\n    VIR_FORCE_CLOSE(*fd);\n    if ((*fd = virStorageBackendVolOpen(path, sb, flags)) < 0)\n        return -1;\n    return virStorageBackendUpdateVolTargetInfoFD(target, *fd, sb);\n}"
  },
  {
    "function_name": "storageBackendIsPloopDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1661-1675",
    "snippet": "static bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "desc"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/DiskDescriptor.xml\"",
            "path"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nstorageBackendIsPloopDir(char *path)\n{\n    g_autofree char *root = NULL;\n    g_autofree char *desc = NULL;\n\n    root = g_strdup_printf(\"%s/root.hds\", path);\n    if (!virFileExists(root))\n        return false;\n    desc = g_strdup_printf(\"%s/DiskDescriptor.xml\", path);\n    if (!virFileExists(desc))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virStorageBackendVolOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1518-1656",
    "snippet": "int\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected storage mode for '%s'\")",
            "path"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected storage mode for '%s'\""
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Skipping volume '%s'\"",
            "path"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set blocking mode for '%s'\")",
            "path"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetBlocking",
          "args": [
            "fd",
            "true"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "virSetBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "113-121",
          "snippet": "int virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected type for file '%s'\")",
            "path"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring unexpected type for file '%s'\"",
            "path"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot use volume path '%s'\")",
            "path"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Skipping special dir '%s'\"",
            "base"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "base",
            "\"..\""
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "base",
            "\".\""
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb->st_mode"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "sb->st_mode"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "sb->st_mode"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb->st_mode"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat file '%s'\")",
            "path"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "sb"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open volume '%s'\")",
            "path"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring permission error for '%s'\"",
            "path"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring missing fifo '%s'\"",
            "path"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring missing file '%s'\"",
            "path"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring dangling symlink '%s'\"",
            "path"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sb->st_mode"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileOpenAs",
          "args": [
            "path",
            "O_RDONLY|O_NONBLOCK|O_NOCTTY",
            "0",
            "sb->st_uid",
            "sb->st_gid",
            "VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2817-2829",
          "snippet": "int\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume path '%s' is a socket\")",
            "path"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring socket '%s'\"",
            "path"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "sb->st_mode"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume path '%s' is a FIFO\")",
            "path"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring FIFO '%s'\"",
            "path"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "sb->st_mode"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat file '%s'\")",
            "path"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_VOL",
            "_(\"no storage vol with matching path '%s'\")",
            "path"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring missing file '%s'\"",
            "path"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lstat",
          "args": [
            "path",
            "sb"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "path"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}"
  },
  {
    "function_name": "virStorageBackendDetectBlockVolFormatFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1459-1508",
    "snippet": "static int\nvirStorageBackendDetectBlockVolFormatFD(virStorageSourcePtr target,\n                                        int fd,\n                                        unsigned int readflags)\n{\n    size_t i;\n    off_t start;\n    unsigned char buffer[1024];\n    ssize_t bytes;\n\n    /* make sure to set the target format \"unknown\" to begin with */\n    target->format = VIR_STORAGE_POOL_DISK_UNKNOWN;\n\n    start = lseek(fd, 0, SEEK_SET);\n    if (start < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot seek to beginning of file '%s'\"),\n                             target->path);\n        return -1;\n    }\n    bytes = saferead(fd, buffer, sizeof(buffer));\n    if (bytes < 0) {\n        if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n            VIR_WARN(\"ignoring failed saferead of file '%s'\",\n                     target->path);\n            return -2;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"cannot read beginning of file '%s'\"),\n                                 target->path);\n            return -1;\n        }\n    }\n\n    for (i = 0; disk_types[i].part_table_type != -1; i++) {\n        if (disk_types[i].offset + disk_types[i].length > bytes)\n            continue;\n        if (memcmp(buffer+disk_types[i].offset, &disk_types[i].magic,\n            disk_types[i].length) == 0) {\n            target->format = disk_types[i].part_table_type;\n            break;\n        }\n    }\n\n    if (target->format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        VIR_DEBUG(\"cannot determine the target format for '%s'\",\n                  target->path);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct diskType const disk_types[] = {\n    { VIR_STORAGE_POOL_DISK_LVM2, 0x218, 8, 0x31303020324D564CULL },\n    { VIR_STORAGE_POOL_DISK_GPT,  0x200, 8, 0x5452415020494645ULL },\n    { VIR_STORAGE_POOL_DISK_DVH,  0x0,   4, 0x41A9E50BULL },\n    { VIR_STORAGE_POOL_DISK_MAC,  0x0,   2, 0x5245ULL },\n    { VIR_STORAGE_POOL_DISK_BSD,  0x40,  4, 0x82564557ULL },\n    { VIR_STORAGE_POOL_DISK_SUN,  0x1fc, 2, 0xBEDAULL },\n    /*\n     * NOTE: pc98 is funky; the actual signature is 0x55AA (just like dos), so\n     * we can't use that.  At the moment I'm relying on the \"dummy\" IPL\n     * bootloader data that comes from parted.  Luckily, the chances of running\n     * into a pc98 machine running libvirt are approximately nil.\n     */\n    /*{ 0x1fe, 2, 0xAA55UL },*/\n    { VIR_STORAGE_POOL_DISK_PC98, 0x0,   8, 0x314C5049000000CBULL },\n    /*\n     * NOTE: the order is important here; some other disk types (like GPT and\n     * and PC98) also have 0x55AA at this offset.  For that reason, the DOS\n     * one must be the last one.\n     */\n    { VIR_STORAGE_POOL_DISK_DOS,  0x1fe, 2, 0xAA55ULL },\n    { -1,                         0x0,   0, 0x0ULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot determine the target format for '%s'\"",
            "target->path"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer+disk_types[i].offset",
            "&disk_types[i].magic",
            "disk_types[i].length"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read beginning of file '%s'\")",
            "target->path"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read beginning of file '%s'\""
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring failed saferead of file '%s'\"",
            "target->path"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot seek to beginning of file '%s'\")",
            "target->path"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic struct diskType const disk_types[] = {\n    { VIR_STORAGE_POOL_DISK_LVM2, 0x218, 8, 0x31303020324D564CULL },\n    { VIR_STORAGE_POOL_DISK_GPT,  0x200, 8, 0x5452415020494645ULL },\n    { VIR_STORAGE_POOL_DISK_DVH,  0x0,   4, 0x41A9E50BULL },\n    { VIR_STORAGE_POOL_DISK_MAC,  0x0,   2, 0x5245ULL },\n    { VIR_STORAGE_POOL_DISK_BSD,  0x40,  4, 0x82564557ULL },\n    { VIR_STORAGE_POOL_DISK_SUN,  0x1fc, 2, 0xBEDAULL },\n    /*\n     * NOTE: pc98 is funky; the actual signature is 0x55AA (just like dos), so\n     * we can't use that.  At the moment I'm relying on the \"dummy\" IPL\n     * bootloader data that comes from parted.  Luckily, the chances of running\n     * into a pc98 machine running libvirt are approximately nil.\n     */\n    /*{ 0x1fe, 2, 0xAA55UL },*/\n    { VIR_STORAGE_POOL_DISK_PC98, 0x0,   8, 0x314C5049000000CBULL },\n    /*\n     * NOTE: the order is important here; some other disk types (like GPT and\n     * and PC98) also have 0x55AA at this offset.  For that reason, the DOS\n     * one must be the last one.\n     */\n    { VIR_STORAGE_POOL_DISK_DOS,  0x1fe, 2, 0xAA55ULL },\n    { -1,                         0x0,   0, 0x0ULL },\n};\n\nstatic int\nvirStorageBackendDetectBlockVolFormatFD(virStorageSourcePtr target,\n                                        int fd,\n                                        unsigned int readflags)\n{\n    size_t i;\n    off_t start;\n    unsigned char buffer[1024];\n    ssize_t bytes;\n\n    /* make sure to set the target format \"unknown\" to begin with */\n    target->format = VIR_STORAGE_POOL_DISK_UNKNOWN;\n\n    start = lseek(fd, 0, SEEK_SET);\n    if (start < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot seek to beginning of file '%s'\"),\n                             target->path);\n        return -1;\n    }\n    bytes = saferead(fd, buffer, sizeof(buffer));\n    if (bytes < 0) {\n        if (readflags & VIR_STORAGE_VOL_READ_NOERROR) {\n            VIR_WARN(\"ignoring failed saferead of file '%s'\",\n                     target->path);\n            return -2;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"cannot read beginning of file '%s'\"),\n                                 target->path);\n            return -1;\n        }\n    }\n\n    for (i = 0; disk_types[i].part_table_type != -1; i++) {\n        if (disk_types[i].offset + disk_types[i].length > bytes)\n            continue;\n        if (memcmp(buffer+disk_types[i].offset, &disk_types[i].magic,\n            disk_types[i].length) == 0) {\n            target->format = disk_types[i].part_table_type;\n            break;\n        }\n    }\n\n    if (target->format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        VIR_DEBUG(\"cannot determine the target format for '%s'\",\n                  target->path);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendGetBuildVolFromFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1387-1412",
    "snippet": "virStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}"
  },
  {
    "function_name": "virStorageBackendCreateVolUsingQemuImg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1364-1384",
    "snippet": "int\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImg",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1282-1345",
          "snippet": "static int\nstorageBackendCreateQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    int ret = -1;\n    virStorageVolEncryptConvertStep convertStep = VIR_STORAGE_VOL_ENCRYPT_NONE;\n    g_autofree char *create_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *inputSecretPath = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, -1);\n\n    create_tool = virFindFileInPath(\"qemu-img\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\"));\n        return -1;\n    }\n\n    if (vol->target.encryption &&\n        !(secretPath = storageBackendCreateQemuImgSecretPath(pool, vol)))\n        goto cleanup;\n\n    if (inputvol && inputvol->target.encryption &&\n        !(inputSecretPath = storageBackendCreateQemuImgSecretPath(pool,\n                                                                  inputvol)))\n        goto cleanup;\n\n    /* Using an input file for encryption requires a multi-step process\n     * to create an image of the same size as the inputvol and then to\n     * convert the inputvol afterwards. */\n    if ((secretPath || inputSecretPath) && inputvol)\n        convertStep = VIR_STORAGE_VOL_ENCRYPT_CREATE;\n\n    do {\n        ret = storageBackendDoCreateQemuImg(pool, vol, inputvol, flags,\n                                            create_tool, secretPath,\n                                            inputSecretPath, convertStep);\n\n        /* Failure to convert, attempt to delete what we created */\n        if (ret < 0 && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            ignore_value(virFileRemove(vol->target.path,\n                                       vol->target.perms->uid,\n                                       vol->target.perms->gid));\n\n        if (ret < 0 || convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n            goto cleanup;\n\n        if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_CONVERT;\n        else if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_DONE;\n    } while (convertStep != VIR_STORAGE_VOL_ENCRYPT_DONE);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    if (inputSecretPath)\n        unlink(inputSecretPath);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    int ret = -1;\n    virStorageVolEncryptConvertStep convertStep = VIR_STORAGE_VOL_ENCRYPT_NONE;\n    g_autofree char *create_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *inputSecretPath = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, -1);\n\n    create_tool = virFindFileInPath(\"qemu-img\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\"));\n        return -1;\n    }\n\n    if (vol->target.encryption &&\n        !(secretPath = storageBackendCreateQemuImgSecretPath(pool, vol)))\n        goto cleanup;\n\n    if (inputvol && inputvol->target.encryption &&\n        !(inputSecretPath = storageBackendCreateQemuImgSecretPath(pool,\n                                                                  inputvol)))\n        goto cleanup;\n\n    /* Using an input file for encryption requires a multi-step process\n     * to create an image of the same size as the inputvol and then to\n     * convert the inputvol afterwards. */\n    if ((secretPath || inputSecretPath) && inputvol)\n        convertStep = VIR_STORAGE_VOL_ENCRYPT_CREATE;\n\n    do {\n        ret = storageBackendDoCreateQemuImg(pool, vol, inputvol, flags,\n                                            create_tool, secretPath,\n                                            inputSecretPath, convertStep);\n\n        /* Failure to convert, attempt to delete what we created */\n        if (ret < 0 && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            ignore_value(virFileRemove(vol->target.path,\n                                       vol->target.perms->uid,\n                                       vol->target.perms->gid));\n\n        if (ret < 0 || convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n            goto cleanup;\n\n        if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_CONVERT;\n        else if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_DONE;\n    } while (convertStep != VIR_STORAGE_VOL_ENCRYPT_DONE);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    if (inputSecretPath)\n        unlink(inputSecretPath);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1282-1345",
    "snippet": "static int\nstorageBackendCreateQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    int ret = -1;\n    virStorageVolEncryptConvertStep convertStep = VIR_STORAGE_VOL_ENCRYPT_NONE;\n    g_autofree char *create_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *inputSecretPath = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, -1);\n\n    create_tool = virFindFileInPath(\"qemu-img\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\"));\n        return -1;\n    }\n\n    if (vol->target.encryption &&\n        !(secretPath = storageBackendCreateQemuImgSecretPath(pool, vol)))\n        goto cleanup;\n\n    if (inputvol && inputvol->target.encryption &&\n        !(inputSecretPath = storageBackendCreateQemuImgSecretPath(pool,\n                                                                  inputvol)))\n        goto cleanup;\n\n    /* Using an input file for encryption requires a multi-step process\n     * to create an image of the same size as the inputvol and then to\n     * convert the inputvol afterwards. */\n    if ((secretPath || inputSecretPath) && inputvol)\n        convertStep = VIR_STORAGE_VOL_ENCRYPT_CREATE;\n\n    do {\n        ret = storageBackendDoCreateQemuImg(pool, vol, inputvol, flags,\n                                            create_tool, secretPath,\n                                            inputSecretPath, convertStep);\n\n        /* Failure to convert, attempt to delete what we created */\n        if (ret < 0 && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            ignore_value(virFileRemove(vol->target.path,\n                                       vol->target.perms->uid,\n                                       vol->target.perms->gid));\n\n        if (ret < 0 || convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n            goto cleanup;\n\n        if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_CONVERT;\n        else if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_DONE;\n    } while (convertStep != VIR_STORAGE_VOL_ENCRYPT_DONE);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    if (inputSecretPath)\n        unlink(inputSecretPath);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "inputSecretPath"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "secretPath"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFileRemove(vol->target.path,\n                                       vol->target.perms->uid,\n                                       vol->target.perms->gid)"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "vol->target.path",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendDoCreateQemuImg",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags",
            "create_tool",
            "secretPath",
            "inputSecretPath",
            "convertStep"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendDoCreateQemuImg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1259-1279",
          "snippet": "static int\nstorageBackendDoCreateQemuImg(virStoragePoolObjPtr pool,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags,\n                              const char *create_tool,\n                              const char *secretPath,\n                              const char *inputSecretPath,\n                              virStorageVolEncryptConvertStep convertStep)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virStorageBackendCreateQemuImgCmdFromVol(pool, vol, inputvol,\n                                                   flags, create_tool,\n                                                   secretPath, inputSecretPath,\n                                                   convertStep);\n    if (!cmd)\n        return -1;\n\n    return virStorageBackendCreateExecCommand(pool, vol, cmd);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendDoCreateQemuImg(virStoragePoolObjPtr pool,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags,\n                              const char *create_tool,\n                              const char *secretPath,\n                              const char *inputSecretPath,\n                              virStorageVolEncryptConvertStep convertStep)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virStorageBackendCreateQemuImgCmdFromVol(pool, vol, inputvol,\n                                                   flags, create_tool,\n                                                   secretPath, inputSecretPath,\n                                                   convertStep);\n    if (!cmd)\n        return -1;\n\n    return virStorageBackendCreateExecCommand(pool, vol, cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSecretPath",
          "args": [
            "pool",
            "inputvol"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSecretPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1188-1256",
          "snippet": "static char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\")"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\""
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"qemu-img\""
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA",
            "-1"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImg(virStoragePoolObjPtr pool,\n                            virStorageVolDefPtr vol,\n                            virStorageVolDefPtr inputvol,\n                            unsigned int flags)\n{\n    int ret = -1;\n    virStorageVolEncryptConvertStep convertStep = VIR_STORAGE_VOL_ENCRYPT_NONE;\n    g_autofree char *create_tool = NULL;\n    g_autofree char *secretPath = NULL;\n    g_autofree char *inputSecretPath = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, -1);\n\n    create_tool = virFindFileInPath(\"qemu-img\");\n    if (!create_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of non-raw file images is \"\n                         \"not supported without qemu-img.\"));\n        return -1;\n    }\n\n    if (vol->target.encryption &&\n        !(secretPath = storageBackendCreateQemuImgSecretPath(pool, vol)))\n        goto cleanup;\n\n    if (inputvol && inputvol->target.encryption &&\n        !(inputSecretPath = storageBackendCreateQemuImgSecretPath(pool,\n                                                                  inputvol)))\n        goto cleanup;\n\n    /* Using an input file for encryption requires a multi-step process\n     * to create an image of the same size as the inputvol and then to\n     * convert the inputvol afterwards. */\n    if ((secretPath || inputSecretPath) && inputvol)\n        convertStep = VIR_STORAGE_VOL_ENCRYPT_CREATE;\n\n    do {\n        ret = storageBackendDoCreateQemuImg(pool, vol, inputvol, flags,\n                                            create_tool, secretPath,\n                                            inputSecretPath, convertStep);\n\n        /* Failure to convert, attempt to delete what we created */\n        if (ret < 0 && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            ignore_value(virFileRemove(vol->target.path,\n                                       vol->target.perms->uid,\n                                       vol->target.perms->gid));\n\n        if (ret < 0 || convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n            goto cleanup;\n\n        if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_CONVERT;\n        else if (convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n            convertStep = VIR_STORAGE_VOL_ENCRYPT_DONE;\n    } while (convertStep != VIR_STORAGE_VOL_ENCRYPT_DONE);\n\n cleanup:\n    if (secretPath)\n        unlink(secretPath);\n    if (inputSecretPath)\n        unlink(inputSecretPath);\n    return ret;\n}"
  },
  {
    "function_name": "storageBackendDoCreateQemuImg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1259-1279",
    "snippet": "static int\nstorageBackendDoCreateQemuImg(virStoragePoolObjPtr pool,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags,\n                              const char *create_tool,\n                              const char *secretPath,\n                              const char *inputSecretPath,\n                              virStorageVolEncryptConvertStep convertStep)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virStorageBackendCreateQemuImgCmdFromVol(pool, vol, inputvol,\n                                                   flags, create_tool,\n                                                   secretPath, inputSecretPath,\n                                                   convertStep);\n    if (!cmd)\n        return -1;\n\n    return virStorageBackendCreateExecCommand(pool, vol, cmd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendCreateExecCommand",
          "args": [
            "pool",
            "vol",
            "cmd"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateExecCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "492-588",
          "snippet": "static int\nvirStorageBackendCreateExecCommand(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virCommandPtr cmd)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode = (vol->target.perms->mode == (mode_t)-1 ?\n                   VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                   vol->target.perms->mode);\n    bool filecreated = false;\n    int ret = -1;\n\n    if ((def->type == VIR_STORAGE_POOL_NETFS)\n        && (((geteuid() == 0)\n             && (vol->target.perms->uid != (uid_t)-1)\n             && (vol->target.perms->uid != 0))\n            || ((vol->target.perms->gid != (gid_t)-1)\n                && (vol->target.perms->gid != getegid())))) {\n\n        virCommandSetUID(cmd, vol->target.perms->uid);\n        virCommandSetGID(cmd, vol->target.perms->gid);\n        virCommandSetUmask(cmd, S_IRWXUGO ^ mode);\n\n        if (virCommandRun(cmd, NULL) == 0) {\n            /* command was successfully run, check if the file was created */\n            if (stat(vol->target.path, &st) >= 0) {\n                filecreated = true;\n\n                /* seems qemu-img disregards umask and open/creates using 0644.\n                 * If that doesn't match what we expect, then let's try to\n                 * re-open the file and attempt to force the mode change.\n                 */\n                if (mode != (st.st_mode & S_IRWXUGO)) {\n                    VIR_AUTOCLOSE fd = -1;\n                    int flags = VIR_FILE_OPEN_FORK | VIR_FILE_OPEN_FORCE_MODE;\n\n                    if ((fd = virFileOpenAs(vol->target.path, O_RDWR, mode,\n                                            vol->target.perms->uid,\n                                            vol->target.perms->gid,\n                                            flags)) >= 0) {\n                        /* Success - means we're good */\n                        ret = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filecreated) {\n        /* don't change uid/gid/mode if we retry */\n        virCommandSetUID(cmd, -1);\n        virCommandSetGID(cmd, -1);\n        virCommandSetUmask(cmd, 0);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n        if (stat(vol->target.path, &st) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create %s\"), vol->target.path);\n            goto cleanup;\n        }\n        filecreated = true;\n    }\n\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (chown(vol->target.path, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown %s to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        goto cleanup;\n    }\n\n    if (mode != (st.st_mode & S_IRWXUGO) &&\n        chmod(vol->target.path, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && filecreated)\n        virFileRemove(vol->target.path, vol->target.perms->uid,\n                      vol->target.perms->gid);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendCreateExecCommand(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virCommandPtr cmd)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode = (vol->target.perms->mode == (mode_t)-1 ?\n                   VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                   vol->target.perms->mode);\n    bool filecreated = false;\n    int ret = -1;\n\n    if ((def->type == VIR_STORAGE_POOL_NETFS)\n        && (((geteuid() == 0)\n             && (vol->target.perms->uid != (uid_t)-1)\n             && (vol->target.perms->uid != 0))\n            || ((vol->target.perms->gid != (gid_t)-1)\n                && (vol->target.perms->gid != getegid())))) {\n\n        virCommandSetUID(cmd, vol->target.perms->uid);\n        virCommandSetGID(cmd, vol->target.perms->gid);\n        virCommandSetUmask(cmd, S_IRWXUGO ^ mode);\n\n        if (virCommandRun(cmd, NULL) == 0) {\n            /* command was successfully run, check if the file was created */\n            if (stat(vol->target.path, &st) >= 0) {\n                filecreated = true;\n\n                /* seems qemu-img disregards umask and open/creates using 0644.\n                 * If that doesn't match what we expect, then let's try to\n                 * re-open the file and attempt to force the mode change.\n                 */\n                if (mode != (st.st_mode & S_IRWXUGO)) {\n                    VIR_AUTOCLOSE fd = -1;\n                    int flags = VIR_FILE_OPEN_FORK | VIR_FILE_OPEN_FORCE_MODE;\n\n                    if ((fd = virFileOpenAs(vol->target.path, O_RDWR, mode,\n                                            vol->target.perms->uid,\n                                            vol->target.perms->gid,\n                                            flags)) >= 0) {\n                        /* Success - means we're good */\n                        ret = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filecreated) {\n        /* don't change uid/gid/mode if we retry */\n        virCommandSetUID(cmd, -1);\n        virCommandSetGID(cmd, -1);\n        virCommandSetUmask(cmd, 0);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n        if (stat(vol->target.path, &st) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create %s\"), vol->target.path);\n            goto cleanup;\n        }\n        filecreated = true;\n    }\n\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (chown(vol->target.path, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown %s to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        goto cleanup;\n    }\n\n    if (mode != (st.st_mode & S_IRWXUGO) &&\n        chmod(vol->target.path, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && filecreated)\n        virFileRemove(vol->target.path, vol->target.perms->uid,\n                      vol->target.perms->gid);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCreateQemuImgCmdFromVol",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags",
            "create_tool",
            "secretPath",
            "inputSecretPath",
            "convertStep"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateQemuImgCmdFromVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1052-1185",
          "snippet": "virCommandPtr\nvirStorageBackendCreateQemuImgCmdFromVol(virStoragePoolObjPtr pool,\n                                         virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol,\n                                         unsigned int flags,\n                                         const char *create_tool,\n                                         const char *secretPath,\n                                         const char *inputSecretPath,\n                                         virStorageVolEncryptConvertStep convertStep)\n{\n    virCommandPtr cmd = NULL;\n    struct _virStorageBackendQemuImgInfo info = {\n        .format = vol->target.format,\n        .type = NULL,\n        .inputType = NULL,\n        .path = vol->target.path,\n        .allocation = vol->target.allocation,\n        .encryption = !!vol->target.encryption,\n        .preallocate = !!(flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA),\n        .compat = vol->target.compat,\n        .features = vol->target.features,\n        .nocow = vol->target.nocow,\n        .secretAlias = NULL,\n    };\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    virStorageEncryptionPtr inputenc = inputvol ? inputvol->target.encryption : NULL;\n    virStorageEncryptionInfoDefPtr encinfo = NULL;\n    g_autofree char *inputSecretAlias = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"creation of qcow2 encrypted image is not supported\"));\n        goto error;\n    }\n\n    if (inputenc && inputenc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encryption format of inputvol must be LUKS\"));\n        goto error;\n    }\n\n    if (virStorageBackendCreateQemuImgSetInfo(pool, vol, inputvol,\n                                              convertStep, &info) < 0)\n        goto error;\n\n    cmd = virCommandNew(create_tool);\n\n    /* ignore the backing volume when we're converting a volume\n     * including when we're doing a two step convert during create */\n    if (info.inputPath || convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n        info.backingPath = NULL;\n\n    /* Converting to use encryption is a two step process - step 1 is to\n     * create the image and step 2 is to convert it using special arguments */\n    if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n        virCommandAddArgList(cmd, \"convert\", \"-f\", info.inputFormatStr,\n                             \"-O\", info.type, NULL);\n    else if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n        virCommandAddArgList(cmd, \"convert\", \"--image-opts\", \"-n\",\n                             \"--target-image-opts\", NULL);\n    else\n        virCommandAddArgList(cmd, \"create\", \"-f\", info.type, NULL);\n\n    if (info.backingPath)\n        virCommandAddArgList(cmd, \"-b\", info.backingPath, NULL);\n\n    if (enc) {\n        if (!secretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to secret data file is required\"));\n            goto error;\n        }\n        info.secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    info.secretAlias) < 0)\n            goto error;\n        encinfo = &enc->encinfo;\n    }\n\n    if (inputenc && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (!inputSecretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to inputvol secret data file is required\"));\n            goto error;\n        }\n        inputSecretAlias = g_strdup_printf(\"%s_encrypt0\", inputvol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, inputSecretPath,\n                                                    inputSecretAlias) < 0)\n            goto error;\n    }\n\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (storageBackendCreateQemuImgSetOptions(cmd, encinfo, &info) < 0)\n            goto error;\n        if (info.inputPath)\n            virCommandAddArg(cmd, info.inputPath);\n        virCommandAddArg(cmd, info.path);\n        if (!info.inputPath && (info.size_arg || !info.backingPath))\n            virCommandAddArgFormat(cmd, \"%lluK\", info.size_arg);\n    } else {\n        /* source */\n        if (inputenc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=luks,file.filename=%s,key-secret=%s\",\n                                   info.inputPath, inputSecretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.inputType ? info.inputType : \"raw\",\n                                   info.inputPath);\n\n        /* dest */\n        if (enc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=%s,file.filename=%s,key-secret=%s\",\n                                   info.type, info.path, info.secretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.type, info.path);\n\n    }\n    VIR_FREE(info.secretAlias);\n\n    return cmd;\n\n error:\n    VIR_FREE(info.secretAlias);\n    virCommandFree(cmd);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirCommandPtr\nvirStorageBackendCreateQemuImgCmdFromVol(virStoragePoolObjPtr pool,\n                                         virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol,\n                                         unsigned int flags,\n                                         const char *create_tool,\n                                         const char *secretPath,\n                                         const char *inputSecretPath,\n                                         virStorageVolEncryptConvertStep convertStep)\n{\n    virCommandPtr cmd = NULL;\n    struct _virStorageBackendQemuImgInfo info = {\n        .format = vol->target.format,\n        .type = NULL,\n        .inputType = NULL,\n        .path = vol->target.path,\n        .allocation = vol->target.allocation,\n        .encryption = !!vol->target.encryption,\n        .preallocate = !!(flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA),\n        .compat = vol->target.compat,\n        .features = vol->target.features,\n        .nocow = vol->target.nocow,\n        .secretAlias = NULL,\n    };\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    virStorageEncryptionPtr inputenc = inputvol ? inputvol->target.encryption : NULL;\n    virStorageEncryptionInfoDefPtr encinfo = NULL;\n    g_autofree char *inputSecretAlias = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"creation of qcow2 encrypted image is not supported\"));\n        goto error;\n    }\n\n    if (inputenc && inputenc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encryption format of inputvol must be LUKS\"));\n        goto error;\n    }\n\n    if (virStorageBackendCreateQemuImgSetInfo(pool, vol, inputvol,\n                                              convertStep, &info) < 0)\n        goto error;\n\n    cmd = virCommandNew(create_tool);\n\n    /* ignore the backing volume when we're converting a volume\n     * including when we're doing a two step convert during create */\n    if (info.inputPath || convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n        info.backingPath = NULL;\n\n    /* Converting to use encryption is a two step process - step 1 is to\n     * create the image and step 2 is to convert it using special arguments */\n    if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n        virCommandAddArgList(cmd, \"convert\", \"-f\", info.inputFormatStr,\n                             \"-O\", info.type, NULL);\n    else if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n        virCommandAddArgList(cmd, \"convert\", \"--image-opts\", \"-n\",\n                             \"--target-image-opts\", NULL);\n    else\n        virCommandAddArgList(cmd, \"create\", \"-f\", info.type, NULL);\n\n    if (info.backingPath)\n        virCommandAddArgList(cmd, \"-b\", info.backingPath, NULL);\n\n    if (enc) {\n        if (!secretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to secret data file is required\"));\n            goto error;\n        }\n        info.secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    info.secretAlias) < 0)\n            goto error;\n        encinfo = &enc->encinfo;\n    }\n\n    if (inputenc && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (!inputSecretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to inputvol secret data file is required\"));\n            goto error;\n        }\n        inputSecretAlias = g_strdup_printf(\"%s_encrypt0\", inputvol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, inputSecretPath,\n                                                    inputSecretAlias) < 0)\n            goto error;\n    }\n\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (storageBackendCreateQemuImgSetOptions(cmd, encinfo, &info) < 0)\n            goto error;\n        if (info.inputPath)\n            virCommandAddArg(cmd, info.inputPath);\n        virCommandAddArg(cmd, info.path);\n        if (!info.inputPath && (info.size_arg || !info.backingPath))\n            virCommandAddArgFormat(cmd, \"%lluK\", info.size_arg);\n    } else {\n        /* source */\n        if (inputenc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=luks,file.filename=%s,key-secret=%s\",\n                                   info.inputPath, inputSecretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.inputType ? info.inputType : \"raw\",\n                                   info.inputPath);\n\n        /* dest */\n        if (enc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=%s,file.filename=%s,key-secret=%s\",\n                                   info.type, info.path, info.secretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.type, info.path);\n\n    }\n    VIR_FREE(info.secretAlias);\n\n    return cmd;\n\n error:\n    VIR_FREE(info.secretAlias);\n    virCommandFree(cmd);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendDoCreateQemuImg(virStoragePoolObjPtr pool,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags,\n                              const char *create_tool,\n                              const char *secretPath,\n                              const char *inputSecretPath,\n                              virStorageVolEncryptConvertStep convertStep)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virStorageBackendCreateQemuImgCmdFromVol(pool, vol, inputvol,\n                                                   flags, create_tool,\n                                                   secretPath, inputSecretPath,\n                                                   convertStep);\n    if (!cmd)\n        return -1;\n\n    return virStorageBackendCreateExecCommand(pool, vol, cmd);\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgSecretPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1188-1256",
    "snippet": "static char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secretPath"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "secretPath"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "secret",
            "secretlen"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to chown secret file\")"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to chown secret file\""
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "secretPath",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to write secret file\")"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "secret",
            "secretlen"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecretGetSecretString",
          "args": [
            "conn",
            "&enc->secrets[0]->seclookupdef",
            "VIR_SECRET_USAGE_TYPE_VOLUME",
            "&secret",
            "&secretlen"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretGetSecretString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "143-195",
          "snippet": "int\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to open secret file for write\")"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mkstemp_full",
          "args": [
            "secretPath",
            "O_RDWR | O_CLOEXEC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjBuildTempFilePath",
          "args": [
            "pool",
            "vol"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjBuildTempFilePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2836-2847",
          "snippet": "char *\nvirStoragePoolObjBuildTempFilePath(virStoragePoolObjPtr obj,\n                                   virStorageVolDefPtr voldef)\n\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(obj);\n    char *tmp = NULL;\n\n    tmp = g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\",\n                          driver->stateDir, def->name, voldef->name);\n    return tmp;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageDriverStatePtr driver;\n\nchar *\nvirStoragePoolObjBuildTempFilePath(virStoragePoolObjPtr obj,\n                                   virStorageVolDefPtr voldef)\n\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(obj);\n    char *tmp = NULL;\n\n    tmp = g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\",\n                          driver->stateDir, def->name, voldef->name);\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectSecret",
          "args": [],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectSecret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "184-187",
          "snippet": "virConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectSecret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectSecret;\n\nvirConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\")"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing encryption description\")"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nstorageBackendCreateQemuImgSecretPath(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    char *secretPath = NULL;\n    uint8_t *secret = NULL;\n    size_t secretlen = 0;\n    virConnectPtr conn = NULL;\n    VIR_AUTOCLOSE fd = -1;\n\n    if (!enc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing encryption description\"));\n        return NULL;\n    }\n\n    if (enc->nsecrets != 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"A single <secret type='passphrase'...> \"\n                         \"element is expected in encryption description\"));\n        return NULL;\n    }\n\n    conn = virGetConnectSecret();\n    if (!conn)\n        return NULL;\n\n    if (!(secretPath = virStoragePoolObjBuildTempFilePath(pool, vol)))\n        goto cleanup;\n\n    if ((fd = g_mkstemp_full(secretPath, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to open secret file for write\"));\n        goto error;\n    }\n\n    if (virSecretGetSecretString(conn, &enc->secrets[0]->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_VOLUME,\n                                 &secret, &secretlen) < 0)\n        goto error;\n\n    if (safewrite(fd, secret, secretlen) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to write secret file\"));\n        goto error;\n    }\n\n    if ((vol->target.perms->uid != (uid_t)-1) &&\n        (vol->target.perms->gid != (gid_t)-1)) {\n        if (chown(secretPath, vol->target.perms->uid,\n                  vol->target.perms->gid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to chown secret file\"));\n            goto error;\n        }\n    }\n\n cleanup:\n    virObjectUnref(conn);\n    VIR_DISPOSE_N(secret, secretlen);\n\n    return secretPath;\n\n error:\n    unlink(secretPath);\n    VIR_FREE(secretPath);\n    goto cleanup;\n}"
  },
  {
    "function_name": "virStorageBackendCreateQemuImgCmdFromVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "1052-1185",
    "snippet": "virCommandPtr\nvirStorageBackendCreateQemuImgCmdFromVol(virStoragePoolObjPtr pool,\n                                         virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol,\n                                         unsigned int flags,\n                                         const char *create_tool,\n                                         const char *secretPath,\n                                         const char *inputSecretPath,\n                                         virStorageVolEncryptConvertStep convertStep)\n{\n    virCommandPtr cmd = NULL;\n    struct _virStorageBackendQemuImgInfo info = {\n        .format = vol->target.format,\n        .type = NULL,\n        .inputType = NULL,\n        .path = vol->target.path,\n        .allocation = vol->target.allocation,\n        .encryption = !!vol->target.encryption,\n        .preallocate = !!(flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA),\n        .compat = vol->target.compat,\n        .features = vol->target.features,\n        .nocow = vol->target.nocow,\n        .secretAlias = NULL,\n    };\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    virStorageEncryptionPtr inputenc = inputvol ? inputvol->target.encryption : NULL;\n    virStorageEncryptionInfoDefPtr encinfo = NULL;\n    g_autofree char *inputSecretAlias = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"creation of qcow2 encrypted image is not supported\"));\n        goto error;\n    }\n\n    if (inputenc && inputenc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encryption format of inputvol must be LUKS\"));\n        goto error;\n    }\n\n    if (virStorageBackendCreateQemuImgSetInfo(pool, vol, inputvol,\n                                              convertStep, &info) < 0)\n        goto error;\n\n    cmd = virCommandNew(create_tool);\n\n    /* ignore the backing volume when we're converting a volume\n     * including when we're doing a two step convert during create */\n    if (info.inputPath || convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n        info.backingPath = NULL;\n\n    /* Converting to use encryption is a two step process - step 1 is to\n     * create the image and step 2 is to convert it using special arguments */\n    if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n        virCommandAddArgList(cmd, \"convert\", \"-f\", info.inputFormatStr,\n                             \"-O\", info.type, NULL);\n    else if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n        virCommandAddArgList(cmd, \"convert\", \"--image-opts\", \"-n\",\n                             \"--target-image-opts\", NULL);\n    else\n        virCommandAddArgList(cmd, \"create\", \"-f\", info.type, NULL);\n\n    if (info.backingPath)\n        virCommandAddArgList(cmd, \"-b\", info.backingPath, NULL);\n\n    if (enc) {\n        if (!secretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to secret data file is required\"));\n            goto error;\n        }\n        info.secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    info.secretAlias) < 0)\n            goto error;\n        encinfo = &enc->encinfo;\n    }\n\n    if (inputenc && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (!inputSecretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to inputvol secret data file is required\"));\n            goto error;\n        }\n        inputSecretAlias = g_strdup_printf(\"%s_encrypt0\", inputvol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, inputSecretPath,\n                                                    inputSecretAlias) < 0)\n            goto error;\n    }\n\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (storageBackendCreateQemuImgSetOptions(cmd, encinfo, &info) < 0)\n            goto error;\n        if (info.inputPath)\n            virCommandAddArg(cmd, info.inputPath);\n        virCommandAddArg(cmd, info.path);\n        if (!info.inputPath && (info.size_arg || !info.backingPath))\n            virCommandAddArgFormat(cmd, \"%lluK\", info.size_arg);\n    } else {\n        /* source */\n        if (inputenc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=luks,file.filename=%s,key-secret=%s\",\n                                   info.inputPath, inputSecretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.inputType ? info.inputType : \"raw\",\n                                   info.inputPath);\n\n        /* dest */\n        if (enc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=%s,file.filename=%s,key-secret=%s\",\n                                   info.type, info.path, info.secretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.type, info.path);\n\n    }\n    VIR_FREE(info.secretAlias);\n\n    return cmd;\n\n error:\n    VIR_FREE(info.secretAlias);\n    virCommandFree(cmd);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info.secretAlias"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info.secretAlias"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"driver=%s,file.filename=%s\"",
            "info.type",
            "info.path"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "info.path"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSetOptions",
          "args": [
            "cmd",
            "encinfo",
            "&info"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSetOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "911-924",
          "snippet": "static int\nstorageBackendCreateQemuImgSetOptions(virCommandPtr cmd,\n                                      virStorageEncryptionInfoDefPtr encinfo,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    g_autofree char *opts = NULL;\n\n    if (storageBackendCreateQemuImgOpts(encinfo, &opts, info) < 0)\n        return -1;\n    if (opts)\n        virCommandAddArgList(cmd, \"-o\", opts, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetOptions(virCommandPtr cmd,\n                                      virStorageEncryptionInfoDefPtr encinfo,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    g_autofree char *opts = NULL;\n\n    if (storageBackendCreateQemuImgOpts(encinfo, &opts, info) < 0)\n        return -1;\n    if (opts)\n        virCommandAddArgList(cmd, \"-o\", opts, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSecretObject",
          "args": [
            "cmd",
            "inputSecretPath",
            "inputSecretAlias"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSecretObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "932-948",
          "snippet": "static int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s_encrypt0\"",
            "inputvol->name"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"path to inputvol secret data file is required\")"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"path to secret data file is required\")"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "create_tool"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCreateQemuImgSetInfo",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "convertStep",
            "&info"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateQemuImgSetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "976-1048",
          "snippet": "static int\nvirStorageBackendCreateQemuImgSetInfo(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      virStorageVolEncryptConvertStep convertStep,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    /* Treat output block devices as 'raw' format */\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (info->format == VIR_STORAGE_FILE_ISO)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(info->type = virStorageFileFormatTypeToString(info->format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->format);\n        return -1;\n    }\n\n    if (inputvol &&\n        !(info->inputType =\n          virStorageFileFormatTypeToString(inputvol->target.format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown inputvol storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (info->preallocate && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation only available with qcow2\"));\n        return -1;\n    }\n    if (info->compat && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"compatibility option only available with qcow2\"));\n        return -1;\n    }\n    if (info->features && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"format features only available with qcow2\"));\n        return -1;\n    }\n    if (info->format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (vol->target.encryption->format == VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            info->type = \"luks\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only luks encryption is supported for raw files\"));\n            return -1;\n        }\n    }\n\n    if (inputvol &&\n        storageBackendCreateQemuImgSetInput(inputvol, convertStep, info) < 0)\n        return -1;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        storageBackendCreateQemuImgSetBacking(pool, vol, inputvol, info) < 0)\n        return -1;\n\n    if (info->encryption &&\n        storageBackendCreateQemuImgCheckEncryption(info->format, info->type,\n                                                   vol) < 0)\n        return -1;\n\n    /* Size in KB */\n    info->size_arg = VIR_DIV_UP(vol->target.capacity, 1024);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendCreateQemuImgSetInfo(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      virStorageVolEncryptConvertStep convertStep,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    /* Treat output block devices as 'raw' format */\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (info->format == VIR_STORAGE_FILE_ISO)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(info->type = virStorageFileFormatTypeToString(info->format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->format);\n        return -1;\n    }\n\n    if (inputvol &&\n        !(info->inputType =\n          virStorageFileFormatTypeToString(inputvol->target.format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown inputvol storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (info->preallocate && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation only available with qcow2\"));\n        return -1;\n    }\n    if (info->compat && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"compatibility option only available with qcow2\"));\n        return -1;\n    }\n    if (info->features && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"format features only available with qcow2\"));\n        return -1;\n    }\n    if (info->format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (vol->target.encryption->format == VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            info->type = \"luks\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only luks encryption is supported for raw files\"));\n            return -1;\n        }\n    }\n\n    if (inputvol &&\n        storageBackendCreateQemuImgSetInput(inputvol, convertStep, info) < 0)\n        return -1;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        storageBackendCreateQemuImgSetBacking(pool, vol, inputvol, info) < 0)\n        return -1;\n\n    if (info->encryption &&\n        storageBackendCreateQemuImgCheckEncryption(info->format, info->type,\n                                                   vol) < 0)\n        return -1;\n\n    /* Size in KB */\n    info->size_arg = VIR_DIV_UP(vol->target.capacity, 1024);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"encryption format of inputvol must be LUKS\")"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"creation of qcow2 encrypted image is not supported\")"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA",
            "NULL"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirCommandPtr\nvirStorageBackendCreateQemuImgCmdFromVol(virStoragePoolObjPtr pool,\n                                         virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol,\n                                         unsigned int flags,\n                                         const char *create_tool,\n                                         const char *secretPath,\n                                         const char *inputSecretPath,\n                                         virStorageVolEncryptConvertStep convertStep)\n{\n    virCommandPtr cmd = NULL;\n    struct _virStorageBackendQemuImgInfo info = {\n        .format = vol->target.format,\n        .type = NULL,\n        .inputType = NULL,\n        .path = vol->target.path,\n        .allocation = vol->target.allocation,\n        .encryption = !!vol->target.encryption,\n        .preallocate = !!(flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA),\n        .compat = vol->target.compat,\n        .features = vol->target.features,\n        .nocow = vol->target.nocow,\n        .secretAlias = NULL,\n    };\n    virStorageEncryptionPtr enc = vol->target.encryption;\n    virStorageEncryptionPtr inputenc = inputvol ? inputvol->target.encryption : NULL;\n    virStorageEncryptionInfoDefPtr encinfo = NULL;\n    g_autofree char *inputSecretAlias = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (enc && (enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_QCOW ||\n                enc->format == VIR_STORAGE_ENCRYPTION_FORMAT_DEFAULT) &&\n        (vol->target.format == VIR_STORAGE_FILE_QCOW ||\n         vol->target.format == VIR_STORAGE_FILE_QCOW2)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"creation of qcow2 encrypted image is not supported\"));\n        goto error;\n    }\n\n    if (inputenc && inputenc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encryption format of inputvol must be LUKS\"));\n        goto error;\n    }\n\n    if (virStorageBackendCreateQemuImgSetInfo(pool, vol, inputvol,\n                                              convertStep, &info) < 0)\n        goto error;\n\n    cmd = virCommandNew(create_tool);\n\n    /* ignore the backing volume when we're converting a volume\n     * including when we're doing a two step convert during create */\n    if (info.inputPath || convertStep == VIR_STORAGE_VOL_ENCRYPT_CREATE)\n        info.backingPath = NULL;\n\n    /* Converting to use encryption is a two step process - step 1 is to\n     * create the image and step 2 is to convert it using special arguments */\n    if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_NONE)\n        virCommandAddArgList(cmd, \"convert\", \"-f\", info.inputFormatStr,\n                             \"-O\", info.type, NULL);\n    else if (info.inputPath && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT)\n        virCommandAddArgList(cmd, \"convert\", \"--image-opts\", \"-n\",\n                             \"--target-image-opts\", NULL);\n    else\n        virCommandAddArgList(cmd, \"create\", \"-f\", info.type, NULL);\n\n    if (info.backingPath)\n        virCommandAddArgList(cmd, \"-b\", info.backingPath, NULL);\n\n    if (enc) {\n        if (!secretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to secret data file is required\"));\n            goto error;\n        }\n        info.secretAlias = g_strdup_printf(\"%s_encrypt0\", vol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, secretPath,\n                                                    info.secretAlias) < 0)\n            goto error;\n        encinfo = &enc->encinfo;\n    }\n\n    if (inputenc && convertStep == VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (!inputSecretPath) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"path to inputvol secret data file is required\"));\n            goto error;\n        }\n        inputSecretAlias = g_strdup_printf(\"%s_encrypt0\", inputvol->name);\n        if (storageBackendCreateQemuImgSecretObject(cmd, inputSecretPath,\n                                                    inputSecretAlias) < 0)\n            goto error;\n    }\n\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CONVERT) {\n        if (storageBackendCreateQemuImgSetOptions(cmd, encinfo, &info) < 0)\n            goto error;\n        if (info.inputPath)\n            virCommandAddArg(cmd, info.inputPath);\n        virCommandAddArg(cmd, info.path);\n        if (!info.inputPath && (info.size_arg || !info.backingPath))\n            virCommandAddArgFormat(cmd, \"%lluK\", info.size_arg);\n    } else {\n        /* source */\n        if (inputenc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=luks,file.filename=%s,key-secret=%s\",\n                                   info.inputPath, inputSecretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.inputType ? info.inputType : \"raw\",\n                                   info.inputPath);\n\n        /* dest */\n        if (enc)\n            virCommandAddArgFormat(cmd,\n                                   \"driver=%s,file.filename=%s,key-secret=%s\",\n                                   info.type, info.path, info.secretAlias);\n        else\n            virCommandAddArgFormat(cmd, \"driver=%s,file.filename=%s\",\n                                   info.type, info.path);\n\n    }\n    VIR_FREE(info.secretAlias);\n\n    return cmd;\n\n error:\n    VIR_FREE(info.secretAlias);\n    virCommandFree(cmd);\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageBackendCreateQemuImgSetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "976-1048",
    "snippet": "static int\nvirStorageBackendCreateQemuImgSetInfo(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      virStorageVolEncryptConvertStep convertStep,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    /* Treat output block devices as 'raw' format */\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (info->format == VIR_STORAGE_FILE_ISO)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(info->type = virStorageFileFormatTypeToString(info->format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->format);\n        return -1;\n    }\n\n    if (inputvol &&\n        !(info->inputType =\n          virStorageFileFormatTypeToString(inputvol->target.format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown inputvol storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (info->preallocate && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation only available with qcow2\"));\n        return -1;\n    }\n    if (info->compat && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"compatibility option only available with qcow2\"));\n        return -1;\n    }\n    if (info->features && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"format features only available with qcow2\"));\n        return -1;\n    }\n    if (info->format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (vol->target.encryption->format == VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            info->type = \"luks\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only luks encryption is supported for raw files\"));\n            return -1;\n        }\n    }\n\n    if (inputvol &&\n        storageBackendCreateQemuImgSetInput(inputvol, convertStep, info) < 0)\n        return -1;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        storageBackendCreateQemuImgSetBacking(pool, vol, inputvol, info) < 0)\n        return -1;\n\n    if (info->encryption &&\n        storageBackendCreateQemuImgCheckEncryption(info->format, info->type,\n                                                   vol) < 0)\n        return -1;\n\n    /* Size in KB */\n    info->size_arg = VIR_DIV_UP(vol->target.capacity, 1024);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "vol->target.capacity",
            "1024"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgCheckEncryption",
          "args": [
            "info->format",
            "info->type",
            "vol"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgCheckEncryption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "778-815",
          "snippet": "static int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSetBacking",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "info"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSetBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "848-908",
          "snippet": "static int\nstorageBackendCreateQemuImgSetBacking(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int accessRetCode = -1;\n    g_autofree char *absolutePath = NULL;\n\n    if (info->format == VIR_STORAGE_FILE_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cannot set backing store for raw volume\"));\n        return -1;\n    }\n\n    info->backingFormat = vol->target.backingStore->format;\n    info->backingPath = vol->target.backingStore->path;\n\n    if (info->preallocate) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation conflicts with backing\"\n                         \" store\"));\n        return -1;\n    }\n\n    /* XXX: Not strictly required: qemu-img has an option a different\n     * backing store, not really sure what use it serves though, and it\n     * may cause issues with lvm. Untested essentially.\n     */\n    if (inputvol && virStorageSourceHasBacking(&inputvol->target) &&\n        STRNEQ_NULLABLE(inputvol->target.backingStore->path,\n                        info->backingPath)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"a different backing store cannot be specified.\"));\n        return -1;\n    }\n\n    if (!virStorageFileFormatTypeToString(info->backingFormat)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol backing store type %d\"),\n                       info->backingFormat);\n        return -1;\n    }\n\n    /* Convert relative backing store paths to absolute paths for access\n     * validation.\n     */\n    if (*(info->backingPath) != '/')\n        absolutePath = g_strdup_printf(\"%s/%s\", def->target.path, info->backingPath);\n    accessRetCode = access(absolutePath ? absolutePath :\n                           info->backingPath, R_OK);\n    if (accessRetCode != 0) {\n        virReportSystemError(errno,\n                             _(\"inaccessible backing store volume %s\"),\n                             info->backingPath);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetBacking(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int accessRetCode = -1;\n    g_autofree char *absolutePath = NULL;\n\n    if (info->format == VIR_STORAGE_FILE_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cannot set backing store for raw volume\"));\n        return -1;\n    }\n\n    info->backingFormat = vol->target.backingStore->format;\n    info->backingPath = vol->target.backingStore->path;\n\n    if (info->preallocate) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation conflicts with backing\"\n                         \" store\"));\n        return -1;\n    }\n\n    /* XXX: Not strictly required: qemu-img has an option a different\n     * backing store, not really sure what use it serves though, and it\n     * may cause issues with lvm. Untested essentially.\n     */\n    if (inputvol && virStorageSourceHasBacking(&inputvol->target) &&\n        STRNEQ_NULLABLE(inputvol->target.backingStore->path,\n                        info->backingPath)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"a different backing store cannot be specified.\"));\n        return -1;\n    }\n\n    if (!virStorageFileFormatTypeToString(info->backingFormat)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol backing store type %d\"),\n                       info->backingFormat);\n        return -1;\n    }\n\n    /* Convert relative backing store paths to absolute paths for access\n     * validation.\n     */\n    if (*(info->backingPath) != '/')\n        absolutePath = g_strdup_printf(\"%s/%s\", def->target.path, info->backingPath);\n    accessRetCode = access(absolutePath ? absolutePath :\n                           info->backingPath, R_OK);\n    if (accessRetCode != 0) {\n        virReportSystemError(errno,\n                             _(\"inaccessible backing store volume %s\"),\n                             info->backingPath);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgSetInput",
          "args": [
            "inputvol",
            "convertStep",
            "info"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgSetInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "818-845",
          "snippet": "static int\nstorageBackendCreateQemuImgSetInput(virStorageVolDefPtr inputvol,\n                                    virStorageVolEncryptConvertStep convertStep,\n                                    struct _virStorageBackendQemuImgInfo *info)\n{\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CREATE) {\n        if (!(info->inputPath = inputvol->target.path)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing input volume target path\"));\n            return -1;\n        }\n    }\n\n    info->inputFormat = inputvol->target.format;\n    if (inputvol->type == VIR_STORAGE_VOL_BLOCK)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (info->inputFormat == VIR_STORAGE_FILE_ISO)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (!(info->inputFormatStr =\n          virStorageFileFormatTypeToString(info->inputFormat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->inputFormat);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetInput(virStorageVolDefPtr inputvol,\n                                    virStorageVolEncryptConvertStep convertStep,\n                                    struct _virStorageBackendQemuImgInfo *info)\n{\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CREATE) {\n        if (!(info->inputPath = inputvol->target.path)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing input volume target path\"));\n            return -1;\n        }\n    }\n\n    info->inputFormat = inputvol->target.format;\n    if (inputvol->type == VIR_STORAGE_VOL_BLOCK)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (info->inputFormat == VIR_STORAGE_FILE_ISO)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (!(info->inputFormatStr =\n          virStorageFileFormatTypeToString(info->inputFormat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->inputFormat);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Only luks encryption is supported for raw files\")"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Only luks encryption is supported for raw files\""
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"format features only available with qcow2\")"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"compatibility option only available with qcow2\")"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"metadata preallocation only available with qcow2\")"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown inputvol storage vol type %d\")",
            "inputvol->target.format"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "inputvol->target.format"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown storage vol type %d\")",
            "info->format"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "info->format"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendCreateQemuImgSetInfo(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      virStorageVolEncryptConvertStep convertStep,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    /* Treat output block devices as 'raw' format */\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (info->format == VIR_STORAGE_FILE_ISO)\n        info->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(info->type = virStorageFileFormatTypeToString(info->format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->format);\n        return -1;\n    }\n\n    if (inputvol &&\n        !(info->inputType =\n          virStorageFileFormatTypeToString(inputvol->target.format))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown inputvol storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (info->preallocate && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation only available with qcow2\"));\n        return -1;\n    }\n    if (info->compat && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"compatibility option only available with qcow2\"));\n        return -1;\n    }\n    if (info->features && info->format != VIR_STORAGE_FILE_QCOW2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"format features only available with qcow2\"));\n        return -1;\n    }\n    if (info->format == VIR_STORAGE_FILE_RAW && vol->target.encryption) {\n        if (vol->target.encryption->format == VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            info->type = \"luks\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only luks encryption is supported for raw files\"));\n            return -1;\n        }\n    }\n\n    if (inputvol &&\n        storageBackendCreateQemuImgSetInput(inputvol, convertStep, info) < 0)\n        return -1;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        storageBackendCreateQemuImgSetBacking(pool, vol, inputvol, info) < 0)\n        return -1;\n\n    if (info->encryption &&\n        storageBackendCreateQemuImgCheckEncryption(info->format, info->type,\n                                                   vol) < 0)\n        return -1;\n\n    /* Size in KB */\n    info->size_arg = VIR_DIV_UP(vol->target.capacity, 1024);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendResizeQemuImgImageOpts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "956-973",
    "snippet": "static int\nstorageBackendResizeQemuImgImageOpts(virCommandPtr cmd,\n                                     const char *path,\n                                     const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"driver=luks,key-secret=%s,file.filename=\",\n                      secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, path);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--image-opts\", commandStr, NULL);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--image-opts\"",
            "commandStr",
            "NULL"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUBuildBufferEscapeComma",
          "args": [
            "&buf",
            "path"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildBufferEscapeComma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "293-297",
          "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"driver=luks,key-secret=%s,file.filename=\"",
            "secretAlias"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendResizeQemuImgImageOpts(virCommandPtr cmd,\n                                     const char *path,\n                                     const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"driver=luks,key-secret=%s,file.filename=\",\n                      secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, path);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--image-opts\", commandStr, NULL);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgSecretObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "932-948",
    "snippet": "static int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--object\"",
            "commandStr",
            "NULL"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUBuildBufferEscapeComma",
          "args": [
            "&buf",
            "secretPath"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildBufferEscapeComma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "293-297",
          "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"secret,id=%s,file=\"",
            "secretAlias"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSecretObject(virCommandPtr cmd,\n                                        const char *secretPath,\n                                        const char *secretAlias)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *commandStr = NULL;\n\n    virBufferAsprintf(&buf, \"secret,id=%s,file=\", secretAlias);\n    virQEMUBuildBufferEscapeComma(&buf, secretPath);\n\n    commandStr = virBufferContentAndReset(&buf);\n\n    virCommandAddArgList(cmd, \"--object\", commandStr, NULL);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgSetOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "911-924",
    "snippet": "static int\nstorageBackendCreateQemuImgSetOptions(virCommandPtr cmd,\n                                      virStorageEncryptionInfoDefPtr encinfo,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    g_autofree char *opts = NULL;\n\n    if (storageBackendCreateQemuImgOpts(encinfo, &opts, info) < 0)\n        return -1;\n    if (opts)\n        virCommandAddArgList(cmd, \"-o\", opts, NULL);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-o\"",
            "opts",
            "NULL"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storageBackendCreateQemuImgOpts",
          "args": [
            "encinfo",
            "&opts",
            "info"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "storageBackendCreateQemuImgOpts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "715-766",
          "snippet": "static int\nstorageBackendCreateQemuImgOpts(virStorageEncryptionInfoDefPtr encinfo,\n                                char **opts,\n                                struct _virStorageBackendQemuImgInfo *info)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (info->backingPath)\n        virBufferAsprintf(&buf, \"backing_fmt=%s,\",\n                          virStorageFileFormatTypeToString(info->backingFormat));\n\n    if (encinfo)\n        virQEMUBuildQemuImgKeySecretOpts(&buf, encinfo, info->secretAlias);\n\n    if (info->preallocate) {\n        if (info->size_arg > info->allocation)\n            virBufferAddLit(&buf, \"preallocation=metadata,\");\n        else\n            virBufferAddLit(&buf, \"preallocation=falloc,\");\n    }\n\n    if (info->nocow)\n        virBufferAddLit(&buf, \"nocow=on,\");\n\n    if (info->compat)\n        virBufferAsprintf(&buf, \"compat=%s,\", info->compat);\n    else if (info->format == VIR_STORAGE_FILE_QCOW2)\n        virBufferAddLit(&buf, \"compat=0.10,\");\n\n    if (info->features && info->format == VIR_STORAGE_FILE_QCOW2) {\n        if (virBitmapIsBitSet(info->features,\n                              VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS)) {\n            if (STREQ_NULLABLE(info->compat, \"0.10\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"lazy_refcounts not supported with compat\"\n                                 \" level %s\"),\n                               info->compat);\n                goto error;\n            }\n            virBufferAddLit(&buf, \"lazy_refcounts,\");\n        }\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    *opts = virBufferContentAndReset(&buf);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgOpts(virStorageEncryptionInfoDefPtr encinfo,\n                                char **opts,\n                                struct _virStorageBackendQemuImgInfo *info)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (info->backingPath)\n        virBufferAsprintf(&buf, \"backing_fmt=%s,\",\n                          virStorageFileFormatTypeToString(info->backingFormat));\n\n    if (encinfo)\n        virQEMUBuildQemuImgKeySecretOpts(&buf, encinfo, info->secretAlias);\n\n    if (info->preallocate) {\n        if (info->size_arg > info->allocation)\n            virBufferAddLit(&buf, \"preallocation=metadata,\");\n        else\n            virBufferAddLit(&buf, \"preallocation=falloc,\");\n    }\n\n    if (info->nocow)\n        virBufferAddLit(&buf, \"nocow=on,\");\n\n    if (info->compat)\n        virBufferAsprintf(&buf, \"compat=%s,\", info->compat);\n    else if (info->format == VIR_STORAGE_FILE_QCOW2)\n        virBufferAddLit(&buf, \"compat=0.10,\");\n\n    if (info->features && info->format == VIR_STORAGE_FILE_QCOW2) {\n        if (virBitmapIsBitSet(info->features,\n                              VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS)) {\n            if (STREQ_NULLABLE(info->compat, \"0.10\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"lazy_refcounts not supported with compat\"\n                                 \" level %s\"),\n                               info->compat);\n                goto error;\n            }\n            virBufferAddLit(&buf, \"lazy_refcounts,\");\n        }\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    *opts = virBufferContentAndReset(&buf);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetOptions(virCommandPtr cmd,\n                                      virStorageEncryptionInfoDefPtr encinfo,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    g_autofree char *opts = NULL;\n\n    if (storageBackendCreateQemuImgOpts(encinfo, &opts, info) < 0)\n        return -1;\n    if (opts)\n        virCommandAddArgList(cmd, \"-o\", opts, NULL);\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgSetBacking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "848-908",
    "snippet": "static int\nstorageBackendCreateQemuImgSetBacking(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int accessRetCode = -1;\n    g_autofree char *absolutePath = NULL;\n\n    if (info->format == VIR_STORAGE_FILE_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cannot set backing store for raw volume\"));\n        return -1;\n    }\n\n    info->backingFormat = vol->target.backingStore->format;\n    info->backingPath = vol->target.backingStore->path;\n\n    if (info->preallocate) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation conflicts with backing\"\n                         \" store\"));\n        return -1;\n    }\n\n    /* XXX: Not strictly required: qemu-img has an option a different\n     * backing store, not really sure what use it serves though, and it\n     * may cause issues with lvm. Untested essentially.\n     */\n    if (inputvol && virStorageSourceHasBacking(&inputvol->target) &&\n        STRNEQ_NULLABLE(inputvol->target.backingStore->path,\n                        info->backingPath)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"a different backing store cannot be specified.\"));\n        return -1;\n    }\n\n    if (!virStorageFileFormatTypeToString(info->backingFormat)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol backing store type %d\"),\n                       info->backingFormat);\n        return -1;\n    }\n\n    /* Convert relative backing store paths to absolute paths for access\n     * validation.\n     */\n    if (*(info->backingPath) != '/')\n        absolutePath = g_strdup_printf(\"%s/%s\", def->target.path, info->backingPath);\n    accessRetCode = access(absolutePath ? absolutePath :\n                           info->backingPath, R_OK);\n    if (accessRetCode != 0) {\n        virReportSystemError(errno,\n                             _(\"inaccessible backing store volume %s\"),\n                             info->backingPath);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"inaccessible backing store volume %s\")",
            "info->backingPath"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"inaccessible backing store volume %s\""
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "absolutePath ? absolutePath :\n                           info->backingPath",
            "R_OK"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown storage vol backing store type %d\")",
            "info->backingFormat"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "info->backingFormat"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"a different backing store cannot be specified.\")"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "inputvol->target.backingStore->path",
            "info->backingPath"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&inputvol->target"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"metadata preallocation conflicts with backing\"\n                         \" store\")"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"cannot set backing store for raw volume\")"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetBacking(virStoragePoolObjPtr pool,\n                                      virStorageVolDefPtr vol,\n                                      virStorageVolDefPtr inputvol,\n                                      struct _virStorageBackendQemuImgInfo *info)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int accessRetCode = -1;\n    g_autofree char *absolutePath = NULL;\n\n    if (info->format == VIR_STORAGE_FILE_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cannot set backing store for raw volume\"));\n        return -1;\n    }\n\n    info->backingFormat = vol->target.backingStore->format;\n    info->backingPath = vol->target.backingStore->path;\n\n    if (info->preallocate) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation conflicts with backing\"\n                         \" store\"));\n        return -1;\n    }\n\n    /* XXX: Not strictly required: qemu-img has an option a different\n     * backing store, not really sure what use it serves though, and it\n     * may cause issues with lvm. Untested essentially.\n     */\n    if (inputvol && virStorageSourceHasBacking(&inputvol->target) &&\n        STRNEQ_NULLABLE(inputvol->target.backingStore->path,\n                        info->backingPath)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"a different backing store cannot be specified.\"));\n        return -1;\n    }\n\n    if (!virStorageFileFormatTypeToString(info->backingFormat)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol backing store type %d\"),\n                       info->backingFormat);\n        return -1;\n    }\n\n    /* Convert relative backing store paths to absolute paths for access\n     * validation.\n     */\n    if (*(info->backingPath) != '/')\n        absolutePath = g_strdup_printf(\"%s/%s\", def->target.path, info->backingPath);\n    accessRetCode = access(absolutePath ? absolutePath :\n                           info->backingPath, R_OK);\n    if (accessRetCode != 0) {\n        virReportSystemError(errno,\n                             _(\"inaccessible backing store volume %s\"),\n                             info->backingPath);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgSetInput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "818-845",
    "snippet": "static int\nstorageBackendCreateQemuImgSetInput(virStorageVolDefPtr inputvol,\n                                    virStorageVolEncryptConvertStep convertStep,\n                                    struct _virStorageBackendQemuImgInfo *info)\n{\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CREATE) {\n        if (!(info->inputPath = inputvol->target.path)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing input volume target path\"));\n            return -1;\n        }\n    }\n\n    info->inputFormat = inputvol->target.format;\n    if (inputvol->type == VIR_STORAGE_VOL_BLOCK)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (info->inputFormat == VIR_STORAGE_FILE_ISO)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (!(info->inputFormatStr =\n          virStorageFileFormatTypeToString(info->inputFormat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->inputFormat);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown storage vol type %d\")",
            "info->inputFormat"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown storage vol type %d\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "info->inputFormat"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing input volume target path\")"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgSetInput(virStorageVolDefPtr inputvol,\n                                    virStorageVolEncryptConvertStep convertStep,\n                                    struct _virStorageBackendQemuImgInfo *info)\n{\n    if (convertStep != VIR_STORAGE_VOL_ENCRYPT_CREATE) {\n        if (!(info->inputPath = inputvol->target.path)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"missing input volume target path\"));\n            return -1;\n        }\n    }\n\n    info->inputFormat = inputvol->target.format;\n    if (inputvol->type == VIR_STORAGE_VOL_BLOCK)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (info->inputFormat == VIR_STORAGE_FILE_ISO)\n        info->inputFormat = VIR_STORAGE_FILE_RAW;\n    if (!(info->inputFormatStr =\n          virStorageFileFormatTypeToString(info->inputFormat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown storage vol type %d\"),\n                       info->inputFormat);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgCheckEncryption",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "778-815",
    "snippet": "static int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"volume encryption unsupported with format %s\")",
            "type"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"volume encryption unsupported with format %s\""
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\")"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHaveCipher",
          "args": [
            "VIR_CRYPTO_CIPHER_AES256CBC"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHaveCipher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "113-127",
          "snippet": "bool\nvirCryptoHaveCipher(virCryptoCipher algorithm)\n{\n    switch (algorithm) {\n\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        return true;\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    };\n\n    return false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nbool\nvirCryptoHaveCipher(virCryptoCipher algorithm)\n{\n    switch (algorithm) {\n\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        return true;\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    };\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"no secret provided for luks encryption\")"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"too many secrets for luks encryption\")"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported volume encryption format %d\")",
            "vol->target.encryption->format"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgCheckEncryption(int format,\n                                           const char *type,\n                                           virStorageVolDefPtr vol)\n{\n    virStorageEncryptionPtr enc = vol->target.encryption;\n\n    if (format == VIR_STORAGE_FILE_RAW) {\n        if (enc->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported volume encryption format %d\"),\n                           vol->target.encryption->format);\n            return -1;\n        }\n        if (enc->nsecrets > 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"too many secrets for luks encryption\"));\n            return -1;\n        }\n        if (enc->nsecrets == 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"no secret provided for luks encryption\"));\n            return -1;\n        }\n        if (!virCryptoHaveCipher(VIR_CRYPTO_CIPHER_AES256CBC)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"luks encryption usage requires encrypted \"\n                             \"secret generation to be supported\"));\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"volume encryption unsupported with format %s\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "storageBackendCreateQemuImgOpts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "715-766",
    "snippet": "static int\nstorageBackendCreateQemuImgOpts(virStorageEncryptionInfoDefPtr encinfo,\n                                char **opts,\n                                struct _virStorageBackendQemuImgInfo *info)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (info->backingPath)\n        virBufferAsprintf(&buf, \"backing_fmt=%s,\",\n                          virStorageFileFormatTypeToString(info->backingFormat));\n\n    if (encinfo)\n        virQEMUBuildQemuImgKeySecretOpts(&buf, encinfo, info->secretAlias);\n\n    if (info->preallocate) {\n        if (info->size_arg > info->allocation)\n            virBufferAddLit(&buf, \"preallocation=metadata,\");\n        else\n            virBufferAddLit(&buf, \"preallocation=falloc,\");\n    }\n\n    if (info->nocow)\n        virBufferAddLit(&buf, \"nocow=on,\");\n\n    if (info->compat)\n        virBufferAsprintf(&buf, \"compat=%s,\", info->compat);\n    else if (info->format == VIR_STORAGE_FILE_QCOW2)\n        virBufferAddLit(&buf, \"compat=0.10,\");\n\n    if (info->features && info->format == VIR_STORAGE_FILE_QCOW2) {\n        if (virBitmapIsBitSet(info->features,\n                              VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS)) {\n            if (STREQ_NULLABLE(info->compat, \"0.10\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"lazy_refcounts not supported with compat\"\n                                 \" level %s\"),\n                               info->compat);\n                goto error;\n            }\n            virBufferAddLit(&buf, \"lazy_refcounts,\");\n        }\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    *opts = virBufferContentAndReset(&buf);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"lazy_refcounts,\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"lazy_refcounts not supported with compat\"\n                                 \" level %s\")",
            "info->compat"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"lazy_refcounts not supported with compat\"\n                                 \" level %s\""
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "info->compat",
            "\"0.10\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "info->features",
            "VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"compat=0.10,\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"compat=%s,\"",
            "info->compat"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"nocow=on,\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"preallocation=falloc,\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"preallocation=metadata,\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUBuildQemuImgKeySecretOpts",
          "args": [
            "&buf",
            "encinfo",
            "info->secretAlias"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildQemuImgKeySecretOpts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "320-355",
          "snippet": "void\nvirQEMUBuildQemuImgKeySecretOpts(virBufferPtr buf,\n                                 virStorageEncryptionInfoDefPtr encinfo,\n                                 const char *alias)\n{\n    virBufferAsprintf(buf, \"key-secret=%s,\", alias);\n\n    if (!encinfo->cipher_name)\n        return;\n\n    virBufferAddLit(buf, \"cipher-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_name);\n    virBufferAsprintf(buf, \"-%u,\", encinfo->cipher_size);\n    if (encinfo->cipher_mode) {\n        virBufferAddLit(buf, \"cipher-mode=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_mode);\n        virBufferAddLit(buf, \",\");\n    }\n    if (encinfo->cipher_hash) {\n        virBufferAddLit(buf, \"hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_hash);\n        virBufferAddLit(buf, \",\");\n    }\n    if (!encinfo->ivgen_name)\n        return;\n\n    virBufferAddLit(buf, \"ivgen-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_name);\n    virBufferAddLit(buf, \",\");\n\n    if (encinfo->ivgen_hash) {\n        virBufferAddLit(buf, \"ivgen-hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_hash);\n        virBufferAddLit(buf, \",\");\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildQemuImgKeySecretOpts(virBufferPtr buf,\n                                 virStorageEncryptionInfoDefPtr encinfo,\n                                 const char *alias)\n{\n    virBufferAsprintf(buf, \"key-secret=%s,\", alias);\n\n    if (!encinfo->cipher_name)\n        return;\n\n    virBufferAddLit(buf, \"cipher-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_name);\n    virBufferAsprintf(buf, \"-%u,\", encinfo->cipher_size);\n    if (encinfo->cipher_mode) {\n        virBufferAddLit(buf, \"cipher-mode=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_mode);\n        virBufferAddLit(buf, \",\");\n    }\n    if (encinfo->cipher_hash) {\n        virBufferAddLit(buf, \"hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_hash);\n        virBufferAddLit(buf, \",\");\n    }\n    if (!encinfo->ivgen_name)\n        return;\n\n    virBufferAddLit(buf, \"ivgen-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_name);\n    virBufferAddLit(buf, \",\");\n\n    if (encinfo->ivgen_hash) {\n        virBufferAddLit(buf, \"ivgen-hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_hash);\n        virBufferAddLit(buf, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "info->backingFormat"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateQemuImgOpts(virStorageEncryptionInfoDefPtr encinfo,\n                                char **opts,\n                                struct _virStorageBackendQemuImgInfo *info)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (info->backingPath)\n        virBufferAsprintf(&buf, \"backing_fmt=%s,\",\n                          virStorageFileFormatTypeToString(info->backingFormat));\n\n    if (encinfo)\n        virQEMUBuildQemuImgKeySecretOpts(&buf, encinfo, info->secretAlias);\n\n    if (info->preallocate) {\n        if (info->size_arg > info->allocation)\n            virBufferAddLit(&buf, \"preallocation=metadata,\");\n        else\n            virBufferAddLit(&buf, \"preallocation=falloc,\");\n    }\n\n    if (info->nocow)\n        virBufferAddLit(&buf, \"nocow=on,\");\n\n    if (info->compat)\n        virBufferAsprintf(&buf, \"compat=%s,\", info->compat);\n    else if (info->format == VIR_STORAGE_FILE_QCOW2)\n        virBufferAddLit(&buf, \"compat=0.10,\");\n\n    if (info->features && info->format == VIR_STORAGE_FILE_QCOW2) {\n        if (virBitmapIsBitSet(info->features,\n                              VIR_STORAGE_FILE_FEATURE_LAZY_REFCOUNTS)) {\n            if (STREQ_NULLABLE(info->compat, \"0.10\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"lazy_refcounts not supported with compat\"\n                                 \" level %s\"),\n                               info->compat);\n                goto error;\n            }\n            virBufferAddLit(&buf, \"lazy_refcounts,\");\n        }\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    *opts = virBufferContentAndReset(&buf);\n    return 0;\n\n error:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
  },
  {
    "function_name": "storagePloopResize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "665-684",
    "snippet": "static int\nstoragePloopResize(virStorageVolDefPtr vol,\n                   unsigned long long capacity)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *resize_tool = NULL;\n\n    resize_tool = virFindFileInPath(\"ploop\");\n    if (!resize_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop, please install ploop tools\"));\n        return -1;\n    }\n    cmd = virCommandNewArgList(resize_tool, \"resize\", \"-s\", NULL);\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(capacity, (1024 * 1024)));\n\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", vol->target.path);\n\n    return virCommandRun(cmd, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s/DiskDescriptor.xml\"",
            "vol->target.path"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "capacity",
            "(1024 * 1024)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "resize_tool",
            "\"resize\"",
            "\"-s\"",
            "NULL"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to find ploop, please install ploop tools\")"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to find ploop, please install ploop tools\""
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"ploop\""
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstoragePloopResize(virStorageVolDefPtr vol,\n                   unsigned long long capacity)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *resize_tool = NULL;\n\n    resize_tool = virFindFileInPath(\"ploop\");\n    if (!resize_tool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to find ploop, please install ploop tools\"));\n        return -1;\n    }\n    cmd = virCommandNewArgList(resize_tool, \"resize\", \"-s\", NULL);\n    virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(capacity, (1024 * 1024)));\n\n    virCommandAddArgFormat(cmd, \"%s/DiskDescriptor.xml\", vol->target.path);\n\n    return virCommandRun(cmd, NULL);\n}"
  },
  {
    "function_name": "storageBackendCreatePloop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "592-662",
    "snippet": "static int\nstorageBackendCreatePloop(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                          virStorageVolDefPtr vol,\n                          virStorageVolDefPtr inputvol,\n                          unsigned int flags)\n{\n    int ret = -1;\n    bool created = false;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *create_tool = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (inputvol && inputvol->target.format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported input storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encrypted ploop volumes are not supported with \"\n                         \"ploop init\"));\n        return -1;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"copy-on-write ploop volumes are not yet supported\"));\n        return -1;\n    }\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool && !inputvol) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    if (!inputvol) {\n        if ((virDirCreate(vol->target.path,\n                          (vol->target.perms->mode == (mode_t)-1 ?\n                           VIR_STORAGE_DEFAULT_VOL_PERM_MODE:\n                           vol->target.perms->mode),\n                          vol->target.perms->uid,\n                          vol->target.perms->gid,\n                          0)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"error creating directory for ploop volume\"));\n            goto cleanup;\n        }\n        cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n        virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                        (1024 * 1024)));\n        virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n        virCommandAddArgFormat(cmd, \"%s/root.hds\", vol->target.path);\n\n    } else {\n        vol->target.capacity = inputvol->target.capacity;\n        cmd = virCommandNewArgList(\"cp\", \"-r\", inputvol->target.path,\n                                   vol->target.path, NULL);\n    }\n    created = true;\n    ret = virCommandRun(cmd, NULL);\n cleanup:\n    if (ret < 0 && created)\n        virFileDeleteTree(vol->target.path);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileDeleteTree",
          "args": [
            "vol->target.path"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virFileDeleteTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1009-1062",
          "snippet": "int virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "\"cp\"",
            "\"-r\"",
            "inputvol->target.path",
            "vol->target.path",
            "NULL"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s/root.hds\"",
            "vol->target.path"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-t\"",
            "\"ext4\"",
            "NULL"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "vol->target.capacity",
            "(1024 * 1024)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error creating directory for ploop volume\")"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"error creating directory for ploop volume\""
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirCreate",
          "args": [
            "vol->target.path",
            "(vol->target.perms->mode == (mode_t)-1 ?\n                           VIR_STORAGE_DEFAULT_VOL_PERM_MODE:\n                           vol->target.perms->mode)",
            "vol->target.perms->uid",
            "vol->target.perms->gid",
            "0"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virDirCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2831-2842",
          "snippet": "int\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirCreate(const char *path G_GNUC_UNUSED,\n             mode_t mode G_GNUC_UNUSED,\n             uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virDirCreate is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to find ploop, please install \"\n                               \"ploop tools\")"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "\"ploop\""
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"copy-on-write ploop volumes are not yet supported\")"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"encrypted ploop volumes are not supported with \"\n                         \"ploop init\")"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unsupported input storage vol type %d\")",
            "inputvol->target.format"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreatePloop(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                          virStorageVolDefPtr vol,\n                          virStorageVolDefPtr inputvol,\n                          unsigned int flags)\n{\n    int ret = -1;\n    bool created = false;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *create_tool = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (inputvol && inputvol->target.format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported input storage vol type %d\"),\n                       inputvol->target.format);\n        return -1;\n    }\n\n    if (vol->target.encryption) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"encrypted ploop volumes are not supported with \"\n                         \"ploop init\"));\n        return -1;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"copy-on-write ploop volumes are not yet supported\"));\n        return -1;\n    }\n\n    create_tool = virFindFileInPath(\"ploop\");\n    if (!create_tool && !inputvol) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unable to find ploop, please install \"\n                               \"ploop tools\"));\n        return -1;\n    }\n\n    if (!inputvol) {\n        if ((virDirCreate(vol->target.path,\n                          (vol->target.perms->mode == (mode_t)-1 ?\n                           VIR_STORAGE_DEFAULT_VOL_PERM_MODE:\n                           vol->target.perms->mode),\n                          vol->target.perms->uid,\n                          vol->target.perms->gid,\n                          0)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"error creating directory for ploop volume\"));\n            goto cleanup;\n        }\n        cmd = virCommandNewArgList(create_tool, \"init\", \"-s\", NULL);\n        virCommandAddArgFormat(cmd, \"%lluM\", VIR_DIV_UP(vol->target.capacity,\n                                                        (1024 * 1024)));\n        virCommandAddArgList(cmd, \"-t\", \"ext4\", NULL);\n        virCommandAddArgFormat(cmd, \"%s/root.hds\", vol->target.path);\n\n    } else {\n        vol->target.capacity = inputvol->target.capacity;\n        cmd = virCommandNewArgList(\"cp\", \"-r\", inputvol->target.path,\n                                   vol->target.path, NULL);\n    }\n    created = true;\n    ret = virCommandRun(cmd, NULL);\n cleanup:\n    if (ret < 0 && created)\n        virFileDeleteTree(vol->target.path);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendCreateExecCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "492-588",
    "snippet": "static int\nvirStorageBackendCreateExecCommand(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virCommandPtr cmd)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode = (vol->target.perms->mode == (mode_t)-1 ?\n                   VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                   vol->target.perms->mode);\n    bool filecreated = false;\n    int ret = -1;\n\n    if ((def->type == VIR_STORAGE_POOL_NETFS)\n        && (((geteuid() == 0)\n             && (vol->target.perms->uid != (uid_t)-1)\n             && (vol->target.perms->uid != 0))\n            || ((vol->target.perms->gid != (gid_t)-1)\n                && (vol->target.perms->gid != getegid())))) {\n\n        virCommandSetUID(cmd, vol->target.perms->uid);\n        virCommandSetGID(cmd, vol->target.perms->gid);\n        virCommandSetUmask(cmd, S_IRWXUGO ^ mode);\n\n        if (virCommandRun(cmd, NULL) == 0) {\n            /* command was successfully run, check if the file was created */\n            if (stat(vol->target.path, &st) >= 0) {\n                filecreated = true;\n\n                /* seems qemu-img disregards umask and open/creates using 0644.\n                 * If that doesn't match what we expect, then let's try to\n                 * re-open the file and attempt to force the mode change.\n                 */\n                if (mode != (st.st_mode & S_IRWXUGO)) {\n                    VIR_AUTOCLOSE fd = -1;\n                    int flags = VIR_FILE_OPEN_FORK | VIR_FILE_OPEN_FORCE_MODE;\n\n                    if ((fd = virFileOpenAs(vol->target.path, O_RDWR, mode,\n                                            vol->target.perms->uid,\n                                            vol->target.perms->gid,\n                                            flags)) >= 0) {\n                        /* Success - means we're good */\n                        ret = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filecreated) {\n        /* don't change uid/gid/mode if we retry */\n        virCommandSetUID(cmd, -1);\n        virCommandSetGID(cmd, -1);\n        virCommandSetUmask(cmd, 0);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n        if (stat(vol->target.path, &st) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create %s\"), vol->target.path);\n            goto cleanup;\n        }\n        filecreated = true;\n    }\n\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (chown(vol->target.path, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown %s to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        goto cleanup;\n    }\n\n    if (mode != (st.st_mode & S_IRWXUGO) &&\n        chmod(vol->target.path, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && filecreated)\n        virFileRemove(vol->target.path, vol->target.perms->uid,\n                      vol->target.perms->gid);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "vol->target.path",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot set mode of '%s' to %04o\")",
            "vol->target.path",
            "mode"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot set mode of '%s' to %04o\""
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "vol->target.path",
            "mode"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chown %s to (%u, %u)\")",
            "vol->target.path",
            "(unsigned int)uid",
            "(unsigned int)gid"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "vol->target.path",
            "uid",
            "gid"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to create %s\")",
            "vol->target.path"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "vol->target.path",
            "&st"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetUmask",
          "args": [
            "cmd",
            "0"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetUmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1165-1171",
          "snippet": "void virCommandSetUmask(virCommandPtr cmd, int mask)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->mask = mask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandSetUmask(virCommandPtr cmd, int mask)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->mask = mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetGID",
          "args": [
            "cmd",
            "-1"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetGID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1111-1118",
          "snippet": "void\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetUID",
          "args": [
            "cmd",
            "-1"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1120-1127",
          "snippet": "void\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileOpenAs",
          "args": [
            "vol->target.path",
            "O_RDWR",
            "mode",
            "vol->target.perms->uid",
            "vol->target.perms->gid",
            "flags"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2817-2829",
          "snippet": "int\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "getegid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "78-79",
          "snippet": "static inline int getegid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int getegid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendCreateExecCommand(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   virCommandPtr cmd)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode = (vol->target.perms->mode == (mode_t)-1 ?\n                   VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                   vol->target.perms->mode);\n    bool filecreated = false;\n    int ret = -1;\n\n    if ((def->type == VIR_STORAGE_POOL_NETFS)\n        && (((geteuid() == 0)\n             && (vol->target.perms->uid != (uid_t)-1)\n             && (vol->target.perms->uid != 0))\n            || ((vol->target.perms->gid != (gid_t)-1)\n                && (vol->target.perms->gid != getegid())))) {\n\n        virCommandSetUID(cmd, vol->target.perms->uid);\n        virCommandSetGID(cmd, vol->target.perms->gid);\n        virCommandSetUmask(cmd, S_IRWXUGO ^ mode);\n\n        if (virCommandRun(cmd, NULL) == 0) {\n            /* command was successfully run, check if the file was created */\n            if (stat(vol->target.path, &st) >= 0) {\n                filecreated = true;\n\n                /* seems qemu-img disregards umask and open/creates using 0644.\n                 * If that doesn't match what we expect, then let's try to\n                 * re-open the file and attempt to force the mode change.\n                 */\n                if (mode != (st.st_mode & S_IRWXUGO)) {\n                    VIR_AUTOCLOSE fd = -1;\n                    int flags = VIR_FILE_OPEN_FORK | VIR_FILE_OPEN_FORCE_MODE;\n\n                    if ((fd = virFileOpenAs(vol->target.path, O_RDWR, mode,\n                                            vol->target.perms->uid,\n                                            vol->target.perms->gid,\n                                            flags)) >= 0) {\n                        /* Success - means we're good */\n                        ret = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filecreated) {\n        /* don't change uid/gid/mode if we retry */\n        virCommandSetUID(cmd, -1);\n        virCommandSetGID(cmd, -1);\n        virCommandSetUmask(cmd, 0);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n        if (stat(vol->target.path, &st) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create %s\"), vol->target.path);\n            goto cleanup;\n        }\n        filecreated = true;\n    }\n\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (chown(vol->target.path, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown %s to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        goto cleanup;\n    }\n\n    if (mode != (st.st_mode & S_IRWXUGO) &&\n        chmod(vol->target.path, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && filecreated)\n        virFileRemove(vol->target.path, vol->target.perms->uid,\n                      vol->target.perms->gid);\n    return ret;\n}"
  },
  {
    "function_name": "storageBackendCreateRaw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "398-489",
    "snippet": "static int\nstorageBackendCreateRaw(virStoragePoolObjPtr pool,\n                        virStorageVolDefPtr vol,\n                        virStorageVolDefPtr inputvol,\n                        unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int ret = -1;\n    int operation_flags;\n    bool reflink_copy = false;\n    mode_t open_mode = VIR_STORAGE_DEFAULT_VOL_PERM_MODE;\n    bool created = false;\n    VIR_AUTOCLOSE fd = -1;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  -1);\n\n    if (flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation is not supported for raw \"\n                         \"volumes\"));\n        goto cleanup;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                       _(\"backing storage not supported for raw volumes\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_STORAGE_VOL_CREATE_REFLINK)\n        reflink_copy = true;\n\n\n    if (vol->target.encryption) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool does not support encrypted volumes\"));\n        goto cleanup;\n    }\n\n    operation_flags = VIR_FILE_OPEN_FORCE_MODE | VIR_FILE_OPEN_FORCE_OWNER;\n    if (def->type == VIR_STORAGE_POOL_NETFS)\n        operation_flags |= VIR_FILE_OPEN_FORK;\n\n    if (vol->target.perms->mode != (mode_t)-1)\n        open_mode = vol->target.perms->mode;\n\n    if ((fd = virFileOpenAs(vol->target.path,\n                            O_RDWR | O_CREAT | O_EXCL,\n                            open_mode,\n                            vol->target.perms->uid,\n                            vol->target.perms->gid,\n                            operation_flags)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to create file '%s'\"),\n                             vol->target.path);\n        goto cleanup;\n    }\n    created = true;\n\n    if (vol->target.nocow) {\n#ifdef __linux__\n        int attr;\n\n        /* Set NOCOW flag. This is an optimisation for btrfs.\n         * The FS_IOC_SETFLAGS ioctl return value will be ignored since any\n         * failure of this operation should not block the volume creation.\n         */\n        if (ioctl(fd, FS_IOC_GETFLAGS, &attr) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Failed to get fs flags\"));\n        } else {\n            attr |= FS_NOCOW_FL;\n            if (ioctl(fd, FS_IOC_SETFLAGS, &attr) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set NOCOW flag\"));\n            }\n        }\n#endif\n    }\n\n    if ((ret = createRawFile(fd, vol, inputvol, reflink_copy)) < 0)\n        /* createRawFile already reported the exact error. */\n        ret = -1;\n\n cleanup:\n    if (ret < 0 && created)\n        ignore_value(virFileRemove(vol->target.path,\n                                   vol->target.perms->uid,\n                                   vol->target.perms->gid));\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFileRemove(vol->target.path,\n                                   vol->target.perms->uid,\n                                   vol->target.perms->gid)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "vol->target.path",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "createRawFile",
          "args": [
            "fd",
            "vol",
            "inputvol",
            "reflink_copy"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "createRawFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "317-396",
          "snippet": "static int\ncreateRawFile(int fd, virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              bool reflink_copy)\n{\n    bool need_alloc = true;\n    int ret = 0;\n    unsigned long long pos = 0;\n\n    /* If the new allocation is lower than the capacity of the original file,\n     * the cloned volume will be sparse */\n    if (inputvol &&\n        vol->target.allocation < inputvol->target.capacity)\n        need_alloc = false;\n\n    /* Seek to the final size, so the capacity is available upfront\n     * for progress reporting */\n    if (ftruncate(fd, vol->target.capacity) < 0) {\n        ret = -errno;\n        virReportSystemError(errno,\n                             _(\"cannot extend file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n/* Avoid issues with older kernel's <linux/fs.h> namespace pollution. */\n#if HAVE_FALLOCATE - 0\n    /* Try to preallocate all requested disk space, but fall back to\n     * other methods if this fails with ENOSYS or EOPNOTSUPP. If allocation\n     * is 0 (or less than 0), then fallocate will fail with EINVAL.\n     * NOTE: do not use posix_fallocate; posix_fallocate falls back\n     * to writing zeroes block by block in case fallocate isn't\n     * available, and since we're going to copy data from another\n     * file it doesn't make sense to write the file twice. */\n    if (vol->target.allocation && need_alloc) {\n        if (fallocate(fd, 0, 0, vol->target.allocation) == 0) {\n            need_alloc = false;\n        } else if (errno != ENOSYS && errno != EOPNOTSUPP) {\n            ret = -errno;\n            virReportSystemError(errno,\n                                 _(\"cannot allocate %llu bytes in file '%s'\"),\n                                 vol->target.allocation, vol->target.path);\n            return ret;\n        }\n    }\n#endif\n\n    if (inputvol) {\n        unsigned long long remain = inputvol->target.capacity;\n        /* allow zero blocks to be skipped if we've requested sparse\n         * allocation (allocation < capacity) or we have already\n         * been able to allocate the required space. */\n        if ((ret = virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                             !need_alloc, reflink_copy)) < 0)\n            return ret;\n\n        /* If the new allocation is greater than the original capacity,\n         * but fallocate failed, fill the rest with zeroes.\n         */\n        pos = inputvol->target.capacity - remain;\n    }\n\n    if (need_alloc && (vol->target.allocation - pos > 0)) {\n        if (safezero(fd, pos, vol->target.allocation - pos) < 0) {\n            ret = -errno;\n            virReportSystemError(errno, _(\"cannot fill file '%s'\"),\n                                 vol->target.path);\n            return ret;\n        }\n    }\n\n    if (g_fsync(fd) < 0) {\n        ret = -errno;\n        virReportSystemError(errno, _(\"cannot sync data to file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ncreateRawFile(int fd, virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              bool reflink_copy)\n{\n    bool need_alloc = true;\n    int ret = 0;\n    unsigned long long pos = 0;\n\n    /* If the new allocation is lower than the capacity of the original file,\n     * the cloned volume will be sparse */\n    if (inputvol &&\n        vol->target.allocation < inputvol->target.capacity)\n        need_alloc = false;\n\n    /* Seek to the final size, so the capacity is available upfront\n     * for progress reporting */\n    if (ftruncate(fd, vol->target.capacity) < 0) {\n        ret = -errno;\n        virReportSystemError(errno,\n                             _(\"cannot extend file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n/* Avoid issues with older kernel's <linux/fs.h> namespace pollution. */\n#if HAVE_FALLOCATE - 0\n    /* Try to preallocate all requested disk space, but fall back to\n     * other methods if this fails with ENOSYS or EOPNOTSUPP. If allocation\n     * is 0 (or less than 0), then fallocate will fail with EINVAL.\n     * NOTE: do not use posix_fallocate; posix_fallocate falls back\n     * to writing zeroes block by block in case fallocate isn't\n     * available, and since we're going to copy data from another\n     * file it doesn't make sense to write the file twice. */\n    if (vol->target.allocation && need_alloc) {\n        if (fallocate(fd, 0, 0, vol->target.allocation) == 0) {\n            need_alloc = false;\n        } else if (errno != ENOSYS && errno != EOPNOTSUPP) {\n            ret = -errno;\n            virReportSystemError(errno,\n                                 _(\"cannot allocate %llu bytes in file '%s'\"),\n                                 vol->target.allocation, vol->target.path);\n            return ret;\n        }\n    }\n#endif\n\n    if (inputvol) {\n        unsigned long long remain = inputvol->target.capacity;\n        /* allow zero blocks to be skipped if we've requested sparse\n         * allocation (allocation < capacity) or we have already\n         * been able to allocate the required space. */\n        if ((ret = virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                             !need_alloc, reflink_copy)) < 0)\n            return ret;\n\n        /* If the new allocation is greater than the original capacity,\n         * but fallocate failed, fill the rest with zeroes.\n         */\n        pos = inputvol->target.capacity - remain;\n    }\n\n    if (need_alloc && (vol->target.allocation - pos > 0)) {\n        if (safezero(fd, pos, vol->target.allocation - pos) < 0) {\n            ret = -errno;\n            virReportSystemError(errno, _(\"cannot fill file '%s'\"),\n                                 vol->target.path);\n            return ret;\n        }\n    }\n\n    if (g_fsync(fd) < 0) {\n        ret = -errno;\n        virReportSystemError(errno, _(\"cannot sync data to file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to set NOCOW flag\")"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to set NOCOW flag\""
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "FS_IOC_SETFLAGS",
            "&attr"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to get fs flags\")"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-fd",
            "_(\"Failed to create file '%s'\")",
            "vol->target.path"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileOpenAs",
          "args": [
            "vol->target.path",
            "O_RDWR | O_CREAT | O_EXCL",
            "open_mode",
            "vol->target.perms->uid",
            "vol->target.perms->gid",
            "operation_flags"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2817-2829",
          "snippet": "int\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"storage pool does not support encrypted volumes\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"backing storage not supported for raw volumes\")"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"metadata preallocation is not supported for raw \"\n                         \"volumes\")"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK",
            "-1"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateRaw(virStoragePoolObjPtr pool,\n                        virStorageVolDefPtr vol,\n                        virStorageVolDefPtr inputvol,\n                        unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int ret = -1;\n    int operation_flags;\n    bool reflink_copy = false;\n    mode_t open_mode = VIR_STORAGE_DEFAULT_VOL_PERM_MODE;\n    bool created = false;\n    VIR_AUTOCLOSE fd = -1;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  -1);\n\n    if (flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation is not supported for raw \"\n                         \"volumes\"));\n        goto cleanup;\n    }\n\n    if (virStorageSourceHasBacking(&vol->target)) {\n        virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                       _(\"backing storage not supported for raw volumes\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_STORAGE_VOL_CREATE_REFLINK)\n        reflink_copy = true;\n\n\n    if (vol->target.encryption) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool does not support encrypted volumes\"));\n        goto cleanup;\n    }\n\n    operation_flags = VIR_FILE_OPEN_FORCE_MODE | VIR_FILE_OPEN_FORCE_OWNER;\n    if (def->type == VIR_STORAGE_POOL_NETFS)\n        operation_flags |= VIR_FILE_OPEN_FORK;\n\n    if (vol->target.perms->mode != (mode_t)-1)\n        open_mode = vol->target.perms->mode;\n\n    if ((fd = virFileOpenAs(vol->target.path,\n                            O_RDWR | O_CREAT | O_EXCL,\n                            open_mode,\n                            vol->target.perms->uid,\n                            vol->target.perms->gid,\n                            operation_flags)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to create file '%s'\"),\n                             vol->target.path);\n        goto cleanup;\n    }\n    created = true;\n\n    if (vol->target.nocow) {\n#ifdef __linux__\n        int attr;\n\n        /* Set NOCOW flag. This is an optimisation for btrfs.\n         * The FS_IOC_SETFLAGS ioctl return value will be ignored since any\n         * failure of this operation should not block the volume creation.\n         */\n        if (ioctl(fd, FS_IOC_GETFLAGS, &attr) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Failed to get fs flags\"));\n        } else {\n            attr |= FS_NOCOW_FL;\n            if (ioctl(fd, FS_IOC_SETFLAGS, &attr) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set NOCOW flag\"));\n            }\n        }\n#endif\n    }\n\n    if ((ret = createRawFile(fd, vol, inputvol, reflink_copy)) < 0)\n        /* createRawFile already reported the exact error. */\n        ret = -1;\n\n cleanup:\n    if (ret < 0 && created)\n        ignore_value(virFileRemove(vol->target.path,\n                                   vol->target.perms->uid,\n                                   vol->target.perms->gid));\n    return ret;\n}"
  },
  {
    "function_name": "createRawFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "317-396",
    "snippet": "static int\ncreateRawFile(int fd, virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              bool reflink_copy)\n{\n    bool need_alloc = true;\n    int ret = 0;\n    unsigned long long pos = 0;\n\n    /* If the new allocation is lower than the capacity of the original file,\n     * the cloned volume will be sparse */\n    if (inputvol &&\n        vol->target.allocation < inputvol->target.capacity)\n        need_alloc = false;\n\n    /* Seek to the final size, so the capacity is available upfront\n     * for progress reporting */\n    if (ftruncate(fd, vol->target.capacity) < 0) {\n        ret = -errno;\n        virReportSystemError(errno,\n                             _(\"cannot extend file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n/* Avoid issues with older kernel's <linux/fs.h> namespace pollution. */\n#if HAVE_FALLOCATE - 0\n    /* Try to preallocate all requested disk space, but fall back to\n     * other methods if this fails with ENOSYS or EOPNOTSUPP. If allocation\n     * is 0 (or less than 0), then fallocate will fail with EINVAL.\n     * NOTE: do not use posix_fallocate; posix_fallocate falls back\n     * to writing zeroes block by block in case fallocate isn't\n     * available, and since we're going to copy data from another\n     * file it doesn't make sense to write the file twice. */\n    if (vol->target.allocation && need_alloc) {\n        if (fallocate(fd, 0, 0, vol->target.allocation) == 0) {\n            need_alloc = false;\n        } else if (errno != ENOSYS && errno != EOPNOTSUPP) {\n            ret = -errno;\n            virReportSystemError(errno,\n                                 _(\"cannot allocate %llu bytes in file '%s'\"),\n                                 vol->target.allocation, vol->target.path);\n            return ret;\n        }\n    }\n#endif\n\n    if (inputvol) {\n        unsigned long long remain = inputvol->target.capacity;\n        /* allow zero blocks to be skipped if we've requested sparse\n         * allocation (allocation < capacity) or we have already\n         * been able to allocate the required space. */\n        if ((ret = virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                             !need_alloc, reflink_copy)) < 0)\n            return ret;\n\n        /* If the new allocation is greater than the original capacity,\n         * but fallocate failed, fill the rest with zeroes.\n         */\n        pos = inputvol->target.capacity - remain;\n    }\n\n    if (need_alloc && (vol->target.allocation - pos > 0)) {\n        if (safezero(fd, pos, vol->target.allocation - pos) < 0) {\n            ret = -errno;\n            virReportSystemError(errno, _(\"cannot fill file '%s'\"),\n                                 vol->target.path);\n            return ret;\n        }\n    }\n\n    if (g_fsync(fd) < 0) {\n        ret = -errno;\n        virReportSystemError(errno, _(\"cannot sync data to file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot sync data to file '%s'\")",
            "vol->target.path"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot sync data to file '%s'\""
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_fsync",
          "args": [
            "fd"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "177-185",
          "snippet": "gint\nvir_g_fsync(gint fd)\n{\n#ifdef G_OS_WIN32\n    return _commit(fd);\n#else\n    return fsync(fd);\n#endif\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\ngint\nvir_g_fsync(gint fd)\n{\n#ifdef G_OS_WIN32\n    return _commit(fd);\n#else\n    return fsync(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot fill file '%s'\")",
            "vol->target.path"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safezero",
          "args": [
            "fd",
            "pos",
            "vol->target.allocation - pos"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "safezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1229-1244",
          "snippet": "int safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCopyToFD",
          "args": [
            "vol",
            "inputvol",
            "fd",
            "&remain",
            "!need_alloc",
            "reflink_copy"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot allocate %llu bytes in file '%s'\")",
            "vol->target.allocation",
            "vol->target.path"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallocate",
          "args": [
            "fd",
            "0",
            "0",
            "vol->target.allocation"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot extend file '%s'\")",
            "vol->target.path"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "vol->target.capacity"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ncreateRawFile(int fd, virStorageVolDefPtr vol,\n              virStorageVolDefPtr inputvol,\n              bool reflink_copy)\n{\n    bool need_alloc = true;\n    int ret = 0;\n    unsigned long long pos = 0;\n\n    /* If the new allocation is lower than the capacity of the original file,\n     * the cloned volume will be sparse */\n    if (inputvol &&\n        vol->target.allocation < inputvol->target.capacity)\n        need_alloc = false;\n\n    /* Seek to the final size, so the capacity is available upfront\n     * for progress reporting */\n    if (ftruncate(fd, vol->target.capacity) < 0) {\n        ret = -errno;\n        virReportSystemError(errno,\n                             _(\"cannot extend file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n/* Avoid issues with older kernel's <linux/fs.h> namespace pollution. */\n#if HAVE_FALLOCATE - 0\n    /* Try to preallocate all requested disk space, but fall back to\n     * other methods if this fails with ENOSYS or EOPNOTSUPP. If allocation\n     * is 0 (or less than 0), then fallocate will fail with EINVAL.\n     * NOTE: do not use posix_fallocate; posix_fallocate falls back\n     * to writing zeroes block by block in case fallocate isn't\n     * available, and since we're going to copy data from another\n     * file it doesn't make sense to write the file twice. */\n    if (vol->target.allocation && need_alloc) {\n        if (fallocate(fd, 0, 0, vol->target.allocation) == 0) {\n            need_alloc = false;\n        } else if (errno != ENOSYS && errno != EOPNOTSUPP) {\n            ret = -errno;\n            virReportSystemError(errno,\n                                 _(\"cannot allocate %llu bytes in file '%s'\"),\n                                 vol->target.allocation, vol->target.path);\n            return ret;\n        }\n    }\n#endif\n\n    if (inputvol) {\n        unsigned long long remain = inputvol->target.capacity;\n        /* allow zero blocks to be skipped if we've requested sparse\n         * allocation (allocation < capacity) or we have already\n         * been able to allocate the required space. */\n        if ((ret = virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                             !need_alloc, reflink_copy)) < 0)\n            return ret;\n\n        /* If the new allocation is greater than the original capacity,\n         * but fallocate failed, fill the rest with zeroes.\n         */\n        pos = inputvol->target.capacity - remain;\n    }\n\n    if (need_alloc && (vol->target.allocation - pos > 0)) {\n        if (safezero(fd, pos, vol->target.allocation - pos) < 0) {\n            ret = -errno;\n            virReportSystemError(errno, _(\"cannot fill file '%s'\"),\n                                 vol->target.path);\n            return ret;\n        }\n    }\n\n    if (g_fsync(fd) < 0) {\n        ret = -errno;\n        virReportSystemError(errno, _(\"cannot sync data to file '%s'\"),\n                             vol->target.path);\n        return ret;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "storageBackendCreateBlockFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "238-315",
    "snippet": "static int\nstorageBackendCreateBlockFrom(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags)\n{\n    unsigned long long remain;\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode;\n    bool reflink_copy = false;\n    VIR_AUTOCLOSE fd = -1;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  -1);\n\n    if (flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation is not supported for block \"\n                         \"volumes\"));\n        return -1;\n    }\n\n    if (flags & VIR_STORAGE_VOL_CREATE_REFLINK)\n        reflink_copy = true;\n\n    if ((fd = open(vol->target.path, O_RDWR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create path '%s'\"),\n                             vol->target.path);\n        return -1;\n    }\n\n    remain = vol->target.capacity;\n\n    if (inputvol) {\n        if (virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                      false, reflink_copy) < 0)\n            return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno, _(\"stat of '%s' failed\"),\n                             vol->target.path);\n        return -1;\n    }\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (fchown(fd, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown '%s' to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        return -1;\n    }\n\n    mode = (vol->target.perms->mode == (mode_t)-1 ?\n            VIR_STORAGE_DEFAULT_VOL_PERM_MODE : vol->target.perms->mode);\n    if (fchmod(fd, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        return -1;\n    }\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot close file '%s'\"),\n                             vol->target.path);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot close file '%s'\")",
            "vol->target.path"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot close file '%s'\""
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot set mode of '%s' to %04o\")",
            "vol->target.path",
            "mode"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "mode"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chown '%s' to (%u, %u)\")",
            "vol->target.path",
            "(unsigned int)uid",
            "(unsigned int)gid"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "uid",
            "gid"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"stat of '%s' failed\")",
            "vol->target.path"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendCopyToFD",
          "args": [
            "vol",
            "inputvol",
            "fd",
            "&remain",
            "false",
            "reflink_copy"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create path '%s'\")",
            "vol->target.path"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "vol->target.path",
            "O_RDWR"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"metadata preallocation is not supported for block \"\n                         \"volumes\")"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK",
            "-1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nstorageBackendCreateBlockFrom(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              virStorageVolDefPtr inputvol,\n                              unsigned int flags)\n{\n    unsigned long long remain;\n    struct stat st;\n    gid_t gid;\n    uid_t uid;\n    mode_t mode;\n    bool reflink_copy = false;\n    VIR_AUTOCLOSE fd = -1;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  -1);\n\n    if (flags & VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"metadata preallocation is not supported for block \"\n                         \"volumes\"));\n        return -1;\n    }\n\n    if (flags & VIR_STORAGE_VOL_CREATE_REFLINK)\n        reflink_copy = true;\n\n    if ((fd = open(vol->target.path, O_RDWR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create path '%s'\"),\n                             vol->target.path);\n        return -1;\n    }\n\n    remain = vol->target.capacity;\n\n    if (inputvol) {\n        if (virStorageBackendCopyToFD(vol, inputvol, fd, &remain,\n                                      false, reflink_copy) < 0)\n            return -1;\n    }\n\n    if (fstat(fd, &st) == -1) {\n        virReportSystemError(errno, _(\"stat of '%s' failed\"),\n                             vol->target.path);\n        return -1;\n    }\n    uid = (vol->target.perms->uid != st.st_uid) ? vol->target.perms->uid\n        : (uid_t)-1;\n    gid = (vol->target.perms->gid != st.st_gid) ? vol->target.perms->gid\n        : (gid_t)-1;\n    if (((uid != (uid_t)-1) || (gid != (gid_t)-1))\n        && (fchown(fd, uid, gid) < 0)) {\n        virReportSystemError(errno,\n                             _(\"cannot chown '%s' to (%u, %u)\"),\n                             vol->target.path, (unsigned int)uid,\n                             (unsigned int)gid);\n        return -1;\n    }\n\n    mode = (vol->target.perms->mode == (mode_t)-1 ?\n            VIR_STORAGE_DEFAULT_VOL_PERM_MODE : vol->target.perms->mode);\n    if (fchmod(fd, mode) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set mode of '%s' to %04o\"),\n                             vol->target.path, mode);\n        return -1;\n    }\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot close file '%s'\"),\n                             vol->target.path);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "reflinkCloneFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "115-121",
    "snippet": "static inline int\nreflinkCloneFile(int dest_fd G_GNUC_UNUSED,\n                 int src_fd G_GNUC_UNUSED)\n{\n    errno = ENOTSUP;\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline int\nreflinkCloneFile(int dest_fd G_GNUC_UNUSED,\n                 int src_fd G_GNUC_UNUSED)\n{\n    errno = ENOTSUP;\n    return -1;\n}"
  },
  {
    "function_name": "reflinkCloneFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "109-113",
    "snippet": "static inline int\nreflinkCloneFile(int dest_fd, int src_fd)\n{\n    return ioctl(dest_fd, REFLINK_IOC_CLONE, src_fd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "dest_fd",
            "REFLINK_IOC_CLONE",
            "src_fd"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline int\nreflinkCloneFile(int dest_fd, int src_fd)\n{\n    return ioctl(dest_fd, REFLINK_IOC_CLONE, src_fd);\n}"
  },
  {
    "function_name": "virStorageBackendNamespaceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
    "lines": "93-98",
    "snippet": "int\nvirStorageBackendNamespaceInit(int poolType,\n                               virXMLNamespacePtr xmlns)\n{\n    return virStoragePoolOptionsPoolTypeSetXMLNamespace(poolType, xmlns);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virjson.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"storage_util.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"viruuid.h\"",
      "#include \"vircrypto.h\"",
      "#include \"virsecret.h\"",
      "#include \"secret_conf.h\"",
      "#include \"internal.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"datatypes.h\"",
      "# include <xfs/xfs.h>",
      "# include <linux/btrfs.h>",
      "# include <selinux/selinux.h>",
      "# include <blkid.h>",
      "# include <linux/fs.h>",
      "# include <sys/ioctl.h>",
      "#include <dirent.h>",
      "#include <sys/param.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolOptionsPoolTypeSetXMLNamespace",
          "args": [
            "poolType",
            "xmlns"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolOptionsPoolTypeSetXMLNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "344-356",
          "snippet": "int\nvirStoragePoolOptionsPoolTypeSetXMLNamespace(int type,\n                                             virXMLNamespacePtr ns)\n{\n    virStoragePoolTypeInfoPtr backend = virStoragePoolTypeInfoLookup(type);\n\n    if (!backend)\n        return -1;\n\n    backend->poolOptions.ns = *ns;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStoragePoolOptionsPoolTypeSetXMLNamespace(int type,\n                                             virXMLNamespacePtr ns)\n{\n    virStoragePoolTypeInfoPtr backend = virStoragePoolTypeInfoLookup(type);\n\n    if (!backend)\n        return -1;\n\n    backend->poolOptions.ns = *ns;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendNamespaceInit(int poolType,\n                               virXMLNamespacePtr xmlns)\n{\n    return virStoragePoolOptionsPoolTypeSetXMLNamespace(poolType, xmlns);\n}"
  }
]