[
  {
    "function_name": "esxStorageVolGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1453-1460",
    "snippet": "static char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    char *path;\n\n    path = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n    return path;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "volume->pool",
            "volume->name"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    char *path;\n\n    path = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n    return path;\n}"
  },
  {
    "function_name": "esxStorageVolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1372-1449",
    "snippet": "static char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume,\n                        unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStoragePoolDef pool;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n    esxVI_IsoImageFileInfo *isoImageFileInfo = NULL;\n    esxVI_FloppyImageFileInfo *floppyImageFileInfo = NULL;\n    virStorageVolDef def;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, volume->pool,\n                                     &pool.type) < 0) {\n        return NULL;\n    }\n\n    /* Lookup file info */\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_LookupFileInfoByDatastorePath(priv->primary, datastorePath,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n    isoImageFileInfo = esxVI_IsoImageFileInfo_DynamicCast(fileInfo);\n    floppyImageFileInfo = esxVI_FloppyImageFileInfo_DynamicCast(fileInfo);\n\n    def.name = volume->name;\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, datastorePath,\n                                                    &def.key) < 0) {\n        goto cleanup;\n    }\n\n    def.type = VIR_STORAGE_VOL_FILE;\n    def.target.path = datastorePath;\n\n    if (vmDiskFileInfo) {\n        /* Scale from kilobyte to byte */\n        def.target.capacity = vmDiskFileInfo->capacityKb->value * 1024;\n        def.target.allocation = vmDiskFileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_VMDK;\n    } else if (isoImageFileInfo) {\n        def.target.capacity = fileInfo->fileSize->value;\n        def.target.allocation = fileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_ISO;\n    } else if (floppyImageFileInfo) {\n        def.target.capacity = fileInfo->fileSize->value;\n        def.target.allocation = fileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_RAW;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File '%s' has unknown type\"), datastorePath);\n        goto cleanup;\n    }\n\n    xml = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(def.key);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def.key"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFormat",
          "args": [
            "&pool",
            "&def"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1594-1670",
          "snippet": "char *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"File '%s' has unknown type\")",
            "datastorePath"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File '%s' has unknown type\""
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePath",
            "&def.key"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3700-3746",
          "snippet": "int\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_FloppyImageFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_IsoImageFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePath",
            "false",
            "&fileInfo",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "volume->pool",
            "volume->name"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxLookupVMFSStoragePoolType",
          "args": [
            "priv->primary",
            "volume->pool",
            "&pool.type"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "esxLookupVMFSStoragePoolType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "97-126",
          "snippet": "static int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pool",
            "0",
            "sizeof(pool)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume,\n                        unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStoragePoolDef pool;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n    esxVI_IsoImageFileInfo *isoImageFileInfo = NULL;\n    esxVI_FloppyImageFileInfo *floppyImageFileInfo = NULL;\n    virStorageVolDef def;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, volume->pool,\n                                     &pool.type) < 0) {\n        return NULL;\n    }\n\n    /* Lookup file info */\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_LookupFileInfoByDatastorePath(priv->primary, datastorePath,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n    isoImageFileInfo = esxVI_IsoImageFileInfo_DynamicCast(fileInfo);\n    floppyImageFileInfo = esxVI_FloppyImageFileInfo_DynamicCast(fileInfo);\n\n    def.name = volume->name;\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, datastorePath,\n                                                    &def.key) < 0) {\n        goto cleanup;\n    }\n\n    def.type = VIR_STORAGE_VOL_FILE;\n    def.target.path = datastorePath;\n\n    if (vmDiskFileInfo) {\n        /* Scale from kilobyte to byte */\n        def.target.capacity = vmDiskFileInfo->capacityKb->value * 1024;\n        def.target.allocation = vmDiskFileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_VMDK;\n    } else if (isoImageFileInfo) {\n        def.target.capacity = fileInfo->fileSize->value;\n        def.target.allocation = fileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_ISO;\n    } else if (floppyImageFileInfo) {\n        def.target.capacity = fileInfo->fileSize->value;\n        def.target.allocation = fileInfo->fileSize->value;\n\n        def.target.format = VIR_STORAGE_FILE_RAW;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File '%s' has unknown type\"), datastorePath);\n        goto cleanup;\n    }\n\n    xml = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(def.key);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxStorageVolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1328-1368",
    "snippet": "static int\nesxStorageVolGetInfo(virStorageVolPtr volume,\n                     virStorageVolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n\n    memset(info, 0, sizeof(*info));\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_LookupFileInfoByDatastorePath(priv->primary, datastorePath,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n\n    info->type = VIR_STORAGE_VOL_FILE;\n\n    if (vmDiskFileInfo) {\n        /* Scale from kilobyte to byte */\n        info->capacity = vmDiskFileInfo->capacityKb->value * 1024;\n        info->allocation = vmDiskFileInfo->fileSize->value;\n    } else {\n        info->capacity = fileInfo->fileSize->value;\n        info->allocation = fileInfo->fileSize->value;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePath",
            "false",
            "&fileInfo",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "volume->pool",
            "volume->name"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolGetInfo(virStorageVolPtr volume,\n                     virStorageVolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n\n    memset(info, 0, sizeof(*info));\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_LookupFileInfoByDatastorePath(priv->primary, datastorePath,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n\n    info->type = VIR_STORAGE_VOL_FILE;\n\n    if (vmDiskFileInfo) {\n        /* Scale from kilobyte to byte */\n        info->capacity = vmDiskFileInfo->capacityKb->value * 1024;\n        info->allocation = vmDiskFileInfo->fileSize->value;\n    } else {\n        info->capacity = fileInfo->fileSize->value;\n        info->allocation = fileInfo->fileSize->value;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStorageVolWipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1286-1324",
    "snippet": "static int\nesxStorageVolWipe(virStorageVolPtr volume, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_ZeroFillVirtualDisk_Task(priv->primary, datastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                    esxVI_Occurrence_None,\n                                    priv->parsedUri->autoAnswer,\n                                    &taskInfoState, &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not wipe volume: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not wipe volume: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not wipe volume: %s\""
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ZeroFillVirtualDisk_Task",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "&task"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "volume->pool",
            "volume->name"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolWipe(virStorageVolPtr volume, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_ZeroFillVirtualDisk_Task(priv->primary, datastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                    esxVI_Occurrence_None,\n                                    priv->parsedUri->autoAnswer,\n                                    &taskInfoState, &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not wipe volume: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStorageVolDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1244-1282",
    "snippet": "static int\nesxStorageVolDelete(virStorageVolPtr volume, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_DeleteVirtualDisk_Task(priv->primary, datastorePath,\n                                     priv->primary->datacenter->_reference,\n                                     &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                    esxVI_Occurrence_None,\n                                    priv->parsedUri->autoAnswer,\n                                    &taskInfoState, &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not delete volume: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not delete volume: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not delete volume: %s\""
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_DeleteVirtualDisk_Task",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "&task"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "volume->pool",
            "volume->name"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolDelete(virStorageVolPtr volume, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", volume->pool, volume->name);\n\n    if (esxVI_DeleteVirtualDisk_Task(priv->primary, datastorePath,\n                                     priv->primary->datacenter->_reference,\n                                     &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                    esxVI_Occurrence_None,\n                                    priv->parsedUri->autoAnswer,\n                                    &taskInfoState, &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not delete volume: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStorageVolCreateXMLFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "1069-1240",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool,\n                           const char *xmldesc,\n                           virStorageVolPtr sourceVolume,\n                           unsigned int flags)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    virStoragePoolDef poolDef;\n    char *sourceDatastorePath = NULL;\n    char *tmp;\n    char *unescapedDatastorePath = NULL;\n    char *unescapedDirectoryName = NULL;\n    char *unescapedDirectoryAndFileName = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *datastorePathWithoutFileName = NULL;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    char *uuid_string = NULL;\n    char *key = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&poolDef, 0, sizeof(poolDef));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, pool->name,\n                                     &poolDef.type) < 0) {\n        goto cleanup;\n    }\n\n    sourceDatastorePath = g_strdup_printf(\"[%s] %s\", sourceVolume->pool,\n                                          sourceVolume->name);\n\n    /* Parse config */\n    def = virStorageVolDefParseString(&poolDef, xmldesc, 0);\n\n    if (!def)\n        goto cleanup;\n\n    if (def->type != VIR_STORAGE_VOL_FILE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Creating non-file volumes is not supported\"));\n        goto cleanup;\n    }\n\n    /* Validate config */\n    tmp = strrchr(def->name, '/');\n\n    if (!tmp || *def->name == '/' || tmp[1] == '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\"), def->name);\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(def->name, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\"), def->name);\n        goto cleanup;\n    }\n\n    unescapedDatastorePath = g_strdup_printf(\"[%s] %s\", pool->name, def->name);\n\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        /* Parse and escape datastore path */\n        if (esxUtil_ParseDatastorePath(unescapedDatastorePath, NULL,\n                                       &unescapedDirectoryName,\n                                       &unescapedDirectoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        directoryName = esxUtil_EscapeDatastoreItem(unescapedDirectoryName);\n\n        if (!directoryName)\n            goto cleanup;\n\n        fileName = esxUtil_EscapeDatastoreItem(unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1);\n\n        if (!fileName)\n            goto cleanup;\n\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", pool->name,\n                                                       directoryName);\n\n        datastorePath = g_strdup_printf(\"[%s] %s/%s\", pool->name, directoryName,\n                                        fileName);\n\n        /* Create directory, if it doesn't exist yet */\n        if (esxVI_LookupFileInfoByDatastorePath\n              (priv->primary, datastorePathWithoutFileName, true, &fileInfo,\n               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!fileInfo) {\n            if (esxVI_MakeDirectory(priv->primary, datastorePathWithoutFileName,\n                                    priv->primary->datacenter->_reference,\n                                    esxVI_Boolean_True) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Copy VirtualDisk */\n        if (esxVI_CopyVirtualDisk_Task(priv->primary, sourceDatastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       datastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       NULL, esxVI_Boolean_False, &task) < 0 ||\n            esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                        esxVI_Occurrence_None,\n                                        priv->parsedUri->autoAnswer,\n                                        &taskInfoState,\n                                        &taskInfoErrorMessage) < 0) {\n            goto cleanup;\n        }\n\n        if (taskInfoState != esxVI_TaskInfoState_Success) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not copy volume: %s\"),\n                           taskInfoErrorMessage);\n            goto cleanup;\n        }\n\n        if (priv->primary->hasQueryVirtualDiskUuid) {\n            if (VIR_ALLOC_N(key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryVirtualDiskUuid(priv->primary, datastorePath,\n                                           priv->primary->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (esxUtil_ReformatUuid(uuid_string, key) < 0)\n                goto cleanup;\n        } else {\n            /* Fall back to the path as key */\n            key = g_strdup(datastorePath);\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Creation of %s volumes is not supported\"),\n                       virStorageFileFormatTypeToString(def->target.format));\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(sourceDatastorePath);\n    VIR_FREE(unescapedDatastorePath);\n    VIR_FREE(unescapedDirectoryName);\n    VIR_FREE(unescapedDirectoryAndFileName);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    VIR_FREE(uuid_string);\n    VIR_FREE(key);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "key"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid_string"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePathWithoutFileName"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDirectoryAndFileName"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDirectoryName"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDatastorePath"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sourceDatastorePath"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "def->name",
            "key",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Creation of %s volumes is not supported\")",
            "virStorageFileFormatTypeToString(def->target.format)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "def->target.format"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Creation of %s volumes is not supported\""
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "datastorePath"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ReformatUuid",
          "args": [
            "uuid_string",
            "key"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ReformatUuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "330-345",
          "snippet": "int\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_QueryVirtualDiskUuid",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "&uuid_string"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "key",
            "VIR_UUID_STRING_BUFLEN"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not copy volume: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CopyVirtualDisk_Task",
          "args": [
            "priv->primary",
            "sourceDatastorePath",
            "priv->primary->datacenter->_reference",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "NULL",
            "esxVI_Boolean_False",
            "&task"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MakeDirectory",
          "args": [
            "priv->primary",
            "datastorePathWithoutFileName",
            "priv->primary->datacenter->_reference",
            "esxVI_Boolean_True"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePathWithoutFileName",
            "true",
            "&fileInfo",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeDatastoreItem",
          "args": [
            "unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeDatastoreItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "429-452",
          "snippet": "char *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "unescapedDirectoryName"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "unescapedDatastorePath",
            "NULL",
            "&unescapedDirectoryName",
            "&unescapedDirectoryAndFileName"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\")",
            "def->name"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "def->name",
            "\".vmdk\""
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\")",
            "def->name"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "def->name",
            "'/'"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Creating non-file volumes is not supported\")"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefParseString",
          "args": [
            "&poolDef",
            "xmldesc",
            "0"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1470-1476",
          "snippet": "virStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxLookupVMFSStoragePoolType",
          "args": [
            "priv->primary",
            "pool->name",
            "&poolDef.type"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "esxLookupVMFSStoragePoolType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "97-126",
          "snippet": "static int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&poolDef",
            "0",
            "sizeof(poolDef)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool,\n                           const char *xmldesc,\n                           virStorageVolPtr sourceVolume,\n                           unsigned int flags)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    virStoragePoolDef poolDef;\n    char *sourceDatastorePath = NULL;\n    char *tmp;\n    char *unescapedDatastorePath = NULL;\n    char *unescapedDirectoryName = NULL;\n    char *unescapedDirectoryAndFileName = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *datastorePathWithoutFileName = NULL;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    char *uuid_string = NULL;\n    char *key = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&poolDef, 0, sizeof(poolDef));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, pool->name,\n                                     &poolDef.type) < 0) {\n        goto cleanup;\n    }\n\n    sourceDatastorePath = g_strdup_printf(\"[%s] %s\", sourceVolume->pool,\n                                          sourceVolume->name);\n\n    /* Parse config */\n    def = virStorageVolDefParseString(&poolDef, xmldesc, 0);\n\n    if (!def)\n        goto cleanup;\n\n    if (def->type != VIR_STORAGE_VOL_FILE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Creating non-file volumes is not supported\"));\n        goto cleanup;\n    }\n\n    /* Validate config */\n    tmp = strrchr(def->name, '/');\n\n    if (!tmp || *def->name == '/' || tmp[1] == '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\"), def->name);\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(def->name, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\"), def->name);\n        goto cleanup;\n    }\n\n    unescapedDatastorePath = g_strdup_printf(\"[%s] %s\", pool->name, def->name);\n\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        /* Parse and escape datastore path */\n        if (esxUtil_ParseDatastorePath(unescapedDatastorePath, NULL,\n                                       &unescapedDirectoryName,\n                                       &unescapedDirectoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        directoryName = esxUtil_EscapeDatastoreItem(unescapedDirectoryName);\n\n        if (!directoryName)\n            goto cleanup;\n\n        fileName = esxUtil_EscapeDatastoreItem(unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1);\n\n        if (!fileName)\n            goto cleanup;\n\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", pool->name,\n                                                       directoryName);\n\n        datastorePath = g_strdup_printf(\"[%s] %s/%s\", pool->name, directoryName,\n                                        fileName);\n\n        /* Create directory, if it doesn't exist yet */\n        if (esxVI_LookupFileInfoByDatastorePath\n              (priv->primary, datastorePathWithoutFileName, true, &fileInfo,\n               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!fileInfo) {\n            if (esxVI_MakeDirectory(priv->primary, datastorePathWithoutFileName,\n                                    priv->primary->datacenter->_reference,\n                                    esxVI_Boolean_True) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Copy VirtualDisk */\n        if (esxVI_CopyVirtualDisk_Task(priv->primary, sourceDatastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       datastorePath,\n                                       priv->primary->datacenter->_reference,\n                                       NULL, esxVI_Boolean_False, &task) < 0 ||\n            esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                        esxVI_Occurrence_None,\n                                        priv->parsedUri->autoAnswer,\n                                        &taskInfoState,\n                                        &taskInfoErrorMessage) < 0) {\n            goto cleanup;\n        }\n\n        if (taskInfoState != esxVI_TaskInfoState_Success) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not copy volume: %s\"),\n                           taskInfoErrorMessage);\n            goto cleanup;\n        }\n\n        if (priv->primary->hasQueryVirtualDiskUuid) {\n            if (VIR_ALLOC_N(key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryVirtualDiskUuid(priv->primary, datastorePath,\n                                           priv->primary->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (esxUtil_ReformatUuid(uuid_string, key) < 0)\n                goto cleanup;\n        } else {\n            /* Fall back to the path as key */\n            key = g_strdup(datastorePath);\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Creation of %s volumes is not supported\"),\n                       virStorageFileFormatTypeToString(def->target.format));\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(sourceDatastorePath);\n    VIR_FREE(unescapedDatastorePath);\n    VIR_FREE(unescapedDirectoryName);\n    VIR_FREE(unescapedDirectoryAndFileName);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    VIR_FREE(uuid_string);\n    VIR_FREE(key);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "859-1065",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool,\n                       const char *xmldesc,\n                       unsigned int flags)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    virStoragePoolDef poolDef;\n    char *tmp;\n    char *unescapedDatastorePath = NULL;\n    char *unescapedDirectoryName = NULL;\n    char *unescapedDirectoryAndFileName = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *datastorePathWithoutFileName = NULL;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_FileBackedVirtualDiskSpec *virtualDiskSpec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    char *uuid_string = NULL;\n    char *key = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&poolDef, 0, sizeof(poolDef));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, pool->name,\n                                     &poolDef.type) < 0) {\n        goto cleanup;\n    }\n\n    /* Parse config */\n    def = virStorageVolDefParseString(&poolDef, xmldesc, 0);\n\n    if (!def)\n        goto cleanup;\n\n    if (def->type != VIR_STORAGE_VOL_FILE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Creating non-file volumes is not supported\"));\n        goto cleanup;\n    }\n\n    /* Validate config */\n    tmp = strrchr(def->name, '/');\n\n    if (!tmp || *def->name == '/' || tmp[1] == '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\"), def->name);\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(def->name, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\"), def->name);\n        goto cleanup;\n    }\n\n    unescapedDatastorePath = g_strdup_printf(\"[%s] %s\", pool->name, def->name);\n\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        /* Parse and escape datastore path */\n        if (esxUtil_ParseDatastorePath(unescapedDatastorePath, NULL,\n                                       &unescapedDirectoryName,\n                                       &unescapedDirectoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        directoryName = esxUtil_EscapeDatastoreItem(unescapedDirectoryName);\n\n        if (!directoryName)\n            goto cleanup;\n\n        fileName = esxUtil_EscapeDatastoreItem(unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1);\n\n        if (!fileName)\n            goto cleanup;\n\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", pool->name,\n                                                       directoryName);\n\n        datastorePath = g_strdup_printf(\"[%s] %s/%s\", pool->name, directoryName,\n                                        fileName);\n\n        /* Create directory, if it doesn't exist yet */\n        if (esxVI_LookupFileInfoByDatastorePath\n              (priv->primary, datastorePathWithoutFileName, true, &fileInfo,\n               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!fileInfo) {\n            if (esxVI_MakeDirectory(priv->primary, datastorePathWithoutFileName,\n                                    priv->primary->datacenter->_reference,\n                                    esxVI_Boolean_True) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Create VirtualDisk */\n        if (esxVI_FileBackedVirtualDiskSpec_Alloc(&virtualDiskSpec) < 0 ||\n            esxVI_Long_Alloc(&virtualDiskSpec->capacityKb) < 0) {\n            goto cleanup;\n        }\n\n        /* From the vSphere API documentation about VirtualDiskType ... */\n        if (def->target.allocation == def->target.capacity) {\n            /*\n             * \"A preallocated disk has all space allocated at creation time\n             *  and the space is zeroed on demand as the space is used.\"\n             */\n            virtualDiskSpec->diskType = (char *)\"preallocated\";\n        } else if (def->target.allocation == 0) {\n            /*\n             * \"Space required for thin-provisioned virtual disk is allocated\n             *  and zeroed on demand as the space is used.\"\n             */\n            virtualDiskSpec->diskType = (char *)\"thin\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported capacity-to-allocation relation\"));\n            goto cleanup;\n        }\n\n        /*\n         * FIXME: The adapter type is a required parameter, but there is no\n         * way to let the user specify it in the volume XML config. Therefore,\n         * default to 'lsiLogic' here.\n         */\n        virtualDiskSpec->adapterType = (char *)\"lsiLogic\";\n\n        virtualDiskSpec->capacityKb->value =\n          VIR_DIV_UP(def->target.capacity, 1024); /* Scale from byte to kilobyte */\n\n        if (esxVI_CreateVirtualDisk_Task\n              (priv->primary, datastorePath,\n               priv->primary->datacenter->_reference,\n               esxVI_VirtualDiskSpec_DynamicCast(virtualDiskSpec), &task) < 0 ||\n            esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                        esxVI_Occurrence_None,\n                                        priv->parsedUri->autoAnswer,\n                                        &taskInfoState,\n                                        &taskInfoErrorMessage) < 0) {\n            goto cleanup;\n        }\n\n        if (taskInfoState != esxVI_TaskInfoState_Success) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not create volume: %s\"),\n                           taskInfoErrorMessage);\n            goto cleanup;\n        }\n\n        if (priv->primary->hasQueryVirtualDiskUuid) {\n            if (VIR_ALLOC_N(key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryVirtualDiskUuid(priv->primary, datastorePath,\n                                           priv->primary->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (esxUtil_ReformatUuid(uuid_string, key) < 0)\n                goto cleanup;\n        } else {\n            /* Fall back to the path as key */\n            key = g_strdup(datastorePath);\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Creation of %s volumes is not supported\"),\n                       virStorageFileFormatTypeToString(def->target.format));\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    if (virtualDiskSpec) {\n        virtualDiskSpec->diskType = NULL;\n        virtualDiskSpec->adapterType = NULL;\n    }\n\n    VIR_FREE(unescapedDatastorePath);\n    VIR_FREE(unescapedDirectoryName);\n    VIR_FREE(unescapedDirectoryAndFileName);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    esxVI_FileBackedVirtualDiskSpec_Free(&virtualDiskSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    VIR_FREE(uuid_string);\n    VIR_FREE(key);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "key"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid_string"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileBackedVirtualDiskSpec_Free",
          "args": [
            "&virtualDiskSpec"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePathWithoutFileName"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDirectoryAndFileName"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDirectoryName"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "unescapedDatastorePath"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "def->name",
            "key",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Creation of %s volumes is not supported\")",
            "virStorageFileFormatTypeToString(def->target.format)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "def->target.format"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Creation of %s volumes is not supported\""
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "datastorePath"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ReformatUuid",
          "args": [
            "uuid_string",
            "key"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ReformatUuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "330-345",
          "snippet": "int\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_QueryVirtualDiskUuid",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "&uuid_string"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "key",
            "VIR_UUID_STRING_BUFLEN"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not create volume: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CreateVirtualDisk_Task",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "esxVI_VirtualDiskSpec_DynamicCast(virtualDiskSpec)",
            "&task"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualDiskSpec_DynamicCast",
          "args": [
            "virtualDiskSpec"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->target.capacity",
            "1024"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unsupported capacity-to-allocation relation\")"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&virtualDiskSpec->capacityKb"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileBackedVirtualDiskSpec_Alloc",
          "args": [
            "&virtualDiskSpec"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MakeDirectory",
          "args": [
            "priv->primary",
            "datastorePathWithoutFileName",
            "priv->primary->datacenter->_reference",
            "esxVI_Boolean_True"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePathWithoutFileName",
            "true",
            "&fileInfo",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeDatastoreItem",
          "args": [
            "unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeDatastoreItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "429-452",
          "snippet": "char *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "unescapedDirectoryName"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "unescapedDatastorePath",
            "NULL",
            "&unescapedDirectoryName",
            "&unescapedDirectoryAndFileName"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\")",
            "def->name"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "def->name",
            "\".vmdk\""
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\")",
            "def->name"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "def->name",
            "'/'"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Creating non-file volumes is not supported\")"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefParseString",
          "args": [
            "&poolDef",
            "xmldesc",
            "0"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1470-1476",
          "snippet": "virStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxLookupVMFSStoragePoolType",
          "args": [
            "priv->primary",
            "pool->name",
            "&poolDef.type"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "esxLookupVMFSStoragePoolType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "97-126",
          "snippet": "static int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&poolDef",
            "0",
            "sizeof(poolDef)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool,\n                       const char *xmldesc,\n                       unsigned int flags)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    virStoragePoolDef poolDef;\n    char *tmp;\n    char *unescapedDatastorePath = NULL;\n    char *unescapedDirectoryName = NULL;\n    char *unescapedDirectoryAndFileName = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *datastorePathWithoutFileName = NULL;\n    char *datastorePath = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_FileBackedVirtualDiskSpec *virtualDiskSpec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    char *uuid_string = NULL;\n    char *key = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&poolDef, 0, sizeof(poolDef));\n\n    if (esxLookupVMFSStoragePoolType(priv->primary, pool->name,\n                                     &poolDef.type) < 0) {\n        goto cleanup;\n    }\n\n    /* Parse config */\n    def = virStorageVolDefParseString(&poolDef, xmldesc, 0);\n\n    if (!def)\n        goto cleanup;\n\n    if (def->type != VIR_STORAGE_VOL_FILE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Creating non-file volumes is not supported\"));\n        goto cleanup;\n    }\n\n    /* Validate config */\n    tmp = strrchr(def->name, '/');\n\n    if (!tmp || *def->name == '/' || tmp[1] == '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' doesn't have expected format \"\n                         \"'<directory>/<file>'\"), def->name);\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(def->name, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume name '%s' has unsupported suffix, \"\n                         \"expecting '.vmdk'\"), def->name);\n        goto cleanup;\n    }\n\n    unescapedDatastorePath = g_strdup_printf(\"[%s] %s\", pool->name, def->name);\n\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        /* Parse and escape datastore path */\n        if (esxUtil_ParseDatastorePath(unescapedDatastorePath, NULL,\n                                       &unescapedDirectoryName,\n                                       &unescapedDirectoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        directoryName = esxUtil_EscapeDatastoreItem(unescapedDirectoryName);\n\n        if (!directoryName)\n            goto cleanup;\n\n        fileName = esxUtil_EscapeDatastoreItem(unescapedDirectoryAndFileName +\n                                               strlen(unescapedDirectoryName) + 1);\n\n        if (!fileName)\n            goto cleanup;\n\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", pool->name,\n                                                       directoryName);\n\n        datastorePath = g_strdup_printf(\"[%s] %s/%s\", pool->name, directoryName,\n                                        fileName);\n\n        /* Create directory, if it doesn't exist yet */\n        if (esxVI_LookupFileInfoByDatastorePath\n              (priv->primary, datastorePathWithoutFileName, true, &fileInfo,\n               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!fileInfo) {\n            if (esxVI_MakeDirectory(priv->primary, datastorePathWithoutFileName,\n                                    priv->primary->datacenter->_reference,\n                                    esxVI_Boolean_True) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Create VirtualDisk */\n        if (esxVI_FileBackedVirtualDiskSpec_Alloc(&virtualDiskSpec) < 0 ||\n            esxVI_Long_Alloc(&virtualDiskSpec->capacityKb) < 0) {\n            goto cleanup;\n        }\n\n        /* From the vSphere API documentation about VirtualDiskType ... */\n        if (def->target.allocation == def->target.capacity) {\n            /*\n             * \"A preallocated disk has all space allocated at creation time\n             *  and the space is zeroed on demand as the space is used.\"\n             */\n            virtualDiskSpec->diskType = (char *)\"preallocated\";\n        } else if (def->target.allocation == 0) {\n            /*\n             * \"Space required for thin-provisioned virtual disk is allocated\n             *  and zeroed on demand as the space is used.\"\n             */\n            virtualDiskSpec->diskType = (char *)\"thin\";\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported capacity-to-allocation relation\"));\n            goto cleanup;\n        }\n\n        /*\n         * FIXME: The adapter type is a required parameter, but there is no\n         * way to let the user specify it in the volume XML config. Therefore,\n         * default to 'lsiLogic' here.\n         */\n        virtualDiskSpec->adapterType = (char *)\"lsiLogic\";\n\n        virtualDiskSpec->capacityKb->value =\n          VIR_DIV_UP(def->target.capacity, 1024); /* Scale from byte to kilobyte */\n\n        if (esxVI_CreateVirtualDisk_Task\n              (priv->primary, datastorePath,\n               priv->primary->datacenter->_reference,\n               esxVI_VirtualDiskSpec_DynamicCast(virtualDiskSpec), &task) < 0 ||\n            esxVI_WaitForTaskCompletion(priv->primary, task, NULL,\n                                        esxVI_Occurrence_None,\n                                        priv->parsedUri->autoAnswer,\n                                        &taskInfoState,\n                                        &taskInfoErrorMessage) < 0) {\n            goto cleanup;\n        }\n\n        if (taskInfoState != esxVI_TaskInfoState_Success) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not create volume: %s\"),\n                           taskInfoErrorMessage);\n            goto cleanup;\n        }\n\n        if (priv->primary->hasQueryVirtualDiskUuid) {\n            if (VIR_ALLOC_N(key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryVirtualDiskUuid(priv->primary, datastorePath,\n                                           priv->primary->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (esxUtil_ReformatUuid(uuid_string, key) < 0)\n                goto cleanup;\n        } else {\n            /* Fall back to the path as key */\n            key = g_strdup(datastorePath);\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Creation of %s volumes is not supported\"),\n                       virStorageFileFormatTypeToString(def->target.format));\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    if (virtualDiskSpec) {\n        virtualDiskSpec->diskType = NULL;\n        virtualDiskSpec->adapterType = NULL;\n    }\n\n    VIR_FREE(unescapedDatastorePath);\n    VIR_FREE(unescapedDirectoryName);\n    VIR_FREE(unescapedDirectoryAndFileName);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    VIR_FREE(datastorePath);\n    esxVI_FileInfo_Free(&fileInfo);\n    esxVI_FileBackedVirtualDiskSpec_Free(&virtualDiskSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    VIR_FREE(uuid_string);\n    VIR_FREE(key);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "730-855",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    char *datastoreName = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    char *directoryAndFileName = NULL;\n    size_t length;\n    char *datastorePath = NULL;\n    char *volumeName = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n    char key_candidate[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (STRPREFIX(key, \"[\")) {\n        /* Key is probably a datastore path */\n        return esxStorageVolLookupByPath(conn, key);\n    }\n\n    if (!priv->primary->hasQueryVirtualDiskUuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"QueryVirtualDiskUuid not available, \"\n                         \"cannot lookup storage volume by UUID\"));\n        return NULL;\n    }\n\n    /* Lookup all datastores */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        datastoreName = NULL;\n\n        if (esxVI_GetStringValue(datastore, \"summary.name\", &datastoreName,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        /* Lookup datastore content */\n        esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n\n        if (esxVI_LookupDatastoreContentByDatastoreName\n              (priv->primary, datastoreName, &searchResultsList) < 0) {\n            goto cleanup;\n        }\n\n        /* Interpret search result */\n        for (searchResults = searchResultsList; searchResults;\n             searchResults = searchResults->_next) {\n            VIR_FREE(directoryAndFileName);\n\n            if (esxUtil_ParseDatastorePath(searchResults->folderPath, NULL,\n                                           NULL, &directoryAndFileName) < 0) {\n                goto cleanup;\n            }\n\n            /* Strip trailing separators */\n            length = strlen(directoryAndFileName);\n\n            while (length > 0 && directoryAndFileName[length - 1] == '/') {\n                directoryAndFileName[length - 1] = '\\0';\n                --length;\n            }\n\n            /* Build datastore path and query the UUID */\n            for (fileInfo = searchResults->file; fileInfo;\n                 fileInfo = fileInfo->_next) {\n                VIR_FREE(datastorePath);\n\n                if (length < 1) {\n                    volumeName = g_strdup(fileInfo->path);\n                } else {\n                    volumeName = g_strdup_printf(\"%s/%s\",\n                                                 directoryAndFileName, fileInfo->path);\n                }\n\n                datastorePath = g_strdup_printf(\"[%s] %s\", datastoreName, volumeName);\n\n                if (!esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n                    /* Only a VirtualDisk has a UUID */\n                    continue;\n                }\n\n                VIR_FREE(uuid_string);\n\n                if (esxVI_QueryVirtualDiskUuid\n                      (priv->primary, datastorePath,\n                       priv->primary->datacenter->_reference,\n                       &uuid_string) < 0) {\n                    goto cleanup;\n                }\n\n                if (esxUtil_ReformatUuid(uuid_string, key_candidate) < 0)\n                    goto cleanup;\n\n                if (STREQ(key, key_candidate)) {\n                    /* Found matching UUID */\n                    volume = virGetStorageVol(conn, datastoreName,\n                                              volumeName, key,\n                                              &esxStorageBackendVMFS, NULL);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(datastorePath);\n    VIR_FREE(volumeName);\n    VIR_FREE(uuid_string);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid_string"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "volumeName"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_Free",
          "args": [
            "&searchResultsList"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "datastoreName",
            "volumeName",
            "key",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "key",
            "key_candidate"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ReformatUuid",
          "args": [
            "uuid_string",
            "key_candidate"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ReformatUuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "330-345",
          "snippet": "int\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_QueryVirtualDiskUuid",
          "args": [
            "priv->primary",
            "datastorePath",
            "priv->primary->datacenter->_reference",
            "&uuid_string"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid_string"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "datastoreName",
            "volumeName"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "directoryAndFileName"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "searchResults->folderPath",
            "NULL",
            "NULL",
            "&directoryAndFileName"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreContentByDatastoreName",
          "args": [
            "priv->primary",
            "datastoreName",
            "&searchResultsList"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreContentByDatastoreName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3582-3696",
          "snippet": "int\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_Free",
          "args": [
            "&searchResultsList"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "datastore",
            "\"summary.name\"",
            "&datastoreName",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&datastoreList"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"summary.name\""
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"QueryVirtualDiskUuid not available, \"\n                         \"cannot lookup storage volume by UUID\")"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QueryVirtualDiskUuid not available, \"\n                         \"cannot lookup storage volume by UUID\""
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxStorageVolLookupByPath",
          "args": [
            "conn",
            "key"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "esxStorageVolLookupByPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "698-726",
          "snippet": "static virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    char *key = NULL;\n\n    if (esxUtil_ParseDatastorePath(path, &datastoreName, NULL,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, path,\n                                                    &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(conn, datastoreName, directoryAndFileName, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(key);\n\n    return volume;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    char *key = NULL;\n\n    if (esxUtil_ParseDatastorePath(path, &datastoreName, NULL,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, path,\n                                                    &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(conn, datastoreName, directoryAndFileName, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(key);\n\n    return volume;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"[\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    char *datastoreName = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    char *directoryAndFileName = NULL;\n    size_t length;\n    char *datastorePath = NULL;\n    char *volumeName = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n    char key_candidate[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (STRPREFIX(key, \"[\")) {\n        /* Key is probably a datastore path */\n        return esxStorageVolLookupByPath(conn, key);\n    }\n\n    if (!priv->primary->hasQueryVirtualDiskUuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"QueryVirtualDiskUuid not available, \"\n                         \"cannot lookup storage volume by UUID\"));\n        return NULL;\n    }\n\n    /* Lookup all datastores */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        datastoreName = NULL;\n\n        if (esxVI_GetStringValue(datastore, \"summary.name\", &datastoreName,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        /* Lookup datastore content */\n        esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n\n        if (esxVI_LookupDatastoreContentByDatastoreName\n              (priv->primary, datastoreName, &searchResultsList) < 0) {\n            goto cleanup;\n        }\n\n        /* Interpret search result */\n        for (searchResults = searchResultsList; searchResults;\n             searchResults = searchResults->_next) {\n            VIR_FREE(directoryAndFileName);\n\n            if (esxUtil_ParseDatastorePath(searchResults->folderPath, NULL,\n                                           NULL, &directoryAndFileName) < 0) {\n                goto cleanup;\n            }\n\n            /* Strip trailing separators */\n            length = strlen(directoryAndFileName);\n\n            while (length > 0 && directoryAndFileName[length - 1] == '/') {\n                directoryAndFileName[length - 1] = '\\0';\n                --length;\n            }\n\n            /* Build datastore path and query the UUID */\n            for (fileInfo = searchResults->file; fileInfo;\n                 fileInfo = fileInfo->_next) {\n                VIR_FREE(datastorePath);\n\n                if (length < 1) {\n                    volumeName = g_strdup(fileInfo->path);\n                } else {\n                    volumeName = g_strdup_printf(\"%s/%s\",\n                                                 directoryAndFileName, fileInfo->path);\n                }\n\n                datastorePath = g_strdup_printf(\"[%s] %s\", datastoreName, volumeName);\n\n                if (!esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n                    /* Only a VirtualDisk has a UUID */\n                    continue;\n                }\n\n                VIR_FREE(uuid_string);\n\n                if (esxVI_QueryVirtualDiskUuid\n                      (priv->primary, datastorePath,\n                       priv->primary->datacenter->_reference,\n                       &uuid_string) < 0) {\n                    goto cleanup;\n                }\n\n                if (esxUtil_ReformatUuid(uuid_string, key_candidate) < 0)\n                    goto cleanup;\n\n                if (STREQ(key, key_candidate)) {\n                    /* Found matching UUID */\n                    volume = virGetStorageVol(conn, datastoreName,\n                                              volumeName, key,\n                                              &esxStorageBackendVMFS, NULL);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(datastorePath);\n    VIR_FREE(volumeName);\n    VIR_FREE(uuid_string);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "698-726",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    char *key = NULL;\n\n    if (esxUtil_ParseDatastorePath(path, &datastoreName, NULL,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, path,\n                                                    &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(conn, datastoreName, directoryAndFileName, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(key);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "key"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreName"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "datastoreName",
            "directoryAndFileName",
            "key",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "args": [
            "priv->primary",
            "path",
            "&key"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3700-3746",
          "snippet": "int\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "path",
            "&datastoreName",
            "NULL",
            "&directoryAndFileName"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    char *key = NULL;\n\n    if (esxUtil_ParseDatastorePath(path, &datastoreName, NULL,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary, path,\n                                                    &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(conn, datastoreName, directoryAndFileName, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(key);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "670-694",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    char *datastorePath = NULL;\n    char *key = NULL;\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", pool->name, name);\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary,\n                                                    datastorePath, &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastorePath);\n    VIR_FREE(key);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "key"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "name",
            "key",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "args": [
            "priv->primary",
            "datastorePath",
            "&key"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupStorageVolumeKeyByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3700-3746",
          "snippet": "int\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "pool->name",
            "name"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    char *datastorePath = NULL;\n    char *key = NULL;\n\n    datastorePath = g_strdup_printf(\"[%s] %s\", pool->name, name);\n\n    if (esxVI_LookupStorageVolumeKeyByDatastorePath(priv->primary,\n                                                    datastorePath, &key) < 0) {\n        goto cleanup;\n    }\n\n    volume = virGetStorageVol(pool->conn, pool->name, name, key,\n                              &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    VIR_FREE(datastorePath);\n    VIR_FREE(key);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStoragePoolListVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "593-666",
    "snippet": "static int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *directoryAndFileName = NULL;\n    size_t length;\n    int count = 0;\n    size_t i;\n\n    if (!names || maxnames < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_LookupDatastoreContentByDatastoreName(priv->primary, pool->name,\n                                                    &searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    for (searchResults = searchResultsList; searchResults;\n         searchResults = searchResults->_next) {\n        VIR_FREE(directoryAndFileName);\n\n        if (esxUtil_ParseDatastorePath(searchResults->folderPath, NULL, NULL,\n                                       &directoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        /* Strip trailing separators */\n        length = strlen(directoryAndFileName);\n\n        while (length > 0 && directoryAndFileName[length - 1] == '/') {\n            directoryAndFileName[length - 1] = '\\0';\n            --length;\n        }\n\n        /* Build volume names */\n        for (fileInfo = searchResults->file; fileInfo;\n             fileInfo = fileInfo->_next) {\n            if (length < 1) {\n                names[count] = g_strdup(fileInfo->path);\n            } else {\n                names[count] = g_strdup_printf(\"%s/%s\",\n                                               directoryAndFileName, fileInfo->path);\n            }\n\n            ++count;\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n    VIR_FREE(directoryAndFileName);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_Free",
          "args": [
            "&searchResultsList"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "directoryAndFileName",
            "fileInfo->path"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "directoryAndFileName"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "searchResults->folderPath",
            "NULL",
            "NULL",
            "&directoryAndFileName"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreContentByDatastoreName",
          "args": [
            "priv->primary",
            "pool->name",
            "&searchResultsList"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreContentByDatastoreName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3582-3696",
          "snippet": "int\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *directoryAndFileName = NULL;\n    size_t length;\n    int count = 0;\n    size_t i;\n\n    if (!names || maxnames < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_LookupDatastoreContentByDatastoreName(priv->primary, pool->name,\n                                                    &searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    for (searchResults = searchResultsList; searchResults;\n         searchResults = searchResults->_next) {\n        VIR_FREE(directoryAndFileName);\n\n        if (esxUtil_ParseDatastorePath(searchResults->folderPath, NULL, NULL,\n                                       &directoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        /* Strip trailing separators */\n        length = strlen(directoryAndFileName);\n\n        while (length > 0 && directoryAndFileName[length - 1] == '/') {\n            directoryAndFileName[length - 1] = '\\0';\n            --length;\n        }\n\n        /* Build volume names */\n        for (fileInfo = searchResults->file; fileInfo;\n             fileInfo = fileInfo->_next) {\n            if (length < 1) {\n                names[count] = g_strdup(fileInfo->path);\n            } else {\n                names[count] = g_strdup_printf(\"%s/%s\",\n                                               directoryAndFileName, fileInfo->path);\n            }\n\n            ++count;\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n    VIR_FREE(directoryAndFileName);\n\n    return count;\n}"
  },
  {
    "function_name": "esxStoragePoolNumOfVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "559-589",
    "snippet": "static int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    bool success = false;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    int count = 0;\n\n    if (esxVI_LookupDatastoreContentByDatastoreName(priv->primary, pool->name,\n                                                    &searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    for (searchResults = searchResultsList; searchResults;\n         searchResults = searchResults->_next) {\n        for (fileInfo = searchResults->file; fileInfo;\n             fileInfo = fileInfo->_next) {\n            ++count;\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_Free",
          "args": [
            "&searchResultsList"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreContentByDatastoreName",
          "args": [
            "priv->primary",
            "pool->name",
            "&searchResultsList"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreContentByDatastoreName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3582-3696",
          "snippet": "int\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    bool success = false;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostDatastoreBrowserSearchResults *searchResultsList = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n    esxVI_FileInfo *fileInfo = NULL;\n    int count = 0;\n\n    if (esxVI_LookupDatastoreContentByDatastoreName(priv->primary, pool->name,\n                                                    &searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    for (searchResults = searchResultsList; searchResults;\n         searchResults = searchResults->_next) {\n        for (fileInfo = searchResults->file; fileInfo;\n             fileInfo = fileInfo->_next) {\n            ++count;\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResultsList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "esxStoragePoolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "438-555",
    "snippet": "static char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_Boolean accessible = esxVI_Boolean_Undefined;\n    virStoragePoolDef def;\n    esxVI_DatastoreInfo *info = NULL;\n    esxVI_NasDatastoreInfo *nasInfo = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\"\n                                           \"info\\0\") < 0 ||\n        esxVI_LookupDatastoreByName(priv->primary, pool->name,\n                                    propertyNameList, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetBoolean(datastore, \"summary.accessible\",\n                         &accessible, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    def.name = pool->name;\n    memcpy(def.uuid, pool->uuid, VIR_UUID_BUFLEN);\n\n    def.target.path = hostMount->mountInfo->path;\n\n    if (accessible == esxVI_Boolean_True) {\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.capacity\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                def.capacity = dynamicProperty->val->int64;\n            } else if (STREQ(dynamicProperty->name, \"summary.freeSpace\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                def.available = dynamicProperty->val->int64;\n            }\n        }\n\n        def.allocation = def.capacity - def.available;\n    }\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &info) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* See vSphere API documentation about HostDatastoreSystem for details */\n    if (esxVI_LocalDatastoreInfo_DynamicCast(info)) {\n        def.type = VIR_STORAGE_POOL_DIR;\n    } else if ((nasInfo = esxVI_NasDatastoreInfo_DynamicCast(info))) {\n        if (VIR_ALLOC_N(def.source.hosts, 1) < 0)\n            goto cleanup;\n        def.type = VIR_STORAGE_POOL_NETFS;\n        def.source.nhost = 1;\n        def.source.hosts[0].name = nasInfo->nas->remoteHost;\n        def.source.dir = nasInfo->nas->remotePath;\n\n        if (STRCASEEQ(nasInfo->nas->type, \"NFS\")) {\n            def.source.format = VIR_STORAGE_POOL_NETFS_NFS;\n        } else  if (STRCASEEQ(nasInfo->nas->type, \"CIFS\")) {\n            def.source.format = VIR_STORAGE_POOL_NETFS_CIFS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore has unexpected type '%s'\"),\n                           nasInfo->nas->type);\n            goto cleanup;\n        }\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(info)) {\n        def.type = VIR_STORAGE_POOL_FS;\n        def.source.format = VIR_STORAGE_POOL_FS_VMFS;\n        /*\n         * FIXME: I'm not sure how to represent the source and target of a\n         * VMFS based datastore in libvirt terms\n         */\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    xml = virStoragePoolDefFormat(&def);\n\n cleanup:\n    VIR_FREE(def.source.hosts);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n    esxVI_DatastoreInfo_Free(&info);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreInfo_Free",
          "args": [
            "&info"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def.source.hosts"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolDefFormat",
          "args": [
            "&def"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1225-1238",
          "snippet": "char *\nvirStoragePoolDefFormat(virStoragePoolDefPtr def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virStoragePoolDefFormatBuf(&buf, def) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStoragePoolDefFormat(virStoragePoolDefPtr def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virStoragePoolDefFormatBuf(&buf, def) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DatastoreInfo has unexpected type\")"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DatastoreInfo has unexpected type\""
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_VmfsDatastoreInfo_DynamicCast",
          "args": [
            "info"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Datastore has unexpected type '%s'\")",
            "nasInfo->nas->type"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "nasInfo->nas->type",
            "\"CIFS\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "nasInfo->nas->type",
            "\"NFS\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def.source.hosts",
            "1"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_NasDatastoreInfo_DynamicCast",
          "args": [
            "info"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LocalDatastoreInfo_DynamicCast",
          "args": [
            "info"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreInfo_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&info"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"info\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Long"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.freeSpace\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.capacity\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "def.uuid",
            "pool->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreHostMount",
          "args": [
            "priv->primary",
            "datastore->obj",
            "&hostMount",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreHostMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3045-3106",
          "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetBoolean",
          "args": [
            "datastore",
            "\"summary.accessible\"",
            "&accessible",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2229-2261",
          "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "priv->primary",
            "pool->name",
            "propertyNameList",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\"\n                                           \"info\\0\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_Boolean accessible = esxVI_Boolean_Undefined;\n    virStoragePoolDef def;\n    esxVI_DatastoreInfo *info = NULL;\n    esxVI_NasDatastoreInfo *nasInfo = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\"\n                                           \"info\\0\") < 0 ||\n        esxVI_LookupDatastoreByName(priv->primary, pool->name,\n                                    propertyNameList, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetBoolean(datastore, \"summary.accessible\",\n                         &accessible, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    def.name = pool->name;\n    memcpy(def.uuid, pool->uuid, VIR_UUID_BUFLEN);\n\n    def.target.path = hostMount->mountInfo->path;\n\n    if (accessible == esxVI_Boolean_True) {\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.capacity\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                def.capacity = dynamicProperty->val->int64;\n            } else if (STREQ(dynamicProperty->name, \"summary.freeSpace\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                def.available = dynamicProperty->val->int64;\n            }\n        }\n\n        def.allocation = def.capacity - def.available;\n    }\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &info) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* See vSphere API documentation about HostDatastoreSystem for details */\n    if (esxVI_LocalDatastoreInfo_DynamicCast(info)) {\n        def.type = VIR_STORAGE_POOL_DIR;\n    } else if ((nasInfo = esxVI_NasDatastoreInfo_DynamicCast(info))) {\n        if (VIR_ALLOC_N(def.source.hosts, 1) < 0)\n            goto cleanup;\n        def.type = VIR_STORAGE_POOL_NETFS;\n        def.source.nhost = 1;\n        def.source.hosts[0].name = nasInfo->nas->remoteHost;\n        def.source.dir = nasInfo->nas->remotePath;\n\n        if (STRCASEEQ(nasInfo->nas->type, \"NFS\")) {\n            def.source.format = VIR_STORAGE_POOL_NETFS_NFS;\n        } else  if (STRCASEEQ(nasInfo->nas->type, \"CIFS\")) {\n            def.source.format = VIR_STORAGE_POOL_NETFS_CIFS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore has unexpected type '%s'\"),\n                           nasInfo->nas->type);\n            goto cleanup;\n        }\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(info)) {\n        def.type = VIR_STORAGE_POOL_FS;\n        def.source.format = VIR_STORAGE_POOL_FS_VMFS;\n        /*\n         * FIXME: I'm not sure how to represent the source and target of a\n         * VMFS based datastore in libvirt terms\n         */\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    xml = virStoragePoolDefFormat(&def);\n\n cleanup:\n    VIR_FREE(def.source.hosts);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n    esxVI_DatastoreInfo_Free(&info);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxStoragePoolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "377-434",
    "snippet": "static int\nesxStoragePoolGetInfo(virStoragePoolPtr pool,\n                      virStoragePoolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_Boolean accessible = esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\") < 0 ||\n        esxVI_LookupDatastoreByName(priv->primary, pool->name,\n                                    propertyNameList, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetBoolean(datastore, \"summary.accessible\",\n                         &accessible, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (accessible == esxVI_Boolean_True) {\n        info->state = VIR_STORAGE_POOL_RUNNING;\n\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.capacity\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                info->capacity = dynamicProperty->val->int64;\n            } else if (STREQ(dynamicProperty->name, \"summary.freeSpace\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                info->available = dynamicProperty->val->int64;\n            }\n        }\n\n        info->allocation = info->capacity - info->available;\n    } else {\n        info->state = VIR_STORAGE_POOL_INACCESSIBLE;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Long"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.freeSpace\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.capacity\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetBoolean",
          "args": [
            "datastore",
            "\"summary.accessible\"",
            "&accessible",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2229-2261",
          "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "priv->primary",
            "pool->name",
            "propertyNameList",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\""
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolGetInfo(virStoragePoolPtr pool,\n                      virStoragePoolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_Boolean accessible = esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.accessible\\0\"\n                                           \"summary.capacity\\0\"\n                                           \"summary.freeSpace\\0\") < 0 ||\n        esxVI_LookupDatastoreByName(priv->primary, pool->name,\n                                    propertyNameList, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetBoolean(datastore, \"summary.accessible\",\n                         &accessible, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (accessible == esxVI_Boolean_True) {\n        info->state = VIR_STORAGE_POOL_RUNNING;\n\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.capacity\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                info->capacity = dynamicProperty->val->int64;\n            } else if (STREQ(dynamicProperty->name, \"summary.freeSpace\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_Long) < 0) {\n                    goto cleanup;\n                }\n\n                info->available = dynamicProperty->val->int64;\n            }\n        }\n\n        info->allocation = info->capacity - info->available;\n    } else {\n        info->state = VIR_STORAGE_POOL_INACCESSIBLE;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStoragePoolRefresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "352-373",
    "snippet": "static int\nesxStoragePoolRefresh(virStoragePoolPtr pool, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_ObjectContent *datastore = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_LookupDatastoreByName(priv->primary, pool->name, NULL, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_RefreshDatastore(priv->primary, datastore->obj) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RefreshDatastore",
          "args": [
            "priv->primary",
            "datastore->obj"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "priv->primary",
            "pool->name",
            "NULL",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolRefresh(virStoragePoolPtr pool, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_ObjectContent *datastore = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_LookupDatastoreByName(priv->primary, pool->name, NULL, &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_RefreshDatastore(priv->primary, datastore->obj) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "284-348",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn,\n                           const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char *name = NULL;\n    virStoragePoolPtr pool = NULL;\n\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        esxVI_DatastoreHostMount_Free(&hostMount);\n\n        if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj,\n                                           &hostMount,\n                                           esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!hostMount) {\n            /*\n             * Storage pool is not of VMFS type, leave error reporting to the\n             * base storage driver.\n             */\n            goto cleanup;\n        }\n\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (esxVI_GetStringValue(datastore, \"summary.name\", &name,\n                             esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    pool = virGetStoragePool(conn, name, uuid, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStoragePool",
          "args": [
            "conn",
            "name",
            "uuid",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "525-556",
          "snippet": "virStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStoragePoolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStoragePoolClass;\n\nvirStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "datastore",
            "\"summary.name\"",
            "&name",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "md5",
            "VIR_UUID_BUFLEN"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostMount->mountInfo->path",
            "md5"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreHostMount",
          "args": [
            "priv->primary",
            "datastore->obj",
            "&hostMount",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreHostMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3045-3106",
          "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&datastoreList"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"summary.name\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn,\n                           const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char *name = NULL;\n    virStoragePoolPtr pool = NULL;\n\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        esxVI_DatastoreHostMount_Free(&hostMount);\n\n        if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj,\n                                           &hostMount,\n                                           esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (!hostMount) {\n            /*\n             * Storage pool is not of VMFS type, leave error reporting to the\n             * base storage driver.\n             */\n            goto cleanup;\n        }\n\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (esxVI_GetStringValue(datastore, \"summary.name\", &name,\n                             esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    pool = virGetStoragePool(conn, name, uuid, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "256-280",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *datastore = NULL;\n    virStoragePoolPtr pool = NULL;\n\n    if (esxVI_LookupDatastoreByName(priv->primary, name, NULL, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    pool = datastoreToStoragePoolPtr(conn, name, datastore);\n\n cleanup:\n    esxVI_ObjectContent_Free(&datastore);\n\n    return pool;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datastoreToStoragePoolPtr",
          "args": [
            "conn",
            "name",
            "datastore"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "datastoreToStoragePoolPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "214-252",
          "snippet": "static virStoragePoolPtr\ndatastoreToStoragePoolPtr(virConnectPtr conn,\n                          const char *name,\n                          esxVI_ObjectContent *datastore)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Datastores don't have a UUID, but we can use the 'host.mountInfo.path'\n     * property as source for a UUID. The mount path is unique per host and\n     * cannot change during the lifetime of the datastore.\n     *\n     * The MD5 sum of the mount path can be used as UUID, assuming MD5 is\n     * considered to be collision-free enough for this use case.\n     */\n    if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostMount) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, name, md5, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStoragePoolPtr\ndatastoreToStoragePoolPtr(virConnectPtr conn,\n                          const char *name,\n                          esxVI_ObjectContent *datastore)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Datastores don't have a UUID, but we can use the 'host.mountInfo.path'\n     * property as source for a UUID. The mount path is unique per host and\n     * cannot change during the lifetime of the datastore.\n     *\n     * The MD5 sum of the mount path can be used as UUID, assuming MD5 is\n     * considered to be collision-free enough for this use case.\n     */\n    if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostMount) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, name, md5, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "priv->primary",
            "name",
            "NULL",
            "&datastore",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *datastore = NULL;\n    virStoragePoolPtr pool = NULL;\n\n    if (esxVI_LookupDatastoreByName(priv->primary, name, NULL, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    pool = datastoreToStoragePoolPtr(conn, name, datastore);\n\n cleanup:\n    esxVI_ObjectContent_Free(&datastore);\n\n    return pool;\n}"
  },
  {
    "function_name": "datastoreToStoragePoolPtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "214-252",
    "snippet": "static virStoragePoolPtr\ndatastoreToStoragePoolPtr(virConnectPtr conn,\n                          const char *name,\n                          esxVI_ObjectContent *datastore)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Datastores don't have a UUID, but we can use the 'host.mountInfo.path'\n     * property as source for a UUID. The mount path is unique per host and\n     * cannot change during the lifetime of the datastore.\n     *\n     * The MD5 sum of the mount path can be used as UUID, assuming MD5 is\n     * considered to be collision-free enough for this use case.\n     */\n    if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostMount) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, name, md5, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStoragePool",
          "args": [
            "conn",
            "name",
            "md5",
            "&esxStorageBackendVMFS",
            "NULL"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "525-556",
          "snippet": "virStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStoragePoolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStoragePoolClass;\n\nvirStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "hostMount->mountInfo->path",
            "md5"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreHostMount",
          "args": [
            "priv->primary",
            "datastore->obj",
            "&hostMount",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreHostMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3045-3106",
          "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendVMFS = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 0.8.2 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 0.8.2 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 0.8.2 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 0.8.2 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 0.8.2 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 0.8.2 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 0.8.2 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 0.8.4 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 0.8.4 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 0.8.4 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 0.8.4 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 0.8.4 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 0.8.4 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 0.8.7 */\n    .storageVolDelete = esxStorageVolDelete, /* 0.8.7 */\n    .storageVolWipe = esxStorageVolWipe, /* 0.8.7 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 0.8.4 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 0.8.4 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 0.8.4 */\n};\n\nstatic virStoragePoolPtr\ndatastoreToStoragePoolPtr(virConnectPtr conn,\n                          const char *name,\n                          esxVI_ObjectContent *datastore)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Datastores don't have a UUID, but we can use the 'host.mountInfo.path'\n     * property as source for a UUID. The mount path is unique per host and\n     * cannot change during the lifetime of the datastore.\n     *\n     * The MD5 sum of the mount path can be used as UUID, assuming MD5 is\n     * considered to be collision-free enough for this use case.\n     */\n    if (esxVI_LookupDatastoreHostMount(priv->primary, datastore->obj, &hostMount,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostMount) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, hostMount->mountInfo->path, md5) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, name, md5, &esxStorageBackendVMFS, NULL);\n\n cleanup:\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return pool;\n}"
  },
  {
    "function_name": "esxConnectListStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "153-210",
    "snippet": "static int\nesxConnectListStoragePools(virConnectPtr conn, char **const names,\n                           const int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto cleanup;\n                }\n\n                names[count] = g_strdup(dynamicProperty->val->string);\n\n                ++count;\n                break;\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dynamicProperty->val->string"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_String"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.name\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&datastoreList"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"summary.name\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxConnectListStoragePools(virConnectPtr conn, char **const names,\n                           const int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(priv->primary, propertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        for (dynamicProperty = datastore->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"summary.name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto cleanup;\n                }\n\n                names[count] = g_strdup(dynamicProperty->val->string);\n\n                ++count;\n                break;\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxConnectNumOfStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "130-149",
    "snippet": "static int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_LookupDatastoreList(priv->primary, NULL, &datastoreList) < 0)\n        return -1;\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        ++count;\n    }\n\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "priv->primary",
            "NULL",
            "&datastoreList"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_LookupDatastoreList(priv->primary, NULL, &datastoreList) < 0)\n        return -1;\n\n    for (datastore = datastoreList; datastore;\n         datastore = datastore->_next) {\n        ++count;\n    }\n\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxLookupVMFSStoragePoolType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "97-126",
    "snippet": "static int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datastorePoolType",
          "args": [
            "datastore",
            "poolType"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "datastorePoolType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
          "lines": "56-93",
          "snippet": "static int\ndatastorePoolType(esxVI_ObjectContent *datastore, int *poolType)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreInfo *datastoreInfo = NULL;\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &datastoreInfo) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (esxVI_LocalDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_DIR;\n    } else if (esxVI_NasDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_NETFS;\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_FS;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_DatastoreInfo_Free(&datastoreInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndatastorePoolType(esxVI_ObjectContent *datastore, int *poolType)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreInfo *datastoreInfo = NULL;\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &datastoreInfo) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (esxVI_LocalDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_DIR;\n    } else if (esxVI_NasDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_NETFS;\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_FS;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_DatastoreInfo_Free(&datastoreInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "ctx",
            "poolName",
            "propertyNameList",
            "&datastore",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"info\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxLookupVMFSStoragePoolType(esxVI_Context *ctx, const char *poolName,\n                             int *poolType)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, poolName, propertyNameList, &datastore,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!datastore) {\n        /* Not found, let the base storage driver handle error reporting */\n        goto cleanup;\n    }\n\n    if (datastorePoolType(datastore, poolType) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n\n    return result;\n}"
  },
  {
    "function_name": "datastorePoolType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_vmfs.c",
    "lines": "56-93",
    "snippet": "static int\ndatastorePoolType(esxVI_ObjectContent *datastore, int *poolType)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreInfo *datastoreInfo = NULL;\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &datastoreInfo) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (esxVI_LocalDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_DIR;\n    } else if (esxVI_NasDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_NETFS;\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_FS;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_DatastoreInfo_Free(&datastoreInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreInfo_Free",
          "args": [
            "&datastoreInfo"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DatastoreInfo has unexpected type\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DatastoreInfo has unexpected type\""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_VmfsDatastoreInfo_DynamicCast",
          "args": [
            "datastoreInfo"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_NasDatastoreInfo_DynamicCast",
          "args": [
            "datastoreInfo"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LocalDatastoreInfo_DynamicCast",
          "args": [
            "datastoreInfo"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreInfo_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&datastoreInfo"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"info\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndatastorePoolType(esxVI_ObjectContent *datastore, int *poolType)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreInfo *datastoreInfo = NULL;\n\n    for (dynamicProperty = datastore->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_DatastoreInfo_CastFromAnyType(dynamicProperty->val,\n                                                    &datastoreInfo) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (esxVI_LocalDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_DIR;\n    } else if (esxVI_NasDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_NETFS;\n    } else if (esxVI_VmfsDatastoreInfo_DynamicCast(datastoreInfo)) {\n        *poolType = VIR_STORAGE_POOL_FS;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DatastoreInfo has unexpected type\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_DatastoreInfo_Free(&datastoreInfo);\n\n    return result;\n}"
  }
]