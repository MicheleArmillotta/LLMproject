[
  {
    "function_name": "virNetDevBandwidthUpdateFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "736-754",
    "snippet": "int\nvirNetDevBandwidthUpdateFilter(const char *ifname,\n                               const virMacAddr *ifmac_ptr,\n                               unsigned int id)\n{\n    int ret = -1;\n    char *class_id = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n\n    if (virNetDevBandwidthManipulateFilter(ifname, ifmac_ptr, id,\n                                           class_id, true, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(class_id);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "class_id"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthManipulateFilter",
          "args": [
            "ifname",
            "ifmac_ptr",
            "id",
            "class_id",
            "true",
            "true"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"1:%x\"",
            "id"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUpdateFilter(const char *ifname,\n                               const virMacAddr *ifmac_ptr,\n                               unsigned int id)\n{\n    int ret = -1;\n    char *class_id = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n\n    if (virNetDevBandwidthManipulateFilter(ifname, ifmac_ptr, id,\n                                           class_id, true, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(class_id);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthUpdateRate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "682-717",
    "snippet": "int\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ceil"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rate"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "class_id"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthCmdAddOptimalQuantum",
          "args": [
            "cmd",
            "bandwidth->in"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthCmdAddOptimalQuantum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "42-63",
          "snippet": "static void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"class\"",
            "\"change\"",
            "\"dev\"",
            "ifname",
            "\"classid\"",
            "class_id",
            "\"htb\"",
            "\"rate\"",
            "rate",
            "\"ceil\"",
            "ceil",
            "NULL"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "TC"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%llukbps\"",
            "bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthUnplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "620-666",
    "snippet": "int\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "class_id"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qdisc_id"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&cmd_ret"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"class\"",
            "\"del\"",
            "\"dev\"",
            "brname",
            "\"classid\"",
            "class_id",
            "NULL"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "TC"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthManipulateFilter",
          "args": [
            "brname",
            "NULL",
            "id",
            "NULL",
            "true",
            "false"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%x:\"",
            "id"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid class ID %d\")",
            "id"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid class ID %d\""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "96-114",
          "snippet": "static int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthPlug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "541-609",
    "snippet": "int\nvirNetDevBandwidthPlug(const char *brname,\n                       virNetDevBandwidthPtr net_bandwidth,\n                       const virMacAddr *ifmac_ptr,\n                       virNetDevBandwidthPtr bandwidth,\n                       unsigned int id)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n    char *floor = NULL;\n    char *ceil = NULL;\n    char ifmacStr[VIR_MAC_STRING_BUFLEN];\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    virMacAddrFormat(ifmac_ptr, ifmacStr);\n\n    if (!net_bandwidth || !net_bandwidth->in) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\"),\n                       brname, ifmacStr);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n    floor = g_strdup_printf(\"%llukbps\", bandwidth->in->floor);\n    ceil = g_strdup_printf(\"%llukbps\", net_bandwidth->in->peak ?\n                           net_bandwidth->in->peak :\n                           net_bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", brname, \"parent\", \"1:1\",\n                         \"classid\", class_id, \"htb\", \"rate\", floor,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", brname, \"parent\",\n                         class_id, \"handle\", qdisc_id, \"sfq\", \"perturb\",\n                         \"10\", NULL);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, ifmac_ptr, id,\n                                           class_id, false, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(ceil);\n    VIR_FREE(floor);\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "class_id"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qdisc_id"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "floor"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ceil"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthManipulateFilter",
          "args": [
            "brname",
            "ifmac_ptr",
            "id",
            "class_id",
            "false",
            "true"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"qdisc\"",
            "\"add\"",
            "\"dev\"",
            "brname",
            "\"parent\"",
            "class_id",
            "\"handle\"",
            "qdisc_id",
            "\"sfq\"",
            "\"perturb\"",
            "\"10\"",
            "NULL"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "TC"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthCmdAddOptimalQuantum",
          "args": [
            "cmd",
            "bandwidth->in"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthCmdAddOptimalQuantum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "42-63",
          "snippet": "static void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%llukbps\"",
            "net_bandwidth->in->peak ?\n                           net_bandwidth->in->peak :\n                           net_bandwidth->in->average"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\")",
            "brname",
            "ifmacStr"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\""
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "96-114",
          "snippet": "static int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "ifmac_ptr",
            "ifmacStr"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid class ID %d\")",
            "id"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthPlug(const char *brname,\n                       virNetDevBandwidthPtr net_bandwidth,\n                       const virMacAddr *ifmac_ptr,\n                       virNetDevBandwidthPtr bandwidth,\n                       unsigned int id)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n    char *floor = NULL;\n    char *ceil = NULL;\n    char ifmacStr[VIR_MAC_STRING_BUFLEN];\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    virMacAddrFormat(ifmac_ptr, ifmacStr);\n\n    if (!net_bandwidth || !net_bandwidth->in) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\"),\n                       brname, ifmacStr);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n    floor = g_strdup_printf(\"%llukbps\", bandwidth->in->floor);\n    ceil = g_strdup_printf(\"%llukbps\", net_bandwidth->in->peak ?\n                           net_bandwidth->in->peak :\n                           net_bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", brname, \"parent\", \"1:1\",\n                         \"classid\", class_id, \"htb\", \"rate\", floor,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", brname, \"parent\",\n                         class_id, \"handle\", qdisc_id, \"sfq\", \"perturb\",\n                         \"10\", NULL);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, ifmac_ptr, id,\n                                           class_id, false, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(ceil);\n    VIR_FREE(floor);\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "480-519",
    "snippet": "bool\nvirNetDevBandwidthEqual(const virNetDevBandwidth *a,\n                        const virNetDevBandwidth *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    /* in */\n    if (a->in) {\n        if (!b->in)\n            return false;\n\n        if (a->in->average != b->in->average ||\n            a->in->peak != b->in->peak ||\n            a->in->floor != b->in->floor ||\n            a->in->burst != b->in->burst)\n            return false;\n    } else if (b->in) {\n        return false;\n    }\n\n    /* out */\n    if (a->out) {\n        if (!b->out)\n            return false;\n\n        if (a->out->average != b->out->average ||\n            a->out->peak != b->out->peak ||\n            a->out->floor != b->out->floor ||\n            a->out->burst != b->out->burst)\n            return false;\n    } else if (b->out) {\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirNetDevBandwidthEqual(const virNetDevBandwidth *a,\n                        const virNetDevBandwidth *b)\n{\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    /* in */\n    if (a->in) {\n        if (!b->in)\n            return false;\n\n        if (a->in->average != b->in->average ||\n            a->in->peak != b->in->peak ||\n            a->in->floor != b->in->floor ||\n            a->in->burst != b->in->burst)\n            return false;\n    } else if (b->in) {\n        return false;\n    }\n\n    /* out */\n    if (a->out) {\n        if (!b->out)\n            return false;\n\n        if (a->out->average != b->out->average ||\n            a->out->peak != b->out->peak ||\n            a->out->floor != b->out->floor ||\n            a->out->burst != b->out->burst)\n            return false;\n    } else if (b->out) {\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virNetDevBandwidthCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "441-478",
    "snippet": "int\nvirNetDevBandwidthCopy(virNetDevBandwidthPtr *dest,\n                       const virNetDevBandwidth *src)\n{\n    int ret = -1;\n\n    *dest = NULL;\n    if (!src) {\n        /* nothing to be copied */\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dest) < 0)\n        goto cleanup;\n\n    if (src->in) {\n        if (VIR_ALLOC((*dest)->in) < 0)\n            goto cleanup;\n        memcpy((*dest)->in, src->in, sizeof(*src->in));\n    }\n\n    if (src->out) {\n        if (VIR_ALLOC((*dest)->out) < 0) {\n            VIR_FREE((*dest)->in);\n            goto cleanup;\n        }\n        memcpy((*dest)->out, src->out, sizeof(*src->out));\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virNetDevBandwidthFree(*dest);\n        *dest = NULL;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevBandwidthFree",
          "args": [
            "*dest"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "31-40",
          "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*dest)->out",
            "src->out",
            "sizeof(*src->out)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*dest)->in"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "(*dest)->out"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*dest)->in",
            "src->in",
            "sizeof(*src->in)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "(*dest)->in"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*dest"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthCopy(virNetDevBandwidthPtr *dest,\n                       const virNetDevBandwidth *src)\n{\n    int ret = -1;\n\n    *dest = NULL;\n    if (!src) {\n        /* nothing to be copied */\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dest) < 0)\n        goto cleanup;\n\n    if (src->in) {\n        if (VIR_ALLOC((*dest)->in) < 0)\n            goto cleanup;\n        memcpy((*dest)->in, src->in, sizeof(*src->in));\n    }\n\n    if (src->out) {\n        if (VIR_ALLOC((*dest)->out) < 0) {\n            VIR_FREE((*dest)->in);\n            goto cleanup;\n        }\n        memcpy((*dest)->out, src->out, sizeof(*src->out));\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virNetDevBandwidthFree(*dest);\n        *dest = NULL;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "404-431",
    "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&dummy"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"qdisc\"",
            "\"del\"",
            "\"dev\"",
            "ifname",
            "\"ingress\"",
            "NULL"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "TC"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevBandwidthSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "189-392",
    "snippet": "int\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "burst"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "peak"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "average"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"filter\"",
            "\"add\"",
            "\"dev\"",
            "ifname",
            "\"parent\"",
            "\"ffff:\"",
            "\"protocol\"",
            "\"all\"",
            "\"u32\"",
            "\"match\"",
            "\"u32\"",
            "\"0\"",
            "\"0\"",
            "\"police\"",
            "\"rate\"",
            "average",
            "\"burst\"",
            "burst",
            "\"mtu\"",
            "\"64kb\"",
            "\"drop\"",
            "\"flowid\"",
            "\":1\"",
            "NULL"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "TC"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%llukb\"",
            "rx->burst ? rx->burst : rx->average"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "burst"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "peak"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "average"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthCmdAddOptimalQuantum",
          "args": [
            "cmd",
            "tx"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthCmdAddOptimalQuantum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "42-63",
          "snippet": "static void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthClear",
          "args": [
            "ifname"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "404-431",
          "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "96-114",
          "snippet": "static int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"Network bandwidth tuning is not available\"\n                         \" in session mode\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "96-114",
    "snippet": "static int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"filter creation API error\")"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"filter creation API error\""
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "96-114",
          "snippet": "static int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1)\nvirNetDevBandwidthManipulateFilter(const char *ifname,\n                                   const virMacAddr *ifmac_ptr,\n                                   unsigned int id,\n                                   const char *class_id,\n                                   bool remove_old,\n                                   bool create_new)\n{\n    int ret = -1;\n    char *filter_id = NULL;\n    virCommandPtr cmd = NULL;\n    unsigned char ifmac[VIR_MAC_BUFLEN];\n    char *mac[2] = {NULL, NULL};\n\n    if (!(remove_old || create_new)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filter creation API error\"));\n        goto cleanup;\n    }"
  },
  {
    "function_name": "virNetDevBandwidthCmdAddOptimalQuantum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "42-63",
    "snippet": "static void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%llu\"",
            "r2q"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"quantum\""
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDevBandwidthCmdAddOptimalQuantum(virCommandPtr cmd,\n                                       const virNetDevBandwidthRate *rate)\n{\n    const unsigned long long mtu = 1500;\n    unsigned long long r2q;\n\n    /* When two or more classes compete for unused bandwidth they are each\n     * given some number of bytes before serving other competing class. This\n     * number is called quantum. It's advised in HTB docs that the number\n     * should be equal to MTU. The class quantum is computed from its rate\n     * divided by global r2q parameter. However, if rate is too small the\n     * default value will not suffice and thus we must provide our own value.\n     * */\n\n    r2q = rate->average * 1024 / 8 / mtu;\n    if (!r2q)\n        r2q = 1;\n\n    virCommandAddArg(cmd, \"quantum\");\n    virCommandAddArgFormat(cmd, \"%llu\", r2q);\n}"
  },
  {
    "function_name": "virNetDevBandwidthFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
    "lines": "31-40",
    "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnetdevbandwidth.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->out"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->in"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
  }
]