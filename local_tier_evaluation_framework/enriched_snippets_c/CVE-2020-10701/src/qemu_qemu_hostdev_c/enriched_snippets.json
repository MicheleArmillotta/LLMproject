[
  {
    "function_name": "qemuHostdevReAttachDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "478-502",
    "snippet": "void\nqemuHostdevReAttachDomainDevices(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return;\n\n    qemuHostdevReAttachNVMeDisks(driver, def->name, def->disks,\n                                 def->ndisks);\n\n    qemuHostdevReAttachPCIDevices(driver, def->name, def->hostdevs,\n                                  def->nhostdevs);\n\n    qemuHostdevReAttachUSBDevices(driver, def->name, def->hostdevs,\n                                  def->nhostdevs);\n\n    qemuHostdevReAttachSCSIDevices(driver, def->name, def->hostdevs,\n                                   def->nhostdevs);\n\n    qemuHostdevReAttachSCSIVHostDevices(driver, def->name, def->hostdevs,\n                                        def->nhostdevs);\n\n    qemuHostdevReAttachMediatedDevices(driver, def->name, def->hostdevs,\n                                       def->nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuHostdevReAttachMediatedDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "466-476",
          "snippet": "void\nqemuHostdevReAttachMediatedDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                      name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachMediatedDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                      name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevReAttachSCSIVHostDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachSCSIVHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "454-464",
          "snippet": "void\nqemuHostdevReAttachSCSIVHostDevices(virQEMUDriverPtr driver,\n                                    const char *name,\n                                    virDomainHostdevDefPtr *hostdevs,\n                                    int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachSCSIVHostDevices(virQEMUDriverPtr driver,\n                                    const char *name,\n                                    virDomainHostdevDefPtr *hostdevs,\n                                    int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevReAttachSCSIDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "431-452",
          "snippet": "void\nqemuHostdevReAttachSCSIDevices(virQEMUDriverPtr driver,\n                               const char *name,\n                               virDomainHostdevDefPtr *hostdevs,\n                               int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainDeviceDef dev;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdev;\n\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, name));\n    }\n\n    virHostdevReAttachSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachSCSIDevices(virQEMUDriverPtr driver,\n                               const char *name,\n                               virDomainHostdevDefPtr *hostdevs,\n                               int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainDeviceDef dev;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdev;\n\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, name));\n    }\n\n    virHostdevReAttachSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevReAttachUSBDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "419-429",
          "snippet": "void\nqemuHostdevReAttachUSBDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachUSBDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevReAttachPCIDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "403-417",
          "snippet": "void\nqemuHostdevReAttachPCIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *oldStateDir = cfg->stateDir;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachPCIDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                 hostdevs, nhostdevs, oldStateDir);\n\n    virObjectUnref(cfg);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachPCIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *oldStateDir = cfg->stateDir;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachPCIDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                 hostdevs, nhostdevs, oldStateDir);\n\n    virObjectUnref(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevReAttachNVMeDisks",
          "args": [
            "driver",
            "def->name",
            "def->disks",
            "def->ndisks"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevReAttachNVMeDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "392-401",
          "snippet": "void\nqemuHostdevReAttachNVMeDisks(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    virHostdevReAttachNVMeDevices(driver->hostdevMgr,\n                                  QEMU_DRIVER_NAME,\n                                  name, disks, ndisks);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachNVMeDisks(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    virHostdevReAttachNVMeDevices(driver->hostdevMgr,\n                                  QEMU_DRIVER_NAME,\n                                  name, disks, ndisks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachDomainDevices(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return;\n\n    qemuHostdevReAttachNVMeDisks(driver, def->name, def->disks,\n                                 def->ndisks);\n\n    qemuHostdevReAttachPCIDevices(driver, def->name, def->hostdevs,\n                                  def->nhostdevs);\n\n    qemuHostdevReAttachUSBDevices(driver, def->name, def->hostdevs,\n                                  def->nhostdevs);\n\n    qemuHostdevReAttachSCSIDevices(driver, def->name, def->hostdevs,\n                                   def->nhostdevs);\n\n    qemuHostdevReAttachSCSIVHostDevices(driver, def->name, def->hostdevs,\n                                        def->nhostdevs);\n\n    qemuHostdevReAttachMediatedDevices(driver, def->name, def->hostdevs,\n                                       def->nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "466-476",
    "snippet": "void\nqemuHostdevReAttachMediatedDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                      name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachMediatedDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1968-2015",
          "snippet": "void\nvirHostdevReAttachMediatedDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    const char *used_by_drvname = NULL;\n    const char *used_by_domname = NULL;\n    size_t i;\n\n    if (nhostdevs == 0)\n        return;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virMediatedDevice) mdev = NULL;\n        virMediatedDevicePtr tmp;\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr,\n                                          mdevsrc->model)))\n            continue;\n\n        /* Remove from the list only mdevs assigned to @drv_name/@dom_name */\n\n        tmp = virMediatedDeviceListFind(mgr->activeMediatedHostdevs, mdev);\n\n        /* skip inactive devices */\n        if (!tmp)\n            continue;\n\n        virMediatedDeviceGetUsedBy(tmp, &used_by_drvname, &used_by_domname);\n        if (STREQ_NULLABLE(drv_name, used_by_drvname) &&\n            STREQ_NULLABLE(dom_name, used_by_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeMediatedHostdevs\",\n                      mdevsrc->uuidstr, dom_name);\n            virMediatedDeviceListDel(mgr->activeMediatedHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachMediatedDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    const char *used_by_drvname = NULL;\n    const char *used_by_domname = NULL;\n    size_t i;\n\n    if (nhostdevs == 0)\n        return;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virMediatedDevice) mdev = NULL;\n        virMediatedDevicePtr tmp;\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr,\n                                          mdevsrc->model)))\n            continue;\n\n        /* Remove from the list only mdevs assigned to @drv_name/@dom_name */\n\n        tmp = virMediatedDeviceListFind(mgr->activeMediatedHostdevs, mdev);\n\n        /* skip inactive devices */\n        if (!tmp)\n            continue;\n\n        virMediatedDeviceGetUsedBy(tmp, &used_by_drvname, &used_by_domname);\n        if (STREQ_NULLABLE(drv_name, used_by_drvname) &&\n            STREQ_NULLABLE(dom_name, used_by_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeMediatedHostdevs\",\n                      mdevsrc->uuidstr, dom_name);\n            virMediatedDeviceListDel(mgr->activeMediatedHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachMediatedDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                      name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachSCSIVHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "454-464",
    "snippet": "void\nqemuHostdevReAttachSCSIVHostDevices(virQEMUDriverPtr driver,\n                                    const char *name,\n                                    virDomainHostdevDefPtr *hostdevs,\n                                    int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachSCSIVHostDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachSCSIVHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1901-1959",
          "snippet": "void\nvirHostdevReAttachSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                   const char *drv_name,\n                                   const char *dom_name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n        virSCSIVHostDevicePtr tmp;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue; /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn))) {\n            VIR_WARN(\"Unable to reattach SCSI_host device %s on domain %s\",\n                     hostsrc->wwpn, NULLSTR(dom_name));\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        /* Only delete the devices which are marked as being used by @name,\n         * because qemuProcessStart could fail half way through. */\n\n        if (!(tmp = virSCSIVHostDeviceListFind(mgr->activeSCSIVHostHostdevs,\n                                               host))) {\n            VIR_WARN(\"Unable to find device %s \"\n                     \"in list of active SCSI_host devices\",\n                     hostsrc->wwpn);\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        virSCSIVHostDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeSCSIVHostHostdevs\",\n                      hostsrc->wwpn, dom_name);\n\n            virSCSIVHostDeviceListDel(mgr->activeSCSIVHostHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                   const char *drv_name,\n                                   const char *dom_name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n        virSCSIVHostDevicePtr tmp;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue; /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn))) {\n            VIR_WARN(\"Unable to reattach SCSI_host device %s on domain %s\",\n                     hostsrc->wwpn, NULLSTR(dom_name));\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        /* Only delete the devices which are marked as being used by @name,\n         * because qemuProcessStart could fail half way through. */\n\n        if (!(tmp = virSCSIVHostDeviceListFind(mgr->activeSCSIVHostHostdevs,\n                                               host))) {\n            VIR_WARN(\"Unable to find device %s \"\n                     \"in list of active SCSI_host devices\",\n                     hostsrc->wwpn);\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        virSCSIVHostDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeSCSIVHostHostdevs\",\n                      hostsrc->wwpn, dom_name);\n\n            virSCSIVHostDeviceListDel(mgr->activeSCSIVHostHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachSCSIVHostDevices(virQEMUDriverPtr driver,\n                                    const char *name,\n                                    virDomainHostdevDefPtr *hostdevs,\n                                    int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "431-452",
    "snippet": "void\nqemuHostdevReAttachSCSIDevices(virQEMUDriverPtr driver,\n                               const char *name,\n                               virDomainHostdevDefPtr *hostdevs,\n                               int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainDeviceDef dev;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdev;\n\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, name));\n    }\n\n    virHostdevReAttachSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachSCSIDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1872-1899",
          "snippet": "void\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuRemoveSharedDevice(driver, &dev, name)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuRemoveSharedDevice",
          "args": [
            "driver",
            "&dev",
            "name"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "qemuRemoveSharedDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1798-1804",
          "snippet": "int\nqemuRemoveSharedDevice(virQEMUDriverPtr driver,\n                       virDomainDeviceDefPtr dev,\n                       const char *name)\n{\n    return qemuSharedDeviceAddRemoveInternal(driver, dev, name, false);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuRemoveSharedDevice(virQEMUDriverPtr driver,\n                       virDomainDeviceDefPtr dev,\n                       const char *name)\n{\n    return qemuSharedDeviceAddRemoveInternal(driver, dev, name, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachSCSIDevices(virQEMUDriverPtr driver,\n                               const char *name,\n                               virDomainHostdevDefPtr *hostdevs,\n                               int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainDeviceDef dev;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdev;\n\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, name));\n    }\n\n    virHostdevReAttachSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "419-429",
    "snippet": "void\nqemuHostdevReAttachUSBDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachUSBDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1772-1830",
          "snippet": "void\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachUSBDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                  name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachPCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "403-417",
    "snippet": "void\nqemuHostdevReAttachPCIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *oldStateDir = cfg->stateDir;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachPCIDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                 hostdevs, nhostdevs, oldStateDir);\n\n    virObjectUnref(cfg);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachPCIDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs",
            "oldStateDir"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1074-1096",
          "snippet": "void\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachPCIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *oldStateDir = cfg->stateDir;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    virHostdevReAttachPCIDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                 hostdevs, nhostdevs, oldStateDir);\n\n    virObjectUnref(cfg);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachNVMeDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "392-401",
    "snippet": "void\nqemuHostdevReAttachNVMeDisks(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    virHostdevReAttachNVMeDevices(driver->hostdevMgr,\n                                  QEMU_DRIVER_NAME,\n                                  name, disks, ndisks);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachNVMeDevices",
          "args": [
            "driver->hostdevMgr",
            "QEMU_DRIVER_NAME",
            "name",
            "disks",
            "ndisks"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachNVMeDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2417-2440",
          "snippet": "int\nvirHostdevReAttachNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainDiskDefPtr *disks,\n                              size_t ndisks)\n{\n    size_t i;\n    int ret = 0;\n\n    /* Contrary to virHostdevPrepareNVMeDevices, this is a best\n     * effort approach. Just iterate over all disks and try to\n     * reattach them. Don't stop at the first failure. */\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name,\n                                            dom_name, disks[i]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[i]->dst);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainDiskDefPtr *disks,\n                              size_t ndisks)\n{\n    size_t i;\n    int ret = 0;\n\n    /* Contrary to virHostdevPrepareNVMeDevices, this is a best\n     * effort approach. Just iterate over all disks and try to\n     * reattach them. Don't stop at the first failure. */\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name,\n                                            dom_name, disks[i]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[i]->dst);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachNVMeDisks(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    virHostdevReAttachNVMeDevices(driver->hostdevMgr,\n                                  QEMU_DRIVER_NAME,\n                                  name, disks, ndisks);\n}"
  },
  {
    "function_name": "qemuHostdevReAttachOneNVMeDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "381-390",
    "snippet": "void\nqemuHostdevReAttachOneNVMeDisk(virQEMUDriverPtr driver,\n                               const char *name,\n                               virStorageSourcePtr src)\n{\n    virHostdevReAttachOneNVMeDevice(driver->hostdevMgr,\n                                    QEMU_DRIVER_NAME,\n                                    name,\n                                    src);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachOneNVMeDevice",
          "args": [
            "driver->hostdevMgr",
            "QEMU_DRIVER_NAME",
            "name",
            "src"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachOneNVMeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2373-2414",
          "snippet": "int\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuHostdevReAttachOneNVMeDisk(virQEMUDriverPtr driver,\n                               const char *name,\n                               virStorageSourcePtr src)\n{\n    virHostdevReAttachOneNVMeDevice(driver->hostdevMgr,\n                                    QEMU_DRIVER_NAME,\n                                    name,\n                                    src);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "345-379",
    "snippet": "int\nqemuHostdevPrepareDomainDevices(virQEMUDriverPtr driver,\n                                virDomainDefPtr def,\n                                virQEMUCapsPtr qemuCaps,\n                                unsigned int flags)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return 0;\n\n    if (qemuHostdevPrepareNVMeDisks(driver, def->name, def->disks, def->ndisks) < 0)\n        return -1;\n\n    if (qemuHostdevPreparePCIDevices(driver, def->name, def->uuid,\n                                     def->hostdevs, def->nhostdevs,\n                                     qemuCaps, flags) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareUSBDevices(driver, def->name,\n                                     def->hostdevs, def->nhostdevs, flags) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareSCSIDevices(driver, def->name,\n                                      def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareSCSIVHostDevices(driver, def->name,\n                                           def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareMediatedDevices(driver, def->name,\n                                          def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuHostdevPrepareMediatedDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPrepareMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "314-343",
          "snippet": "int\nqemuHostdevPrepareMediatedDevices(virQEMUDriverPtr driver,\n                                  const char *name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    bool supportsVFIO;\n    size_t i;\n\n    /* Checking for VFIO only is fine with mdev, as IOMMU isolation is achieved\n     * by the physical parent device.\n     */\n    supportsVFIO = virFileExists(QEMU_DEV_VFIO);\n\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevIsMdevDevice(hostdevs[i])) {\n            if (!supportsVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Mediated host device assignment requires \"\n                                 \"VFIO support\"));\n                return -1;\n            }\n            break;\n        }\n    }\n\n    return virHostdevPrepareMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                            name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareMediatedDevices(virQEMUDriverPtr driver,\n                                  const char *name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    bool supportsVFIO;\n    size_t i;\n\n    /* Checking for VFIO only is fine with mdev, as IOMMU isolation is achieved\n     * by the physical parent device.\n     */\n    supportsVFIO = virFileExists(QEMU_DEV_VFIO);\n\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevIsMdevDevice(hostdevs[i])) {\n            if (!supportsVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Mediated host device assignment requires \"\n                                 \"VFIO support\"));\n                return -1;\n            }\n            break;\n        }\n    }\n\n    return virHostdevPrepareMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                            name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPrepareSCSIVHostDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPrepareSCSIVHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "302-312",
          "snippet": "int\nqemuHostdevPrepareSCSIVHostDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                             name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareSCSIVHostDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                             name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPrepareSCSIDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPrepareSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "270-300",
          "snippet": "int\nqemuHostdevPrepareSCSIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    /* Loop 1: Add the shared scsi host device to shared device\n     * table.\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainDeviceDef dev;\n\n        if (!virHostdevIsSCSIDevice(hostdevs[i]))\n            continue;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdevs[i];\n\n        if (qemuAddSharedDevice(driver, &dev, name) < 0)\n            return -1;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            return -1;\n    }\n\n    return virHostdevPrepareSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                        name, hostdevs, nhostdevs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareSCSIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    /* Loop 1: Add the shared scsi host device to shared device\n     * table.\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainDeviceDef dev;\n\n        if (!virHostdevIsSCSIDevice(hostdevs[i]))\n            continue;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdevs[i];\n\n        if (qemuAddSharedDevice(driver, &dev, name) < 0)\n            return -1;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            return -1;\n    }\n\n    return virHostdevPrepareSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                        name, hostdevs, nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPrepareUSBDevices",
          "args": [
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs",
            "flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPrepareUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "257-268",
          "snippet": "int\nqemuHostdevPrepareUSBDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                       hostdevs, nhostdevs, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareUSBDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                       hostdevs, nhostdevs, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPreparePCIDevices",
          "args": [
            "driver",
            "def->name",
            "def->uuid",
            "def->hostdevs",
            "def->nhostdevs",
            "qemuCaps",
            "flags"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPreparePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "238-255",
          "snippet": "int\nqemuHostdevPreparePCIDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             const unsigned char *uuid,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             virQEMUCapsPtr qemuCaps,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!qemuHostdevPreparePCIDevicesCheckSupport(hostdevs, nhostdevs, qemuCaps))\n        return -1;\n\n    return virHostdevPreparePCIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, uuid, hostdevs,\n                                       nhostdevs, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPreparePCIDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             const unsigned char *uuid,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             virQEMUCapsPtr qemuCaps,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!qemuHostdevPreparePCIDevicesCheckSupport(hostdevs, nhostdevs, qemuCaps))\n        return -1;\n\n    return virHostdevPreparePCIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, uuid, hostdevs,\n                                       nhostdevs, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPrepareNVMeDisks",
          "args": [
            "driver",
            "def->name",
            "def->disks",
            "def->ndisks"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPrepareNVMeDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "227-236",
          "snippet": "int\nqemuHostdevPrepareNVMeDisks(virQEMUDriverPtr driver,\n                            const char *name,\n                            virDomainDiskDefPtr *disks,\n                            size_t ndisks)\n{\n    return virHostdevPrepareNVMeDevices(driver->hostdevMgr,\n                                        QEMU_DRIVER_NAME,\n                                        name, disks, ndisks);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareNVMeDisks(virQEMUDriverPtr driver,\n                            const char *name,\n                            virDomainDiskDefPtr *disks,\n                            size_t ndisks)\n{\n    return virHostdevPrepareNVMeDevices(driver->hostdevMgr,\n                                        QEMU_DRIVER_NAME,\n                                        name, disks, ndisks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareDomainDevices(virQEMUDriverPtr driver,\n                                virDomainDefPtr def,\n                                virQEMUCapsPtr qemuCaps,\n                                unsigned int flags)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return 0;\n\n    if (qemuHostdevPrepareNVMeDisks(driver, def->name, def->disks, def->ndisks) < 0)\n        return -1;\n\n    if (qemuHostdevPreparePCIDevices(driver, def->name, def->uuid,\n                                     def->hostdevs, def->nhostdevs,\n                                     qemuCaps, flags) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareUSBDevices(driver, def->name,\n                                     def->hostdevs, def->nhostdevs, flags) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareSCSIDevices(driver, def->name,\n                                      def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareSCSIVHostDevices(driver, def->name,\n                                           def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    if (qemuHostdevPrepareMediatedDevices(driver, def->name,\n                                          def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuHostdevPrepareMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "314-343",
    "snippet": "int\nqemuHostdevPrepareMediatedDevices(virQEMUDriverPtr driver,\n                                  const char *name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    bool supportsVFIO;\n    size_t i;\n\n    /* Checking for VFIO only is fine with mdev, as IOMMU isolation is achieved\n     * by the physical parent device.\n     */\n    supportsVFIO = virFileExists(QEMU_DEV_VFIO);\n\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevIsMdevDevice(hostdevs[i])) {\n            if (!supportsVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Mediated host device assignment requires \"\n                                 \"VFIO support\"));\n                return -1;\n            }\n            break;\n        }\n    }\n\n    return virHostdevPrepareMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                            name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareMediatedDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1716-1770",
          "snippet": "int\nvirHostdevPrepareMediatedDevices(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs)\n{\n    size_t i;\n    g_autoptr(virMediatedDeviceList) list = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where mediated device is assigned to multiple\n     * domains we maintain a driver list of currently assigned mediated devices.\n     * A device is appended to the driver list after a series of preparations.\n     */\n    if (!(list = virMediatedDeviceListNew()))\n        return -1;\n\n    /* Loop 1: Build a temporary list of ALL mediated devices. */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr src = &hostdev->source.subsys.u.mdev;\n        g_autoptr(virMediatedDevice) mdev = NULL;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(src->uuidstr, src->model)))\n            return -1;\n\n        if (virMediatedDeviceListAdd(list, &mdev) < 0)\n            return -1;\n        mdev = NULL;\n    }\n\n    /* Mark the devices in the list as used by @drv_name-@dom_name and copy the\n     * references to the driver list\n     */\n    if (virMediatedDeviceListMarkDevices(mgr->activeMediatedHostdevs,\n                                         list, drv_name, dom_name) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virMediatedDeviceListCount(list) > 0) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(list, 0);\n        virMediatedDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareMediatedDevices(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs)\n{\n    size_t i;\n    g_autoptr(virMediatedDeviceList) list = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where mediated device is assigned to multiple\n     * domains we maintain a driver list of currently assigned mediated devices.\n     * A device is appended to the driver list after a series of preparations.\n     */\n    if (!(list = virMediatedDeviceListNew()))\n        return -1;\n\n    /* Loop 1: Build a temporary list of ALL mediated devices. */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr src = &hostdev->source.subsys.u.mdev;\n        g_autoptr(virMediatedDevice) mdev = NULL;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(src->uuidstr, src->model)))\n            return -1;\n\n        if (virMediatedDeviceListAdd(list, &mdev) < 0)\n            return -1;\n        mdev = NULL;\n    }\n\n    /* Mark the devices in the list as used by @drv_name-@dom_name and copy the\n     * references to the driver list\n     */\n    if (virMediatedDeviceListMarkDevices(mgr->activeMediatedHostdevs,\n                                         list, drv_name, dom_name) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virMediatedDeviceListCount(list) > 0) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(list, 0);\n        virMediatedDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Mediated host device assignment requires \"\n                                 \"VFIO support\")"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Mediated host device assignment requires \"\n                                 \"VFIO support\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdevs[i]"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "QEMU_DEV_VFIO"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareMediatedDevices(virQEMUDriverPtr driver,\n                                  const char *name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    bool supportsVFIO;\n    size_t i;\n\n    /* Checking for VFIO only is fine with mdev, as IOMMU isolation is achieved\n     * by the physical parent device.\n     */\n    supportsVFIO = virFileExists(QEMU_DEV_VFIO);\n\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevIsMdevDevice(hostdevs[i])) {\n            if (!supportsVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Mediated host device assignment requires \"\n                                 \"VFIO support\"));\n                return -1;\n            }\n            break;\n        }\n    }\n\n    return virHostdevPrepareMediatedDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                            name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareSCSIVHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "302-312",
    "snippet": "int\nqemuHostdevPrepareSCSIVHostDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                             name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareSCSIVHostDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareSCSIVHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1631-1713",
          "snippet": "int\nvirHostdevPrepareSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    g_autoptr(virSCSIVHostDeviceList) list = NULL;\n    virSCSIVHostDevicePtr tmp;\n    size_t i, j;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where scsi_host device is assigned to two domains\n     * we need to keep a list of currently assigned scsi_host devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIVHostDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue;  /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn)))\n            return -1;\n\n        if (virSCSIVHostDeviceSetUsedBy(host, drv_name, dom_name) < 0)\n            return -1;\n\n        if (virSCSIVHostDeviceListAdd(list, host) < 0)\n            return -1;\n        host = NULL;\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n\n    for (i = 0; i < virSCSIVHostDeviceListCount(list); i++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n\n        VIR_DEBUG(\"Adding %s to activeSCSIVHostHostdevs\",\n                  virSCSIVHostDeviceGetName(tmp));\n\n        if (virSCSIVHostDeviceListAdd(mgr->activeSCSIVHostHostdevs, tmp) < 0)\n            goto rollback;\n    }\n\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIVHostDeviceListCount(list) > 0) {\n        tmp = virSCSIVHostDeviceListGet(list, 0);\n        virSCSIVHostDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n        virSCSIVHostDeviceListSteal(mgr->activeSCSIVHostHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    g_autoptr(virSCSIVHostDeviceList) list = NULL;\n    virSCSIVHostDevicePtr tmp;\n    size_t i, j;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where scsi_host device is assigned to two domains\n     * we need to keep a list of currently assigned scsi_host devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIVHostDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue;  /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn)))\n            return -1;\n\n        if (virSCSIVHostDeviceSetUsedBy(host, drv_name, dom_name) < 0)\n            return -1;\n\n        if (virSCSIVHostDeviceListAdd(list, host) < 0)\n            return -1;\n        host = NULL;\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n\n    for (i = 0; i < virSCSIVHostDeviceListCount(list); i++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n\n        VIR_DEBUG(\"Adding %s to activeSCSIVHostHostdevs\",\n                  virSCSIVHostDeviceGetName(tmp));\n\n        if (virSCSIVHostDeviceListAdd(mgr->activeSCSIVHostHostdevs, tmp) < 0)\n            goto rollback;\n    }\n\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIVHostDeviceListCount(list) > 0) {\n        tmp = virSCSIVHostDeviceListGet(list, 0);\n        virSCSIVHostDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n        virSCSIVHostDeviceListSteal(mgr->activeSCSIVHostHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareSCSIVHostDevices(virQEMUDriverPtr driver,\n                                   const char *name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareSCSIVHostDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                             name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "270-300",
    "snippet": "int\nqemuHostdevPrepareSCSIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    /* Loop 1: Add the shared scsi host device to shared device\n     * table.\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainDeviceDef dev;\n\n        if (!virHostdevIsSCSIDevice(hostdevs[i]))\n            continue;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdevs[i];\n\n        if (qemuAddSharedDevice(driver, &dev, name) < 0)\n            return -1;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            return -1;\n    }\n\n    return virHostdevPrepareSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                        name, hostdevs, nhostdevs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareSCSIDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1534-1629",
          "snippet": "int\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSetUnprivSGIO",
          "args": [
            "&dev"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSetUnprivSGIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1807-1860",
          "snippet": "int\nqemuSetUnprivSGIO(virDomainDeviceDefPtr dev)\n{\n    virDomainDiskDefPtr disk = NULL;\n    virDomainHostdevDefPtr hostdev = NULL;\n    g_autofree char *sysfs_path = NULL;\n    const char *path = NULL;\n    int val = -1;\n\n    /* \"sgio\" is only valid for block disk; cdrom\n     * and floopy disk can have empty source.\n     */\n    if (dev->type == VIR_DOMAIN_DEVICE_DISK) {\n        disk = dev->data.disk;\n\n        if (disk->device != VIR_DOMAIN_DISK_DEVICE_LUN ||\n            !virStorageSourceIsBlockLocal(disk->src))\n            return 0;\n\n        path = virDomainDiskGetSource(disk);\n    } else if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        hostdev = dev->data.hostdev;\n\n        if (!qemuIsSharedHostdev(hostdev))\n            return 0;\n\n        if (hostdev->source.subsys.u.scsi.sgio) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'sgio' is not supported for SCSI \"\n                             \"generic device yet \"));\n            return -1;\n        }\n\n        return 0;\n    } else {\n        return 0;\n    }\n\n    if (!(sysfs_path = virGetUnprivSGIOSysfsPath(path, NULL)))\n        return -1;\n\n    /* By default, filter the SG_IO commands, i.e. set unpriv_sgio to 0.  */\n    val = (disk->sgio == VIR_DOMAIN_DEVICE_SGIO_UNFILTERED);\n\n    /* Do not do anything if unpriv_sgio is not supported by the kernel and the\n     * whitelist is enabled.  But if requesting unfiltered access, always call\n     * virSetDeviceUnprivSGIO, to report an error for unsupported unpriv_sgio.\n     */\n    if ((virFileExists(sysfs_path) || val == 1) &&\n        virSetDeviceUnprivSGIO(path, NULL, val) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuSetUnprivSGIO(virDomainDeviceDefPtr dev)\n{\n    virDomainDiskDefPtr disk = NULL;\n    virDomainHostdevDefPtr hostdev = NULL;\n    g_autofree char *sysfs_path = NULL;\n    const char *path = NULL;\n    int val = -1;\n\n    /* \"sgio\" is only valid for block disk; cdrom\n     * and floopy disk can have empty source.\n     */\n    if (dev->type == VIR_DOMAIN_DEVICE_DISK) {\n        disk = dev->data.disk;\n\n        if (disk->device != VIR_DOMAIN_DISK_DEVICE_LUN ||\n            !virStorageSourceIsBlockLocal(disk->src))\n            return 0;\n\n        path = virDomainDiskGetSource(disk);\n    } else if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        hostdev = dev->data.hostdev;\n\n        if (!qemuIsSharedHostdev(hostdev))\n            return 0;\n\n        if (hostdev->source.subsys.u.scsi.sgio) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'sgio' is not supported for SCSI \"\n                             \"generic device yet \"));\n            return -1;\n        }\n\n        return 0;\n    } else {\n        return 0;\n    }\n\n    if (!(sysfs_path = virGetUnprivSGIOSysfsPath(path, NULL)))\n        return -1;\n\n    /* By default, filter the SG_IO commands, i.e. set unpriv_sgio to 0.  */\n    val = (disk->sgio == VIR_DOMAIN_DEVICE_SGIO_UNFILTERED);\n\n    /* Do not do anything if unpriv_sgio is not supported by the kernel and the\n     * whitelist is enabled.  But if requesting unfiltered access, always call\n     * virSetDeviceUnprivSGIO, to report an error for unsupported unpriv_sgio.\n     */\n    if ((virFileExists(sysfs_path) || val == 1) &&\n        virSetDeviceUnprivSGIO(path, NULL, val) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAddSharedDevice",
          "args": [
            "driver",
            "&dev",
            "name"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAddSharedDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1771-1777",
          "snippet": "int\nqemuAddSharedDevice(virQEMUDriverPtr driver,\n                    virDomainDeviceDefPtr dev,\n                    const char *name)\n{\n    return qemuSharedDeviceAddRemoveInternal(driver, dev, name, true);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuAddSharedDevice(virQEMUDriverPtr driver,\n                    virDomainDeviceDefPtr dev,\n                    const char *name)\n{\n    return qemuSharedDeviceAddRemoveInternal(driver, dev, name, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsSCSIDevice",
          "args": [
            "hostdevs[i]"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsSCSIDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32282-32287",
          "snippet": "bool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareSCSIDevices(virQEMUDriverPtr driver,\n                              const char *name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    /* Loop 1: Add the shared scsi host device to shared device\n     * table.\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainDeviceDef dev;\n\n        if (!virHostdevIsSCSIDevice(hostdevs[i]))\n            continue;\n\n        dev.type = VIR_DOMAIN_DEVICE_HOSTDEV;\n        dev.data.hostdev = hostdevs[i];\n\n        if (qemuAddSharedDevice(driver, &dev, name) < 0)\n            return -1;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            return -1;\n    }\n\n    return virHostdevPrepareSCSIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                        name, hostdevs, nhostdevs);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "257-268",
    "snippet": "int\nqemuHostdevPrepareUSBDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                       hostdevs, nhostdevs, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareUSBDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "hostdevs",
            "nhostdevs",
            "flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1439-1505",
          "snippet": "int\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareUSBDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    return virHostdevPrepareUSBDevices(hostdev_mgr, QEMU_DRIVER_NAME, name,\n                                       hostdevs, nhostdevs, flags);\n}"
  },
  {
    "function_name": "qemuHostdevPreparePCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "238-255",
    "snippet": "int\nqemuHostdevPreparePCIDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             const unsigned char *uuid,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             virQEMUCapsPtr qemuCaps,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!qemuHostdevPreparePCIDevicesCheckSupport(hostdevs, nhostdevs, qemuCaps))\n        return -1;\n\n    return virHostdevPreparePCIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, uuid, hostdevs,\n                                       nhostdevs, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPreparePCIDevices",
          "args": [
            "hostdev_mgr",
            "QEMU_DRIVER_NAME",
            "name",
            "uuid",
            "hostdevs",
            "nhostdevs",
            "flags"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPreparePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "942-961",
          "snippet": "int\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevPreparePCIDevicesCheckSupport",
          "args": [
            "hostdevs",
            "nhostdevs",
            "qemuCaps"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevPreparePCIDevicesCheckSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "161-214",
          "snippet": "static bool\nqemuHostdevPreparePCIDevicesCheckSupport(virDomainHostdevDefPtr *hostdevs,\n                                         size_t nhostdevs,\n                                         virQEMUCapsPtr qemuCaps)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n    size_t i;\n\n    /* assign defaults for hostdev passthrough */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        int *backend = &hostdev->source.subsys.u.pci.backend;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        switch ((virDomainHostdevSubsysPCIBackendType)*backend) {\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT:\n            if (supportsPassthroughVFIO &&\n                virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n                *backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support passthrough of \"\n                                 \"host PCI devices\"));\n                return false;\n            }\n\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO:\n            if (!supportsPassthroughVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support VFIO PCI passthrough\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_KVM:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support legacy PCI passthrough\"));\n            return false;\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN:\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_TYPE_LAST:\n            break;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nqemuHostdevPreparePCIDevicesCheckSupport(virDomainHostdevDefPtr *hostdevs,\n                                         size_t nhostdevs,\n                                         virQEMUCapsPtr qemuCaps)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n    size_t i;\n\n    /* assign defaults for hostdev passthrough */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        int *backend = &hostdev->source.subsys.u.pci.backend;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        switch ((virDomainHostdevSubsysPCIBackendType)*backend) {\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT:\n            if (supportsPassthroughVFIO &&\n                virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n                *backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support passthrough of \"\n                                 \"host PCI devices\"));\n                return false;\n            }\n\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO:\n            if (!supportsPassthroughVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support VFIO PCI passthrough\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_KVM:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support legacy PCI passthrough\"));\n            return false;\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN:\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_TYPE_LAST:\n            break;\n        }\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPreparePCIDevices(virQEMUDriverPtr driver,\n                             const char *name,\n                             const unsigned char *uuid,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             virQEMUCapsPtr qemuCaps,\n                             unsigned int flags)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!qemuHostdevPreparePCIDevicesCheckSupport(hostdevs, nhostdevs, qemuCaps))\n        return -1;\n\n    return virHostdevPreparePCIDevices(hostdev_mgr, QEMU_DRIVER_NAME,\n                                       name, uuid, hostdevs,\n                                       nhostdevs, flags);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareNVMeDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "227-236",
    "snippet": "int\nqemuHostdevPrepareNVMeDisks(virQEMUDriverPtr driver,\n                            const char *name,\n                            virDomainDiskDefPtr *disks,\n                            size_t ndisks)\n{\n    return virHostdevPrepareNVMeDevices(driver->hostdevMgr,\n                                        QEMU_DRIVER_NAME,\n                                        name, disks, ndisks);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareNVMeDevices",
          "args": [
            "driver->hostdevMgr",
            "QEMU_DRIVER_NAME",
            "name",
            "disks",
            "ndisks"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareNVMeDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2338-2370",
          "snippet": "int\nvirHostdevPrepareNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    size_t i;\n    ssize_t lastGoodDiskIdx = -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevPrepareOneNVMeDevice(hostdev_mgr, drv_name,\n                                           dom_name, disks[i]->src) < 0)\n            goto rollback;\n\n        lastGoodDiskIdx = i;\n    }\n\n    return 0;\n\n rollback:\n    while (lastGoodDiskIdx >= 0) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name, dom_name,\n                                            disks[lastGoodDiskIdx]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[lastGoodDiskIdx]->dst);\n        }\n\n        lastGoodDiskIdx--;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    size_t i;\n    ssize_t lastGoodDiskIdx = -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevPrepareOneNVMeDevice(hostdev_mgr, drv_name,\n                                           dom_name, disks[i]->src) < 0)\n            goto rollback;\n\n        lastGoodDiskIdx = i;\n    }\n\n    return 0;\n\n rollback:\n    while (lastGoodDiskIdx >= 0) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name, dom_name,\n                                            disks[lastGoodDiskIdx]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[lastGoodDiskIdx]->dst);\n        }\n\n        lastGoodDiskIdx--;\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareNVMeDisks(virQEMUDriverPtr driver,\n                            const char *name,\n                            virDomainDiskDefPtr *disks,\n                            size_t ndisks)\n{\n    return virHostdevPrepareNVMeDevices(driver->hostdevMgr,\n                                        QEMU_DRIVER_NAME,\n                                        name, disks, ndisks);\n}"
  },
  {
    "function_name": "qemuHostdevPrepareOneNVMeDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "216-225",
    "snippet": "int\nqemuHostdevPrepareOneNVMeDisk(virQEMUDriverPtr driver,\n                              const char *name,\n                              virStorageSourcePtr src)\n{\n    return virHostdevPrepareOneNVMeDevice(driver->hostdevMgr,\n                                          QEMU_DRIVER_NAME,\n                                          name,\n                                          src);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareOneNVMeDevice",
          "args": [
            "driver->hostdevMgr",
            "QEMU_DRIVER_NAME",
            "name",
            "src"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareOneNVMeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2229-2335",
          "snippet": "int\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevPrepareOneNVMeDisk(virQEMUDriverPtr driver,\n                              const char *name,\n                              virStorageSourcePtr src)\n{\n    return virHostdevPrepareOneNVMeDevice(driver->hostdevMgr,\n                                          QEMU_DRIVER_NAME,\n                                          name,\n                                          src);\n}"
  },
  {
    "function_name": "qemuHostdevPreparePCIDevicesCheckSupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "161-214",
    "snippet": "static bool\nqemuHostdevPreparePCIDevicesCheckSupport(virDomainHostdevDefPtr *hostdevs,\n                                         size_t nhostdevs,\n                                         virQEMUCapsPtr qemuCaps)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n    size_t i;\n\n    /* assign defaults for hostdev passthrough */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        int *backend = &hostdev->source.subsys.u.pci.backend;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        switch ((virDomainHostdevSubsysPCIBackendType)*backend) {\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT:\n            if (supportsPassthroughVFIO &&\n                virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n                *backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support passthrough of \"\n                                 \"host PCI devices\"));\n                return false;\n            }\n\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO:\n            if (!supportsPassthroughVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support VFIO PCI passthrough\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_KVM:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support legacy PCI passthrough\"));\n            return false;\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN:\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_TYPE_LAST:\n            break;\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"host doesn't support legacy PCI passthrough\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"host doesn't support legacy PCI passthrough\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"host doesn't support VFIO PCI passthrough\")"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"host doesn't support passthrough of \"\n                                 \"host PCI devices\")"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VFIO_PCI"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevHostSupportsPassthroughVFIO",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevHostSupportsPassthroughVFIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "146-158",
          "snippet": "bool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nqemuHostdevPreparePCIDevicesCheckSupport(virDomainHostdevDefPtr *hostdevs,\n                                         size_t nhostdevs,\n                                         virQEMUCapsPtr qemuCaps)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n    size_t i;\n\n    /* assign defaults for hostdev passthrough */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        int *backend = &hostdev->source.subsys.u.pci.backend;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        switch ((virDomainHostdevSubsysPCIBackendType)*backend) {\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT:\n            if (supportsPassthroughVFIO &&\n                virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n                *backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support passthrough of \"\n                                 \"host PCI devices\"));\n                return false;\n            }\n\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO:\n            if (!supportsPassthroughVFIO) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support VFIO PCI passthrough\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_KVM:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support legacy PCI passthrough\"));\n            return false;\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN:\n        case VIR_DOMAIN_HOSTDEV_PCI_BACKEND_TYPE_LAST:\n            break;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "qemuHostdevHostSupportsPassthroughVFIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "146-158",
    "snippet": "bool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "QEMU_DEV_VFIO"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostHasIOMMU",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "virHostHasIOMMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1657-1679",
          "snippet": "bool\nvirHostHasIOMMU(void)\n{\n    DIR *iommuDir = NULL;\n    struct dirent *iommuGroup = NULL;\n    bool ret = false;\n    int direrr;\n\n    if (virDirOpenQuiet(&iommuDir, \"/sys/kernel/iommu_groups/\") < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(iommuDir, &iommuGroup, NULL)) > 0)\n        break;\n\n    if (direrr < 0 || !iommuGroup)\n        goto cleanup;\n\n    ret = true;\n\n cleanup:\n    VIR_DIR_CLOSE(iommuDir);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirHostHasIOMMU(void)\n{\n    DIR *iommuDir = NULL;\n    struct dirent *iommuGroup = NULL;\n    bool ret = false;\n    int direrr;\n\n    if (virDirOpenQuiet(&iommuDir, \"/sys/kernel/iommu_groups/\") < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(iommuDir, &iommuGroup, NULL)) > 0)\n        break;\n\n    if (direrr < 0 || !iommuGroup)\n        goto cleanup;\n\n    ret = true;\n\n cleanup:\n    VIR_DIR_CLOSE(iommuDir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "qemuHostdevNeedsVFIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "138-143",
    "snippet": "bool\nqemuHostdevNeedsVFIO(const virDomainHostdevDef *hostdev)\n{\n    return virHostdevIsVFIODevice(hostdev) ||\n        virHostdevIsMdevDevice(hostdev);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdev"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsVFIODevice",
          "args": [
            "hostdev"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsVFIODevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32310-32316",
          "snippet": "bool\nvirHostdevIsVFIODevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->source.subsys.u.pci.backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsVFIODevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->source.subsys.u.pci.backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nqemuHostdevNeedsVFIO(const virDomainHostdevDef *hostdev)\n{\n    return virHostdevIsVFIODevice(hostdev) ||\n        virHostdevIsMdevDevice(hostdev);\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActiveDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "112-135",
    "snippet": "int\nqemuHostdevUpdateActiveDomainDevices(virQEMUDriverPtr driver,\n                                     virDomainDefPtr def)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return 0;\n\n    if (qemuHostdevUpdateActiveNVMeDisks(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActivePCIDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveUSBDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveSCSIDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveMediatedDevices(driver, def) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuHostdevUpdateActiveMediatedDevices",
          "args": [
            "driver",
            "def"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevUpdateActiveMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "85-97",
          "snippet": "int\nqemuHostdevUpdateActiveMediatedDevices(virQEMUDriverPtr driver,\n                                       virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveMediatedDevices(mgr, def->hostdevs,\n                                                 def->nhostdevs,\n                                                 QEMU_DRIVER_NAME, def->name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveMediatedDevices(virQEMUDriverPtr driver,\n                                       virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveMediatedDevices(mgr, def->hostdevs,\n                                                 def->nhostdevs,\n                                                 QEMU_DRIVER_NAME, def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevUpdateActiveSCSIDevices",
          "args": [
            "driver",
            "def"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevUpdateActiveSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "71-82",
          "snippet": "int\nqemuHostdevUpdateActiveSCSIDevices(virQEMUDriverPtr driver,\n                                   virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveSCSIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                             QEMU_DRIVER_NAME, def->name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveSCSIDevices(virQEMUDriverPtr driver,\n                                   virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveSCSIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                             QEMU_DRIVER_NAME, def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevUpdateActiveUSBDevices",
          "args": [
            "driver",
            "def"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevUpdateActiveUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "58-69",
          "snippet": "int\nqemuHostdevUpdateActiveUSBDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveUSBDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevUpdateActivePCIDevices",
          "args": [
            "driver",
            "def"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevUpdateActivePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "45-56",
          "snippet": "int\nqemuHostdevUpdateActivePCIDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActivePCIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActivePCIDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActivePCIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuHostdevUpdateActiveNVMeDisks",
          "args": [
            "driver",
            "def"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevUpdateActiveNVMeDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "100-109",
          "snippet": "int\nqemuHostdevUpdateActiveNVMeDisks(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    return virHostdevUpdateActiveNVMeDevices(driver->hostdevMgr,\n                                             QEMU_DRIVER_NAME,\n                                             def->name,\n                                             def->disks,\n                                             def->ndisks);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveNVMeDisks(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    return virHostdevUpdateActiveNVMeDevices(driver->hostdevMgr,\n                                             QEMU_DRIVER_NAME,\n                                             def->name,\n                                             def->disks,\n                                             def->ndisks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveDomainDevices(virQEMUDriverPtr driver,\n                                     virDomainDefPtr def)\n{\n    if (!def->nhostdevs && !def->ndisks)\n        return 0;\n\n    if (qemuHostdevUpdateActiveNVMeDisks(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActivePCIDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveUSBDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveSCSIDevices(driver, def) < 0)\n        return -1;\n\n    if (qemuHostdevUpdateActiveMediatedDevices(driver, def) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActiveNVMeDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "100-109",
    "snippet": "int\nqemuHostdevUpdateActiveNVMeDisks(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    return virHostdevUpdateActiveNVMeDevices(driver->hostdevMgr,\n                                             QEMU_DRIVER_NAME,\n                                             def->name,\n                                             def->disks,\n                                             def->ndisks);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveNVMeDevices",
          "args": [
            "driver->hostdevMgr",
            "QEMU_DRIVER_NAME",
            "def->name",
            "def->disks",
            "def->ndisks"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveNVMeDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2443-2523",
          "snippet": "int\nvirHostdevUpdateActiveNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainDiskDefPtr *disks,\n                                  size_t ndisks)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    ssize_t lastGoodPCIIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevGetNVMeDeviceList(nvmeDevices, disks[i]->src, drv_name, dom_name) < 0)\n            return -1;\n    }\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n    virObjectLock(hostdev_mgr->activePCIHostdevs);\n    virObjectLock(hostdev_mgr->inactivePCIHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        /* We must restore some attributes that were lost on daemon restart. */\n        virPCIDeviceSetUnbindFromStub(actual, true);\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto rollback;\n\n        if (virPCIDeviceListAddCopy(hostdev_mgr->activePCIHostdevs, actual) < 0)\n            goto rollback;\n\n        lastGoodPCIIdx = i;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->inactivePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    while (lastGoodPCIIdx >= 0) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        virPCIDeviceListDel(hostdev_mgr->activePCIHostdevs, actual);\n\n        lastGoodPCIIdx--;\n    }\n    goto cleanup;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainDiskDefPtr *disks,\n                                  size_t ndisks)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    ssize_t lastGoodPCIIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevGetNVMeDeviceList(nvmeDevices, disks[i]->src, drv_name, dom_name) < 0)\n            return -1;\n    }\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n    virObjectLock(hostdev_mgr->activePCIHostdevs);\n    virObjectLock(hostdev_mgr->inactivePCIHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        /* We must restore some attributes that were lost on daemon restart. */\n        virPCIDeviceSetUnbindFromStub(actual, true);\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto rollback;\n\n        if (virPCIDeviceListAddCopy(hostdev_mgr->activePCIHostdevs, actual) < 0)\n            goto rollback;\n\n        lastGoodPCIIdx = i;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->inactivePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    while (lastGoodPCIIdx >= 0) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        virPCIDeviceListDel(hostdev_mgr->activePCIHostdevs, actual);\n\n        lastGoodPCIIdx--;\n    }\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveNVMeDisks(virQEMUDriverPtr driver,\n                                 virDomainDefPtr def)\n{\n    return virHostdevUpdateActiveNVMeDevices(driver->hostdevMgr,\n                                             QEMU_DRIVER_NAME,\n                                             def->name,\n                                             def->disks,\n                                             def->ndisks);\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActiveMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "85-97",
    "snippet": "int\nqemuHostdevUpdateActiveMediatedDevices(virQEMUDriverPtr driver,\n                                       virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveMediatedDevices(mgr, def->hostdevs,\n                                                 def->nhostdevs,\n                                                 QEMU_DRIVER_NAME, def->name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveMediatedDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "QEMU_DRIVER_NAME",
            "def->name"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveMediatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1257-1294",
          "snippet": "int\nvirHostdevUpdateActiveMediatedDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr *hostdevs,\n                                      int nhostdevs,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    int ret = -1;\n    size_t i;\n    g_autoptr(virMediatedDevice) mdev = NULL;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr, mdevsrc->model)))\n            goto cleanup;\n\n        virMediatedDeviceSetUsedBy(mdev, drv_name, dom_name);\n\n        if (virMediatedDeviceListAdd(mgr->activeMediatedHostdevs, &mdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveMediatedDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr *hostdevs,\n                                      int nhostdevs,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    int ret = -1;\n    size_t i;\n    g_autoptr(virMediatedDevice) mdev = NULL;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr, mdevsrc->model)))\n            goto cleanup;\n\n        virMediatedDeviceSetUsedBy(mdev, drv_name, dom_name);\n\n        if (virMediatedDeviceListAdd(mgr->activeMediatedHostdevs, &mdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveMediatedDevices(virQEMUDriverPtr driver,\n                                       virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveMediatedDevices(mgr, def->hostdevs,\n                                                 def->nhostdevs,\n                                                 QEMU_DRIVER_NAME, def->name);\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActiveSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "71-82",
    "snippet": "int\nqemuHostdevUpdateActiveSCSIDevices(virQEMUDriverPtr driver,\n                                   virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveSCSIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                             QEMU_DRIVER_NAME, def->name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveSCSIDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "QEMU_DRIVER_NAME",
            "def->name"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1218-1254",
          "snippet": "int\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveSCSIDevices(virQEMUDriverPtr driver,\n                                   virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveSCSIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                             QEMU_DRIVER_NAME, def->name);\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActiveUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "58-69",
    "snippet": "int\nqemuHostdevUpdateActiveUSBDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveUSBDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "QEMU_DRIVER_NAME",
            "def->name"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1145-1187",
          "snippet": "int\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActiveUSBDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}"
  },
  {
    "function_name": "qemuHostdevUpdateActivePCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
    "lines": "45-56",
    "snippet": "int\nqemuHostdevUpdateActivePCIDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActivePCIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostdev.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActivePCIDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "QEMU_DRIVER_NAME",
            "def->name"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActivePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1099-1143",
          "snippet": "int\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuHostdevUpdateActivePCIDevices(virQEMUDriverPtr driver,\n                                  virDomainDefPtr def)\n{\n    virHostdevManagerPtr mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActivePCIDevices(mgr, def->hostdevs, def->nhostdevs,\n                                            QEMU_DRIVER_NAME, def->name);\n}"
  }
]