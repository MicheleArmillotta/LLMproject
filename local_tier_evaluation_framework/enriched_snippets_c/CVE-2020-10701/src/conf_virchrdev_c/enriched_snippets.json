[
  {
    "function_name": "virChrdevOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "327-446",
    "snippet": "int virChrdevOpen(virChrdevsPtr devs,\n                  virDomainChrSourceDefPtr source,\n                  virStreamPtr st,\n                  bool force)\n{\n    virChrdevStreamInfoPtr cbdata = NULL;\n    virChrdevHashEntry *ent;\n    char *path;\n    int ret;\n    bool added = false;\n\n    switch (source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        path = source->data.file.path;\n        if (!path) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"PTY device is not yet assigned\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        path = source->data.nix.path;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainChrTypeToString(source->type));\n        return -1;\n    }\n\n    virMutexLock(&devs->lock);\n\n    if ((ent = virHashLookup(devs->hash, path))) {\n        if (!force) {\n             /* entry found, device is busy */\n            virMutexUnlock(&devs->lock);\n            return 1;\n       } else {\n           /* terminate existing connection */\n           /* The internal close callback handler needs to lock devs->lock to\n            * remove the aborted stream from the hash. This would cause a\n            * deadlock as we would try to enter the lock twice from the very\n            * same thread. We need to unregister the callback and abort the\n            * stream manually before we create a new device connection.\n            */\n           virFDStreamSetInternalCloseCb(ent->st, NULL, NULL, NULL);\n           virStreamAbort(ent->st);\n           virHashRemoveEntry(devs->hash, path);\n           /* continue adding a new stream connection */\n       }\n    }\n\n    /* create the lock file */\n    if ((ret = virChrdevLockFileCreate(path)) < 0) {\n        virMutexUnlock(&devs->lock);\n        return ret;\n    }\n\n    /* obtain a reference to the stream */\n    if (virStreamRef(st) < 0) {\n        virMutexUnlock(&devs->lock);\n        return -1;\n    }\n\n    if (VIR_ALLOC(cbdata) < 0)\n        goto error;\n\n    if (VIR_ALLOC(ent) < 0)\n        goto error;\n\n    ent->st = st;\n    ent->dev = g_strdup(path);\n\n    if (virHashAddEntry(devs->hash, path, ent) < 0)\n        goto error;\n    ent = NULL;\n    added = true;\n\n    cbdata->devs = devs;\n    cbdata->path = g_strdup(path);\n\n    /* open the character device */\n    switch (source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        if (virFDStreamOpenPTY(st, path, 0, 0, O_RDWR) < 0)\n            goto error;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (virFDStreamConnectUNIX(st, path, false) < 0)\n            goto error;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainChrTypeToString(source->type));\n        goto error;\n    }\n\n    /* add cleanup callback */\n    virFDStreamSetInternalCloseCb(st,\n                                  virChrdevFDStreamCloseCb,\n                                  cbdata,\n                                  virChrdevFDStreamCloseCbFree);\n\n    virMutexUnlock(&devs->lock);\n    return 0;\n\n error:\n    if (added)\n        virHashRemoveEntry(devs->hash, path);\n    else\n        virObjectUnref(st);\n\n    if (cbdata)\n        VIR_FREE(cbdata->path);\n    VIR_FREE(cbdata);\n    virMutexUnlock(&devs->lock);\n    virChrdevHashEntryFree(ent);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virChrdevHashEntryFree",
          "args": [
            "ent"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevHashEntryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "200-215",
          "snippet": "static void virChrdevHashEntryFree(void *data)\n{\n    virChrdevHashEntry *ent = data;\n\n    if (!ent)\n        return;\n\n    /* free stream reference */\n    virObjectUnref(ent->st);\n\n    /* delete lock file */\n    virChrdevLockFileRemove(ent->dev);\n\n    g_free(ent->dev);\n    g_free(ent);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevHashEntryFree(void *data)\n{\n    virChrdevHashEntry *ent = data;\n\n    if (!ent)\n        return;\n\n    /* free stream reference */\n    virObjectUnref(ent->st);\n\n    /* delete lock file */\n    virChrdevLockFileRemove(ent->dev);\n\n    g_free(ent->dev);\n    g_free(ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&devs->lock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cbdata"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cbdata->path"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "devs->hash",
            "path"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamSetInternalCloseCb",
          "args": [
            "st",
            "virChrdevFDStreamCloseCb",
            "cbdata",
            "virChrdevFDStreamCloseCbFree"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamSetInternalCloseCb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1500-1509",
          "snippet": "int\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported device type '%s'\")",
            "virDomainChrTypeToString(source->type)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "source->type"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported device type '%s'\""
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamConnectUNIX",
          "args": [
            "st",
            "path",
            "false"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamConnectUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1435-1443",
          "snippet": "int\nvirFDStreamConnectUNIX(virStreamPtr st G_GNUC_UNUSED,\n                       const char *path G_GNUC_UNUSED,\n                       bool abstract G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamConnectUNIX(virStreamPtr st G_GNUC_UNUSED,\n                       const char *path G_GNUC_UNUSED,\n                       bool abstract G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamOpenPTY",
          "args": [
            "st",
            "path",
            "0",
            "0",
            "O_RDWR"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenPTY",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1473-1483",
          "snippet": "int\nvirFDStreamOpenPTY(virStreamPtr st G_GNUC_UNUSED,\n                   const char *path G_GNUC_UNUSED,\n                   unsigned long long offset G_GNUC_UNUSED,\n                   unsigned long long length G_GNUC_UNUSED,\n                   int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenPTY(virStreamPtr st G_GNUC_UNUSED,\n                   const char *path G_GNUC_UNUSED,\n                   unsigned long long offset G_GNUC_UNUSED,\n                   unsigned long long length G_GNUC_UNUSED,\n                   int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "devs->hash",
            "path",
            "ent"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ent"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cbdata"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamRef",
          "args": [
            "st"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "85-97",
          "snippet": "int\nvirStreamRef(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p refs=%d\", stream,\n              stream ? stream->parent.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    virObjectRef(stream);\n    return 0;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamRef(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p refs=%d\", stream,\n              stream ? stream->parent.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    virObjectRef(stream);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virChrdevLockFileCreate",
          "args": [
            "path"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevLockFileCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "179-182",
          "snippet": "static int virChrdevLockFileCreate(const char *dev G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virChrdevLockFileCreate(const char *dev G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "ent->st"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "devs->hash",
            "path"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&devs->lock"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported device type '%s'\")",
            "virDomainChrTypeToString(source->type)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "source->type"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"PTY device is not yet assigned\")"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virChrdevOpen(virChrdevsPtr devs,\n                  virDomainChrSourceDefPtr source,\n                  virStreamPtr st,\n                  bool force)\n{\n    virChrdevStreamInfoPtr cbdata = NULL;\n    virChrdevHashEntry *ent;\n    char *path;\n    int ret;\n    bool added = false;\n\n    switch (source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        path = source->data.file.path;\n        if (!path) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"PTY device is not yet assigned\"));\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        path = source->data.nix.path;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainChrTypeToString(source->type));\n        return -1;\n    }\n\n    virMutexLock(&devs->lock);\n\n    if ((ent = virHashLookup(devs->hash, path))) {\n        if (!force) {\n             /* entry found, device is busy */\n            virMutexUnlock(&devs->lock);\n            return 1;\n       } else {\n           /* terminate existing connection */\n           /* The internal close callback handler needs to lock devs->lock to\n            * remove the aborted stream from the hash. This would cause a\n            * deadlock as we would try to enter the lock twice from the very\n            * same thread. We need to unregister the callback and abort the\n            * stream manually before we create a new device connection.\n            */\n           virFDStreamSetInternalCloseCb(ent->st, NULL, NULL, NULL);\n           virStreamAbort(ent->st);\n           virHashRemoveEntry(devs->hash, path);\n           /* continue adding a new stream connection */\n       }\n    }\n\n    /* create the lock file */\n    if ((ret = virChrdevLockFileCreate(path)) < 0) {\n        virMutexUnlock(&devs->lock);\n        return ret;\n    }\n\n    /* obtain a reference to the stream */\n    if (virStreamRef(st) < 0) {\n        virMutexUnlock(&devs->lock);\n        return -1;\n    }\n\n    if (VIR_ALLOC(cbdata) < 0)\n        goto error;\n\n    if (VIR_ALLOC(ent) < 0)\n        goto error;\n\n    ent->st = st;\n    ent->dev = g_strdup(path);\n\n    if (virHashAddEntry(devs->hash, path, ent) < 0)\n        goto error;\n    ent = NULL;\n    added = true;\n\n    cbdata->devs = devs;\n    cbdata->path = g_strdup(path);\n\n    /* open the character device */\n    switch (source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        if (virFDStreamOpenPTY(st, path, 0, 0, O_RDWR) < 0)\n            goto error;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (virFDStreamConnectUNIX(st, path, false) < 0)\n            goto error;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainChrTypeToString(source->type));\n        goto error;\n    }\n\n    /* add cleanup callback */\n    virFDStreamSetInternalCloseCb(st,\n                                  virChrdevFDStreamCloseCb,\n                                  cbdata,\n                                  virChrdevFDStreamCloseCbFree);\n\n    virMutexUnlock(&devs->lock);\n    return 0;\n\n error:\n    if (added)\n        virHashRemoveEntry(devs->hash, path);\n    else\n        virObjectUnref(st);\n\n    if (cbdata)\n        VIR_FREE(cbdata->path);\n    VIR_FREE(cbdata);\n    virMutexUnlock(&devs->lock);\n    virChrdevHashEntryFree(ent);\n    return -1;\n}"
  },
  {
    "function_name": "virChrdevFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "297-309",
    "snippet": "void virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devs"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&devs->lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&devs->lock"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "devs->hash"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashForEach",
          "args": [
            "devs->hash",
            "virChrdevFreeClearCallbacks",
            "NULL"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virHashForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "626-649",
          "snippet": "int\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&devs->lock"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}"
  },
  {
    "function_name": "virChrdevFreeClearCallbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "282-290",
    "snippet": "static int virChrdevFreeClearCallbacks(void *payload,\n                                       const void *name G_GNUC_UNUSED,\n                                       void *data G_GNUC_UNUSED)\n{\n    virChrdevHashEntry *ent = payload;\n\n    virFDStreamSetInternalCloseCb(ent->st, NULL, NULL, NULL);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamSetInternalCloseCb",
          "args": [
            "ent->st",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamSetInternalCloseCb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1500-1509",
          "snippet": "int\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virChrdevFreeClearCallbacks(void *payload,\n                                       const void *name G_GNUC_UNUSED,\n                                       void *data G_GNUC_UNUSED)\n{\n    virChrdevHashEntry *ent = payload;\n\n    virFDStreamSetInternalCloseCb(ent->st, NULL, NULL, NULL);\n    return 0;\n}"
  },
  {
    "function_name": "virChrdevAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "255-277",
    "snippet": "virChrdevsPtr virChrdevAlloc(void)\n{\n    virChrdevsPtr devs;\n    if (VIR_ALLOC(devs) < 0)\n        return NULL;\n\n    if (virMutexInit(&devs->lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to init device stream mutex\"));\n        VIR_FREE(devs);\n        return NULL;\n    }\n\n    /* there will hardly be any devices most of the time, the hash\n     * does not have to be huge */\n    if (!(devs->hash = virHashCreate(3, virChrdevHashEntryFree)))\n        goto error;\n\n    return devs;\n error:\n    virChrdevFree(devs);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virChrdevFree",
          "args": [
            "devs"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "297-309",
          "snippet": "void virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "3",
            "virChrdevHashEntryFree"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devs"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to init device stream mutex\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to init device stream mutex\""
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&devs->lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "devs"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirChrdevsPtr virChrdevAlloc(void)\n{\n    virChrdevsPtr devs;\n    if (VIR_ALLOC(devs) < 0)\n        return NULL;\n\n    if (virMutexInit(&devs->lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to init device stream mutex\"));\n        VIR_FREE(devs);\n        return NULL;\n    }\n\n    /* there will hardly be any devices most of the time, the hash\n     * does not have to be huge */\n    if (!(devs->hash = virHashCreate(3, virChrdevHashEntryFree)))\n        goto error;\n\n    return devs;\n error:\n    virChrdevFree(devs);\n    return NULL;\n}"
  },
  {
    "function_name": "virChrdevFDStreamCloseCb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "237-247",
    "snippet": "static void virChrdevFDStreamCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    virChrdevStreamInfoPtr priv = opaque;\n    virMutexLock(&priv->devs->lock);\n\n    /* remove entry from hash */\n    virHashRemoveEntry(priv->devs->hash, priv->path);\n\n    virMutexUnlock(&priv->devs->lock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->devs->lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "priv->devs->hash",
            "priv->path"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->devs->lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevFDStreamCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    virChrdevStreamInfoPtr priv = opaque;\n    virMutexLock(&priv->devs->lock);\n\n    /* remove entry from hash */\n    virHashRemoveEntry(priv->devs->hash, priv->path);\n\n    virMutexUnlock(&priv->devs->lock);\n}"
  },
  {
    "function_name": "virChrdevFDStreamCloseCbFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "222-228",
    "snippet": "static void virChrdevFDStreamCloseCbFree(void *opaque)\n{\n    virChrdevStreamInfoPtr priv = opaque;\n\n    VIR_FREE(priv->path);\n    VIR_FREE(priv);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->path"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevFDStreamCloseCbFree(void *opaque)\n{\n    virChrdevStreamInfoPtr priv = opaque;\n\n    VIR_FREE(priv->path);\n    VIR_FREE(priv);\n}"
  },
  {
    "function_name": "virChrdevHashEntryFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "200-215",
    "snippet": "static void virChrdevHashEntryFree(void *data)\n{\n    virChrdevHashEntry *ent = data;\n\n    if (!ent)\n        return;\n\n    /* free stream reference */\n    virObjectUnref(ent->st);\n\n    /* delete lock file */\n    virChrdevLockFileRemove(ent->dev);\n\n    g_free(ent->dev);\n    g_free(ent);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "ent"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "ent->dev"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virChrdevLockFileRemove",
          "args": [
            "ent->dev"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevLockFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "184-187",
          "snippet": "static void virChrdevLockFileRemove(const char *dev G_GNUC_UNUSED)\n{\n    return;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevLockFileRemove(const char *dev G_GNUC_UNUSED)\n{\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ent->st"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevHashEntryFree(void *data)\n{\n    virChrdevHashEntry *ent = data;\n\n    if (!ent)\n        return;\n\n    /* free stream reference */\n    virObjectUnref(ent->st);\n\n    /* delete lock file */\n    virChrdevLockFileRemove(ent->dev);\n\n    g_free(ent->dev);\n    g_free(ent);\n}"
  },
  {
    "function_name": "virChrdevLockFileRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "184-187",
    "snippet": "static void virChrdevLockFileRemove(const char *dev G_GNUC_UNUSED)\n{\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevLockFileRemove(const char *dev G_GNUC_UNUSED)\n{\n    return;\n}"
  },
  {
    "function_name": "virChrdevLockFileCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "179-182",
    "snippet": "static int virChrdevLockFileCreate(const char *dev G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virChrdevLockFileCreate(const char *dev G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virChrdevLockFileRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "172-176",
    "snippet": "static void virChrdevLockFileRemove(const char *dev)\n{\n    g_autofree char *path = virChrdevLockFilePath(dev);\n    unlink(path);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virChrdevLockFilePath",
          "args": [
            "dev"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevLockFilePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "68-96",
          "snippet": "static char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virChrdevLockFileRemove(const char *dev)\n{\n    g_autofree char *path = virChrdevLockFilePath(dev);\n    unlink(path);\n}"
  },
  {
    "function_name": "virChrdevLockFileCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "105-165",
    "snippet": "static int virChrdevLockFileCreate(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *pidStr = NULL;\n    VIR_AUTOCLOSE lockfd = -1;\n    pid_t pid;\n\n    /* build lock file path */\n    if (!(path = virChrdevLockFilePath(dev)))\n        return -1;\n\n    /* check if a log file and process holding the lock still exists */\n    if (virPidFileReadPathIfAlive(path, &pid, NULL) == 0 && pid >= 0) {\n        /* the process exists, the lockfile is valid */\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Requested device '%s' is locked by \"\n                         \"lock file '%s' held by process %lld\"),\n                       dev, path, (long long) pid);\n        return -1;\n    } else {\n        /* clean up the stale/corrupted/nonexistent lockfile */\n        unlink(path);\n    }\n    /* lockfile doesn't (shouldn't) exist */\n\n    /* ensure correct format according to filesystem hierarchy standard */\n    /* http://www.pathname.com/fhs/pub/fhs-2.3.html#VARLOCKLOCKFILES */\n    pidStr = g_strdup_printf(\"%10lld\\n\", (long long)getpid());\n\n    /* create the lock file */\n    if ((lockfd = open(path, O_WRONLY | O_CREAT | O_EXCL, 00644)) < 0) {\n        /* If we run in session mode, we might have no access to the lock\n         * file directory. We have to check for an permission denied error\n         * and see if we can reach it. This should cause an error only if\n         * we run in daemon mode and thus privileged.\n         */\n        if (errno == EACCES && geteuid() != 0) {\n            VIR_DEBUG(\"Skipping lock file creation for device '%s in path '%s'.\",\n                      dev, path);\n            return 0;\n        }\n        virReportSystemError(errno,\n                             _(\"Couldn't create lock file for \"\n                               \"device '%s' in path '%s'\"),\n                             dev, path);\n        return -1;\n    }\n\n    /* write the pid to the file */\n    if (safewrite(lockfd, pidStr, strlen(pidStr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Couldn't write to lock file for \"\n                               \"device '%s' in path '%s'\"),\n                             dev, path);\n        unlink(path);\n        return -1;\n    }\n\n    /* we hold the lock */\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Couldn't write to lock file for \"\n                               \"device '%s' in path '%s'\")",
            "dev",
            "path"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Couldn't write to lock file for \"\n                               \"device '%s' in path '%s'\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "lockfd",
            "pidStr",
            "strlen(pidStr)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pidStr"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Couldn't create lock file for \"\n                               \"device '%s' in path '%s'\")",
            "dev",
            "path"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping lock file creation for device '%s in path '%s'.\"",
            "dev",
            "path"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY | O_CREAT | O_EXCL",
            "00644"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%10lld\\n\"",
            "(long long)getpid()"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Requested device '%s' is locked by \"\n                         \"lock file '%s' held by process %lld\")",
            "dev",
            "path",
            "(long long) pid"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "path",
            "&pid",
            "NULL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virChrdevLockFilePath",
          "args": [
            "dev"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevLockFilePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "68-96",
          "snippet": "static char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virChrdevLockFileCreate(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *pidStr = NULL;\n    VIR_AUTOCLOSE lockfd = -1;\n    pid_t pid;\n\n    /* build lock file path */\n    if (!(path = virChrdevLockFilePath(dev)))\n        return -1;\n\n    /* check if a log file and process holding the lock still exists */\n    if (virPidFileReadPathIfAlive(path, &pid, NULL) == 0 && pid >= 0) {\n        /* the process exists, the lockfile is valid */\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Requested device '%s' is locked by \"\n                         \"lock file '%s' held by process %lld\"),\n                       dev, path, (long long) pid);\n        return -1;\n    } else {\n        /* clean up the stale/corrupted/nonexistent lockfile */\n        unlink(path);\n    }\n    /* lockfile doesn't (shouldn't) exist */\n\n    /* ensure correct format according to filesystem hierarchy standard */\n    /* http://www.pathname.com/fhs/pub/fhs-2.3.html#VARLOCKLOCKFILES */\n    pidStr = g_strdup_printf(\"%10lld\\n\", (long long)getpid());\n\n    /* create the lock file */\n    if ((lockfd = open(path, O_WRONLY | O_CREAT | O_EXCL, 00644)) < 0) {\n        /* If we run in session mode, we might have no access to the lock\n         * file directory. We have to check for an permission denied error\n         * and see if we can reach it. This should cause an error only if\n         * we run in daemon mode and thus privileged.\n         */\n        if (errno == EACCES && geteuid() != 0) {\n            VIR_DEBUG(\"Skipping lock file creation for device '%s in path '%s'.\",\n                      dev, path);\n            return 0;\n        }\n        virReportSystemError(errno,\n                             _(\"Couldn't create lock file for \"\n                               \"device '%s' in path '%s'\"),\n                             dev, path);\n        return -1;\n    }\n\n    /* write the pid to the file */\n    if (safewrite(lockfd, pidStr, strlen(pidStr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Couldn't write to lock file for \"\n                               \"device '%s' in path '%s'\"),\n                             dev, path);\n        unlink(path);\n        return -1;\n    }\n\n    /* we hold the lock */\n    return 0;\n}"
  },
  {
    "function_name": "virChrdevLockFilePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
    "lines": "68-96",
    "snippet": "static char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virhash.h\"",
      "#include \"virchrdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&sanitizedPath"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileSanitizePath",
          "args": [
            "path"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virFileSanitizePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3242-3290",
          "snippet": "char *\nvirFileSanitizePath(const char *path)\n{\n    const char *cur = path;\n    char *uri;\n    char *cleanpath;\n    int idx = 0;\n\n    cleanpath = g_strdup(path);\n\n    /* don't sanitize URIs - rfc3986 states that two slashes may lead to a\n     * different resource, thus removing them would possibly change the path */\n    if ((uri = strstr(path, \"://\")) && strchr(path, '/') > uri)\n        return cleanpath;\n\n    /* Need to sanitize:\n     * //           -> //\n     * ///          -> /\n     * /../foo      -> /../foo\n     * /foo///bar/  -> /foo/bar\n     */\n\n    /* Starting with // is valid posix, but ///foo == /foo */\n    if (cur[0] == '/' && cur[1] == '/' && cur[2] != '/') {\n        idx = 2;\n        cur += 2;\n    }\n\n    /* Sanitize path in place */\n    while (*cur != '\\0') {\n        if (*cur != '/') {\n            cleanpath[idx++] = *cur++;\n            continue;\n        }\n\n        /* Skip all extra / */\n        while (*++cur == '/')\n            continue;\n\n        /* Don't add a trailing / */\n        if (idx != 0 && *cur == '\\0')\n            break;\n\n        cleanpath[idx++] = '/';\n    }\n    cleanpath[idx] = '\\0';\n\n    return cleanpath;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileSanitizePath(const char *path)\n{\n    const char *cur = path;\n    char *uri;\n    char *cleanpath;\n    int idx = 0;\n\n    cleanpath = g_strdup(path);\n\n    /* don't sanitize URIs - rfc3986 states that two slashes may lead to a\n     * different resource, thus removing them would possibly change the path */\n    if ((uri = strstr(path, \"://\")) && strchr(path, '/') > uri)\n        return cleanpath;\n\n    /* Need to sanitize:\n     * //           -> //\n     * ///          -> /\n     * /../foo      -> /../foo\n     * /foo///bar/  -> /foo/bar\n     */\n\n    /* Starting with // is valid posix, but ///foo == /foo */\n    if (cur[0] == '/' && cur[1] == '/' && cur[2] != '/') {\n        idx = 2;\n        cur += 2;\n    }\n\n    /* Sanitize path in place */\n    while (*cur != '\\0') {\n        if (*cur != '/') {\n            cleanpath[idx++] = *cur++;\n            continue;\n        }\n\n        /* Skip all extra / */\n        while (*++cur == '/')\n            continue;\n\n        /* Don't add a trailing / */\n        if (idx != 0 && *cur == '\\0')\n            break;\n\n        cleanpath[idx++] = '/';\n    }\n    cleanpath[idx] = '\\0';\n\n    return cleanpath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/LCK..%s\"",
            "VIR_CHRDEV_LOCK_FILE_PATH",
            "filename"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "devCopy",
            "\"/dev\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *virChrdevLockFilePath(const char *dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *sanitizedPath = NULL;\n    g_autofree char *devCopy = NULL;\n    char *filename;\n    char *p;\n\n    devCopy = g_strdup(dev);\n\n    /* skip the leading \"/dev/\" */\n    filename = STRSKIP(devCopy, \"/dev\");\n    if (!filename)\n        filename = devCopy;\n\n    /* substitute path forward slashes for underscores */\n    p = filename;\n    while (*p) {\n        if (*p == '/')\n            *p = '_';\n        ++p;\n    }\n\n    path = g_strdup_printf(\"%s/LCK..%s\", VIR_CHRDEV_LOCK_FILE_PATH, filename);\n\n    sanitizedPath = virFileSanitizePath(path);\n\n    return g_steal_pointer(&sanitizedPath);\n}"
  }
]