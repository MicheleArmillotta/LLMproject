[
  {
    "function_name": "virLockSpaceProtocolDispatchCreateLockSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "387-429",
    "snippet": "static int\nvirLockSpaceProtocolDispatchCreateLockSpace(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolCreateLockSpaceArgs *args)\n{\n    int rv = -1;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (virLockDaemonFindLockSpace(lockDaemon, args->path) != NULL) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Lockspace for path %s already exists\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockSpaceNew(args->path)))\n        goto cleanup;\n\n    if (virLockDaemonAddLockSpace(lockDaemon, args->path, lockspace) < 0) {\n        virLockSpaceFree(lockspace);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceFree",
          "args": [
            "lockspace"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "505-514",
          "snippet": "void virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nvoid virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonAddLockSpace",
          "args": [
            "lockDaemon",
            "args->path",
            "lockspace"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonAddLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "330-339",
          "snippet": "int virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceNew",
          "args": [
            "args->path"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "287-425",
          "snippet": "virLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCKSPACE_TABLE_SIZE 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\n#define VIR_LOCKSPACE_TABLE_SIZE 10\n\nvirLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Lockspace for path %s already exists\")",
            "args->path"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s already exists\""
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchCreateLockSpace(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolCreateLockSpaceArgs *args)\n{\n    int rv = -1;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (virLockDaemonFindLockSpace(lockDaemon, args->path) != NULL) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Lockspace for path %s already exists\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockSpaceNew(args->path)))\n        goto cleanup;\n\n    if (virLockDaemonAddLockSpace(lockDaemon, args->path, lockspace) < 0) {\n        virLockSpaceFree(lockspace);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchRestrict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "348-384",
    "snippet": "static int\nvirLockSpaceProtocolDispatchRestrict(virNetServerPtr server G_GNUC_UNUSED,\n                                     virNetServerClientPtr client,\n                                     virNetMessagePtr msg G_GNUC_UNUSED,\n                                     virNetMessageErrorPtr rerr,\n                                     virLockSpaceProtocolRestrictArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    priv->restricted = true;\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"lock owner details have not been registered\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchRestrict(virNetServerPtr server G_GNUC_UNUSED,\n                                     virNetServerClientPtr client,\n                                     virNetMessagePtr msg G_GNUC_UNUSED,\n                                     virNetMessageErrorPtr rerr,\n                                     virLockSpaceProtocolRestrictArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    priv->restricted = true;\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchReleaseResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "297-345",
    "snippet": "static int\nvirLockSpaceProtocolDispatchReleaseResource(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolReleaseResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceReleaseResource(lockspace,\n                                    args->name,\n                                    priv->ownerPid) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceReleaseResource",
          "args": [
            "lockspace",
            "args->name",
            "priv->ownerPid"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceReleaseResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "641-684",
          "snippet": "int virLockSpaceReleaseResource(virLockSpacePtr lockspace,\n                                const char *resname,\n                                pid_t owner)\n{\n    int ret = -1;\n    virLockSpaceResourcePtr res;\n    size_t i;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s owner=%lld\",\n              lockspace, resname, (unsigned long long)owner);\n\n    virMutexLock(&lockspace->lock);\n\n    if (!(res = virHashLookup(lockspace->resources, resname))) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is not locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    for (i = 0; i < res->nOwners; i++) {\n        if (res->owners[i] == owner)\n            break;\n    }\n\n    if (i == res->nOwners) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"owner %lld does not hold the resource lock\"),\n                       (unsigned long long)owner);\n        goto cleanup;\n    }\n\n    VIR_DELETE_ELEMENT(res->owners, i, res->nOwners);\n\n    if ((res->nOwners == 0) &&\n        virHashRemoveEntry(lockspace->resources, resname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nint virLockSpaceReleaseResource(virLockSpacePtr lockspace,\n                                const char *resname,\n                                pid_t owner)\n{\n    int ret = -1;\n    virLockSpaceResourcePtr res;\n    size_t i;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s owner=%lld\",\n              lockspace, resname, (unsigned long long)owner);\n\n    virMutexLock(&lockspace->lock);\n\n    if (!(res = virHashLookup(lockspace->resources, resname))) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is not locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    for (i = 0; i < res->nOwners; i++) {\n        if (res->owners[i] == owner)\n            break;\n    }\n\n    if (i == res->nOwners) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"owner %lld does not hold the resource lock\"),\n                       (unsigned long long)owner);\n        goto cleanup;\n    }\n\n    VIR_DELETE_ELEMENT(res->owners, i, res->nOwners);\n\n    if ((res->nOwners == 0) &&\n        virHashRemoveEntry(lockspace->resources, resname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace for path %s does not exist\")",
            "args->path"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s does not exist\""
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchReleaseResource(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolReleaseResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceReleaseResource(lockspace,\n                                    args->name,\n                                    priv->ownerPid) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "252-294",
    "snippet": "static int\nvirLockSpaceProtocolDispatchRegister(virNetServerPtr server G_GNUC_UNUSED,\n                                     virNetServerClientPtr client,\n                                     virNetMessagePtr msg G_GNUC_UNUSED,\n                                     virNetMessageErrorPtr rerr,\n                                     virLockSpaceProtocolRegisterArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!args->owner.id) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    priv->ownerName = g_strdup(args->owner.name);\n    memcpy(priv->ownerUUID, args->owner.uuid, VIR_UUID_BUFLEN);\n    priv->ownerId = args->owner.id;\n    priv->ownerPid = args->owner.pid;\n    VIR_DEBUG(\"ownerName=%s ownerId=%d ownerPid=%lld\",\n              priv->ownerName, priv->ownerId, (unsigned long long)priv->ownerPid);\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ownerName=%s ownerId=%d ownerPid=%lld\"",
            "priv->ownerName",
            "priv->ownerId",
            "(unsigned long long)priv->ownerPid"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->ownerUUID",
            "args->owner.uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "args->owner.name"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"lock owner details have not been registered\""
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchRegister(virNetServerPtr server G_GNUC_UNUSED,\n                                     virNetServerClientPtr client,\n                                     virNetMessagePtr msg G_GNUC_UNUSED,\n                                     virNetMessageErrorPtr rerr,\n                                     virLockSpaceProtocolRegisterArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!args->owner.id) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    priv->ownerName = g_strdup(args->owner.name);\n    memcpy(priv->ownerUUID, args->owner.uuid, VIR_UUID_BUFLEN);\n    priv->ownerId = args->owner.id;\n    priv->ownerPid = args->owner.pid;\n    VIR_DEBUG(\"ownerName=%s ownerId=%d ownerPid=%lld\",\n              priv->ownerName, priv->ownerId, (unsigned long long)priv->ownerPid);\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "196-249",
    "snippet": "static int\nvirLockSpaceProtocolDispatchNew(virNetServerPtr server G_GNUC_UNUSED,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg G_GNUC_UNUSED,\n                                virNetMessageErrorPtr rerr,\n                                virLockSpaceProtocolNewArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!args->path || STREQ(args->path, \"\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the default lockspace already exists\"));\n        goto cleanup;\n    }\n\n    if (virLockDaemonFindLockSpace(lockDaemon, args->path) != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s already exists\"),\n                       args->path);\n        goto cleanup;\n    }\n    virResetLastError();\n\n    lockspace = virLockSpaceNew(args->path);\n    virLockDaemonAddLockSpace(lockDaemon, args->path, lockspace);\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonAddLockSpace",
          "args": [
            "lockDaemon",
            "args->path",
            "lockspace"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonAddLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "330-339",
          "snippet": "int virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceNew",
          "args": [
            "args->path"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "287-425",
          "snippet": "virLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCKSPACE_TABLE_SIZE 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\n#define VIR_LOCKSPACE_TABLE_SIZE 10\n\nvirLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace for path %s already exists\")",
            "args->path"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s already exists\""
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"the default lockspace already exists\")"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "args->path",
            "\"\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchNew(virNetServerPtr server G_GNUC_UNUSED,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg G_GNUC_UNUSED,\n                                virNetMessageErrorPtr rerr,\n                                virLockSpaceProtocolNewArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!args->path || STREQ(args->path, \"\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the default lockspace already exists\"));\n        goto cleanup;\n    }\n\n    if (virLockDaemonFindLockSpace(lockDaemon, args->path) != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s already exists\"),\n                       args->path);\n        goto cleanup;\n    }\n    virResetLastError();\n\n    lockspace = virLockSpaceNew(args->path);\n    virLockDaemonAddLockSpace(lockDaemon, args->path, lockspace);\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchDeleteResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "147-193",
    "snippet": "static int\nvirLockSpaceProtocolDispatchDeleteResource(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           virLockSpaceProtocolDeleteResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceDeleteResource(lockspace, args->name) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceDeleteResource",
          "args": [
            "lockspace",
            "args->name"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceDeleteResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "555-589",
          "snippet": "int virLockSpaceDeleteResource(virLockSpacePtr lockspace,\n                               const char *resname)\n{\n    int ret = -1;\n    char *respath = NULL;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s\", lockspace, resname);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashLookup(lockspace->resources, resname) != NULL) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(respath = virLockSpaceGetResourcePath(lockspace, resname)))\n        goto cleanup;\n\n    if (unlink(respath) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to delete lockspace resource %s\"),\n                             respath);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    VIR_FREE(respath);\n    return ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nint virLockSpaceDeleteResource(virLockSpacePtr lockspace,\n                               const char *resname)\n{\n    int ret = -1;\n    char *respath = NULL;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s\", lockspace, resname);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashLookup(lockspace->resources, resname) != NULL) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(respath = virLockSpaceGetResourcePath(lockspace, resname)))\n        goto cleanup;\n\n    if (unlink(respath) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to delete lockspace resource %s\"),\n                             respath);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    VIR_FREE(respath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace for path %s does not exist\")",
            "args->path"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s does not exist\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchDeleteResource(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           virLockSpaceProtocolDeleteResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceDeleteResource(lockspace, args->name) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchCreateResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "98-144",
    "snippet": "static int\nvirLockSpaceProtocolDispatchCreateResource(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           virLockSpaceProtocolCreateResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceCreateResource(lockspace, args->name) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceCreateResource",
          "args": [
            "lockspace",
            "args->name"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceCreateResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "523-552",
          "snippet": "int virLockSpaceCreateResource(virLockSpacePtr lockspace,\n                               const char *resname)\n{\n    int ret = -1;\n    char *respath = NULL;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s\", lockspace, resname);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashLookup(lockspace->resources, resname) != NULL) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(respath = virLockSpaceGetResourcePath(lockspace, resname)))\n        goto cleanup;\n\n    if (virFileTouch(respath, 0600) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    VIR_FREE(respath);\n    return ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nint virLockSpaceCreateResource(virLockSpacePtr lockspace,\n                               const char *resname)\n{\n    int ret = -1;\n    char *respath = NULL;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s\", lockspace, resname);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashLookup(lockspace->resources, resname) != NULL) {\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(respath = virLockSpaceGetResourcePath(lockspace, resname)))\n        goto cleanup;\n\n    if (virFileTouch(respath, 0600) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    VIR_FREE(respath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace for path %s does not exist\")",
            "args->path"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s does not exist\""
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchCreateResource(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           virLockSpaceProtocolCreateResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(0, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    if (virLockSpaceCreateResource(lockspace, args->name) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  },
  {
    "function_name": "virLockSpaceProtocolDispatchAcquireResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_dispatch.c",
    "lines": "38-95",
    "snippet": "static int\nvirLockSpaceProtocolDispatchAcquireResource(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolAcquireResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n    unsigned int newFlags;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED |\n                      VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    newFlags = 0;\n    if (flags & VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED)\n        newFlags |= VIR_LOCK_SPACE_ACQUIRE_SHARED;\n    if (flags & VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE)\n        newFlags |= VIR_LOCK_SPACE_ACQUIRE_AUTOCREATE;\n\n    if (virLockSpaceAcquireResource(lockspace,\n                                    args->name,\n                                    priv->ownerPid,\n                                    newFlags) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}",
    "includes": [
      "#include \"lock_daemon_dispatch_stubs.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"lock_protocol.h\"",
      "#include \"lock_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceAcquireResource",
          "args": [
            "lockspace",
            "args->name",
            "priv->ownerPid",
            "newFlags"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceAcquireResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "592-638",
          "snippet": "int virLockSpaceAcquireResource(virLockSpacePtr lockspace,\n                                const char *resname,\n                                pid_t owner,\n                                unsigned int flags)\n{\n    int ret = -1;\n    virLockSpaceResourcePtr res;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s flags=0x%x owner=%lld\",\n              lockspace, resname, flags, (unsigned long long)owner);\n\n    virCheckFlags(VIR_LOCK_SPACE_ACQUIRE_SHARED |\n                  VIR_LOCK_SPACE_ACQUIRE_AUTOCREATE, -1);\n\n    virMutexLock(&lockspace->lock);\n\n    if ((res = virHashLookup(lockspace->resources, resname))) {\n        if ((res->flags & VIR_LOCK_SPACE_ACQUIRE_SHARED) &&\n            (flags & VIR_LOCK_SPACE_ACQUIRE_SHARED)) {\n\n            if (VIR_EXPAND_N(res->owners, res->nOwners, 1) < 0)\n                goto cleanup;\n            res->owners[res->nOwners-1] = owner;\n\n            goto done;\n        }\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(res = virLockSpaceResourceNew(lockspace, resname, flags, owner)))\n        goto cleanup;\n\n    if (virHashAddEntry(lockspace->resources, resname, res) < 0) {\n        virLockSpaceResourceFree(res);\n        goto cleanup;\n    }\n\n done:\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nint virLockSpaceAcquireResource(virLockSpacePtr lockspace,\n                                const char *resname,\n                                pid_t owner,\n                                unsigned int flags)\n{\n    int ret = -1;\n    virLockSpaceResourcePtr res;\n\n    VIR_DEBUG(\"lockspace=%p resname=%s flags=0x%x owner=%lld\",\n              lockspace, resname, flags, (unsigned long long)owner);\n\n    virCheckFlags(VIR_LOCK_SPACE_ACQUIRE_SHARED |\n                  VIR_LOCK_SPACE_ACQUIRE_AUTOCREATE, -1);\n\n    virMutexLock(&lockspace->lock);\n\n    if ((res = virHashLookup(lockspace->resources, resname))) {\n        if ((res->flags & VIR_LOCK_SPACE_ACQUIRE_SHARED) &&\n            (flags & VIR_LOCK_SPACE_ACQUIRE_SHARED)) {\n\n            if (VIR_EXPAND_N(res->owners, res->nOwners, 1) < 0)\n                goto cleanup;\n            res->owners[res->nOwners-1] = owner;\n\n            goto done;\n        }\n        virReportError(VIR_ERR_RESOURCE_BUSY,\n                       _(\"Lockspace resource '%s' is locked\"),\n                       resname);\n        goto cleanup;\n    }\n\n    if (!(res = virLockSpaceResourceNew(lockspace, resname, flags, owner)))\n        goto cleanup;\n\n    if (virHashAddEntry(lockspace->resources, resname, res) < 0) {\n        virLockSpaceResourceFree(res);\n        goto cleanup;\n    }\n\n done:\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace for path %s does not exist\")",
            "args->path"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lockspace for path %s does not exist\""
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFindLockSpace",
          "args": [
            "lockDaemon",
            "args->path"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFindLockSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "341-352",
          "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"lock owner details have not been registered\")"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_DENIED",
            "\"%s\"",
            "_(\"lock manager connection has been restricted\")"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED |\n                      VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE",
            "cleanup"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lock_daemon_dispatch_stubs.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"lock_protocol.h\"\n#include \"lock_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetdaemon.h\"\n#include <config.h>\n\nstatic int\nvirLockSpaceProtocolDispatchAcquireResource(virNetServerPtr server G_GNUC_UNUSED,\n                                            virNetServerClientPtr client,\n                                            virNetMessagePtr msg G_GNUC_UNUSED,\n                                            virNetMessageErrorPtr rerr,\n                                            virLockSpaceProtocolAcquireResourceArgs *args)\n{\n    int rv = -1;\n    unsigned int flags = args->flags;\n    virLockDaemonClientPtr priv =\n        virNetServerClientGetPrivateData(client);\n    virLockSpacePtr lockspace;\n    unsigned int newFlags;\n\n    virMutexLock(&priv->lock);\n\n    virCheckFlagsGoto(VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED |\n                      VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE, cleanup);\n\n    if (priv->restricted) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"lock manager connection has been restricted\"));\n        goto cleanup;\n    }\n\n    if (!priv->ownerId) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"lock owner details have not been registered\"));\n        goto cleanup;\n    }\n\n    if (!(lockspace = virLockDaemonFindLockSpace(lockDaemon, args->path))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace for path %s does not exist\"),\n                       args->path);\n        goto cleanup;\n    }\n\n    newFlags = 0;\n    if (flags & VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_SHARED)\n        newFlags |= VIR_LOCK_SPACE_ACQUIRE_SHARED;\n    if (flags & VIR_LOCK_SPACE_PROTOCOL_ACQUIRE_RESOURCE_AUTOCREATE)\n        newFlags |= VIR_LOCK_SPACE_ACQUIRE_AUTOCREATE;\n\n    if (virLockSpaceAcquireResource(lockspace,\n                                    args->name,\n                                    priv->ownerPid,\n                                    newFlags) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return rv;\n}"
  }
]