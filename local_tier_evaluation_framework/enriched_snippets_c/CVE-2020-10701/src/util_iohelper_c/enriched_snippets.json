[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/iohelper.c",
    "lines": "192-244",
    "snippet": "int\nmain(int argc, char **argv)\n{\n    const char *path;\n    int oflags = -1;\n    int fd = -1;\n\n    program_name = argv[0];\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\"), program_name);\n        exit(EXIT_FAILURE);\n    }\n\n    path = argv[1];\n\n    if (argc > 1 && STREQ(argv[1], \"--help\"))\n        usage(EXIT_SUCCESS);\n    if (argc == 3) { /* FILENAME FD */\n        if (virStrToLong_i(argv[2], NULL, 10, &fd) < 0) {\n            fprintf(stderr, _(\"%s: malformed fd %s\"),\n                    program_name, argv[3]);\n            exit(EXIT_FAILURE);\n        }\n#ifdef F_GETFL\n        oflags = fcntl(fd, F_GETFL);\n#else\n        /* Stupid mingw.  */\n        if (fd == STDIN_FILENO)\n            oflags = O_RDONLY;\n        else if (fd == STDOUT_FILENO)\n            oflags = O_WRONLY;\n#endif\n        if (oflags < 0) {\n            fprintf(stderr, _(\"%s: unable to determine access mode of fd %d\"),\n                    program_name, fd);\n            exit(EXIT_FAILURE);\n        }\n    } else { /* unknown argc pattern */\n        usage(EXIT_FAILURE);\n    }\n\n    if (fd < 0 || runIO(path, fd, oflags) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    fprintf(stderr, _(\"%s: failure with %s: %s\"),\n            program_name, path, virGetLastErrorMessage());\n    exit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *program_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: failure with %s: %s\")",
            "program_name",
            "path",
            "virGetLastErrorMessage()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: failure with %s: %s\""
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "runIO",
          "args": [
            "path",
            "fd",
            "oflags"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "runIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/iohelper.c",
          "lines": "45-177",
          "snippet": "static int\nrunIO(const char *path, int fd, int oflags)\n{\n    g_autofree void *base = NULL; /* Location to be freed */\n    char *buf = NULL; /* Aligned location within base */\n    size_t buflen = 1024*1024;\n    intptr_t alignMask = 64*1024 - 1;\n    int ret = -1;\n    int fdin, fdout;\n    const char *fdinname, *fdoutname;\n    unsigned long long total = 0;\n    bool direct = O_DIRECT && ((oflags & O_DIRECT) != 0);\n    off_t end = 0;\n\n#if HAVE_POSIX_MEMALIGN\n    if (posix_memalign(&base, alignMask + 1, buflen)) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    buf = base;\n#else\n    if (VIR_ALLOC_N(buf, buflen + alignMask) < 0)\n        goto cleanup;\n    base = buf;\n    buf = (char *) (((intptr_t) base + alignMask) & ~alignMask);\n#endif\n\n    switch (oflags & O_ACCMODE) {\n    case O_RDONLY:\n        fdin = fd;\n        fdinname = path;\n        fdout = STDOUT_FILENO;\n        fdoutname = \"stdout\";\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && ((end = lseek(fd, 0, SEEK_CUR)) != 0)) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT read needs entire seekable file\"));\n            goto cleanup;\n        }\n        break;\n    case O_WRONLY:\n        fdin = STDIN_FILENO;\n        fdinname = \"stdin\";\n        fdout = fd;\n        fdoutname = path;\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && (end = lseek(fd, 0, SEEK_END)) != 0) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT write needs empty seekable file\"));\n            goto cleanup;\n        }\n        break;\n\n    case O_RDWR:\n    default:\n        virReportSystemError(EINVAL,\n                             _(\"Unable to process file with flags %d\"),\n                             (oflags & O_ACCMODE));\n        goto cleanup;\n    }\n\n    while (1) {\n        ssize_t got;\n\n        /* If we read with O_DIRECT from file we can't use saferead as\n         * it can lead to unaligned read after reading last bytes.\n         * If we write with O_DIRECT use should use saferead so that\n         * writes will be aligned.\n         * In other cases using saferead reduces number of syscalls.\n         */\n        if (fdin == fd && direct) {\n            if ((got = read(fdin, buf, buflen)) < 0 &&\n                errno == EINTR)\n                continue;\n        } else {\n            got = saferead(fdin, buf, buflen);\n        }\n\n        if (got < 0) {\n            virReportSystemError(errno, _(\"Unable to read %s\"), fdinname);\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n\n        total += got;\n\n        /* handle last write size align in direct case */\n        if (got < buflen && direct && fdout == fd) {\n            ssize_t aligned_got = (got + alignMask) & ~alignMask;\n\n            memset(buf + got, 0, aligned_got - got);\n\n            if (safewrite(fdout, buf, aligned_got) < 0) {\n                virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            if (ftruncate(fd, total) < 0) {\n                virReportSystemError(errno, _(\"Unable to truncate %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            break;\n        }\n\n        if (safewrite(fdout, buf, got) < 0) {\n            virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    /* Ensure all data is written */\n    if (virFileDataSync(fdout) < 0) {\n        if (errno != EINVAL && errno != EROFS) {\n            /* fdatasync() may fail on some special FDs, e.g. pipes */\n            virReportSystemError(errno, _(\"unable to fsync %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0 &&\n        ret == 0) {\n        virReportSystemError(errno, _(\"Unable to close %s\"), path);\n        ret = -1;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nrunIO(const char *path, int fd, int oflags)\n{\n    g_autofree void *base = NULL; /* Location to be freed */\n    char *buf = NULL; /* Aligned location within base */\n    size_t buflen = 1024*1024;\n    intptr_t alignMask = 64*1024 - 1;\n    int ret = -1;\n    int fdin, fdout;\n    const char *fdinname, *fdoutname;\n    unsigned long long total = 0;\n    bool direct = O_DIRECT && ((oflags & O_DIRECT) != 0);\n    off_t end = 0;\n\n#if HAVE_POSIX_MEMALIGN\n    if (posix_memalign(&base, alignMask + 1, buflen)) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    buf = base;\n#else\n    if (VIR_ALLOC_N(buf, buflen + alignMask) < 0)\n        goto cleanup;\n    base = buf;\n    buf = (char *) (((intptr_t) base + alignMask) & ~alignMask);\n#endif\n\n    switch (oflags & O_ACCMODE) {\n    case O_RDONLY:\n        fdin = fd;\n        fdinname = path;\n        fdout = STDOUT_FILENO;\n        fdoutname = \"stdout\";\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && ((end = lseek(fd, 0, SEEK_CUR)) != 0)) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT read needs entire seekable file\"));\n            goto cleanup;\n        }\n        break;\n    case O_WRONLY:\n        fdin = STDIN_FILENO;\n        fdinname = \"stdin\";\n        fdout = fd;\n        fdoutname = path;\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && (end = lseek(fd, 0, SEEK_END)) != 0) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT write needs empty seekable file\"));\n            goto cleanup;\n        }\n        break;\n\n    case O_RDWR:\n    default:\n        virReportSystemError(EINVAL,\n                             _(\"Unable to process file with flags %d\"),\n                             (oflags & O_ACCMODE));\n        goto cleanup;\n    }\n\n    while (1) {\n        ssize_t got;\n\n        /* If we read with O_DIRECT from file we can't use saferead as\n         * it can lead to unaligned read after reading last bytes.\n         * If we write with O_DIRECT use should use saferead so that\n         * writes will be aligned.\n         * In other cases using saferead reduces number of syscalls.\n         */\n        if (fdin == fd && direct) {\n            if ((got = read(fdin, buf, buflen)) < 0 &&\n                errno == EINTR)\n                continue;\n        } else {\n            got = saferead(fdin, buf, buflen);\n        }\n\n        if (got < 0) {\n            virReportSystemError(errno, _(\"Unable to read %s\"), fdinname);\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n\n        total += got;\n\n        /* handle last write size align in direct case */\n        if (got < buflen && direct && fdout == fd) {\n            ssize_t aligned_got = (got + alignMask) & ~alignMask;\n\n            memset(buf + got, 0, aligned_got - got);\n\n            if (safewrite(fdout, buf, aligned_got) < 0) {\n                virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            if (ftruncate(fd, total) < 0) {\n                virReportSystemError(errno, _(\"Unable to truncate %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            break;\n        }\n\n        if (safewrite(fdout, buf, got) < 0) {\n            virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    /* Ensure all data is written */\n    if (virFileDataSync(fdout) < 0) {\n        if (errno != EINVAL && errno != EROFS) {\n            /* fdatasync() may fail on some special FDs, e.g. pipes */\n            virReportSystemError(errno, _(\"unable to fsync %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0 &&\n        ret == 0) {\n        virReportSystemError(errno, _(\"Unable to close %s\"), path);\n        ret = -1;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/iohelper.c",
          "lines": "181-190",
          "snippet": "G_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\"), program_name);\n    } else {\n        printf(_(\"Usage: %s FILENAME FD\"), program_name);\n    }\n    exit(status);\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *program_name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic const char *program_name;\n\nG_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\"), program_name);\n    } else {\n        printf(_(\"Usage: %s FILENAME FD\"), program_name);\n    }\n    exit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: unable to determine access mode of fd %d\")",
            "program_name",
            "fd"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: malformed fd %s\")",
            "program_name",
            "argv[3]"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "argv[2]",
            "NULL",
            "10",
            "&fd"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: initialization failed\")",
            "program_name"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorInitialize",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "172-176",
          "snippet": "int\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal virLastErr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirThreadLocal virLastErr;\n\nint\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic const char *program_name;\n\nint\nmain(int argc, char **argv)\n{\n    const char *path;\n    int oflags = -1;\n    int fd = -1;\n\n    program_name = argv[0];\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\"), program_name);\n        exit(EXIT_FAILURE);\n    }\n\n    path = argv[1];\n\n    if (argc > 1 && STREQ(argv[1], \"--help\"))\n        usage(EXIT_SUCCESS);\n    if (argc == 3) { /* FILENAME FD */\n        if (virStrToLong_i(argv[2], NULL, 10, &fd) < 0) {\n            fprintf(stderr, _(\"%s: malformed fd %s\"),\n                    program_name, argv[3]);\n            exit(EXIT_FAILURE);\n        }\n#ifdef F_GETFL\n        oflags = fcntl(fd, F_GETFL);\n#else\n        /* Stupid mingw.  */\n        if (fd == STDIN_FILENO)\n            oflags = O_RDONLY;\n        else if (fd == STDOUT_FILENO)\n            oflags = O_WRONLY;\n#endif\n        if (oflags < 0) {\n            fprintf(stderr, _(\"%s: unable to determine access mode of fd %d\"),\n                    program_name, fd);\n            exit(EXIT_FAILURE);\n        }\n    } else { /* unknown argc pattern */\n        usage(EXIT_FAILURE);\n    }\n\n    if (fd < 0 || runIO(path, fd, oflags) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    fprintf(stderr, _(\"%s: failure with %s: %s\"),\n            program_name, path, virGetLastErrorMessage());\n    exit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/iohelper.c",
    "lines": "181-190",
    "snippet": "G_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\"), program_name);\n    } else {\n        printf(_(\"Usage: %s FILENAME FD\"), program_name);\n    }\n    exit(status);\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *program_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "status"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "_(\"Usage: %s FILENAME FD\")",
            "program_name"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Usage: %s FILENAME FD\""
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: try --help for more details\")",
            "program_name"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic const char *program_name;\n\nG_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\"), program_name);\n    } else {\n        printf(_(\"Usage: %s FILENAME FD\"), program_name);\n    }\n    exit(status);\n}"
  },
  {
    "function_name": "runIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/iohelper.c",
    "lines": "45-177",
    "snippet": "static int\nrunIO(const char *path, int fd, int oflags)\n{\n    g_autofree void *base = NULL; /* Location to be freed */\n    char *buf = NULL; /* Aligned location within base */\n    size_t buflen = 1024*1024;\n    intptr_t alignMask = 64*1024 - 1;\n    int ret = -1;\n    int fdin, fdout;\n    const char *fdinname, *fdoutname;\n    unsigned long long total = 0;\n    bool direct = O_DIRECT && ((oflags & O_DIRECT) != 0);\n    off_t end = 0;\n\n#if HAVE_POSIX_MEMALIGN\n    if (posix_memalign(&base, alignMask + 1, buflen)) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    buf = base;\n#else\n    if (VIR_ALLOC_N(buf, buflen + alignMask) < 0)\n        goto cleanup;\n    base = buf;\n    buf = (char *) (((intptr_t) base + alignMask) & ~alignMask);\n#endif\n\n    switch (oflags & O_ACCMODE) {\n    case O_RDONLY:\n        fdin = fd;\n        fdinname = path;\n        fdout = STDOUT_FILENO;\n        fdoutname = \"stdout\";\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && ((end = lseek(fd, 0, SEEK_CUR)) != 0)) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT read needs entire seekable file\"));\n            goto cleanup;\n        }\n        break;\n    case O_WRONLY:\n        fdin = STDIN_FILENO;\n        fdinname = \"stdin\";\n        fdout = fd;\n        fdoutname = path;\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && (end = lseek(fd, 0, SEEK_END)) != 0) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT write needs empty seekable file\"));\n            goto cleanup;\n        }\n        break;\n\n    case O_RDWR:\n    default:\n        virReportSystemError(EINVAL,\n                             _(\"Unable to process file with flags %d\"),\n                             (oflags & O_ACCMODE));\n        goto cleanup;\n    }\n\n    while (1) {\n        ssize_t got;\n\n        /* If we read with O_DIRECT from file we can't use saferead as\n         * it can lead to unaligned read after reading last bytes.\n         * If we write with O_DIRECT use should use saferead so that\n         * writes will be aligned.\n         * In other cases using saferead reduces number of syscalls.\n         */\n        if (fdin == fd && direct) {\n            if ((got = read(fdin, buf, buflen)) < 0 &&\n                errno == EINTR)\n                continue;\n        } else {\n            got = saferead(fdin, buf, buflen);\n        }\n\n        if (got < 0) {\n            virReportSystemError(errno, _(\"Unable to read %s\"), fdinname);\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n\n        total += got;\n\n        /* handle last write size align in direct case */\n        if (got < buflen && direct && fdout == fd) {\n            ssize_t aligned_got = (got + alignMask) & ~alignMask;\n\n            memset(buf + got, 0, aligned_got - got);\n\n            if (safewrite(fdout, buf, aligned_got) < 0) {\n                virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            if (ftruncate(fd, total) < 0) {\n                virReportSystemError(errno, _(\"Unable to truncate %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            break;\n        }\n\n        if (safewrite(fdout, buf, got) < 0) {\n            virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    /* Ensure all data is written */\n    if (virFileDataSync(fdout) < 0) {\n        if (errno != EINVAL && errno != EROFS) {\n            /* fdatasync() may fail on some special FDs, e.g. pipes */\n            virReportSystemError(errno, _(\"unable to fsync %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0 &&\n        ret == 0) {\n        virReportSystemError(errno, _(\"Unable to close %s\"), path);\n        ret = -1;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to close %s\")",
            "path"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to close %s\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to fsync %s\")",
            "fdoutname"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileDataSync",
          "args": [
            "fdout"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virFileDataSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4498-4506",
          "snippet": "int\nvirFileDataSync(int fd)\n{\n#if defined(__APPLE__) || defined(WIN32)\n    return g_fsync(fd);\n#else\n    return fdatasync(fd);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileDataSync(int fd)\n{\n#if defined(__APPLE__) || defined(WIN32)\n    return g_fsync(fd);\n#else\n    return fdatasync(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to write %s\")",
            "fdoutname"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fdout",
            "buf",
            "got"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to truncate %s\")",
            "fdoutname"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "total"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to write %s\")",
            "fdoutname"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf + got",
            "0",
            "aligned_got - got"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to read %s\")",
            "fdinname"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fdin",
            "buf",
            "buflen"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fdin",
            "buf",
            "buflen"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"Unable to process file with flags %d\")",
            "(oflags & O_ACCMODE)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "end < 0 ? errno : EINVAL",
            "\"%s\"",
            "_(\"O_DIRECT write needs empty seekable file\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_END"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "end < 0 ? errno : EINVAL",
            "\"%s\"",
            "_(\"O_DIRECT read needs entire seekable file\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_CUR"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buf",
            "buflen + alignMask"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_memalign",
          "args": [
            "&base",
            "alignMask + 1",
            "buflen"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nrunIO(const char *path, int fd, int oflags)\n{\n    g_autofree void *base = NULL; /* Location to be freed */\n    char *buf = NULL; /* Aligned location within base */\n    size_t buflen = 1024*1024;\n    intptr_t alignMask = 64*1024 - 1;\n    int ret = -1;\n    int fdin, fdout;\n    const char *fdinname, *fdoutname;\n    unsigned long long total = 0;\n    bool direct = O_DIRECT && ((oflags & O_DIRECT) != 0);\n    off_t end = 0;\n\n#if HAVE_POSIX_MEMALIGN\n    if (posix_memalign(&base, alignMask + 1, buflen)) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    buf = base;\n#else\n    if (VIR_ALLOC_N(buf, buflen + alignMask) < 0)\n        goto cleanup;\n    base = buf;\n    buf = (char *) (((intptr_t) base + alignMask) & ~alignMask);\n#endif\n\n    switch (oflags & O_ACCMODE) {\n    case O_RDONLY:\n        fdin = fd;\n        fdinname = path;\n        fdout = STDOUT_FILENO;\n        fdoutname = \"stdout\";\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && ((end = lseek(fd, 0, SEEK_CUR)) != 0)) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT read needs entire seekable file\"));\n            goto cleanup;\n        }\n        break;\n    case O_WRONLY:\n        fdin = STDIN_FILENO;\n        fdinname = \"stdin\";\n        fdout = fd;\n        fdoutname = path;\n        /* To make the implementation simpler, we give up on any\n         * attempt to use O_DIRECT in a non-trivial manner.  */\n        if (direct && (end = lseek(fd, 0, SEEK_END)) != 0) {\n            virReportSystemError(end < 0 ? errno : EINVAL, \"%s\",\n                                 _(\"O_DIRECT write needs empty seekable file\"));\n            goto cleanup;\n        }\n        break;\n\n    case O_RDWR:\n    default:\n        virReportSystemError(EINVAL,\n                             _(\"Unable to process file with flags %d\"),\n                             (oflags & O_ACCMODE));\n        goto cleanup;\n    }\n\n    while (1) {\n        ssize_t got;\n\n        /* If we read with O_DIRECT from file we can't use saferead as\n         * it can lead to unaligned read after reading last bytes.\n         * If we write with O_DIRECT use should use saferead so that\n         * writes will be aligned.\n         * In other cases using saferead reduces number of syscalls.\n         */\n        if (fdin == fd && direct) {\n            if ((got = read(fdin, buf, buflen)) < 0 &&\n                errno == EINTR)\n                continue;\n        } else {\n            got = saferead(fdin, buf, buflen);\n        }\n\n        if (got < 0) {\n            virReportSystemError(errno, _(\"Unable to read %s\"), fdinname);\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n\n        total += got;\n\n        /* handle last write size align in direct case */\n        if (got < buflen && direct && fdout == fd) {\n            ssize_t aligned_got = (got + alignMask) & ~alignMask;\n\n            memset(buf + got, 0, aligned_got - got);\n\n            if (safewrite(fdout, buf, aligned_got) < 0) {\n                virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            if (ftruncate(fd, total) < 0) {\n                virReportSystemError(errno, _(\"Unable to truncate %s\"), fdoutname);\n                goto cleanup;\n            }\n\n            break;\n        }\n\n        if (safewrite(fdout, buf, got) < 0) {\n            virReportSystemError(errno, _(\"Unable to write %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    /* Ensure all data is written */\n    if (virFileDataSync(fdout) < 0) {\n        if (errno != EINVAL && errno != EROFS) {\n            /* fdatasync() may fail on some special FDs, e.g. pipes */\n            virReportSystemError(errno, _(\"unable to fsync %s\"), fdoutname);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0 &&\n        ret == 0) {\n        virReportSystemError(errno, _(\"Unable to close %s\"), path);\n        ret = -1;\n    }\n    return ret;\n}"
  }
]