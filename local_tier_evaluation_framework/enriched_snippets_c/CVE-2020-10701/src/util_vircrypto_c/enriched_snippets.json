[
  {
    "function_name": "virCryptoEncryptData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
    "lines": "234-279",
    "snippet": "int\nvirCryptoEncryptData(virCryptoCipher algorithm,\n                     uint8_t *enckey,\n                     size_t enckeylen,\n                     uint8_t *iv,\n                     size_t ivlen,\n                     uint8_t *data,\n                     size_t datalen,\n                     uint8_t **ciphertext,\n                     size_t *ciphertextlen)\n{\n    switch (algorithm) {\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        if (enckeylen != 32) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"AES256CBC encryption invalid keylen=%zu\"),\n                           enckeylen);\n            return -1;\n        }\n\n        if (ivlen != 16) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"AES256CBC initialization vector invalid len=%zu\"),\n                           ivlen);\n            return -1;\n        }\n\n        /*\n         * Encrypt the data buffer using an encryption key and\n         * initialization vector via the gnutls_cipher_encrypt API\n         * for GNUTLS_CIPHER_AES_256_CBC.\n         */\n        return virCryptoEncryptDataAESgnutls(GNUTLS_CIPHER_AES_256_CBC,\n                                             enckey, enckeylen, iv, ivlen,\n                                             data, datalen,\n                                             ciphertext, ciphertextlen);\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"algorithm=%d is not supported\"), algorithm);\n    return -1;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"virrandom.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"algorithm=%d is not supported\")",
            "algorithm"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"algorithm=%d is not supported\""
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoEncryptDataAESgnutls",
          "args": [
            "GNUTLS_CIPHER_AES_256_CBC",
            "enckey",
            "enckeylen",
            "iv",
            "ivlen",
            "data",
            "datalen",
            "ciphertext",
            "ciphertextlen"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoEncryptDataAESgnutls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "143-215",
          "snippet": "static int\nvirCryptoEncryptDataAESgnutls(gnutls_cipher_algorithm_t gnutls_enc_alg,\n                              uint8_t *enckey,\n                              size_t enckeylen,\n                              uint8_t *iv,\n                              size_t ivlen,\n                              uint8_t *data,\n                              size_t datalen,\n                              uint8_t **ciphertextret,\n                              size_t *ciphertextlenret)\n{\n    int rc;\n    size_t i;\n    gnutls_cipher_hd_t handle = NULL;\n    gnutls_datum_t enc_key;\n    gnutls_datum_t iv_buf;\n    uint8_t *ciphertext;\n    size_t ciphertextlen;\n\n    /* Allocate a padded buffer, copy in the data.\n     *\n     * NB, we must *always* have at least 1 byte of\n     * padding - we can't skip it on multiples of\n     * 16, otherwise decoder can't distinguish padded\n     * data from non-padded data. Hence datalen + 1\n     */\n    ciphertextlen = VIR_ROUND_UP(datalen + 1, 16);\n    if (VIR_ALLOC_N(ciphertext, ciphertextlen) < 0)\n        return -1;\n    memcpy(ciphertext, data, datalen);\n\n     /* Fill in the padding of the buffer with the size of the padding\n      * which is required for decryption. */\n    for (i = datalen; i < ciphertextlen; i++)\n        ciphertext[i] = ciphertextlen - datalen;\n\n    /* Initialize the gnutls cipher */\n    enc_key.size = enckeylen;\n    enc_key.data = enckey;\n    if (iv) {\n        iv_buf.size = ivlen;\n        iv_buf.data = iv;\n    }\n    if ((rc = gnutls_cipher_init(&handle, gnutls_enc_alg,\n                                 &enc_key, &iv_buf)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to initialize cipher: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    /* Encrypt the data and free the memory for cipher operations */\n    rc = gnutls_cipher_encrypt(handle, ciphertext, ciphertextlen);\n    gnutls_cipher_deinit(handle);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encrypt the data: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    *ciphertextret = ciphertext;\n    *ciphertextlenret = ciphertextlen;\n    return 0;\n\n error:\n    VIR_DISPOSE_N(ciphertext, ciphertextlen);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    return -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstatic int\nvirCryptoEncryptDataAESgnutls(gnutls_cipher_algorithm_t gnutls_enc_alg,\n                              uint8_t *enckey,\n                              size_t enckeylen,\n                              uint8_t *iv,\n                              size_t ivlen,\n                              uint8_t *data,\n                              size_t datalen,\n                              uint8_t **ciphertextret,\n                              size_t *ciphertextlenret)\n{\n    int rc;\n    size_t i;\n    gnutls_cipher_hd_t handle = NULL;\n    gnutls_datum_t enc_key;\n    gnutls_datum_t iv_buf;\n    uint8_t *ciphertext;\n    size_t ciphertextlen;\n\n    /* Allocate a padded buffer, copy in the data.\n     *\n     * NB, we must *always* have at least 1 byte of\n     * padding - we can't skip it on multiples of\n     * 16, otherwise decoder can't distinguish padded\n     * data from non-padded data. Hence datalen + 1\n     */\n    ciphertextlen = VIR_ROUND_UP(datalen + 1, 16);\n    if (VIR_ALLOC_N(ciphertext, ciphertextlen) < 0)\n        return -1;\n    memcpy(ciphertext, data, datalen);\n\n     /* Fill in the padding of the buffer with the size of the padding\n      * which is required for decryption. */\n    for (i = datalen; i < ciphertextlen; i++)\n        ciphertext[i] = ciphertextlen - datalen;\n\n    /* Initialize the gnutls cipher */\n    enc_key.size = enckeylen;\n    enc_key.data = enckey;\n    if (iv) {\n        iv_buf.size = ivlen;\n        iv_buf.data = iv;\n    }\n    if ((rc = gnutls_cipher_init(&handle, gnutls_enc_alg,\n                                 &enc_key, &iv_buf)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to initialize cipher: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    /* Encrypt the data and free the memory for cipher operations */\n    rc = gnutls_cipher_encrypt(handle, ciphertext, ciphertextlen);\n    gnutls_cipher_deinit(handle);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encrypt the data: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    *ciphertextret = ciphertext;\n    *ciphertextlenret = ciphertextlen;\n    return 0;\n\n error:\n    VIR_DISPOSE_N(ciphertext, ciphertextlen);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"AES256CBC initialization vector invalid len=%zu\")",
            "ivlen"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"AES256CBC encryption invalid keylen=%zu\")",
            "enckeylen"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nint\nvirCryptoEncryptData(virCryptoCipher algorithm,\n                     uint8_t *enckey,\n                     size_t enckeylen,\n                     uint8_t *iv,\n                     size_t ivlen,\n                     uint8_t *data,\n                     size_t datalen,\n                     uint8_t **ciphertext,\n                     size_t *ciphertextlen)\n{\n    switch (algorithm) {\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        if (enckeylen != 32) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"AES256CBC encryption invalid keylen=%zu\"),\n                           enckeylen);\n            return -1;\n        }\n\n        if (ivlen != 16) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"AES256CBC initialization vector invalid len=%zu\"),\n                           ivlen);\n            return -1;\n        }\n\n        /*\n         * Encrypt the data buffer using an encryption key and\n         * initialization vector via the gnutls_cipher_encrypt API\n         * for GNUTLS_CIPHER_AES_256_CBC.\n         */\n        return virCryptoEncryptDataAESgnutls(GNUTLS_CIPHER_AES_256_CBC,\n                                             enckey, enckeylen, iv, ivlen,\n                                             data, datalen,\n                                             ciphertext, ciphertextlen);\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"algorithm=%d is not supported\"), algorithm);\n    return -1;\n}"
  },
  {
    "function_name": "virCryptoEncryptDataAESgnutls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
    "lines": "143-215",
    "snippet": "static int\nvirCryptoEncryptDataAESgnutls(gnutls_cipher_algorithm_t gnutls_enc_alg,\n                              uint8_t *enckey,\n                              size_t enckeylen,\n                              uint8_t *iv,\n                              size_t ivlen,\n                              uint8_t *data,\n                              size_t datalen,\n                              uint8_t **ciphertextret,\n                              size_t *ciphertextlenret)\n{\n    int rc;\n    size_t i;\n    gnutls_cipher_hd_t handle = NULL;\n    gnutls_datum_t enc_key;\n    gnutls_datum_t iv_buf;\n    uint8_t *ciphertext;\n    size_t ciphertextlen;\n\n    /* Allocate a padded buffer, copy in the data.\n     *\n     * NB, we must *always* have at least 1 byte of\n     * padding - we can't skip it on multiples of\n     * 16, otherwise decoder can't distinguish padded\n     * data from non-padded data. Hence datalen + 1\n     */\n    ciphertextlen = VIR_ROUND_UP(datalen + 1, 16);\n    if (VIR_ALLOC_N(ciphertext, ciphertextlen) < 0)\n        return -1;\n    memcpy(ciphertext, data, datalen);\n\n     /* Fill in the padding of the buffer with the size of the padding\n      * which is required for decryption. */\n    for (i = datalen; i < ciphertextlen; i++)\n        ciphertext[i] = ciphertextlen - datalen;\n\n    /* Initialize the gnutls cipher */\n    enc_key.size = enckeylen;\n    enc_key.data = enckey;\n    if (iv) {\n        iv_buf.size = ivlen;\n        iv_buf.data = iv;\n    }\n    if ((rc = gnutls_cipher_init(&handle, gnutls_enc_alg,\n                                 &enc_key, &iv_buf)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to initialize cipher: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    /* Encrypt the data and free the memory for cipher operations */\n    rc = gnutls_cipher_encrypt(handle, ciphertext, ciphertextlen);\n    gnutls_cipher_deinit(handle);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encrypt the data: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    *ciphertextret = ciphertext;\n    *ciphertextlenret = ciphertextlen;\n    return 0;\n\n error:\n    VIR_DISPOSE_N(ciphertext, ciphertextlen);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    return -1;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"virrandom.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iv_buf",
            "0",
            "sizeof(gnutls_datum_t)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&enc_key",
            "0",
            "sizeof(gnutls_datum_t)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "ciphertext",
            "ciphertextlen"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to encrypt the data: '%s'\")",
            "gnutls_strerror(rc)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "rc"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to encrypt the data: '%s'\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iv_buf",
            "0",
            "sizeof(gnutls_datum_t)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&enc_key",
            "0",
            "sizeof(gnutls_datum_t)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_cipher_deinit",
          "args": [
            "handle"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_cipher_encrypt",
          "args": [
            "handle",
            "ciphertext",
            "ciphertextlen"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to initialize cipher: '%s'\")",
            "gnutls_strerror(rc)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "rc"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_cipher_init",
          "args": [
            "&handle",
            "gnutls_enc_alg",
            "&enc_key",
            "&iv_buf"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ciphertext",
            "data",
            "datalen"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ciphertext",
            "ciphertextlen"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ROUND_UP",
          "args": [
            "datalen + 1",
            "16"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstatic int\nvirCryptoEncryptDataAESgnutls(gnutls_cipher_algorithm_t gnutls_enc_alg,\n                              uint8_t *enckey,\n                              size_t enckeylen,\n                              uint8_t *iv,\n                              size_t ivlen,\n                              uint8_t *data,\n                              size_t datalen,\n                              uint8_t **ciphertextret,\n                              size_t *ciphertextlenret)\n{\n    int rc;\n    size_t i;\n    gnutls_cipher_hd_t handle = NULL;\n    gnutls_datum_t enc_key;\n    gnutls_datum_t iv_buf;\n    uint8_t *ciphertext;\n    size_t ciphertextlen;\n\n    /* Allocate a padded buffer, copy in the data.\n     *\n     * NB, we must *always* have at least 1 byte of\n     * padding - we can't skip it on multiples of\n     * 16, otherwise decoder can't distinguish padded\n     * data from non-padded data. Hence datalen + 1\n     */\n    ciphertextlen = VIR_ROUND_UP(datalen + 1, 16);\n    if (VIR_ALLOC_N(ciphertext, ciphertextlen) < 0)\n        return -1;\n    memcpy(ciphertext, data, datalen);\n\n     /* Fill in the padding of the buffer with the size of the padding\n      * which is required for decryption. */\n    for (i = datalen; i < ciphertextlen; i++)\n        ciphertext[i] = ciphertextlen - datalen;\n\n    /* Initialize the gnutls cipher */\n    enc_key.size = enckeylen;\n    enc_key.data = enckey;\n    if (iv) {\n        iv_buf.size = ivlen;\n        iv_buf.data = iv;\n    }\n    if ((rc = gnutls_cipher_init(&handle, gnutls_enc_alg,\n                                 &enc_key, &iv_buf)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to initialize cipher: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    /* Encrypt the data and free the memory for cipher operations */\n    rc = gnutls_cipher_encrypt(handle, ciphertext, ciphertextlen);\n    gnutls_cipher_deinit(handle);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encrypt the data: '%s'\"),\n                       gnutls_strerror(rc));\n        goto error;\n    }\n\n    *ciphertextret = ciphertext;\n    *ciphertextlenret = ciphertextlen;\n    return 0;\n\n error:\n    VIR_DISPOSE_N(ciphertext, ciphertextlen);\n    memset(&enc_key, 0, sizeof(gnutls_datum_t));\n    memset(&iv_buf, 0, sizeof(gnutls_datum_t));\n    return -1;\n}"
  },
  {
    "function_name": "virCryptoHaveCipher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
    "lines": "113-127",
    "snippet": "bool\nvirCryptoHaveCipher(virCryptoCipher algorithm)\n{\n    switch (algorithm) {\n\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        return true;\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    };\n\n    return false;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"virrandom.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nbool\nvirCryptoHaveCipher(virCryptoCipher algorithm)\n{\n    switch (algorithm) {\n\n    case VIR_CRYPTO_CIPHER_AES256CBC:\n        return true;\n\n    case VIR_CRYPTO_CIPHER_NONE:\n    case VIR_CRYPTO_CIPHER_LAST:\n        break;\n    };\n\n    return false;\n}"
  },
  {
    "function_name": "virCryptoHashString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
    "lines": "76-100",
    "snippet": "int\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"virrandom.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256"
    ],
    "globals_used": [
      "static const char hex[] = \"0123456789abcdef\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*output",
            "hashstrlen"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "hash",
            "input",
            "buf"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\n#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256\n\nstatic const char hex[] = \"0123456789abcdef\";\n\nint\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCryptoHashBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
    "lines": "52-73",
    "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"virrandom.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to compute hash of data: %s\")",
            "gnutls_strerror(rc)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "rc"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to compute hash of data: %s\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_hash_fast",
          "args": [
            "hashinfo[hash].algorithm",
            "input",
            "strlen(input)",
            "output"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "input"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Unknown crypto hash %d\")",
            "hash"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
  }
]