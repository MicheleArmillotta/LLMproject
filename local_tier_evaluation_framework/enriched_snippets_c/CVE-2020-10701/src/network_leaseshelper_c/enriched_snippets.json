[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/leaseshelper.c",
    "lines": "82-256",
    "snippet": "int\nmain(int argc, char **argv)\n{\n    char *pid_file = NULL;\n    char *custom_lease_file = NULL;\n    const char *ip = NULL;\n    const char *mac = NULL;\n    const char *leases_str = NULL;\n    const char *iaid = getenv(\"DNSMASQ_IAID\");\n    const char *clientid = getenv(\"DNSMASQ_CLIENT_ID\");\n    const char *interface = getenv(\"DNSMASQ_INTERFACE\");\n    const char *hostname = getenv(\"DNSMASQ_SUPPLIED_HOSTNAME\");\n    char *server_duid = NULL;\n    int action = -1;\n    int pid_file_fd = -1;\n    int rv = EXIT_FAILURE;\n    bool delete = false;\n    virJSONValuePtr lease_new = NULL;\n    virJSONValuePtr leases_array_new = NULL;\n\n    virSetErrorFunc(NULL, NULL);\n    virSetErrorLogPriorityFunc(NULL);\n\n    program_name = argv[0];\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), program_name);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Doesn't hurt to check */\n    if (argc > 1) {\n        if (STREQ(argv[1], \"--help\"))\n            usage(EXIT_SUCCESS);\n\n        if (STREQ(argv[1], \"--version\")) {\n            helperVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (argc != 4 && argc != 5 && argc != 2) {\n        /* Refer man page of dnsmasq --dhcp-script for more details */\n        usage(EXIT_FAILURE);\n    }\n\n    /* Make sure dnsmasq knows the interface. The interface name is not known\n     * via env variable set by dnsmasq when dnsmasq (re)starts and throws 'del'\n     * events for expired leases. So, libvirtd sets another env var for this\n     * purpose */\n    if (!interface &&\n        !(interface = getenv(\"VIR_BRIDGE_NAME\")))\n        goto cleanup;\n\n    ip = argv[3];\n    mac = argv[2];\n\n    if ((action = virLeaseActionTypeFromString(argv[1])) < 0) {\n        fprintf(stderr, _(\"Unsupported action: %s\\n\"), argv[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    /* In case hostname is known, it is the 5th argument */\n    if (argc == 5)\n        hostname = argv[4];\n\n    /* Check if it is an IPv6 lease */\n    if (iaid) {\n        mac = getenv(\"DNSMASQ_MAC\");\n        clientid = argv[2];\n    }\n\n    server_duid = g_strdup(getenv(\"DNSMASQ_SERVER_DUID\"));\n\n    custom_lease_file = g_strdup_printf(LOCALSTATEDIR \"/lib/libvirt/dnsmasq/%s.status\",\n                                        interface);\n\n    pid_file = g_strdup(RUNSTATEDIR \"/leaseshelper.pid\");\n\n    /* Try to claim the pidfile, exiting if we can't */\n    if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    /* Since interfaces can be hot plugged, we need to make sure that the\n     * corresponding custom lease file exists. If not, 'touch' it */\n    if (virFileTouch(custom_lease_file, 0644) < 0)\n        goto cleanup;\n\n    switch ((enum virLeaseActionFlags) action) {\n    case VIR_LEASE_ACTION_ADD:\n    case VIR_LEASE_ACTION_OLD:\n        /* Create new lease */\n        if (virLeaseNew(&lease_new, mac, clientid, ip, hostname, iaid, server_duid) < 0)\n            goto cleanup;\n        /* Custom ipv6 leases *will not* be created if the env-var DNSMASQ_MAC\n         * is not set. In the special case, when the $(interface).status file\n         * is not already present and dnsmasq is (re)started, the corresponding\n         * ipv6 custom lease will be created only when the guest sends the\n         * 'old' action for its existing ipv6 interfaces.\n         *\n         * According to rfc3315, the combination of DUID and IAID can be used\n         * to uniquely identify each ipv6 guest interface. So, in future, if\n         * we introduce virNetworkGetDHCPLeaseBy(IAID|DUID|IAID+DUID) for ipv6\n         * interfaces, then, the following if condition won't be required, as\n         * the new lease will be created irrespective of whether the MACID is\n         * known or not.\n         */\n        if (!lease_new)\n            break;\n\n        G_GNUC_FALLTHROUGH;\n    case VIR_LEASE_ACTION_DEL:\n        /* Delete the corresponding lease, if it already exists */\n        delete = true;\n        break;\n\n    case VIR_LEASE_ACTION_INIT:\n    case VIR_LEASE_ACTION_LAST:\n        break;\n    }\n\n    leases_array_new = virJSONValueNewArray();\n\n    if (virLeaseReadCustomLeaseFile(leases_array_new, custom_lease_file,\n                                    delete ? ip : NULL, &server_duid) < 0)\n        goto cleanup;\n\n    switch ((enum virLeaseActionFlags) action) {\n    case VIR_LEASE_ACTION_INIT:\n        if (virLeasePrintLeases(leases_array_new, server_duid) < 0)\n            goto cleanup;\n\n        break;\n\n    case VIR_LEASE_ACTION_OLD:\n    case VIR_LEASE_ACTION_ADD:\n        if (lease_new && virJSONValueArrayAppend(leases_array_new, lease_new) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to create json\"));\n            goto cleanup;\n        }\n        lease_new = NULL;\n\n        G_GNUC_FALLTHROUGH;\n    case VIR_LEASE_ACTION_DEL:\n        if (!(leases_str = virJSONValueToString(leases_array_new, true))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"empty json array\"));\n            goto cleanup;\n        }\n\n        /* Write to file */\n        if (virFileRewriteStr(custom_lease_file, 0644, leases_str) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_LEASE_ACTION_LAST:\n        break;\n    }\n\n    rv = EXIT_SUCCESS;\n\n cleanup:\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n\n    VIR_FREE(pid_file);\n    VIR_FREE(server_duid);\n    VIR_FREE(custom_lease_file);\n    virJSONValueFree(lease_new);\n    virJSONValueFree(leases_array_new);\n\n    return rv;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virgettext.h\"",
      "#include \"configmake.h\"",
      "#include \"virenum.h\"",
      "#include \"virlease.h\"",
      "#include \"virjson.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *program_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "leases_array_new"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "custom_lease_file"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "server_duid"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pid_file"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReleasePath",
          "args": [
            "pid_file",
            "pid_file_fd"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReleasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "430-450",
          "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileRewriteStr",
          "args": [
            "custom_lease_file",
            "0644",
            "leases_str"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRewriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "581-588",
          "snippet": "int\nvirFileRewriteStr(const char *path,\n                  mode_t mode,\n                  const char *str)\n{\n    return virFileRewrite(path, mode,\n                          virFileRewriteStrHelper, str);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRewriteStr(const char *path,\n                  mode_t mode,\n                  const char *str)\n{\n    return virFileRewrite(path, mode,\n                          virFileRewriteStrHelper, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"empty json array\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"empty json array\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueToString",
          "args": [
            "leases_array_new",
            "true"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "2014-2024",
          "snippet": "char *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nchar *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to create json\")"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppend",
          "args": [
            "leases_array_new",
            "lease_new"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLeasePrintLeases",
          "args": [
            "leases_array_new",
            "server_duid"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "virLeasePrintLeases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlease.c",
          "lines": "134-199",
          "snippet": "int\nvirLeasePrintLeases(virJSONValuePtr leases_array_new,\n                    const char *server_duid)\n{\n    virJSONValuePtr lease_tmp = NULL;\n    const char *ip_tmp = NULL;\n    long long expirytime = 0;\n    size_t i;\n\n    /* Man page of dnsmasq says: the script (helper program, in our case)\n     * should write the saved state of the lease database, in dnsmasq\n     * leasefile format, to stdout and exit with zero exit code, when\n     * called with argument init. Format:\n     * $expirytime $mac $ip $hostname $clientid # For all ipv4 leases\n     * duid $server-duid # If DHCPv6 is present\n     * $expirytime $iaid $ip $hostname $clientduid # For all ipv6 leases */\n\n    /* Traversing the ipv4 leases */\n    for (i = 0; i < virJSONValueArraySize(leases_array_new); i++) {\n        lease_tmp = virJSONValueArrayGet(leases_array_new, i);\n        if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n        if (!strchr(ip_tmp, ':')) {\n            if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\",\n                                                &expirytime) < 0)\n                continue;\n\n            printf(\"%lld %s %s %s %s\\n\",\n                   expirytime,\n                   virJSONValueObjectGetString(lease_tmp, \"mac-address\"),\n                   virJSONValueObjectGetString(lease_tmp, \"ip-address\"),\n                   NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"hostname\")),\n                   NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"client-id\")));\n        }\n    }\n\n    /* Traversing the ipv6 leases */\n    if (server_duid) {\n        printf(\"duid %s\\n\", server_duid);\n        for (i = 0; i < virJSONValueArraySize(leases_array_new); i++) {\n            lease_tmp = virJSONValueArrayGet(leases_array_new, i);\n            if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"failed to parse json\"));\n                return -1;\n            }\n            if (strchr(ip_tmp, ':')) {\n                if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\",\n                                                    &expirytime) < 0)\n                    continue;\n\n                printf(\"%lld %s %s %s %s\\n\",\n                       expirytime,\n                       virJSONValueObjectGetString(lease_tmp, \"iaid\"),\n                       virJSONValueObjectGetString(lease_tmp, \"ip-address\"),\n                       NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"hostname\")),\n                       NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"client-id\")));\n            }\n        }\n    }\n\n    return  0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include <time.h>",
            "#include \"virlease.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <time.h>\n#include \"virlease.h\"\n#include <config.h>\n\nint\nvirLeasePrintLeases(virJSONValuePtr leases_array_new,\n                    const char *server_duid)\n{\n    virJSONValuePtr lease_tmp = NULL;\n    const char *ip_tmp = NULL;\n    long long expirytime = 0;\n    size_t i;\n\n    /* Man page of dnsmasq says: the script (helper program, in our case)\n     * should write the saved state of the lease database, in dnsmasq\n     * leasefile format, to stdout and exit with zero exit code, when\n     * called with argument init. Format:\n     * $expirytime $mac $ip $hostname $clientid # For all ipv4 leases\n     * duid $server-duid # If DHCPv6 is present\n     * $expirytime $iaid $ip $hostname $clientduid # For all ipv6 leases */\n\n    /* Traversing the ipv4 leases */\n    for (i = 0; i < virJSONValueArraySize(leases_array_new); i++) {\n        lease_tmp = virJSONValueArrayGet(leases_array_new, i);\n        if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n        if (!strchr(ip_tmp, ':')) {\n            if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\",\n                                                &expirytime) < 0)\n                continue;\n\n            printf(\"%lld %s %s %s %s\\n\",\n                   expirytime,\n                   virJSONValueObjectGetString(lease_tmp, \"mac-address\"),\n                   virJSONValueObjectGetString(lease_tmp, \"ip-address\"),\n                   NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"hostname\")),\n                   NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"client-id\")));\n        }\n    }\n\n    /* Traversing the ipv6 leases */\n    if (server_duid) {\n        printf(\"duid %s\\n\", server_duid);\n        for (i = 0; i < virJSONValueArraySize(leases_array_new); i++) {\n            lease_tmp = virJSONValueArrayGet(leases_array_new, i);\n            if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"failed to parse json\"));\n                return -1;\n            }\n            if (strchr(ip_tmp, ':')) {\n                if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\",\n                                                    &expirytime) < 0)\n                    continue;\n\n                printf(\"%lld %s %s %s %s\\n\",\n                       expirytime,\n                       virJSONValueObjectGetString(lease_tmp, \"iaid\"),\n                       virJSONValueObjectGetString(lease_tmp, \"ip-address\"),\n                       NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"hostname\")),\n                       NULLSTR_STAR(virJSONValueObjectGetString(lease_tmp, \"client-id\")));\n            }\n        }\n    }\n\n    return  0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLeaseReadCustomLeaseFile",
          "args": [
            "leases_array_new",
            "custom_lease_file",
            "delete ? ip : NULL",
            "&server_duid"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virLeaseReadCustomLeaseFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlease.c",
          "lines": "45-131",
          "snippet": "int\nvirLeaseReadCustomLeaseFile(virJSONValuePtr leases_array_new,\n                            const char *custom_lease_file,\n                            const char *ip_to_delete,\n                            char **server_duid)\n{\n    g_autofree char *lease_entries = NULL;\n    g_autoptr(virJSONValue) leases_array = NULL;\n    long long expirytime;\n    int custom_lease_file_len = 0;\n    virJSONValuePtr lease_tmp = NULL;\n    const char *ip_tmp = NULL;\n    const char *server_duid_tmp = NULL;\n    size_t i;\n\n    /* Read entire contents */\n    if ((custom_lease_file_len = virFileReadAll(custom_lease_file,\n                                                VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX,\n                                                &lease_entries)) < 0) {\n        return -1;\n    }\n\n    /* Check for previous leases */\n    if (custom_lease_file_len == 0)\n        return 0;\n\n    if (!(leases_array = virJSONValueFromString(lease_entries))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid json in file: %s, rewriting it\"),\n                       custom_lease_file);\n        return 0;\n    }\n\n    if (!virJSONValueIsArray(leases_array)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"couldn't fetch array of leases\"));\n        return -1;\n    }\n\n    i = 0;\n    while (i < virJSONValueArraySize(leases_array)) {\n        if (!(lease_tmp = virJSONValueArrayGet(leases_array, i))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n\n        if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\")) ||\n            (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\", &expirytime) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n\n        /* Check whether lease has to be included or not */\n        if (ip_to_delete && STREQ(ip_tmp, ip_to_delete)) {\n            i++;\n            continue;\n        }\n\n        if (server_duid && strchr(ip_tmp, ':')) {\n            /* This is an ipv6 lease */\n            if ((server_duid_tmp\n                 = virJSONValueObjectGetString(lease_tmp, \"server-duid\"))) {\n                if (!*server_duid)\n                    *server_duid = g_strdup(server_duid_tmp);\n            } else {\n                /* Inject server-duid into those ipv6 leases which\n                 * didn't have it previously, for example, those\n                 * created by leaseshelper from libvirt 1.2.6 */\n                if (virJSONValueObjectAppendString(lease_tmp, \"server-duid\", *server_duid) < 0)\n                    return -1;\n            }\n        }\n\n        /* Move old lease to new array */\n        if (virJSONValueArrayAppend(leases_array_new, lease_tmp) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to create json\"));\n            return -1;\n        }\n\n        ignore_value(virJSONValueArraySteal(leases_array, i));\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include <time.h>",
            "#include \"virlease.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX (32 * 1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <time.h>\n#include \"virlease.h\"\n#include <config.h>\n\n#define VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX (32 * 1024 * 1024)\n\nint\nvirLeaseReadCustomLeaseFile(virJSONValuePtr leases_array_new,\n                            const char *custom_lease_file,\n                            const char *ip_to_delete,\n                            char **server_duid)\n{\n    g_autofree char *lease_entries = NULL;\n    g_autoptr(virJSONValue) leases_array = NULL;\n    long long expirytime;\n    int custom_lease_file_len = 0;\n    virJSONValuePtr lease_tmp = NULL;\n    const char *ip_tmp = NULL;\n    const char *server_duid_tmp = NULL;\n    size_t i;\n\n    /* Read entire contents */\n    if ((custom_lease_file_len = virFileReadAll(custom_lease_file,\n                                                VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX,\n                                                &lease_entries)) < 0) {\n        return -1;\n    }\n\n    /* Check for previous leases */\n    if (custom_lease_file_len == 0)\n        return 0;\n\n    if (!(leases_array = virJSONValueFromString(lease_entries))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid json in file: %s, rewriting it\"),\n                       custom_lease_file);\n        return 0;\n    }\n\n    if (!virJSONValueIsArray(leases_array)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"couldn't fetch array of leases\"));\n        return -1;\n    }\n\n    i = 0;\n    while (i < virJSONValueArraySize(leases_array)) {\n        if (!(lease_tmp = virJSONValueArrayGet(leases_array, i))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n\n        if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\")) ||\n            (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\", &expirytime) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            return -1;\n        }\n\n        /* Check whether lease has to be included or not */\n        if (ip_to_delete && STREQ(ip_tmp, ip_to_delete)) {\n            i++;\n            continue;\n        }\n\n        if (server_duid && strchr(ip_tmp, ':')) {\n            /* This is an ipv6 lease */\n            if ((server_duid_tmp\n                 = virJSONValueObjectGetString(lease_tmp, \"server-duid\"))) {\n                if (!*server_duid)\n                    *server_duid = g_strdup(server_duid_tmp);\n            } else {\n                /* Inject server-duid into those ipv6 leases which\n                 * didn't have it previously, for example, those\n                 * created by leaseshelper from libvirt 1.2.6 */\n                if (virJSONValueObjectAppendString(lease_tmp, \"server-duid\", *server_duid) < 0)\n                    return -1;\n            }\n        }\n\n        /* Move old lease to new array */\n        if (virJSONValueArrayAppend(leases_array_new, lease_tmp) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to create json\"));\n            return -1;\n        }\n\n        ignore_value(virJSONValueArraySteal(leases_array, i));\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLeaseNew",
          "args": [
            "&lease_new",
            "mac",
            "clientid",
            "ip",
            "hostname",
            "iaid",
            "server_duid"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virLeaseNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlease.c",
          "lines": "202-261",
          "snippet": "int\nvirLeaseNew(virJSONValuePtr *lease_ret,\n            const char *mac,\n            const char *clientid,\n            const char *ip,\n            const char *hostname,\n            const char *iaid,\n            const char *server_duid)\n{\n    g_autoptr(virJSONValue) lease_new = NULL;\n    const char *exptime_tmp = getenv(\"DNSMASQ_LEASE_EXPIRES\");\n    long long expirytime = 0;\n    g_autofree char *exptime = NULL;\n\n    /* In case hostname is still unknown, use the last known one */\n    if (!hostname)\n        hostname = getenv(\"DNSMASQ_OLD_HOSTNAME\");\n\n    if (!mac)\n        return 0;\n\n    if (exptime_tmp) {\n        exptime = g_strdup(exptime_tmp);\n\n        /* Removed extraneous trailing space in DNSMASQ_LEASE_EXPIRES\n         * (dnsmasq < 2.52) */\n        if (exptime[strlen(exptime) - 1] == ' ')\n            exptime[strlen(exptime) - 1] = '\\0';\n    }\n\n    if (!exptime ||\n        virStrToLong_ll(exptime, NULL, 10, &expirytime) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to convert lease expiry time to long long: %s\"),\n                       NULLSTR(exptime));\n        return -1;\n    }\n\n    /* Create new lease */\n    lease_new = virJSONValueNewObject();\n\n    if (iaid && virJSONValueObjectAppendString(lease_new, \"iaid\", iaid) < 0)\n        return -1;\n    if (ip && virJSONValueObjectAppendString(lease_new, \"ip-address\", ip) < 0)\n        return -1;\n    if (mac && virJSONValueObjectAppendString(lease_new, \"mac-address\", mac) < 0)\n        return -1;\n    if (hostname && virJSONValueObjectAppendString(lease_new, \"hostname\", hostname) < 0)\n        return -1;\n    if (clientid && virJSONValueObjectAppendString(lease_new, \"client-id\", clientid) < 0)\n        return -1;\n    if (server_duid && virJSONValueObjectAppendString(lease_new, \"server-duid\", server_duid) < 0)\n        return -1;\n    if (expirytime && virJSONValueObjectAppendNumberLong(lease_new, \"expiry-time\", expirytime) < 0)\n        return -1;\n\n    *lease_ret = lease_new;\n    lease_new = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include <time.h>",
            "#include \"virlease.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <time.h>\n#include \"virlease.h\"\n#include <config.h>\n\nint\nvirLeaseNew(virJSONValuePtr *lease_ret,\n            const char *mac,\n            const char *clientid,\n            const char *ip,\n            const char *hostname,\n            const char *iaid,\n            const char *server_duid)\n{\n    g_autoptr(virJSONValue) lease_new = NULL;\n    const char *exptime_tmp = getenv(\"DNSMASQ_LEASE_EXPIRES\");\n    long long expirytime = 0;\n    g_autofree char *exptime = NULL;\n\n    /* In case hostname is still unknown, use the last known one */\n    if (!hostname)\n        hostname = getenv(\"DNSMASQ_OLD_HOSTNAME\");\n\n    if (!mac)\n        return 0;\n\n    if (exptime_tmp) {\n        exptime = g_strdup(exptime_tmp);\n\n        /* Removed extraneous trailing space in DNSMASQ_LEASE_EXPIRES\n         * (dnsmasq < 2.52) */\n        if (exptime[strlen(exptime) - 1] == ' ')\n            exptime[strlen(exptime) - 1] = '\\0';\n    }\n\n    if (!exptime ||\n        virStrToLong_ll(exptime, NULL, 10, &expirytime) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to convert lease expiry time to long long: %s\"),\n                       NULLSTR(exptime));\n        return -1;\n    }\n\n    /* Create new lease */\n    lease_new = virJSONValueNewObject();\n\n    if (iaid && virJSONValueObjectAppendString(lease_new, \"iaid\", iaid) < 0)\n        return -1;\n    if (ip && virJSONValueObjectAppendString(lease_new, \"ip-address\", ip) < 0)\n        return -1;\n    if (mac && virJSONValueObjectAppendString(lease_new, \"mac-address\", mac) < 0)\n        return -1;\n    if (hostname && virJSONValueObjectAppendString(lease_new, \"hostname\", hostname) < 0)\n        return -1;\n    if (clientid && virJSONValueObjectAppendString(lease_new, \"client-id\", clientid) < 0)\n        return -1;\n    if (server_duid && virJSONValueObjectAppendString(lease_new, \"server-duid\", server_duid) < 0)\n        return -1;\n    if (expirytime && virJSONValueObjectAppendNumberLong(lease_new, \"expiry-time\", expirytime) < 0)\n        return -1;\n\n    *lease_ret = lease_new;\n    lease_new = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileTouch",
          "args": [
            "custom_lease_file",
            "0644"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virFileTouch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "591-609",
          "snippet": "int virFileTouch(const char *path, mode_t mode)\n{\n    int fd = -1;\n\n    if ((fd = open(path, O_WRONLY | O_CREAT, mode)) < 0) {\n        virReportSystemError(errno, _(\"cannot create file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"cannot save file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileTouch(const char *path, mode_t mode)\n{\n    int fd = -1;\n\n    if ((fd = open(path, O_WRONLY | O_CREAT, mode)) < 0) {\n        virReportSystemError(errno, _(\"cannot create file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno, _(\"cannot save file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "pid_file",
            "false",
            "getpid()"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_SERVER_DUID\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_MAC\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"Unsupported action: %s\\n\")",
            "argv[1]"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLeaseActionTypeFromString",
          "args": [
            "argv[1]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"VIR_BRIDGE_NAME\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/leaseshelper.c",
          "lines": "51-63",
          "snippet": "G_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\\n\"), program_name);\n    } else {\n        printf(_(\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\"),\n               program_name);\n    }\n    exit(status);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virgettext.h\"",
            "#include \"configmake.h\"",
            "#include \"virenum.h\"",
            "#include \"virlease.h\"",
            "#include \"virjson.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *program_name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virgettext.h\"\n#include \"configmake.h\"\n#include \"virenum.h\"\n#include \"virlease.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <config.h>\n\nstatic const char *program_name;\n\nG_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\\n\"), program_name);\n    } else {\n        printf(_(\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\"),\n               program_name);\n    }\n    exit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "helperVersion",
          "args": [
            "argv[0]"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "helperVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/leaseshelper.c",
          "lines": "45-49",
          "snippet": "static void\nhelperVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virgettext.h\"",
            "#include \"configmake.h\"",
            "#include \"virenum.h\"",
            "#include \"virlease.h\"",
            "#include \"virjson.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virgettext.h\"\n#include \"configmake.h\"\n#include \"virenum.h\"\n#include \"virlease.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <config.h>\n\nstatic void\nhelperVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "argv[1]",
            "\"--version\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: initialization failed\\n\")",
            "program_name"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorInitialize",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "172-176",
          "snippet": "int\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal virLastErr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirThreadLocal virLastErr;\n\nint\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetErrorLogPriorityFunc",
          "args": [
            "NULL"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetErrorFunc",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "609-614",
          "snippet": "void\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_SUPPLIED_HOSTNAME\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_INTERFACE\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_CLIENT_ID\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DNSMASQ_IAID\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virgettext.h\"\n#include \"configmake.h\"\n#include \"virenum.h\"\n#include \"virlease.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <config.h>\n\nstatic const char *program_name;\n\nint\nmain(int argc, char **argv)\n{\n    char *pid_file = NULL;\n    char *custom_lease_file = NULL;\n    const char *ip = NULL;\n    const char *mac = NULL;\n    const char *leases_str = NULL;\n    const char *iaid = getenv(\"DNSMASQ_IAID\");\n    const char *clientid = getenv(\"DNSMASQ_CLIENT_ID\");\n    const char *interface = getenv(\"DNSMASQ_INTERFACE\");\n    const char *hostname = getenv(\"DNSMASQ_SUPPLIED_HOSTNAME\");\n    char *server_duid = NULL;\n    int action = -1;\n    int pid_file_fd = -1;\n    int rv = EXIT_FAILURE;\n    bool delete = false;\n    virJSONValuePtr lease_new = NULL;\n    virJSONValuePtr leases_array_new = NULL;\n\n    virSetErrorFunc(NULL, NULL);\n    virSetErrorLogPriorityFunc(NULL);\n\n    program_name = argv[0];\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), program_name);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Doesn't hurt to check */\n    if (argc > 1) {\n        if (STREQ(argv[1], \"--help\"))\n            usage(EXIT_SUCCESS);\n\n        if (STREQ(argv[1], \"--version\")) {\n            helperVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (argc != 4 && argc != 5 && argc != 2) {\n        /* Refer man page of dnsmasq --dhcp-script for more details */\n        usage(EXIT_FAILURE);\n    }\n\n    /* Make sure dnsmasq knows the interface. The interface name is not known\n     * via env variable set by dnsmasq when dnsmasq (re)starts and throws 'del'\n     * events for expired leases. So, libvirtd sets another env var for this\n     * purpose */\n    if (!interface &&\n        !(interface = getenv(\"VIR_BRIDGE_NAME\")))\n        goto cleanup;\n\n    ip = argv[3];\n    mac = argv[2];\n\n    if ((action = virLeaseActionTypeFromString(argv[1])) < 0) {\n        fprintf(stderr, _(\"Unsupported action: %s\\n\"), argv[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    /* In case hostname is known, it is the 5th argument */\n    if (argc == 5)\n        hostname = argv[4];\n\n    /* Check if it is an IPv6 lease */\n    if (iaid) {\n        mac = getenv(\"DNSMASQ_MAC\");\n        clientid = argv[2];\n    }\n\n    server_duid = g_strdup(getenv(\"DNSMASQ_SERVER_DUID\"));\n\n    custom_lease_file = g_strdup_printf(LOCALSTATEDIR \"/lib/libvirt/dnsmasq/%s.status\",\n                                        interface);\n\n    pid_file = g_strdup(RUNSTATEDIR \"/leaseshelper.pid\");\n\n    /* Try to claim the pidfile, exiting if we can't */\n    if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    /* Since interfaces can be hot plugged, we need to make sure that the\n     * corresponding custom lease file exists. If not, 'touch' it */\n    if (virFileTouch(custom_lease_file, 0644) < 0)\n        goto cleanup;\n\n    switch ((enum virLeaseActionFlags) action) {\n    case VIR_LEASE_ACTION_ADD:\n    case VIR_LEASE_ACTION_OLD:\n        /* Create new lease */\n        if (virLeaseNew(&lease_new, mac, clientid, ip, hostname, iaid, server_duid) < 0)\n            goto cleanup;\n        /* Custom ipv6 leases *will not* be created if the env-var DNSMASQ_MAC\n         * is not set. In the special case, when the $(interface).status file\n         * is not already present and dnsmasq is (re)started, the corresponding\n         * ipv6 custom lease will be created only when the guest sends the\n         * 'old' action for its existing ipv6 interfaces.\n         *\n         * According to rfc3315, the combination of DUID and IAID can be used\n         * to uniquely identify each ipv6 guest interface. So, in future, if\n         * we introduce virNetworkGetDHCPLeaseBy(IAID|DUID|IAID+DUID) for ipv6\n         * interfaces, then, the following if condition won't be required, as\n         * the new lease will be created irrespective of whether the MACID is\n         * known or not.\n         */\n        if (!lease_new)\n            break;\n\n        G_GNUC_FALLTHROUGH;\n    case VIR_LEASE_ACTION_DEL:\n        /* Delete the corresponding lease, if it already exists */\n        delete = true;\n        break;\n\n    case VIR_LEASE_ACTION_INIT:\n    case VIR_LEASE_ACTION_LAST:\n        break;\n    }\n\n    leases_array_new = virJSONValueNewArray();\n\n    if (virLeaseReadCustomLeaseFile(leases_array_new, custom_lease_file,\n                                    delete ? ip : NULL, &server_duid) < 0)\n        goto cleanup;\n\n    switch ((enum virLeaseActionFlags) action) {\n    case VIR_LEASE_ACTION_INIT:\n        if (virLeasePrintLeases(leases_array_new, server_duid) < 0)\n            goto cleanup;\n\n        break;\n\n    case VIR_LEASE_ACTION_OLD:\n    case VIR_LEASE_ACTION_ADD:\n        if (lease_new && virJSONValueArrayAppend(leases_array_new, lease_new) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to create json\"));\n            goto cleanup;\n        }\n        lease_new = NULL;\n\n        G_GNUC_FALLTHROUGH;\n    case VIR_LEASE_ACTION_DEL:\n        if (!(leases_str = virJSONValueToString(leases_array_new, true))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"empty json array\"));\n            goto cleanup;\n        }\n\n        /* Write to file */\n        if (virFileRewriteStr(custom_lease_file, 0644, leases_str) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_LEASE_ACTION_LAST:\n        break;\n    }\n\n    rv = EXIT_SUCCESS;\n\n cleanup:\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n\n    VIR_FREE(pid_file);\n    VIR_FREE(server_duid);\n    VIR_FREE(custom_lease_file);\n    virJSONValueFree(lease_new);\n    virJSONValueFree(leases_array_new);\n\n    return rv;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/leaseshelper.c",
    "lines": "51-63",
    "snippet": "G_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\\n\"), program_name);\n    } else {\n        printf(_(\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\"),\n               program_name);\n    }\n    exit(status);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virgettext.h\"",
      "#include \"configmake.h\"",
      "#include \"virenum.h\"",
      "#include \"virlease.h\"",
      "#include \"virjson.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *program_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "status"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "_(\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\")",
            "program_name"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\""
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: try --help for more details\\n\")",
            "program_name"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virgettext.h\"\n#include \"configmake.h\"\n#include \"virenum.h\"\n#include \"virlease.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <config.h>\n\nstatic const char *program_name;\n\nG_GNUC_NORETURN static void\nusage(int status)\n{\n    if (status) {\n        fprintf(stderr, _(\"%s: try --help for more details\\n\"), program_name);\n    } else {\n        printf(_(\"Usage: %s add|old|del|init mac|clientid ip [hostname]\\n\"\n                 \"Designed for use with 'dnsmasq --dhcp-script'\\n\"\n                 \"Refer to man page of dnsmasq for more details'\\n\"),\n               program_name);\n    }\n    exit(status);\n}"
  },
  {
    "function_name": "helperVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/leaseshelper.c",
    "lines": "45-49",
    "snippet": "static void\nhelperVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virgettext.h\"",
      "#include \"configmake.h\"",
      "#include \"virenum.h\"",
      "#include \"virlease.h\"",
      "#include \"virjson.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s (%s) %s\\n\"",
            "argv0",
            "PACKAGE_NAME",
            "PACKAGE_VERSION"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virgettext.h\"\n#include \"configmake.h\"\n#include \"virenum.h\"\n#include \"virlease.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include <config.h>\n\nstatic void\nhelperVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
  }
]