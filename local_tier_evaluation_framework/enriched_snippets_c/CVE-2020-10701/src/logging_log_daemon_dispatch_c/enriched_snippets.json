[
  {
    "function_name": "virLogManagerProtocolDispatchDomainAppendLogFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon_dispatch.c",
    "lines": "146-169",
    "snippet": "static int\nvirLogManagerProtocolDispatchDomainAppendLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                                 virNetServerClientPtr client G_GNUC_UNUSED,\n                                                 virNetMessagePtr msg G_GNUC_UNUSED,\n                                                 virNetMessageErrorPtr rerr,\n                                                 virLogManagerProtocolDomainAppendLogFileArgs *args,\n                                                 virLogManagerProtocolDomainAppendLogFileRet *ret)\n{\n    int rv;\n\n    if ((rv = virLogHandlerDomainAppendLogFile(virLogDaemonGetHandler(logDaemon),\n                                               args->driver,\n                                               (unsigned char *)args->dom.uuid,\n                                               args->dom.name,\n                                               args->path,\n                                               args->message,\n                                               args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    ret->ret = rv;\n    return 0;\n}",
    "includes": [
      "#include \"log_daemon_dispatch_stubs.h\"",
      "#include \"virfile.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogHandlerDomainAppendLogFile",
          "args": [
            "virLogDaemonGetHandler(logDaemon)",
            "args->driver",
            "(unsigned char *)args->dom.uuid",
            "args->dom.name",
            "args->path",
            "args->message",
            "args->flags"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virLogHandlerDomainAppendLogFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_handler.c",
          "lines": "560-607",
          "snippet": "int\nvirLogHandlerDomainAppendLogFile(virLogHandlerPtr handler,\n                                 const char *driver G_GNUC_UNUSED,\n                                 const unsigned char *domuuid G_GNUC_UNUSED,\n                                 const char *domname G_GNUC_UNUSED,\n                                 const char *path,\n                                 const char *message,\n                                 unsigned int flags)\n{\n    size_t i;\n    virRotatingFileWriterPtr writer = NULL;\n    virRotatingFileWriterPtr newwriter = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Appending to log '%s' message: '%s'\", path, message);\n\n    virObjectLock(handler);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file), path)) {\n            writer = handler->files[i]->file;\n            break;\n        }\n    }\n\n    if (!writer) {\n        if (!(newwriter = virRotatingFileWriterNew(path,\n                                                   handler->max_size,\n                                                   handler->max_backups,\n                                                   false,\n                                                   DEFAULT_MODE)))\n            goto cleanup;\n\n        writer = newwriter;\n    }\n\n    if (virRotatingFileWriterAppend(writer, message, strlen(message)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virRotatingFileWriterFree(newwriter);\n    virObjectUnlock(handler);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virutil.h\"",
            "#include \"viruuid.h\"",
            "#include \"virrotatingfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"log_handler.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEFAULT_MODE 0600"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virutil.h\"\n#include \"viruuid.h\"\n#include \"virrotatingfile.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"log_handler.h\"\n#include <config.h>\n\n#define DEFAULT_MODE 0600\n\nint\nvirLogHandlerDomainAppendLogFile(virLogHandlerPtr handler,\n                                 const char *driver G_GNUC_UNUSED,\n                                 const unsigned char *domuuid G_GNUC_UNUSED,\n                                 const char *domname G_GNUC_UNUSED,\n                                 const char *path,\n                                 const char *message,\n                                 unsigned int flags)\n{\n    size_t i;\n    virRotatingFileWriterPtr writer = NULL;\n    virRotatingFileWriterPtr newwriter = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Appending to log '%s' message: '%s'\", path, message);\n\n    virObjectLock(handler);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file), path)) {\n            writer = handler->files[i]->file;\n            break;\n        }\n    }\n\n    if (!writer) {\n        if (!(newwriter = virRotatingFileWriterNew(path,\n                                                   handler->max_size,\n                                                   handler->max_backups,\n                                                   false,\n                                                   DEFAULT_MODE)))\n            goto cleanup;\n\n        writer = newwriter;\n    }\n\n    if (virRotatingFileWriterAppend(writer, message, strlen(message)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virRotatingFileWriterFree(newwriter);\n    virObjectUnlock(handler);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogDaemonGetHandler",
          "args": [
            "logDaemon"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virLogDaemonGetHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon.c",
          "lines": "206-210",
          "snippet": "virLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"log_daemon_config.h\"",
            "#include \"log_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"log_daemon_config.h\"\n#include \"log_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log_daemon_dispatch_stubs.h\"\n#include \"virfile.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetserver.h\"\n#include <config.h>\n\nstatic int\nvirLogManagerProtocolDispatchDomainAppendLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                                 virNetServerClientPtr client G_GNUC_UNUSED,\n                                                 virNetMessagePtr msg G_GNUC_UNUSED,\n                                                 virNetMessageErrorPtr rerr,\n                                                 virLogManagerProtocolDomainAppendLogFileArgs *args,\n                                                 virLogManagerProtocolDomainAppendLogFileRet *ret)\n{\n    int rv;\n\n    if ((rv = virLogHandlerDomainAppendLogFile(virLogDaemonGetHandler(logDaemon),\n                                               args->driver,\n                                               (unsigned char *)args->dom.uuid,\n                                               args->dom.name,\n                                               args->path,\n                                               args->message,\n                                               args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    ret->ret = rv;\n    return 0;\n}"
  },
  {
    "function_name": "virLogManagerProtocolDispatchDomainReadLogFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon_dispatch.c",
    "lines": "108-143",
    "snippet": "static int\nvirLogManagerProtocolDispatchDomainReadLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                               virNetServerClientPtr client G_GNUC_UNUSED,\n                                               virNetMessagePtr msg G_GNUC_UNUSED,\n                                               virNetMessageErrorPtr rerr,\n                                               virLogManagerProtocolDomainReadLogFileArgs *args,\n                                               virLogManagerProtocolDomainReadLogFileRet *ret)\n{\n    int rv = -1;\n    char *data;\n\n    if (args->maxlen > VIR_LOG_MANAGER_PROTOCOL_STRING_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Requested data len %llu is larger than maximum %d\"),\n                       (unsigned long long)args->maxlen,\n                       VIR_LOG_MANAGER_PROTOCOL_STRING_MAX);\n        goto cleanup;\n    }\n\n    if ((data = virLogHandlerDomainReadLogFile(virLogDaemonGetHandler(logDaemon),\n                                               args->path,\n                                               args->pos.inode,\n                                               args->pos.offset,\n                                               args->maxlen,\n                                               args->flags)) == NULL)\n        goto cleanup;\n\n    ret->data = data;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}",
    "includes": [
      "#include \"log_daemon_dispatch_stubs.h\"",
      "#include \"virfile.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogHandlerDomainReadLogFile",
          "args": [
            "virLogDaemonGetHandler(logDaemon)",
            "args->path",
            "args->pos.inode",
            "args->pos.offset",
            "args->maxlen",
            "args->flags"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virLogHandlerDomainReadLogFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_handler.c",
          "lines": "518-557",
          "snippet": "char *\nvirLogHandlerDomainReadLogFile(virLogHandlerPtr handler,\n                               const char *path,\n                               ino_t inode,\n                               off_t offset,\n                               size_t maxlen,\n                               unsigned int flags)\n{\n    virRotatingFileReaderPtr file = NULL;\n    char *data = NULL;\n    ssize_t got;\n\n    virCheckFlags(0, NULL);\n\n    virObjectLock(handler);\n\n    if (!(file = virRotatingFileReaderNew(path, handler->max_backups)))\n        goto error;\n\n    if (virRotatingFileReaderSeek(file, inode, offset) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(data, maxlen + 1) < 0)\n        goto error;\n\n    got = virRotatingFileReaderConsume(file, data, maxlen);\n    if (got < 0)\n        goto error;\n    data[got] = '\\0';\n\n    virRotatingFileReaderFree(file);\n    virObjectUnlock(handler);\n    return data;\n\n error:\n    VIR_FREE(data);\n    virRotatingFileReaderFree(file);\n    virObjectUnlock(handler);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virutil.h\"",
            "#include \"viruuid.h\"",
            "#include \"virrotatingfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"log_handler.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virutil.h\"\n#include \"viruuid.h\"\n#include \"virrotatingfile.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"log_handler.h\"\n#include <config.h>\n\nchar *\nvirLogHandlerDomainReadLogFile(virLogHandlerPtr handler,\n                               const char *path,\n                               ino_t inode,\n                               off_t offset,\n                               size_t maxlen,\n                               unsigned int flags)\n{\n    virRotatingFileReaderPtr file = NULL;\n    char *data = NULL;\n    ssize_t got;\n\n    virCheckFlags(0, NULL);\n\n    virObjectLock(handler);\n\n    if (!(file = virRotatingFileReaderNew(path, handler->max_backups)))\n        goto error;\n\n    if (virRotatingFileReaderSeek(file, inode, offset) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(data, maxlen + 1) < 0)\n        goto error;\n\n    got = virRotatingFileReaderConsume(file, data, maxlen);\n    if (got < 0)\n        goto error;\n    data[got] = '\\0';\n\n    virRotatingFileReaderFree(file);\n    virObjectUnlock(handler);\n    return data;\n\n error:\n    VIR_FREE(data);\n    virRotatingFileReaderFree(file);\n    virObjectUnlock(handler);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogDaemonGetHandler",
          "args": [
            "logDaemon"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virLogDaemonGetHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon.c",
          "lines": "206-210",
          "snippet": "virLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"log_daemon_config.h\"",
            "#include \"log_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"log_daemon_config.h\"\n#include \"log_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Requested data len %llu is larger than maximum %d\")",
            "(unsigned long long)args->maxlen",
            "VIR_LOG_MANAGER_PROTOCOL_STRING_MAX"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Requested data len %llu is larger than maximum %d\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log_daemon_dispatch_stubs.h\"\n#include \"virfile.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetserver.h\"\n#include <config.h>\n\nstatic int\nvirLogManagerProtocolDispatchDomainReadLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                               virNetServerClientPtr client G_GNUC_UNUSED,\n                                               virNetMessagePtr msg G_GNUC_UNUSED,\n                                               virNetMessageErrorPtr rerr,\n                                               virLogManagerProtocolDomainReadLogFileArgs *args,\n                                               virLogManagerProtocolDomainReadLogFileRet *ret)\n{\n    int rv = -1;\n    char *data;\n\n    if (args->maxlen > VIR_LOG_MANAGER_PROTOCOL_STRING_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Requested data len %llu is larger than maximum %d\"),\n                       (unsigned long long)args->maxlen,\n                       VIR_LOG_MANAGER_PROTOCOL_STRING_MAX);\n        goto cleanup;\n    }\n\n    if ((data = virLogHandlerDomainReadLogFile(virLogDaemonGetHandler(logDaemon),\n                                               args->path,\n                                               args->pos.inode,\n                                               args->pos.offset,\n                                               args->maxlen,\n                                               args->flags)) == NULL)\n        goto cleanup;\n\n    ret->data = data;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}"
  },
  {
    "function_name": "virLogManagerProtocolDispatchDomainGetLogFilePosition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon_dispatch.c",
    "lines": "78-105",
    "snippet": "static int\nvirLogManagerProtocolDispatchDomainGetLogFilePosition(virNetServerPtr server G_GNUC_UNUSED,\n                                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                                      virNetMessageErrorPtr rerr,\n                                                      virLogManagerProtocolDomainGetLogFilePositionArgs *args,\n                                                      virLogManagerProtocolDomainGetLogFilePositionRet *ret)\n{\n    int rv = -1;\n    off_t offset;\n    ino_t inode;\n\n    if (virLogHandlerDomainGetLogFilePosition(virLogDaemonGetHandler(logDaemon),\n                                              args->path,\n                                              args->flags,\n                                              &inode, &offset) < 0)\n        goto cleanup;\n\n    ret->pos.inode = inode;\n    ret->pos.offset = offset;\n\n    rv = 0;\n cleanup:\n\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}",
    "includes": [
      "#include \"log_daemon_dispatch_stubs.h\"",
      "#include \"virfile.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogHandlerDomainGetLogFilePosition",
          "args": [
            "virLogDaemonGetHandler(logDaemon)",
            "args->path",
            "args->flags",
            "&inode",
            "&offset"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virLogHandlerDomainGetLogFilePosition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_handler.c",
          "lines": "475-515",
          "snippet": "int\nvirLogHandlerDomainGetLogFilePosition(virLogHandlerPtr handler,\n                                      const char *path,\n                                      unsigned int flags,\n                                      ino_t *inode,\n                                      off_t *offset)\n{\n    virLogHandlerLogFilePtr file = NULL;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(handler);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file),\n                  path)) {\n            file = handler->files[i];\n            break;\n        }\n    }\n\n    if (!file) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No open log file %s\"),\n                       path);\n        goto cleanup;\n    }\n\n    virLogHandlerDomainLogFileDrain(file);\n\n    *inode = virRotatingFileWriterGetINode(file->file);\n    *offset = virRotatingFileWriterGetOffset(file->file);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(handler);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virutil.h\"",
            "#include \"viruuid.h\"",
            "#include \"virrotatingfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"log_handler.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virutil.h\"\n#include \"viruuid.h\"\n#include \"virrotatingfile.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"log_handler.h\"\n#include <config.h>\n\nint\nvirLogHandlerDomainGetLogFilePosition(virLogHandlerPtr handler,\n                                      const char *path,\n                                      unsigned int flags,\n                                      ino_t *inode,\n                                      off_t *offset)\n{\n    virLogHandlerLogFilePtr file = NULL;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(handler);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file),\n                  path)) {\n            file = handler->files[i];\n            break;\n        }\n    }\n\n    if (!file) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No open log file %s\"),\n                       path);\n        goto cleanup;\n    }\n\n    virLogHandlerDomainLogFileDrain(file);\n\n    *inode = virRotatingFileWriterGetINode(file->file);\n    *offset = virRotatingFileWriterGetOffset(file->file);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(handler);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogDaemonGetHandler",
          "args": [
            "logDaemon"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virLogDaemonGetHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon.c",
          "lines": "206-210",
          "snippet": "virLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"log_daemon_config.h\"",
            "#include \"log_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"log_daemon_config.h\"\n#include \"log_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log_daemon_dispatch_stubs.h\"\n#include \"virfile.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetserver.h\"\n#include <config.h>\n\nstatic int\nvirLogManagerProtocolDispatchDomainGetLogFilePosition(virNetServerPtr server G_GNUC_UNUSED,\n                                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                                      virNetMessageErrorPtr rerr,\n                                                      virLogManagerProtocolDomainGetLogFilePositionArgs *args,\n                                                      virLogManagerProtocolDomainGetLogFilePositionRet *ret)\n{\n    int rv = -1;\n    off_t offset;\n    ino_t inode;\n\n    if (virLogHandlerDomainGetLogFilePosition(virLogDaemonGetHandler(logDaemon),\n                                              args->path,\n                                              args->flags,\n                                              &inode, &offset) < 0)\n        goto cleanup;\n\n    ret->pos.inode = inode;\n    ret->pos.offset = offset;\n\n    rv = 0;\n cleanup:\n\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}"
  },
  {
    "function_name": "virLogManagerProtocolDispatchDomainOpenLogFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon_dispatch.c",
    "lines": "39-75",
    "snippet": "static int\nvirLogManagerProtocolDispatchDomainOpenLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                               virNetServerClientPtr client G_GNUC_UNUSED,\n                                               virNetMessagePtr msg,\n                                               virNetMessageErrorPtr rerr,\n                                               virLogManagerProtocolDomainOpenLogFileArgs *args,\n                                               virLogManagerProtocolDomainOpenLogFileRet *ret)\n{\n    int fd = -1;\n    int rv = -1;\n    off_t offset;\n    ino_t inode;\n    bool trunc = args->flags & VIR_LOG_MANAGER_PROTOCOL_DOMAIN_OPEN_LOG_FILE_TRUNCATE;\n\n    if ((fd = virLogHandlerDomainOpenLogFile(virLogDaemonGetHandler(logDaemon),\n                                             args->driver,\n                                             (unsigned char *)args->dom.uuid,\n                                             args->dom.name,\n                                             args->path,\n                                             trunc,\n                                             &inode, &offset)) < 0)\n        goto cleanup;\n\n    ret->pos.inode = inode;\n    ret->pos.offset = offset;\n\n    if (virNetMessageAddFD(msg, fd) < 0)\n        goto cleanup;\n\n    rv = 1; /* '1' tells caller we added some FDs */\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}",
    "includes": [
      "#include \"log_daemon_dispatch_stubs.h\"",
      "#include \"virfile.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virerror.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_daemon.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"rpc/virnetserverclient.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageAddFD",
          "args": [
            "msg",
            "fd"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageAddFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "574-598",
          "snippet": "int virNetMessageAddFD(virNetMessagePtr msg,\n                       int fd)\n{\n    int newfd = -1;\n\n    if ((newfd = dup(fd)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             fd);\n        goto error;\n    }\n\n    if (virSetInherit(newfd, false) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             newfd);\n        goto error;\n    }\n    if (VIR_APPEND_ELEMENT(msg->fds, msg->nfds, newfd) < 0)\n        goto error;\n    return 0;\n error:\n    VIR_FORCE_CLOSE(newfd);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageAddFD(virNetMessagePtr msg,\n                       int fd)\n{\n    int newfd = -1;\n\n    if ((newfd = dup(fd)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             fd);\n        goto error;\n    }\n\n    if (virSetInherit(newfd, false) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             newfd);\n        goto error;\n    }\n    if (VIR_APPEND_ELEMENT(msg->fds, msg->nfds, newfd) < 0)\n        goto error;\n    return 0;\n error:\n    VIR_FORCE_CLOSE(newfd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogHandlerDomainOpenLogFile",
          "args": [
            "virLogDaemonGetHandler(logDaemon)",
            "args->driver",
            "(unsigned char *)args->dom.uuid",
            "args->dom.name",
            "args->path",
            "trunc",
            "&inode",
            "&offset"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virLogHandlerDomainOpenLogFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_handler.c",
          "lines": "361-434",
          "snippet": "int\nvirLogHandlerDomainOpenLogFile(virLogHandlerPtr handler,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               bool trunc,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    size_t i;\n    virLogHandlerLogFilePtr file = NULL;\n    int pipefd[2] = { -1, -1 };\n\n    virObjectLock(handler);\n\n    handler->inhibitor(true, handler->opaque);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file),\n                  path)) {\n            virReportSystemError(EBUSY,\n                                 _(\"Cannot open log file: '%s'\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    if (virPipe(pipefd) < 0)\n        goto error;\n\n    if (VIR_ALLOC(file) < 0)\n        goto error;\n\n    file->watch = -1;\n    file->pipefd = pipefd[0];\n    pipefd[0] = -1;\n    memcpy(file->domuuid, domuuid, VIR_UUID_BUFLEN);\n    file->driver = g_strdup(driver);\n    file->domname = g_strdup(domname);\n\n    if ((file->file = virRotatingFileWriterNew(path,\n                                               handler->max_size,\n                                               handler->max_backups,\n                                               trunc,\n                                               DEFAULT_MODE)) == NULL)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(handler->files, handler->nfiles, file) < 0)\n        goto error;\n\n    if ((file->watch = virEventAddHandle(file->pipefd,\n                                         VIR_EVENT_HANDLE_READABLE,\n                                         virLogHandlerDomainLogFileEvent,\n                                         handler,\n                                         NULL)) < 0) {\n        VIR_DELETE_ELEMENT(handler->files, handler->nfiles - 1, handler->nfiles);\n        goto error;\n    }\n\n    *inode = virRotatingFileWriterGetINode(file->file);\n    *offset = virRotatingFileWriterGetOffset(file->file);\n\n    virObjectUnlock(handler);\n    return pipefd[1];\n\n error:\n    VIR_FORCE_CLOSE(pipefd[0]);\n    VIR_FORCE_CLOSE(pipefd[1]);\n    handler->inhibitor(false, handler->opaque);\n    virLogHandlerLogFileFree(file);\n    virObjectUnlock(handler);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virutil.h\"",
            "#include \"viruuid.h\"",
            "#include \"virrotatingfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"log_handler.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEFAULT_MODE 0600"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virutil.h\"\n#include \"viruuid.h\"\n#include \"virrotatingfile.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"log_handler.h\"\n#include <config.h>\n\n#define DEFAULT_MODE 0600\n\nint\nvirLogHandlerDomainOpenLogFile(virLogHandlerPtr handler,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               bool trunc,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    size_t i;\n    virLogHandlerLogFilePtr file = NULL;\n    int pipefd[2] = { -1, -1 };\n\n    virObjectLock(handler);\n\n    handler->inhibitor(true, handler->opaque);\n\n    for (i = 0; i < handler->nfiles; i++) {\n        if (STREQ(virRotatingFileWriterGetPath(handler->files[i]->file),\n                  path)) {\n            virReportSystemError(EBUSY,\n                                 _(\"Cannot open log file: '%s'\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    if (virPipe(pipefd) < 0)\n        goto error;\n\n    if (VIR_ALLOC(file) < 0)\n        goto error;\n\n    file->watch = -1;\n    file->pipefd = pipefd[0];\n    pipefd[0] = -1;\n    memcpy(file->domuuid, domuuid, VIR_UUID_BUFLEN);\n    file->driver = g_strdup(driver);\n    file->domname = g_strdup(domname);\n\n    if ((file->file = virRotatingFileWriterNew(path,\n                                               handler->max_size,\n                                               handler->max_backups,\n                                               trunc,\n                                               DEFAULT_MODE)) == NULL)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(handler->files, handler->nfiles, file) < 0)\n        goto error;\n\n    if ((file->watch = virEventAddHandle(file->pipefd,\n                                         VIR_EVENT_HANDLE_READABLE,\n                                         virLogHandlerDomainLogFileEvent,\n                                         handler,\n                                         NULL)) < 0) {\n        VIR_DELETE_ELEMENT(handler->files, handler->nfiles - 1, handler->nfiles);\n        goto error;\n    }\n\n    *inode = virRotatingFileWriterGetINode(file->file);\n    *offset = virRotatingFileWriterGetOffset(file->file);\n\n    virObjectUnlock(handler);\n    return pipefd[1];\n\n error:\n    VIR_FORCE_CLOSE(pipefd[0]);\n    VIR_FORCE_CLOSE(pipefd[1]);\n    handler->inhibitor(false, handler->opaque);\n    virLogHandlerLogFileFree(file);\n    virObjectUnlock(handler);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogDaemonGetHandler",
          "args": [
            "logDaemon"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virLogDaemonGetHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_daemon.c",
          "lines": "206-210",
          "snippet": "virLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"log_daemon_config.h\"",
            "#include \"log_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"log_daemon_config.h\"\n#include \"log_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLogHandlerPtr\nvirLogDaemonGetHandler(virLogDaemonPtr dmn)\n{\n    return dmn->handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log_daemon_dispatch_stubs.h\"\n#include \"virfile.h\"\n#include \"virthreadjob.h\"\n#include \"virerror.h\"\n#include \"log_protocol.h\"\n#include \"log_daemon.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"rpc/virnetserverclient.h\"\n#include \"rpc/virnetserver.h\"\n#include <config.h>\n\nstatic int\nvirLogManagerProtocolDispatchDomainOpenLogFile(virNetServerPtr server G_GNUC_UNUSED,\n                                               virNetServerClientPtr client G_GNUC_UNUSED,\n                                               virNetMessagePtr msg,\n                                               virNetMessageErrorPtr rerr,\n                                               virLogManagerProtocolDomainOpenLogFileArgs *args,\n                                               virLogManagerProtocolDomainOpenLogFileRet *ret)\n{\n    int fd = -1;\n    int rv = -1;\n    off_t offset;\n    ino_t inode;\n    bool trunc = args->flags & VIR_LOG_MANAGER_PROTOCOL_DOMAIN_OPEN_LOG_FILE_TRUNCATE;\n\n    if ((fd = virLogHandlerDomainOpenLogFile(virLogDaemonGetHandler(logDaemon),\n                                             args->driver,\n                                             (unsigned char *)args->dom.uuid,\n                                             args->dom.name,\n                                             args->path,\n                                             trunc,\n                                             &inode, &offset)) < 0)\n        goto cleanup;\n\n    ret->pos.inode = inode;\n    ret->pos.offset = offset;\n\n    if (virNetMessageAddFD(msg, fd) < 0)\n        goto cleanup;\n\n    rv = 1; /* '1' tells caller we added some FDs */\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    return rv;\n}"
  }
]