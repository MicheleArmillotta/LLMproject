[
  {
    "function_name": "bhyveDomainAssignAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
    "lines": "186-189",
    "snippet": "int bhyveDomainAssignAddresses(virDomainDefPtr def, virDomainObjPtr obj)\n{\n    return bhyveDomainAssignPCIAddresses(def, obj);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_addr.h\"",
      "#include \"bhyve_device.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bhyveDomainAssignPCIAddresses",
          "args": [
            "def",
            "obj"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDomainAssignPCIAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
          "lines": "160-184",
          "snippet": "int bhyveDomainAssignPCIAddresses(virDomainDefPtr def,\n                                  virDomainObjPtr obj)\n{\n    virDomainPCIAddressSetPtr addrs = NULL;\n    bhyveDomainObjPrivatePtr priv = NULL;\n\n    if (!(addrs = bhyveDomainPCIAddressSetCreate(def, 1)))\n        return -1;\n\n    if (bhyveAssignDevicePCISlots(def, addrs) < 0)\n        return -1;\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        if (addrs) {\n            virDomainPCIAddressSetFree(priv->pciaddrs);\n            priv->persistentAddrs = 1;\n            priv->pciaddrs = addrs;\n        } else {\n            priv->persistentAddrs = 0;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_addr.h\"",
            "#include \"bhyve_device.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nint bhyveDomainAssignPCIAddresses(virDomainDefPtr def,\n                                  virDomainObjPtr obj)\n{\n    virDomainPCIAddressSetPtr addrs = NULL;\n    bhyveDomainObjPrivatePtr priv = NULL;\n\n    if (!(addrs = bhyveDomainPCIAddressSetCreate(def, 1)))\n        return -1;\n\n    if (bhyveAssignDevicePCISlots(def, addrs) < 0)\n        return -1;\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        if (addrs) {\n            virDomainPCIAddressSetFree(priv->pciaddrs);\n            priv->persistentAddrs = 1;\n            priv->pciaddrs = addrs;\n        } else {\n            priv->persistentAddrs = 0;\n        }\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nint bhyveDomainAssignAddresses(virDomainDefPtr def, virDomainObjPtr obj)\n{\n    return bhyveDomainAssignPCIAddresses(def, obj);\n}"
  },
  {
    "function_name": "bhyveDomainAssignPCIAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
    "lines": "160-184",
    "snippet": "int bhyveDomainAssignPCIAddresses(virDomainDefPtr def,\n                                  virDomainObjPtr obj)\n{\n    virDomainPCIAddressSetPtr addrs = NULL;\n    bhyveDomainObjPrivatePtr priv = NULL;\n\n    if (!(addrs = bhyveDomainPCIAddressSetCreate(def, 1)))\n        return -1;\n\n    if (bhyveAssignDevicePCISlots(def, addrs) < 0)\n        return -1;\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        if (addrs) {\n            virDomainPCIAddressSetFree(priv->pciaddrs);\n            priv->persistentAddrs = 1;\n            priv->pciaddrs = addrs;\n        } else {\n            priv->persistentAddrs = 0;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_addr.h\"",
      "#include \"bhyve_device.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetFree",
          "args": [
            "priv->pciaddrs"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1079-1088",
          "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveAssignDevicePCISlots",
          "args": [
            "def",
            "addrs"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveAssignDevicePCISlots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
          "lines": "87-158",
          "snippet": "static int\nbhyveAssignDevicePCISlots(virDomainDefPtr def,\n                          virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress lpc_addr;\n\n    /* explicitly reserve slot 1 for LPC-ISA bridge */\n    memset(&lpc_addr, 0, sizeof(lpc_addr));\n    lpc_addr.slot = 0x1;\n\n    if (virDomainPCIAddressReserveAddr(addrs, &lpc_addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) ||\n            (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SATA) ||\n            ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) &&\n             (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI))) {\n            if (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&def->controllers[i]->info))\n                continue;\n\n            if (virDomainPCIAddressReserveNextAddr(addrs,\n                                                   &def->controllers[i]->info,\n                                                   VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                                   -1) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->nets[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->nets[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* We only handle virtio disk addresses as SATA disks are\n         * attached to a controller and don't have their own PCI\n         * addresses */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        if (def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            !virPCIDeviceAddressIsEmpty(&def->disks[i]->info.addr.pci))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->videos[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_addr.h\"",
            "#include \"bhyve_device.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nstatic int\nbhyveAssignDevicePCISlots(virDomainDefPtr def,\n                          virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress lpc_addr;\n\n    /* explicitly reserve slot 1 for LPC-ISA bridge */\n    memset(&lpc_addr, 0, sizeof(lpc_addr));\n    lpc_addr.slot = 0x1;\n\n    if (virDomainPCIAddressReserveAddr(addrs, &lpc_addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) ||\n            (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SATA) ||\n            ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) &&\n             (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI))) {\n            if (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&def->controllers[i]->info))\n                continue;\n\n            if (virDomainPCIAddressReserveNextAddr(addrs,\n                                                   &def->controllers[i]->info,\n                                                   VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                                   -1) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->nets[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->nets[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* We only handle virtio disk addresses as SATA disks are\n         * attached to a controller and don't have their own PCI\n         * addresses */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        if (def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            !virPCIDeviceAddressIsEmpty(&def->disks[i]->info.addr.pci))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->videos[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveDomainPCIAddressSetCreate",
          "args": [
            "def",
            "1"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveDomainPCIAddressSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
          "lines": "64-85",
          "snippet": "virDomainPCIAddressSetPtr\nbhyveDomainPCIAddressSetCreate(virDomainDefPtr def, unsigned int nbuses)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses,\n                                             VIR_PCI_ADDRESS_EXTENSION_NONE)) == NULL)\n        return NULL;\n\n    if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                       VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, bhyveCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_addr.h\"",
            "#include \"bhyve_device.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nvirDomainPCIAddressSetPtr\nbhyveDomainPCIAddressSetCreate(virDomainDefPtr def, unsigned int nbuses)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses,\n                                             VIR_PCI_ADDRESS_EXTENSION_NONE)) == NULL)\n        return NULL;\n\n    if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                       VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, bhyveCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nint bhyveDomainAssignPCIAddresses(virDomainDefPtr def,\n                                  virDomainObjPtr obj)\n{\n    virDomainPCIAddressSetPtr addrs = NULL;\n    bhyveDomainObjPrivatePtr priv = NULL;\n\n    if (!(addrs = bhyveDomainPCIAddressSetCreate(def, 1)))\n        return -1;\n\n    if (bhyveAssignDevicePCISlots(def, addrs) < 0)\n        return -1;\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        if (addrs) {\n            virDomainPCIAddressSetFree(priv->pciaddrs);\n            priv->persistentAddrs = 1;\n            priv->pciaddrs = addrs;\n        } else {\n            priv->persistentAddrs = 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveAssignDevicePCISlots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
    "lines": "87-158",
    "snippet": "static int\nbhyveAssignDevicePCISlots(virDomainDefPtr def,\n                          virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress lpc_addr;\n\n    /* explicitly reserve slot 1 for LPC-ISA bridge */\n    memset(&lpc_addr, 0, sizeof(lpc_addr));\n    lpc_addr.slot = 0x1;\n\n    if (virDomainPCIAddressReserveAddr(addrs, &lpc_addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) ||\n            (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SATA) ||\n            ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) &&\n             (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI))) {\n            if (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&def->controllers[i]->info))\n                continue;\n\n            if (virDomainPCIAddressReserveNextAddr(addrs,\n                                                   &def->controllers[i]->info,\n                                                   VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                                   -1) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->nets[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->nets[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* We only handle virtio disk addresses as SATA disks are\n         * attached to a controller and don't have their own PCI\n         * addresses */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        if (def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            !virPCIDeviceAddressIsEmpty(&def->disks[i]->info.addr.pci))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->videos[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_addr.h\"",
      "#include \"bhyve_device.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&def->videos[i]->info",
            "VIR_PCI_CONNECT_TYPE_PCI_DEVICE",
            "-1"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1260-1285",
          "snippet": "int\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsWanted",
          "args": [
            "&def->videos[i]->info"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsWanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "183-189",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressIsEmpty",
          "args": [
            "&def->disks[i]->info.addr.pci"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1318-1322",
          "snippet": "bool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "&lpc_addr",
            "VIR_PCI_CONNECT_TYPE_PCI_DEVICE",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lpc_addr",
            "0",
            "sizeof(lpc_addr)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nstatic int\nbhyveAssignDevicePCISlots(virDomainDefPtr def,\n                          virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress lpc_addr;\n\n    /* explicitly reserve slot 1 for LPC-ISA bridge */\n    memset(&lpc_addr, 0, sizeof(lpc_addr));\n    lpc_addr.slot = 0x1;\n\n    if (virDomainPCIAddressReserveAddr(addrs, &lpc_addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) ||\n            (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SATA) ||\n            ((def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) &&\n             (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI))) {\n            if (def->controllers[i]->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&def->controllers[i]->info))\n                continue;\n\n            if (virDomainPCIAddressReserveNextAddr(addrs,\n                                                   &def->controllers[i]->info,\n                                                   VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                                   -1) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->nets[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->nets[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* We only handle virtio disk addresses as SATA disks are\n         * attached to a controller and don't have their own PCI\n         * addresses */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        if (def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            !virPCIDeviceAddressIsEmpty(&def->disks[i]->info.addr.pci))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n        if (virDomainPCIAddressReserveNextAddr(addrs,\n                                               &def->videos[i]->info,\n                                               VIR_PCI_CONNECT_TYPE_PCI_DEVICE,\n                                               -1) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveDomainPCIAddressSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
    "lines": "64-85",
    "snippet": "virDomainPCIAddressSetPtr\nbhyveDomainPCIAddressSetCreate(virDomainDefPtr def, unsigned int nbuses)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses,\n                                             VIR_PCI_ADDRESS_EXTENSION_NONE)) == NULL)\n        return NULL;\n\n    if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                       VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, bhyveCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_addr.h\"",
      "#include \"bhyve_device.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1079-1088",
          "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "bhyveCollectPCIAddress",
            "addrs"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusSetModel",
          "args": [
            "&addrs->buses[0]",
            "VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressBusSetModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "503-603",
          "snippet": "int\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetAlloc",
          "args": [
            "nbuses",
            "VIR_PCI_ADDRESS_EXTENSION_NONE"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1054-1076",
          "snippet": "virDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nvirDomainPCIAddressSetPtr\nbhyveDomainPCIAddressSetCreate(virDomainDefPtr def, unsigned int nbuses)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses,\n                                             VIR_PCI_ADDRESS_EXTENSION_NONE)) == NULL)\n        return NULL;\n\n    if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                       VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, bhyveCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
  },
  {
    "function_name": "bhyveCollectPCIAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_device.c",
    "lines": "33-62",
    "snippet": "static int\nbhyveCollectPCIAddress(virDomainDefPtr def G_GNUC_UNUSED,\n                       virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                       virDomainDeviceInfoPtr info,\n                       void *opaque)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE)\n        return 0;\n\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (addr->domain == 0 && addr->bus == 0) {\n        if (addr->slot == 0) {\n            return 0;\n        } else if (addr->slot == 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"PCI bus 0 slot 1 is reserved for the implicit \"\n                             \"LPC PCI-ISA bridge\"));\n            return -1;\n        }\n    }\n\n    if (virDomainPCIAddressReserveAddr(addrs, addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_addr.h\"",
      "#include \"bhyve_device.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "addr",
            "VIR_PCI_CONNECT_TYPE_PCI_DEVICE",
            "0"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"PCI bus 0 slot 1 is reserved for the implicit \"\n                             \"LPC PCI-ISA bridge\")"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PCI bus 0 slot 1 is reserved for the implicit \"\n                             \"LPC PCI-ISA bridge\""
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_addr.h\"\n#include \"bhyve_device.h\"\n#include <config.h>\n\nstatic int\nbhyveCollectPCIAddress(virDomainDefPtr def G_GNUC_UNUSED,\n                       virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                       virDomainDeviceInfoPtr info,\n                       void *opaque)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE)\n        return 0;\n\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (addr->domain == 0 && addr->bus == 0) {\n        if (addr->slot == 0) {\n            return 0;\n        } else if (addr->slot == 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"PCI bus 0 slot 1 is reserved for the implicit \"\n                             \"LPC PCI-ISA bridge\"));\n            return -1;\n        }\n    }\n\n    if (virDomainPCIAddressReserveAddr(addrs, addr,\n                                       VIR_PCI_CONNECT_TYPE_PCI_DEVICE, 0) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  }
]