[
  {
    "function_name": "esxStreamOpenDownload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "484-489",
    "snippet": "int\nesxStreamOpenDownload(virStreamPtr stream, esxPrivate *priv, const char *url,\n                      unsigned long long offset, unsigned long long length)\n{\n    return esxStreamOpen(stream, priv, url, offset, length, ESX_STREAM_MODE_DOWNLOAD);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStreamOpen",
          "args": [
            "stream",
            "priv",
            "url",
            "offset",
            "length",
            "ESX_STREAM_MODE_DOWNLOAD"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "393-476",
          "snippet": "static int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};\n\nstatic int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxStreamOpenDownload(virStreamPtr stream, esxPrivate *priv, const char *url,\n                      unsigned long long offset, unsigned long long length)\n{\n    return esxStreamOpen(stream, priv, url, offset, length, ESX_STREAM_MODE_DOWNLOAD);\n}"
  },
  {
    "function_name": "esxStreamOpenUpload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "478-482",
    "snippet": "int\nesxStreamOpenUpload(virStreamPtr stream, esxPrivate *priv, const char *url)\n{\n    return esxStreamOpen(stream, priv, url, 0, 0, ESX_STREAM_MODE_UPLOAD);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStreamOpen",
          "args": [
            "stream",
            "priv",
            "url",
            "0",
            "0",
            "ESX_STREAM_MODE_UPLOAD"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "393-476",
          "snippet": "static int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};\n\nstatic int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxStreamOpenUpload(virStreamPtr stream, esxPrivate *priv, const char *url)\n{\n    return esxStreamOpen(stream, priv, url, 0, 0, ESX_STREAM_MODE_UPLOAD);\n}"
  },
  {
    "function_name": "esxStreamOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "393-476",
    "snippet": "static int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "userpwd"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "range"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxFreeStreamPrivate",
          "args": [
            "&streamPriv"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "esxFreeStreamPrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "333-342",
          "snippet": "static void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Free",
          "args": [
            "&multi"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Add",
          "args": [
            "multi",
            "streamPriv->curl"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Alloc",
          "args": [
            "&multi"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_USERPWD",
            "userpwd"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s:%s\"",
            "priv->primary->username",
            "priv->primary->password"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_PASSWORD",
            "priv->primary->password"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_USERNAME",
            "priv->primary->username"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_RANGE",
            "range"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_URL",
            "url"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_WRITEDATA",
            "streamPriv"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_WRITEFUNCTION",
            "esxVI_CURL_WriteStream"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_HTTPGET",
            "1"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_UPLOAD",
            "0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_READDATA",
            "streamPriv"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_READFUNCTION",
            "esxVI_CURL_ReadStream"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "streamPriv->curl->handle",
            "CURLOPT_UPLOAD",
            "1"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Connect",
          "args": [
            "streamPriv->curl",
            "priv->parsedUri"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "295-366",
          "snippet": "int\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\n#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0\n\nint\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Alloc",
          "args": [
            "&streamPriv->curl"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "streamPriv"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Non-blocking streams are not supported yet\")"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Non-blocking streams are not supported yet\""
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirStreamDriver esxStreamDriver = {\n    .streamSend = esxStreamSend,\n    .streamRecv = esxStreamRecv,\n    .streamRecvFlags = esxStreamRecvFlags,\n    /* FIXME: streamAddCallback missing */\n    /* FIXME: streamUpdateCallback missing */\n    /* FIXME: streamRemoveCallback missing */\n    .streamFinish = esxStreamFinish,\n    .streamAbort = esxStreamAbort,\n};\n\nstatic int\nesxStreamOpen(virStreamPtr stream, esxPrivate *priv, const char *url,\n              unsigned long long offset, unsigned long long length, int mode)\n{\n    int result = -1;\n    esxStreamPrivate *streamPriv;\n    char *range = NULL;\n    char *userpwd = NULL;\n    esxVI_MultiCURL *multi = NULL;\n\n    /* FIXME: Although there is already some code in place to deal with\n     *        non-blocking streams it is currently incomplete, so usage\n     *        of the non-blocking mode is denied here for now. */\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Non-blocking streams are not supported yet\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(streamPriv) < 0)\n        return -1;\n\n    streamPriv->mode = mode;\n\n    if (length > 0) {\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    if (esxVI_CURL_Alloc(&streamPriv->curl) < 0 ||\n        esxVI_CURL_Connect(streamPriv->curl, priv->parsedUri) < 0)\n        goto cleanup;\n\n    if (mode == ESX_STREAM_MODE_UPLOAD) {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READFUNCTION,\n                         esxVI_CURL_ReadStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_READDATA, streamPriv);\n    } else {\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_UPLOAD, 0);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEFUNCTION,\n                         esxVI_CURL_WriteStream);\n        curl_easy_setopt(streamPriv->curl->handle, CURLOPT_WRITEDATA, streamPriv);\n    }\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_RANGE, range);\n\n#if LIBCURL_VERSION_NUM >= 0x071301 /* 7.19.1 */\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERNAME,\n                     priv->primary->username);\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_PASSWORD,\n                     priv->primary->password);\n#else\n    userpwd = g_strdup_printf(\"%s:%s\", priv->primary->username,\n                              priv->primary->password);\n\n    curl_easy_setopt(streamPriv->curl->handle, CURLOPT_USERPWD, userpwd);\n#endif\n\n    if (esxVI_MultiCURL_Alloc(&multi) < 0 ||\n        esxVI_MultiCURL_Add(multi, streamPriv->curl) < 0)\n        goto cleanup;\n\n    stream->driver = &esxStreamDriver;\n    stream->privateData = streamPriv;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (streamPriv->curl && multi != streamPriv->curl->multi)\n            esxVI_MultiCURL_Free(&multi);\n\n        esxFreeStreamPrivate(&streamPriv);\n    }\n\n    VIR_FREE(range);\n    VIR_FREE(userpwd);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStreamAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "376-380",
    "snippet": "static int\nesxStreamAbort(virStreamPtr stream)\n{\n    return esxStreamClose(stream, false);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStreamClose",
          "args": [
            "stream",
            "false"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "344-368",
          "snippet": "static int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamAbort(virStreamPtr stream)\n{\n    return esxStreamClose(stream, false);\n}"
  },
  {
    "function_name": "esxStreamFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "370-374",
    "snippet": "static int\nesxStreamFinish(virStreamPtr stream)\n{\n    return esxStreamClose(stream, true);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStreamClose",
          "args": [
            "stream",
            "true"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "344-368",
          "snippet": "static int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamFinish(virStreamPtr stream)\n{\n    return esxStreamClose(stream, true);\n}"
  },
  {
    "function_name": "esxStreamClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "344-368",
    "snippet": "static int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxFreeStreamPrivate",
          "args": [
            "&priv"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "esxFreeStreamPrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "333-342",
          "snippet": "static void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Stream has untransferred data left\")"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Stream has untransferred data left\""
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamClose(virStreamPtr stream, bool finish)\n{\n    int result = 0;\n    esxStreamPrivate *priv = stream->privateData;\n\n    if (!priv)\n        return 0;\n\n    virMutexLock(&priv->curl->lock);\n\n    if (finish && priv->backlog_used > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Stream has untransferred data left\"));\n        result = -1;\n    }\n\n    stream->privateData = NULL;\n\n    virMutexUnlock(&priv->curl->lock);\n\n    esxFreeStreamPrivate(&priv);\n\n    return result;\n}"
  },
  {
    "function_name": "esxFreeStreamPrivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "333-342",
    "snippet": "static void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*priv"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*priv)->backlog"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Free",
          "args": [
            "&(*priv)->curl"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreeStreamPrivate(esxStreamPrivate **priv)\n{\n    if (!priv || !*priv)\n        return;\n\n    esxVI_CURL_Free(&(*priv)->curl);\n    VIR_FREE((*priv)->backlog);\n    VIR_FREE(*priv);\n}"
  },
  {
    "function_name": "esxStreamRecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "325-331",
    "snippet": "static int\nesxStreamRecv(virStreamPtr stream,\n              char *data,\n              size_t nbytes)\n{\n    return esxStreamRecvFlags(stream, data, nbytes, 0);\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStreamRecvFlags",
          "args": [
            "stream",
            "data",
            "nbytes",
            "0"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamRecvFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "254-323",
          "snippet": "static int\nesxStreamRecvFlags(virStreamPtr stream,\n                   char *data,\n                   size_t nbytes,\n                   unsigned int flags)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    virCheckFlags(0, -1);\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_DOWNLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not a download stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = 0;\n\n    if (priv->backlog_used > 0) {\n        if (priv->buffer_size > priv->backlog_used)\n            priv->buffer_used = priv->backlog_used;\n        else\n            priv->buffer_used = priv->buffer_size;\n\n        memcpy(priv->buffer, priv->backlog, priv->buffer_used);\n        memmove(priv->backlog, priv->backlog + priv->buffer_used,\n                priv->backlog_used - priv->buffer_used);\n\n        priv->backlog_used -= priv->buffer_used;\n        result = priv->buffer_used;\n    } else if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used > 0)\n            result = priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used < priv->buffer_size);\n\n        result = priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamRecvFlags(virStreamPtr stream,\n                   char *data,\n                   size_t nbytes,\n                   unsigned int flags)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    virCheckFlags(0, -1);\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_DOWNLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not a download stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = 0;\n\n    if (priv->backlog_used > 0) {\n        if (priv->buffer_size > priv->backlog_used)\n            priv->buffer_used = priv->backlog_used;\n        else\n            priv->buffer_used = priv->buffer_size;\n\n        memcpy(priv->buffer, priv->backlog, priv->buffer_used);\n        memmove(priv->backlog, priv->backlog + priv->buffer_used,\n                priv->backlog_used - priv->buffer_used);\n\n        priv->backlog_used -= priv->buffer_used;\n        result = priv->buffer_used;\n    } else if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used > 0)\n            result = priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used < priv->buffer_size);\n\n        result = priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamRecv(virStreamPtr stream,\n              char *data,\n              size_t nbytes)\n{\n    return esxStreamRecvFlags(stream, data, nbytes, 0);\n}"
  },
  {
    "function_name": "esxStreamRecvFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "254-323",
    "snippet": "static int\nesxStreamRecvFlags(virStreamPtr stream,\n                   char *data,\n                   size_t nbytes,\n                   unsigned int flags)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    virCheckFlags(0, -1);\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_DOWNLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not a download stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = 0;\n\n    if (priv->backlog_used > 0) {\n        if (priv->buffer_size > priv->backlog_used)\n            priv->buffer_used = priv->backlog_used;\n        else\n            priv->buffer_used = priv->buffer_size;\n\n        memcpy(priv->buffer, priv->backlog, priv->buffer_used);\n        memmove(priv->backlog, priv->backlog + priv->buffer_used,\n                priv->backlog_used - priv->buffer_used);\n\n        priv->backlog_used -= priv->buffer_used;\n        result = priv->buffer_used;\n    } else if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used > 0)\n            result = priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used < priv->buffer_size);\n\n        result = priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxStreamTransfer",
          "args": [
            "priv",
            "true"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamTransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "154-198",
          "snippet": "static int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "priv->backlog",
            "priv->backlog + priv->buffer_used",
            "priv->backlog_used - priv->buffer_used"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->buffer",
            "priv->backlog",
            "priv->buffer_used"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Not a download stream\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Not a download stream\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Stream is not open\")"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamRecvFlags(virStreamPtr stream,\n                   char *data,\n                   size_t nbytes,\n                   unsigned int flags)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    virCheckFlags(0, -1);\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_DOWNLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not a download stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = 0;\n\n    if (priv->backlog_used > 0) {\n        if (priv->buffer_size > priv->backlog_used)\n            priv->buffer_used = priv->backlog_used;\n        else\n            priv->buffer_used = priv->buffer_size;\n\n        memcpy(priv->buffer, priv->backlog, priv->buffer_used);\n        memmove(priv->backlog, priv->backlog + priv->buffer_used,\n                priv->backlog_used - priv->buffer_used);\n\n        priv->backlog_used -= priv->buffer_used;\n        result = priv->buffer_used;\n    } else if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used > 0)\n            result = priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used < priv->buffer_size);\n\n        result = priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStreamSend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "200-252",
    "snippet": "static int\nesxStreamSend(virStreamPtr stream, const char *data, size_t nbytes)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_UPLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not an upload stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = (char *)data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = nbytes;\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used < priv->buffer_size)\n            result = priv->buffer_size - priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used > 0);\n\n        result = priv->buffer_size - priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxStreamTransfer",
          "args": [
            "priv",
            "true"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamTransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "154-198",
          "snippet": "static int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->curl->lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Not an upload stream\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Not an upload stream\""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Stream is not open\")"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamSend(virStreamPtr stream, const char *data, size_t nbytes)\n{\n    int result = -1;\n    esxStreamPrivate *priv = stream->privateData;\n    int status;\n\n    if (nbytes == 0)\n        return 0;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Stream is not open\"));\n        return -1;\n    }\n\n    if (priv->mode != ESX_STREAM_MODE_UPLOAD) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Not an upload stream\"));\n        return -1;\n    }\n\n    virMutexLock(&priv->curl->lock);\n\n    priv->buffer = (char *)data;\n    priv->buffer_size = nbytes;\n    priv->buffer_used = nbytes;\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        if (esxStreamTransfer(priv, false) < 0)\n            goto cleanup;\n\n        if (priv->buffer_used < priv->buffer_size)\n            result = priv->buffer_size - priv->buffer_used;\n        else\n            result = -2;\n    } else /* blocking */ {\n        do {\n            status = esxStreamTransfer(priv, true);\n\n            if (status < 0)\n                goto cleanup;\n\n            if (status > 0)\n                break;\n        } while (priv->buffer_used > 0);\n\n        result = priv->buffer_size - priv->buffer_used;\n    }\n\n cleanup:\n    virMutexUnlock(&priv->curl->lock);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStreamTransfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "154-198",
    "snippet": "static int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected HTTP response code %lu\")",
            "responseCode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected HTTP response code %lu\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not complete transfer: %s (%d)\")",
            "curl_easy_strerror(errorCode)",
            "errorCode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_strerror",
          "args": [
            "errorCode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_CheckFirstMessage",
          "args": [
            "priv->curl->multi",
            "&responseCode",
            "&errorCode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_MultiCURL_CheckFirstMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "777-797",
          "snippet": "int\nesxVI_MultiCURL_CheckFirstMessage(esxVI_MultiCURL *multi, long *responseCode,\n                                  CURLcode *errorCode)\n{\n    int messagesInQueue;\n    CURLMsg* msg = curl_multi_info_read(multi->handle, &messagesInQueue);\n\n    *responseCode = 0;\n\n    if (!msg || msg->msg != CURLMSG_DONE)\n        return 0;\n\n    *errorCode = msg->data.result;\n\n    if (*errorCode != CURLE_OK)\n        return -1;\n\n    curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, responseCode);\n\n    return 1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_CheckFirstMessage(esxVI_MultiCURL *multi, long *responseCode,\n                                  CURLcode *errorCode)\n{\n    int messagesInQueue;\n    CURLMsg* msg = curl_multi_info_read(multi->handle, &messagesInQueue);\n\n    *responseCode = 0;\n\n    if (!msg || msg->msg != CURLMSG_DONE)\n        return 0;\n\n    *errorCode = msg->data.result;\n\n    if (*errorCode != CURLE_OK)\n        return -1;\n\n    curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, responseCode);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Perform",
          "args": [
            "priv->curl->multi",
            "&runningHandles"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_MultiCURL_Perform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "757-774",
          "snippet": "int\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Wait",
          "args": [
            "priv->curl->multi",
            "&runningHandles"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_MultiCURL_Wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "734-755",
          "snippet": "int\nesxVI_MultiCURL_Wait(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    long timeout = -1;\n    CURLMcode errorCode;\n\n    curl_multi_timeout(multi->handle, &timeout);\n\n    if (timeout < 0)\n        timeout = 1000; /* default to 1 sec timeout */\n\n    errorCode = curl_multi_wait(multi->handle, NULL, 0, timeout, NULL);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not wait for transfer: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return esxVI_MultiCURL_Perform(multi, runningHandles);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Wait(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    long timeout = -1;\n    CURLMcode errorCode;\n\n    curl_multi_timeout(multi->handle, &timeout);\n\n    if (timeout < 0)\n        timeout = 1000; /* default to 1 sec timeout */\n\n    errorCode = curl_multi_wait(multi->handle, NULL, 0, timeout, NULL);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not wait for transfer: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return esxVI_MultiCURL_Perform(multi, runningHandles);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxStreamTransfer(esxStreamPrivate *priv, bool blocking)\n{\n    int runningHandles = 0;\n    long responseCode = 0;\n    int status;\n    CURLcode errorCode;\n\n    if (blocking) {\n        if (esxVI_MultiCURL_Wait(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    } else {\n        if (esxVI_MultiCURL_Perform(priv->curl->multi, &runningHandles) < 0)\n            return -1;\n    }\n\n    if (runningHandles == 0) {\n        /* Transfer is done check for result */\n        status = esxVI_MultiCURL_CheckFirstMessage(priv->curl->multi,\n                                                   &responseCode, &errorCode);\n\n        if (status == 0) {\n            /* No message, transfer finished successfully */\n            return 1;\n        }\n\n        if (status < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not complete transfer: %s (%d)\"),\n                           curl_easy_strerror(errorCode), errorCode);\n            return -1;\n        }\n\n        if (responseCode != 200 && responseCode != 206) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected HTTP response code %lu\"),\n                           responseCode);\n            return -1;\n        }\n\n        return 1;\n    }\n\n    return blocking ? 0 : 1;\n}"
  },
  {
    "function_name": "esxVI_CURL_WriteStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "109-151",
    "snippet": "static size_t\nesxVI_CURL_WriteStream(char *input, size_t size, size_t nmemb, void *userdata)\n{\n    esxStreamPrivate *priv = userdata;\n    size_t input_size = size * nmemb;\n    size_t input_used = priv->buffer_size - priv->buffer_used;\n\n    if (input_size == 0)\n        return input_size;\n\n    if (input_used > input_size)\n        input_used = input_size;\n\n    /* Fill buffer */\n    memcpy(priv->buffer + priv->buffer_used, input, input_used);\n    priv->buffer_used += input_used;\n\n    /* Move rest to backlog */\n    if (input_size > input_used) {\n        size_t input_remaining = input_size - input_used;\n        size_t backlog_remaining = priv->backlog_size - priv->backlog_used;\n\n        if (!priv->backlog) {\n            priv->backlog_size = input_remaining;\n            priv->backlog_used = 0;\n\n            if (VIR_ALLOC_N(priv->backlog, priv->backlog_size) < 0)\n                return 0;\n        } else if (input_remaining > backlog_remaining) {\n            priv->backlog_size += input_remaining - backlog_remaining;\n\n            if (VIR_REALLOC_N(priv->backlog, priv->backlog_size) < 0)\n                return 0;\n        }\n\n        memcpy(priv->backlog + priv->backlog_used, input + input_used,\n               input_remaining);\n\n        priv->backlog_used += input_remaining;\n    }\n\n    return input_size;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->backlog + priv->backlog_used",
            "input + input_used",
            "input_remaining"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "priv->backlog",
            "priv->backlog_size"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "priv->backlog",
            "priv->backlog_size"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->buffer + priv->buffer_used",
            "input",
            "input_used"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic size_t\nesxVI_CURL_WriteStream(char *input, size_t size, size_t nmemb, void *userdata)\n{\n    esxStreamPrivate *priv = userdata;\n    size_t input_size = size * nmemb;\n    size_t input_used = priv->buffer_size - priv->buffer_used;\n\n    if (input_size == 0)\n        return input_size;\n\n    if (input_used > input_size)\n        input_used = input_size;\n\n    /* Fill buffer */\n    memcpy(priv->buffer + priv->buffer_used, input, input_used);\n    priv->buffer_used += input_used;\n\n    /* Move rest to backlog */\n    if (input_size > input_used) {\n        size_t input_remaining = input_size - input_used;\n        size_t backlog_remaining = priv->backlog_size - priv->backlog_used;\n\n        if (!priv->backlog) {\n            priv->backlog_size = input_remaining;\n            priv->backlog_used = 0;\n\n            if (VIR_ALLOC_N(priv->backlog, priv->backlog_size) < 0)\n                return 0;\n        } else if (input_remaining > backlog_remaining) {\n            priv->backlog_size += input_remaining - backlog_remaining;\n\n            if (VIR_REALLOC_N(priv->backlog, priv->backlog_size) < 0)\n                return 0;\n        }\n\n        memcpy(priv->backlog + priv->backlog_used, input + input_used,\n               input_remaining);\n\n        priv->backlog_used += input_remaining;\n    }\n\n    return input_size;\n}"
  },
  {
    "function_name": "esxVI_CURL_ReadStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
    "lines": "89-107",
    "snippet": "static size_t\nesxVI_CURL_ReadStream(char *output, size_t size, size_t nmemb, void *userdata)\n{\n    esxStreamPrivate *priv = userdata;\n    size_t output_size = size * nmemb;\n    size_t output_used = 0;\n\n    if (output_size > priv->buffer_used)\n        output_used = priv->buffer_used;\n    else\n        output_used = output_size;\n\n    memcpy(output, priv->buffer + priv->buffer_size - priv->buffer_used,\n           output_used);\n\n    priv->buffer_used -= output_used;\n\n    return output_used;\n}",
    "includes": [
      "#include \"esx_stream.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "output",
            "priv->buffer + priv->buffer_size - priv->buffer_used",
            "output_used"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic size_t\nesxVI_CURL_ReadStream(char *output, size_t size, size_t nmemb, void *userdata)\n{\n    esxStreamPrivate *priv = userdata;\n    size_t output_size = size * nmemb;\n    size_t output_used = 0;\n\n    if (output_size > priv->buffer_used)\n        output_used = priv->buffer_used;\n    else\n        output_used = output_size;\n\n    memcpy(output, priv->buffer + priv->buffer_size - priv->buffer_used,\n           output_used);\n\n    priv->buffer_used -= output_used;\n\n    return output_used;\n}"
  }
]