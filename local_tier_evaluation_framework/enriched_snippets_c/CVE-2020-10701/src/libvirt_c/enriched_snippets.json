[
  {
    "function_name": "virTypedParameterValidateSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "1288-1325",
    "snippet": "int\nvirTypedParameterValidateSet(virConnectPtr conn,\n                             virTypedParameterPtr params,\n                             int nparams)\n{\n    bool string_okay;\n    size_t i;\n\n    string_okay = VIR_DRV_SUPPORTS_FEATURE(conn->driver,\n                                           conn,\n                                           VIR_DRV_FEATURE_TYPED_PARAM_STRING);\n    for (i = 0; i < nparams; i++) {\n        if (strnlen(params[i].field, VIR_TYPED_PARAM_FIELD_LENGTH) ==\n            VIR_TYPED_PARAM_FIELD_LENGTH) {\n            virReportInvalidArg(params,\n                                _(\"string parameter name '%.*s' too long\"),\n                                VIR_TYPED_PARAM_FIELD_LENGTH,\n                                params[i].field);\n            return -1;\n        }\n        if (params[i].type == VIR_TYPED_PARAM_STRING) {\n            if (string_okay) {\n                if (!params[i].value.s) {\n                    virReportInvalidArg(params,\n                                        _(\"NULL string parameter '%s'\"),\n                                        params[i].field);\n                    return -1;\n                }\n            } else {\n                virReportInvalidArg(params,\n                                    _(\"string parameter '%s' unsupported\"),\n                                    params[i].field);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "params",
            "_(\"string parameter '%s' unsupported\")",
            "params[i].field"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"string parameter '%s' unsupported\""
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "params",
            "_(\"NULL string parameter '%s'\")",
            "params[i].field"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "params",
            "_(\"string parameter name '%.*s' too long\")",
            "VIR_TYPED_PARAM_FIELD_LENGTH",
            "params[i].field"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "params[i].field",
            "VIR_TYPED_PARAM_FIELD_LENGTH"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "conn->driver",
            "conn",
            "VIR_DRV_FEATURE_TYPED_PARAM_STRING"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirTypedParameterValidateSet(virConnectPtr conn,\n                             virTypedParameterPtr params,\n                             int nparams)\n{\n    bool string_okay;\n    size_t i;\n\n    string_okay = VIR_DRV_SUPPORTS_FEATURE(conn->driver,\n                                           conn,\n                                           VIR_DRV_FEATURE_TYPED_PARAM_STRING);\n    for (i = 0; i < nparams; i++) {\n        if (strnlen(params[i].field, VIR_TYPED_PARAM_FIELD_LENGTH) ==\n            VIR_TYPED_PARAM_FIELD_LENGTH) {\n            virReportInvalidArg(params,\n                                _(\"string parameter name '%.*s' too long\"),\n                                VIR_TYPED_PARAM_FIELD_LENGTH,\n                                params[i].field);\n            return -1;\n        }\n        if (params[i].type == VIR_TYPED_PARAM_STRING) {\n            if (string_okay) {\n                if (!params[i].value.s) {\n                    virReportInvalidArg(params,\n                                        _(\"NULL string parameter '%s'\"),\n                                        params[i].field);\n                    return -1;\n                }\n            } else {\n                virReportInvalidArg(params,\n                                    _(\"string parameter '%s' unsupported\"),\n                                    params[i].field);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "1271-1283",
    "snippet": "int\nvirConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (!virObjectUnref(conn))\n        return 0;\n    return 1;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckConnectReturn",
          "args": [
            "conn",
            "-1"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"conn=%p\"",
            "conn"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (!virObjectUnref(conn))\n        return 0;\n    return 1;\n}"
  },
  {
    "function_name": "virConnectOpenAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "1219-1239",
    "snippet": "virConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpenInternal",
          "args": [
            "name",
            "auth",
            "flags"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "836-1117",
          "snippet": "static virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\n\nstatic virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s, auth=%p, flags=0x%x\"",
            "NULLSTR(name)",
            "auth",
            "flags"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
  },
  {
    "function_name": "virConnectOpenReadOnly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "1181-1199",
    "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpenInternal",
          "args": [
            "name",
            "NULL",
            "VIR_CONNECT_RO"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "836-1117",
          "snippet": "static virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\n\nstatic virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "NULLSTR(name)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
  },
  {
    "function_name": "virConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "1145-1163",
    "snippet": "virConnectPtr\nvirConnectOpen(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, 0);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpenInternal",
          "args": [
            "name",
            "NULL",
            "0"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "836-1117",
          "snippet": "static virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\n\nstatic virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "NULLSTR(name)"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpen(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, 0);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
  },
  {
    "function_name": "virConnectOpenInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "836-1117",
    "snippet": "static virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
      "static int virConnectDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uristr"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uristr"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CONNECT",
            "\"%s\"",
            "NULLSTR(name)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver %zu %s returned %s\"",
            "i",
            "virConnectDriverTab[i]->hypervisorDriver->name",
            "res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\"))"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectDriverTab[i]->hypervisorDriver->connectOpen",
          "args": [
            "ret",
            "auth",
            "conf",
            "flags"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"URI is missing the server part\")"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"URI is missing the server part\""
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Driver %s cannot be used in embedded mode\")",
            "virConnectDriverTab[i]->hypervisorDriver->name"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Matching any URI scheme for '%s'\"",
            "ret->uri ? ret->uri->scheme : \"\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping wildcard for embedded URI\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No matching URI scheme\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Matched URI scheme '%s'\"",
            "ret->uri->scheme"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ret->uri->scheme",
            "virConnectDriverTab[i]->uriSchemes[s]"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking for supported URI schemes\""
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ignoring non-embeddable driver %s\"",
            "virConnectDriverTab[i]->hypervisorDriver->name"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No URI, skipping driver with URI whitelist\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Server present, skipping local only driver\""
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"trying driver %zu (%s) ...\"",
            "i",
            "virConnectDriverTab[i]->hypervisorDriver->name"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportErrorHelper",
          "args": [
            "VIR_FROM_NONE",
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "__FILE__",
            "__FUNCTION__",
            "__LINE__",
            "_(\"libvirt was built without the '%s' driver\")",
            "ret->uri->scheme"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "ret->uri->scheme",
            "\"parallels\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "ret->uri->scheme",
            "\"hyperv\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "ret->uri->scheme",
            "\"gsx\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "ret->uri->scheme",
            "\"esx\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "ret->uri->scheme",
            "\"vpx\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virConnectDriverTab[i]->hypervisorDriver->name",
            "\"remote\""
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"no name, allowing driver auto-select\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStateInitialize",
          "args": [
            "geteuid() == 0",
            "true",
            "root",
            "NULL",
            "NULL"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "virStateInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "635-672",
          "snippet": "int\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "virAccessManagerSetDefault",
          "args": [
            "acl"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virAccessManagerSetDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/access/viraccessmanager.c",
          "lines": "78-83",
          "snippet": "void virAccessManagerSetDefault(virAccessManagerPtr mgr)\n{\n    virObjectUnref(virAccessManagerDefault);\n\n    virAccessManagerDefault = virObjectRef(mgr);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "# include \"viraccessdriverpolkit.h\"",
            "#include \"viraccessdriverstack.h\"",
            "#include \"viraccessdrivernop.h\"",
            "#include \"viraccessmanager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virAccessManagerPtr virAccessManagerDefault;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n# include \"viraccessdriverpolkit.h\"\n#include \"viraccessdriverstack.h\"\n#include \"viraccessdrivernop.h\"\n#include \"viraccessmanager.h\"\n#include <config.h>\n\nstatic virAccessManagerPtr virAccessManagerDefault;\n\nvoid virAccessManagerSetDefault(virAccessManagerPtr mgr)\n{\n    virObjectUnref(virAccessManagerDefault);\n\n    virAccessManagerDefault = virObjectRef(mgr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAccessManagerNew",
          "args": [
            "\"none\""
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "virAccessManagerNewStack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/access/viraccessmanager.c",
          "lines": "154-179",
          "snippet": "virAccessManagerPtr virAccessManagerNewStack(const char **names)\n{\n    virAccessManagerPtr manager = virAccessManagerNewDriver(&accessDriverStack);\n    size_t i;\n\n    if (!manager)\n        return NULL;\n\n    for (i = 0; names[i] != NULL; i++) {\n        virAccessManagerPtr child = virAccessManagerNew(names[i]);\n\n        if (!child)\n            goto error;\n\n        if (virAccessDriverStackAppend(manager, child) < 0) {\n            virObjectUnref(child);\n            goto error;\n        }\n    }\n\n    return manager;\n\n error:\n    virObjectUnref(manager);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "# include \"viraccessdriverpolkit.h\"",
            "#include \"viraccessdriverstack.h\"",
            "#include \"viraccessdrivernop.h\"",
            "#include \"viraccessmanager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n# include \"viraccessdriverpolkit.h\"\n#include \"viraccessdriverstack.h\"\n#include \"viraccessdrivernop.h\"\n#include \"viraccessmanager.h\"\n#include <config.h>\n\nvirAccessManagerPtr virAccessManagerNewStack(const char **names)\n{\n    virAccessManagerPtr manager = virAccessManagerNewDriver(&accessDriverStack);\n    size_t i;\n\n    if (!manager)\n        return NULL;\n\n    for (i = 0; names[i] != NULL; i++) {\n        virAccessManagerPtr child = virAccessManagerNew(names[i]);\n\n        if (!child)\n            goto error;\n\n        if (virAccessDriverStackAppend(manager, child) < 0) {\n            virObjectUnref(child);\n            goto error;\n        }\n    }\n\n    return manager;\n\n error:\n    virObjectUnref(manager);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAccessManagerGetDefault",
          "args": [],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "virAccessManagerGetDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/access/viraccessmanager.c",
          "lines": "66-75",
          "snippet": "virAccessManagerPtr virAccessManagerGetDefault(void)\n{\n    if (virAccessManagerDefault == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No access manager registered\"));\n        return NULL;\n    }\n\n    return virObjectRef(virAccessManagerDefault);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "# include \"viraccessdriverpolkit.h\"",
            "#include \"viraccessdriverstack.h\"",
            "#include \"viraccessdrivernop.h\"",
            "#include \"viraccessmanager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virAccessManagerPtr virAccessManagerDefault;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n# include \"viraccessdriverpolkit.h\"\n#include \"viraccessdriverstack.h\"\n#include \"viraccessdrivernop.h\"\n#include \"viraccessmanager.h\"\n#include <config.h>\n\nstatic virAccessManagerPtr virAccessManagerDefault;\n\nvirAccessManagerPtr virAccessManagerGetDefault(void)\n{\n    if (virAccessManagerDefault == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No access manager registered\"));\n        return NULL;\n    }\n\n    return virObjectRef(virAccessManagerDefault);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDriverLoadModule",
          "args": [
            "ret->uri->scheme",
            "regMethod",
            "false"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "virDriverLoadModule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "46-69",
          "snippet": "int\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\"\n\nint\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventRequireImpl",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRequireImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "271-280",
          "snippet": "int virEventRequireImpl(void)\n{\n    if (!addHandleImpl || !addTimeoutImpl) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"An event loop implementation must be registered\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;",
            "static virEventAddTimeoutFunc addTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\nstatic virEventAddTimeoutFunc addTimeoutImpl;\n\nint virEventRequireImpl(void)\n{\n    if (!addHandleImpl || !addTimeoutImpl) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"An event loop implementation must be registered\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIGetParam",
          "args": [
            "ret->uri",
            "\"root\""
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "virURIGetParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "380-393",
          "snippet": "const char *\nvirURIGetParam(virURIPtr uri, const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        if (STREQ(uri->params[i].name, name))\n            return uri->params[i].value;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"Missing URI parameter '%s'\"), name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nconst char *\nvirURIGetParam(virURIPtr uri, const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        if (STREQ(uri->params[i].name, name))\n            return uri->params[i].value;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"Missing URI parameter '%s'\"), name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CONNECT",
            "_(\"URI scheme '%s' for embedded driver is not valid\")",
            "ret->uri->scheme"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ret->uri->scheme"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "ret->uri->scheme",
            "\"abcdefghijklmnopqrstuvwxyz\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"URI path requests %s driver embedded mode\"",
            "ret->uri->scheme"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ret->uri->path",
            "\"/embed\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectCheckURIMissingSlash",
          "args": [
            "uristr",
            "ret->uri"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectCheckURIMissingSlash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "811-833",
          "snippet": "static int\nvirConnectCheckURIMissingSlash(const char *uristr, virURIPtr uri)\n{\n    if (!uri->path || !uri->server)\n        return 0;\n\n    /* To avoid false positives, only check drivers that mandate\n       a path component in the URI, like /system or /session */\n    if (STRNEQ(uri->scheme, \"qemu\") &&\n        STRNEQ(uri->scheme, \"vbox\") &&\n        STRNEQ(uri->scheme, \"vz\"))\n        return 0;\n\n    if (STREQ(uri->server, \"session\") ||\n        STREQ(uri->server, \"system\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid URI %s (maybe you want %s:///%s)\"),\n                       uristr, uri->scheme, uri->server);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirConnectCheckURIMissingSlash(const char *uristr, virURIPtr uri)\n{\n    if (!uri->path || !uri->server)\n        return 0;\n\n    /* To avoid false positives, only check drivers that mandate\n       a path component in the URI, like /system or /session */\n    if (STRNEQ(uri->scheme, \"qemu\") &&\n        STRNEQ(uri->scheme, \"vbox\") &&\n        STRNEQ(uri->scheme, \"vz\"))\n        return 0;\n\n    if (STREQ(uri->server, \"session\") ||\n        STREQ(uri->server, \"system\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid URI %s (maybe you want %s:///%s)\"),\n                       uristr, uri->scheme, uri->server);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CONNECT",
            "_(\"URI '%s' does not include a driver name\")",
            "name"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\"",
            "uristr",
            "NULLSTR(ret->uri->scheme)",
            "NULLSTR(ret->uri->server)",
            "NULLSTR(ret->uri->user)",
            "ret->uri->port",
            "ret->uri->path"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ret->uri->user"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ret->uri->server"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ret->uri->scheme"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "alias"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uristr"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uristr"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIResolveAlias",
          "args": [
            "conf",
            "uristr",
            "&alias"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "virURIResolveAlias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "358-377",
          "snippet": "int\nvirURIResolveAlias(virConfPtr conf, const char *alias, char **uri)\n{\n    int ret = -1;\n    char **aliases = NULL;\n\n    *uri = NULL;\n\n    if (virConfGetValueStringList(conf, \"uri_aliases\", false, &aliases) < 0)\n        return -1;\n\n    if (aliases && *aliases) {\n        ret = virURIFindAliasMatch(aliases, alias, uri);\n        virStringListFree(aliases);\n    } else {\n        ret = 0;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nint\nvirURIResolveAlias(virConfPtr conf, const char *alias, char **uri)\n{\n    int ret = -1;\n    char **aliases = NULL;\n\n    *uri = NULL;\n\n    if (virConfGetValueStringList(conf, \"uri_aliases\", false, &aliases) < 0)\n        return -1;\n\n    if (aliases && *aliases) {\n        ret = virURIFindAliasMatch(aliases, alias, uri);\n        virStringListFree(aliases);\n    } else {\n        ret = 0;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s driver URI probe returned '%s'\"",
            "virConnectDriverTab[i]->hypervisorDriver->name",
            "NULLSTR(uristr)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uristr"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectDriverTab[i]->hypervisorDriver->connectURIProbe",
          "args": [
            "&uristr"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Trying to probe for default URI\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectGetDefaultURI",
          "args": [
            "conf",
            "&uristr"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectGetDefaultURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "787-804",
          "snippet": "static int\nvirConnectGetDefaultURI(virConfPtr conf,\n                        char **name)\n{\n    const char *defname = getenv(\"LIBVIRT_DEFAULT_URI\");\n    if (defname && *defname) {\n        VIR_DEBUG(\"Using LIBVIRT_DEFAULT_URI '%s'\", defname);\n        *name = g_strdup(defname);\n    } else {\n        if (virConfGetValueString(conf, \"uri_default\", name) < 0)\n            return -1;\n\n        if (*name)\n            VIR_DEBUG(\"Using config file uri '%s'\", *name);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirConnectGetDefaultURI(virConfPtr conf,\n                        char **name)\n{\n    const char *defname = getenv(\"LIBVIRT_DEFAULT_URI\");\n    if (defname && *defname) {\n        VIR_DEBUG(\"Using LIBVIRT_DEFAULT_URI '%s'\", defname);\n        *name = g_strdup(defname);\n    } else {\n        if (virConfGetValueString(conf, \"uri_default\", name) < 0)\n            return -1;\n\n        if (*name)\n            VIR_DEBUG(\"Using config file uri '%s'\", *name);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"xen://\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "name",
            "\"xen\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfLoadConfig",
          "args": [
            "&conf",
            "\"libvirt.conf\""
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virConfLoadConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1517-1542",
          "snippet": "int\nvirConfLoadConfig(virConfPtr *conf, const char *name)\n{\n    char *path = NULL;\n    int ret = -1;\n\n    *conf = NULL;\n\n    if (!(path = virConfLoadConfigPath(name)))\n        goto cleanup;\n\n    if (!virFileExists(path)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Loading config file '%s'\", path);\n    if (!(*conf = virConfReadFile(path, 0)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfLoadConfig(virConfPtr *conf, const char *name)\n{\n    char *path = NULL;\n    int ret = -1;\n\n    *conf = NULL;\n\n    if (!(path = virConfLoadConfigPath(name)))\n        goto cleanup;\n\n    if (!virFileExists(path)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Loading config file '%s'\", path);\n    if (!(*conf = virConfReadFile(path, 0)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnect",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "189-192",
          "snippet": "virConnectPtr virGetConnectStorage(void)\n{\n    return virGetConnectGeneric(&connectStorage, \"storage\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectStorage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectStorage;\n\nvirConnectPtr virGetConnectStorage(void)\n{\n    return virGetConnectGeneric(&connectStorage, \"storage\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\n\nstatic virConnectPtr\nvirConnectOpenInternal(const char *name,\n                       virConnectAuthPtr auth,\n                       unsigned int flags)\n{\n    size_t i;\n    int res;\n    virConnectPtr ret;\n    g_autoptr(virConf) conf = NULL;\n    char *uristr = NULL;\n    bool embed = false;\n\n    ret = virGetConnect();\n    if (ret == NULL)\n        return NULL;\n\n    if (virConfLoadConfig(&conf, \"libvirt.conf\") < 0)\n        goto failed;\n\n    if (name && name[0] == '\\0')\n        name = NULL;\n\n    /* Convert xen -> xen:///system for back compat */\n    if (name && STRCASEEQ(name, \"xen\"))\n        name = \"xen:///system\";\n\n    /* Convert xen:// -> xen:///system because xmlParseURI cannot parse the\n     * former.  This allows URIs such as xen://localhost to work.\n     */\n    if (name && STREQ(name, \"xen://\"))\n        name = \"xen:///system\";\n\n    /*\n     * If no URI is passed, then check for an environment string if not\n     * available probe the compiled in drivers to find a default hypervisor\n     * if detectable.\n     */\n    if (name) {\n        uristr = g_strdup(name);\n    } else {\n        if (virConnectGetDefaultURI(conf, &uristr) < 0)\n            goto failed;\n\n        if (uristr == NULL) {\n            VIR_DEBUG(\"Trying to probe for default URI\");\n            for (i = 0; i < virConnectDriverTabCount && uristr == NULL; i++) {\n                if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe) {\n                    if (virConnectDriverTab[i]->hypervisorDriver->connectURIProbe(&uristr) < 0)\n                        goto failed;\n                    VIR_DEBUG(\"%s driver URI probe returned '%s'\",\n                              virConnectDriverTab[i]->hypervisorDriver->name,\n                              NULLSTR(uristr));\n                }\n            }\n        }\n    }\n\n    if (uristr) {\n        char *alias = NULL;\n\n        if (!(flags & VIR_CONNECT_NO_ALIASES) &&\n            virURIResolveAlias(conf, uristr, &alias) < 0)\n            goto failed;\n\n        if (alias) {\n            VIR_FREE(uristr);\n            uristr = alias;\n        }\n\n        if (!(ret->uri = virURIParse(uristr))) {\n            VIR_FREE(alias);\n            goto failed;\n        }\n\n        /* Avoid need for drivers to worry about NULLs, as\n         * no one needs to distinguish \"\" vs NULL */\n        if (ret->uri->path == NULL)\n            ret->uri->path = g_strdup(\"\");\n\n        VIR_DEBUG(\"Split \\\"%s\\\" to URI components:\\n\"\n                  \"  scheme %s\\n\"\n                  \"  server %s\\n\"\n                  \"  user %s\\n\"\n                  \"  port %d\\n\"\n                  \"  path %s\",\n                  uristr,\n                  NULLSTR(ret->uri->scheme), NULLSTR(ret->uri->server),\n                  NULLSTR(ret->uri->user), ret->uri->port,\n                  ret->uri->path);\n\n        if (ret->uri->scheme == NULL) {\n            virReportError(VIR_ERR_NO_CONNECT,\n                           _(\"URI '%s' does not include a driver name\"),\n                           name);\n            goto failed;\n        }\n\n        if (virConnectCheckURIMissingSlash(uristr,\n                                           ret->uri) < 0) {\n            goto failed;\n        }\n\n        if (STREQ(ret->uri->path, \"/embed\")) {\n            const char *root = NULL;\n            g_autofree char *regMethod = NULL;\n            VIR_DEBUG(\"URI path requests %s driver embedded mode\",\n                      ret->uri->scheme);\n            if (strspn(ret->uri->scheme, \"abcdefghijklmnopqrstuvwxyz\")  !=\n                strlen(ret->uri->scheme)) {\n                virReportError(VIR_ERR_NO_CONNECT,\n                               _(\"URI scheme '%s' for embedded driver is not valid\"),\n                               ret->uri->scheme);\n                goto failed;\n            }\n\n            root = virURIGetParam(ret->uri, \"root\");\n            if (!root)\n                goto failed;\n\n            if (virEventRequireImpl() < 0)\n                goto failed;\n\n            regMethod = g_strdup_printf(\"%sRegister\", ret->uri->scheme);\n\n            if (virDriverLoadModule(ret->uri->scheme, regMethod, false) < 0)\n                goto failed;\n\n            if (virAccessManagerGetDefault() == NULL) {\n                virAccessManagerPtr acl;\n\n                virResetLastError();\n\n                if (!(acl = virAccessManagerNew(\"none\")))\n                    goto failed;\n                virAccessManagerSetDefault(acl);\n            }\n\n            if (virStateInitialize(geteuid() == 0, true, root, NULL, NULL) < 0)\n                goto failed;\n\n            embed = true;\n        }\n    } else {\n        VIR_DEBUG(\"no name, allowing driver auto-select\");\n    }\n\n    /* Cleansing flags */\n    ret->flags = flags & VIR_CONNECT_RO;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        /* We're going to probe the remote driver next. So we have already\n         * probed all other client-side-only driver before, but none of them\n         * accepted the URI.\n         * If the scheme corresponds to a known but disabled client-side-only\n         * driver then report a useful error, instead of a cryptic one about\n         * not being able to connect to libvirtd or not being able to find\n         * certificates. */\n        if (STREQ(virConnectDriverTab[i]->hypervisorDriver->name, \"remote\") &&\n            ret->uri != NULL &&\n            (\n#ifndef WITH_ESX\n             STRCASEEQ(ret->uri->scheme, \"vpx\") ||\n             STRCASEEQ(ret->uri->scheme, \"esx\") ||\n             STRCASEEQ(ret->uri->scheme, \"gsx\") ||\n#endif\n#ifndef WITH_HYPERV\n             STRCASEEQ(ret->uri->scheme, \"hyperv\") ||\n#endif\n#ifndef WITH_VZ\n             STRCASEEQ(ret->uri->scheme, \"parallels\") ||\n#endif\n             false)) {\n            virReportErrorHelper(VIR_FROM_NONE, VIR_ERR_CONFIG_UNSUPPORTED,\n                                 __FILE__, __FUNCTION__, __LINE__,\n                                 _(\"libvirt was built without the '%s' driver\"),\n                                 ret->uri->scheme);\n            goto failed;\n        }\n\n        VIR_DEBUG(\"trying driver %zu (%s) ...\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name);\n\n        if (virConnectDriverTab[i]->localOnly && ret->uri && ret->uri->server) {\n            VIR_DEBUG(\"Server present, skipping local only driver\");\n            continue;\n        }\n\n        /* Filter drivers based on declared URI schemes */\n        if (virConnectDriverTab[i]->uriSchemes) {\n            bool matchScheme = false;\n            size_t s;\n            if (!ret->uri) {\n                VIR_DEBUG(\"No URI, skipping driver with URI whitelist\");\n                continue;\n            }\n            if (embed && !virConnectDriverTab[i]->embeddable) {\n                VIR_DEBUG(\"Ignoring non-embeddable driver %s\",\n                          virConnectDriverTab[i]->hypervisorDriver->name);\n                continue;\n            }\n\n            VIR_DEBUG(\"Checking for supported URI schemes\");\n            for (s = 0; virConnectDriverTab[i]->uriSchemes[s] != NULL; s++) {\n                if (STREQ(ret->uri->scheme, virConnectDriverTab[i]->uriSchemes[s])) {\n                    VIR_DEBUG(\"Matched URI scheme '%s'\", ret->uri->scheme);\n                    matchScheme = true;\n                    break;\n                }\n            }\n            if (!matchScheme) {\n                VIR_DEBUG(\"No matching URI scheme\");\n                continue;\n            }\n        } else {\n            if (embed) {\n                VIR_DEBUG(\"Skipping wildcard for embedded URI\");\n                continue;\n            } else {\n                VIR_DEBUG(\"Matching any URI scheme for '%s'\", ret->uri ? ret->uri->scheme : \"\");\n            }\n        }\n\n        if (embed && !virConnectDriverTab[i]->embeddable) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Driver %s cannot be used in embedded mode\"),\n                           virConnectDriverTab[i]->hypervisorDriver->name);\n            goto failed;\n        }\n        /* before starting the new connection, check if the driver only works\n         * with a server, and so return an error if the server is missing */\n        if (virConnectDriverTab[i]->remoteOnly && ret->uri && !ret->uri->server) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"URI is missing the server part\"));\n            goto failed;\n        }\n\n        ret->driver = virConnectDriverTab[i]->hypervisorDriver;\n        ret->interfaceDriver = virConnectDriverTab[i]->interfaceDriver;\n        ret->networkDriver = virConnectDriverTab[i]->networkDriver;\n        ret->nodeDeviceDriver = virConnectDriverTab[i]->nodeDeviceDriver;\n        ret->nwfilterDriver = virConnectDriverTab[i]->nwfilterDriver;\n        ret->secretDriver = virConnectDriverTab[i]->secretDriver;\n        ret->storageDriver = virConnectDriverTab[i]->storageDriver;\n\n        res = virConnectDriverTab[i]->hypervisorDriver->connectOpen(ret, auth, conf, flags);\n        VIR_DEBUG(\"driver %zu %s returned %s\",\n                  i, virConnectDriverTab[i]->hypervisorDriver->name,\n                  res == VIR_DRV_OPEN_SUCCESS ? \"SUCCESS\" :\n                  (res == VIR_DRV_OPEN_DECLINED ? \"DECLINED\" :\n                  (res == VIR_DRV_OPEN_ERROR ? \"ERROR\" : \"unknown status\")));\n\n        if (res == VIR_DRV_OPEN_SUCCESS) {\n            break;\n        } else {\n            ret->driver = NULL;\n            ret->interfaceDriver = NULL;\n            ret->networkDriver = NULL;\n            ret->nodeDeviceDriver = NULL;\n            ret->nwfilterDriver = NULL;\n            ret->secretDriver = NULL;\n            ret->storageDriver = NULL;\n\n            if (res == VIR_DRV_OPEN_ERROR)\n                goto failed;\n        }\n    }\n\n    if (!ret->driver) {\n        /* If we reach here, then all drivers declined the connection. */\n        virReportError(VIR_ERR_NO_CONNECT, \"%s\", NULLSTR(name));\n        goto failed;\n    }\n\n    VIR_FREE(uristr);\n\n    return ret;\n\n failed:\n    VIR_FREE(uristr);\n    virObjectUnref(ret);\n\n    return NULL;\n}"
  },
  {
    "function_name": "virConnectCheckURIMissingSlash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "811-833",
    "snippet": "static int\nvirConnectCheckURIMissingSlash(const char *uristr, virURIPtr uri)\n{\n    if (!uri->path || !uri->server)\n        return 0;\n\n    /* To avoid false positives, only check drivers that mandate\n       a path component in the URI, like /system or /session */\n    if (STRNEQ(uri->scheme, \"qemu\") &&\n        STRNEQ(uri->scheme, \"vbox\") &&\n        STRNEQ(uri->scheme, \"vz\"))\n        return 0;\n\n    if (STREQ(uri->server, \"session\") ||\n        STREQ(uri->server, \"system\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid URI %s (maybe you want %s:///%s)\"),\n                       uristr, uri->scheme, uri->server);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid URI %s (maybe you want %s:///%s)\")",
            "uristr",
            "uri->scheme",
            "uri->server"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid URI %s (maybe you want %s:///%s)\""
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "uri->server",
            "\"system\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "uri->server",
            "\"session\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uri->scheme",
            "\"vz\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uri->scheme",
            "\"vbox\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uri->scheme",
            "\"qemu\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirConnectCheckURIMissingSlash(const char *uristr, virURIPtr uri)\n{\n    if (!uri->path || !uri->server)\n        return 0;\n\n    /* To avoid false positives, only check drivers that mandate\n       a path component in the URI, like /system or /session */\n    if (STRNEQ(uri->scheme, \"qemu\") &&\n        STRNEQ(uri->scheme, \"vbox\") &&\n        STRNEQ(uri->scheme, \"vz\"))\n        return 0;\n\n    if (STREQ(uri->server, \"session\") ||\n        STREQ(uri->server, \"system\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"invalid URI %s (maybe you want %s:///%s)\"),\n                       uristr, uri->scheme, uri->server);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virConnectGetDefaultURI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "787-804",
    "snippet": "static int\nvirConnectGetDefaultURI(virConfPtr conf,\n                        char **name)\n{\n    const char *defname = getenv(\"LIBVIRT_DEFAULT_URI\");\n    if (defname && *defname) {\n        VIR_DEBUG(\"Using LIBVIRT_DEFAULT_URI '%s'\", defname);\n        *name = g_strdup(defname);\n    } else {\n        if (virConfGetValueString(conf, \"uri_default\", name) < 0)\n            return -1;\n\n        if (*name)\n            VIR_DEBUG(\"Using config file uri '%s'\", *name);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using config file uri '%s'\"",
            "*name"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "\"uri_default\"",
            "name"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "defname"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using LIBVIRT_DEFAULT_URI '%s'\"",
            "defname"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LIBVIRT_DEFAULT_URI\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirConnectGetDefaultURI(virConfPtr conf,\n                        char **name)\n{\n    const char *defname = getenv(\"LIBVIRT_DEFAULT_URI\");\n    if (defname && *defname) {\n        VIR_DEBUG(\"Using LIBVIRT_DEFAULT_URI '%s'\", defname);\n        *name = g_strdup(defname);\n    } else {\n        if (virConfGetValueString(conf, \"uri_default\", name) < 0)\n            return -1;\n\n        if (*name)\n            VIR_DEBUG(\"Using config file uri '%s'\", *name);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "763-784",
    "snippet": "int\nvirGetVersion(unsigned long *libVer, const char *type G_GNUC_UNUSED,\n              unsigned long *typeVer)\n{\n    if (virInitialize() < 0)\n        goto error;\n    VIR_DEBUG(\"libVir=%p, type=%s, typeVer=%p\", libVer, type, typeVer);\n\n    virResetLastError();\n    if (libVer == NULL)\n        goto error;\n    *libVer = LIBVIR_VERSION_NUMBER;\n\n    if (typeVer != NULL)\n        *typeVer = LIBVIR_VERSION_NUMBER;\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"libVir=%p, type=%s, typeVer=%p\"",
            "libVer",
            "type",
            "typeVer"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirGetVersion(unsigned long *libVer, const char *type G_GNUC_UNUSED,\n              unsigned long *typeVer)\n{\n    if (virInitialize() < 0)\n        goto error;\n    VIR_DEBUG(\"libVir=%p, type=%s, typeVer=%p\", libVer, type, typeVer);\n\n    virResetLastError();\n    if (libVer == NULL)\n        goto error;\n    *libVer = LIBVIR_VERSION_NUMBER;\n\n    if (typeVer != NULL)\n        *typeVer = LIBVIR_VERSION_NUMBER;\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}"
  },
  {
    "function_name": "virStateStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "726-738",
    "snippet": "int\nvirStateStop(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateStop &&\n            virStateDriverTab[i]->stateStop())\n            ret = 1;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
      "static int virStateDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStateDriverTab[i]->stateStop",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateStop(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateStop &&\n            virStateDriverTab[i]->stateStop())\n            ret = 1;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virStateReload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "704-716",
    "snippet": "int\nvirStateReload(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateReload &&\n            virStateDriverTab[i]->stateReload() < 0)\n            ret = -1;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
      "static int virStateDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStateDriverTab[i]->stateReload",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateReload(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateReload &&\n            virStateDriverTab[i]->stateReload() < 0)\n            ret = -1;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "682-694",
    "snippet": "int\nvirStateCleanup(void)\n{\n    int r;\n    int ret = 0;\n\n    for (r = virStateDriverTabCount - 1; r >= 0; r--) {\n        if (virStateDriverTab[r]->stateCleanup &&\n            virStateDriverTab[r]->stateCleanup() < 0)\n            ret = -1;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
      "static int virStateDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStateDriverTab[r]->stateCleanup",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateCleanup(void)\n{\n    int r;\n    int ret = 0;\n\n    for (r = virStateDriverTabCount - 1; r >= 0; r--) {\n        if (virStateDriverTab[r]->stateCleanup &&\n            virStateDriverTab[r]->stateCleanup() < 0)\n            ret = -1;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "635-672",
    "snippet": "int\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
      "static int virStateDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Initialization of mandatory %s state driver skipped\")",
            "virStateDriverTab[i]->name"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Initialization of mandatory %s state driver skipped\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Initialization of %s state driver failed: %s\")",
            "virStateDriverTab[i]->name",
            "virGetLastErrorMessage()"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"State init result %d (mandatory=%d)\"",
            "ret",
            "mandatory"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStateDriverTab[i]->stateInitialize",
          "args": [
            "privileged",
            "root",
            "callback",
            "opaque"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running global init for %s state driver\"",
            "virStateDriverTab[i]->name"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virRegisterStateDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "588-602",
    "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_DRIVERS 21"
    ],
    "globals_used": [
      "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
      "static int virStateDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Too many drivers, cannot register %s\")",
            "driver->name"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Too many drivers, cannot register %s\""
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
  },
  {
    "function_name": "virHasDriverForURIScheme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "562-578",
    "snippet": "bool\nvirHasDriverForURIScheme(const char *scheme)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        if (!virConnectDriverTab[i]->uriSchemes)\n            continue;\n        for (j = 0; virConnectDriverTab[i]->uriSchemes[j]; j++) {\n            if (STREQ(virConnectDriverTab[i]->uriSchemes[j], scheme))\n                return true;\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
      "static int virConnectDriverTabCount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virConnectDriverTab[i]->uriSchemes[j]",
            "scheme"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\n\nbool\nvirHasDriverForURIScheme(const char *scheme)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < virConnectDriverTabCount; i++) {\n        if (!virConnectDriverTab[i]->uriSchemes)\n            continue;\n        for (j = 0; virConnectDriverTab[i]->uriSchemes[j]; j++) {\n            if (STREQ(virConnectDriverTab[i]->uriSchemes[j], scheme))\n                return true;\n        }\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virRegisterConnectDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "515-550",
    "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_DRIVERS 21"
    ],
    "globals_used": [
      "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
      "static int virConnectDriverTabCount;",
      "static virNetworkDriverPtr virSharedNetworkDriver;",
      "static virInterfaceDriverPtr virSharedInterfaceDriver;",
      "static virStorageDriverPtr virSharedStorageDriver;",
      "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
      "static virSecretDriverPtr virSharedSecretDriver;",
      "static virNWFilterDriverPtr virSharedNWFilterDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as driver %d\"",
            "driver->hypervisorDriver->name",
            "virConnectDriverTabCount"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Too many drivers, cannot register %s\")",
            "driver->hypervisorDriver->name"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Too many drivers, cannot register %s\""
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p name=%s\"",
            "driver",
            "driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "driver->hypervisorDriver->name"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
  },
  {
    "function_name": "virSetSharedNWFilterDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "487-502",
    "snippet": "int\nvirSetSharedNWFilterDriver(virNWFilterDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNWFilterDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network filter driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network filter driver\", driver->name);\n\n    virSharedNWFilterDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNWFilterDriverPtr virSharedNWFilterDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as network filter driver\"",
            "driver->name"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A network filter driver is already registered\")"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A network filter driver is already registered\""
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirSetSharedNWFilterDriver(virNWFilterDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNWFilterDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network filter driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network filter driver\", driver->name);\n\n    virSharedNWFilterDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "virSetSharedSecretDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "461-476",
    "snippet": "int\nvirSetSharedSecretDriver(virSecretDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedSecretDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A secret driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as secret driver\", driver->name);\n\n    virSharedSecretDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virSecretDriverPtr virSharedSecretDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as secret driver\"",
            "driver->name"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A secret driver is already registered\")"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A secret driver is already registered\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virSecretDriverPtr virSharedSecretDriver;\n\nint\nvirSetSharedSecretDriver(virSecretDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedSecretDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A secret driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as secret driver\", driver->name);\n\n    virSharedSecretDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "virSetSharedNodeDeviceDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "435-450",
    "snippet": "int\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as device driver\"",
            "driver->name"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A node device driver is already registered\")"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A node device driver is already registered\""
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\n\nint\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "virSetSharedStorageDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "409-424",
    "snippet": "int\nvirSetSharedStorageDriver(virStorageDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedStorageDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A storage driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as storage driver\", driver->name);\n\n    virSharedStorageDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr virSharedStorageDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as storage driver\"",
            "driver->name"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A storage driver is already registered\")"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A storage driver is already registered\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStorageDriverPtr virSharedStorageDriver;\n\nint\nvirSetSharedStorageDriver(virStorageDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedStorageDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A storage driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as storage driver\", driver->name);\n\n    virSharedStorageDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "virSetSharedInterfaceDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "383-398",
    "snippet": "int\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDriverPtr virSharedInterfaceDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as interface driver\"",
            "driver->name"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A interface driver is already registered\")"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A interface driver is already registered\""
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\n\nint\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "virSetSharedNetworkDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "357-372",
    "snippet": "int\nvirSetSharedNetworkDriver(virNetworkDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNetworkDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network driver\", driver->name);\n\n    virSharedNetworkDriver = driver;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverPtr virSharedNetworkDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"registering %s as network driver\"",
            "driver->name"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"A network driver is already registered\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"A network driver is already registered\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "driver",
            "-1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverPtr virSharedNetworkDriver;\n\nint\nvirSetSharedNetworkDriver(virNetworkDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNetworkDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network driver\", driver->name);\n\n    virSharedNetworkDriver = driver;\n    return 0;\n}"
  },
  {
    "function_name": "DllMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "322-345",
    "snippet": "BOOL WINAPI\nDllMain(HINSTANCE instance G_GNUC_UNUSED,\n        DWORD reason,\n        LPVOID ignore G_GNUC_UNUSED)\n{\n    switch (reason) {\n    case DLL_PROCESS_ATTACH:\n        virInitialize();\n        break;\n\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n        /* Nothing todo in libvirt yet */\n        break;\n\n    case DLL_PROCESS_DETACH:\n        /* Don't bother releasing per-thread data\n           since (hopefully) windows cleans up\n           everything on process exit */\n        break;\n    }\n\n    return TRUE;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nBOOL WINAPI\nDllMain(HINSTANCE instance G_GNUC_UNUSED,\n        DWORD reason,\n        LPVOID ignore G_GNUC_UNUSED)\n{\n    switch (reason) {\n    case DLL_PROCESS_ATTACH:\n        virInitialize();\n        break;\n\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n        /* Nothing todo in libvirt yet */\n        break;\n\n    case DLL_PROCESS_DETACH:\n        /* Don't bother releasing per-thread data\n           since (hopefully) windows cleans up\n           everything on process exit */\n        break;\n    }\n\n    return TRUE;\n}"
  },
  {
    "function_name": "virInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "306-315",
    "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool virGlobalError;",
      "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virOnce",
          "args": [
            "&virGlobalOnce",
            "virGlobalInit"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virOnce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "40-43",
          "snippet": "int virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virGlobalInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "213-283",
    "snippet": "static void\nvirGlobalInit(void)\n{\n    /* It would be nice if we could trace the use of this call, to\n     * help diagnose in log files if a user calls something other than\n     * virConnectOpen first.  But we can't rely on VIR_DEBUG working\n     * until after initialization is complete, and since this is\n     * one-shot, we never get here again.  */\n    if (virErrorInitialize() < 0)\n        goto error;\n\n    virFileActivateDirOverrideForLib();\n\n    if (getuid() != geteuid() ||\n        getgid() != getegid()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libvirt.so is not safe to use from setuid/setgid programs\"));\n        goto error;\n    }\n\n    virLogSetFromEnv();\n\n    virNetTLSInit();\n\n#if WITH_CURL\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n#endif\n\n    VIR_DEBUG(\"register drivers\");\n\n    g_networking_init();\n\n#ifdef HAVE_LIBINTL_H\n    if (!bindtextdomain(PACKAGE, LOCALEDIR))\n        goto error;\n#endif /* HAVE_LIBINTL_H */\n\n    /*\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virConnectOpen.\n     */\n#ifdef WITH_TEST\n    if (testRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_OPENVZ\n    if (openvzRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_VMWARE\n    if (vmwareRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_ESX\n    if (esxRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_HYPERV\n    if (hypervRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_REMOTE\n    if (remoteRegister() == -1)\n        goto error;\n#endif\n\n    return;\n\n error:\n    virGlobalError = true;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool virGlobalError;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remoteRegister",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "remoteRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_driver.c",
          "lines": "8858-8868",
          "snippet": "int\nremoteRegister(void)\n{\n    if (virRegisterConnectDriver(&connect_driver,\n                                 false) < 0)\n        return -1;\n    if (virRegisterStateDriver(&state_driver) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_client_bodies.h\"",
            "#include \"lxc_client_bodies.h\"",
            "#include \"remote_client_bodies.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"virauth.h\"",
            "#include \"viruri.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"remote_driver.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"secret_event.h\"",
            "#include \"node_device_event.h\"",
            "#include \"storage_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetclientstream.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include \"virnetclient.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver connect_driver = {\n    .hypervisorDriver = &hypervisor_driver,\n    .interfaceDriver = &interface_driver,\n    .networkDriver = &network_driver,\n    .nodeDeviceDriver = &node_device_driver,\n    .nwfilterDriver = &nwfilter_driver,\n    .secretDriver = &secret_driver,\n    .storageDriver = &storage_driver,\n};",
            "static virStateDriver state_driver = {\n    .name = \"Remote\",\n    .stateInitialize = remoteStateInitialize,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_client_bodies.h\"\n#include \"lxc_client_bodies.h\"\n#include \"remote_client_bodies.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"virauth.h\"\n#include \"viruri.h\"\n#include \"virtypedparam.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"qemu_protocol.h\"\n#include \"lxc_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"remote_driver.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"secret_event.h\"\n#include \"node_device_event.h\"\n#include \"storage_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virnetclientstream.h\"\n#include \"virnetclientprogram.h\"\n#include \"virnetclient.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virConnectDriver connect_driver = {\n    .hypervisorDriver = &hypervisor_driver,\n    .interfaceDriver = &interface_driver,\n    .networkDriver = &network_driver,\n    .nodeDeviceDriver = &node_device_driver,\n    .nwfilterDriver = &nwfilter_driver,\n    .secretDriver = &secret_driver,\n    .storageDriver = &storage_driver,\n};\nstatic virStateDriver state_driver = {\n    .name = \"Remote\",\n    .stateInitialize = remoteStateInitialize,\n};\n\nint\nremoteRegister(void)\n{\n    if (virRegisterConnectDriver(&connect_driver,\n                                 false) < 0)\n        return -1;\n    if (virRegisterStateDriver(&state_driver) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervRegister",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "hypervRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_driver.c",
          "lines": "1638-1646",
          "snippet": "int\nhypervRegister(void)\n{\n    /* Forward openwsman errors and warnings to libvirt's logging */\n    debug_add_handler(hypervDebugHandler, DEBUG_LEVEL_WARNING, NULL);\n\n    return virRegisterConnectDriver(&hypervConnectDriver,\n                                    false);\n}",
          "includes": [
            "#include \"virkeycode.h\"",
            "#include \"virstring.h\"",
            "#include \"openwsman.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_util.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"hyperv_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver hypervConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"hyperv\", NULL },\n    .hypervisorDriver = &hypervHypervisorDriver,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeycode.h\"\n#include \"virstring.h\"\n#include \"openwsman.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_util.h\"\n#include \"hyperv_private.h\"\n#include \"hyperv_driver.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virConnectDriver hypervConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"hyperv\", NULL },\n    .hypervisorDriver = &hypervHypervisorDriver,\n};\n\nint\nhypervRegister(void)\n{\n    /* Forward openwsman errors and warnings to libvirt's logging */\n    debug_add_handler(hypervDebugHandler, DEBUG_LEVEL_WARNING, NULL);\n\n    return virRegisterConnectDriver(&hypervConnectDriver,\n                                    false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxRegister",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "esxRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "5164-5169",
          "snippet": "int\nesxRegister(void)\n{\n    return virRegisterConnectDriver(&esxConnectDriver,\n                                    false);\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver esxConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"vpx\", \"esx\", \"gsx\", NULL },\n    .hypervisorDriver = &esxHypervisorDriver,\n    .interfaceDriver = &esxInterfaceDriver,\n    .networkDriver = &esxNetworkDriver,\n    .storageDriver = &esxStorageDriver,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virConnectDriver esxConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"vpx\", \"esx\", \"gsx\", NULL },\n    .hypervisorDriver = &esxHypervisorDriver,\n    .interfaceDriver = &esxInterfaceDriver,\n    .networkDriver = &esxNetworkDriver,\n    .storageDriver = &esxStorageDriver,\n};\n\nint\nesxRegister(void)\n{\n    return virRegisterConnectDriver(&esxConnectDriver,\n                                    false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareRegister",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "1197-1202",
          "snippet": "int\nvmwareRegister(void)\n{\n    return virRegisterConnectDriver(&vmwareConnectDriver,\n                                    false);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver vmwareConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"vmwareplayer\", \"vmwarews\", \"vmwarefusion\", NULL },\n    .hypervisorDriver = &vmwareHypervisorDriver,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virConnectDriver vmwareConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"vmwareplayer\", \"vmwarews\", \"vmwarefusion\", NULL },\n    .hypervisorDriver = &vmwareHypervisorDriver,\n};\n\nint\nvmwareRegister(void)\n{\n    return virRegisterConnectDriver(&vmwareConnectDriver,\n                                    false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openvzRegister",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "openvzRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/openvz/openvz_driver.c",
          "lines": "2422-2426",
          "snippet": "int openvzRegister(void)\n{\n    return virRegisterConnectDriver(&openvzConnectDriver,\n                                    false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"viruri.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"openvz_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"openvz_util.h\"",
            "#include \"openvz_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver openvzConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"openvz\", NULL },\n    .hypervisorDriver = &openvzHypervisorDriver,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevtap.h\"\n#include \"viruri.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"openvz_conf.h\"\n#include \"virbuffer.h\"\n#include \"openvz_util.h\"\n#include \"openvz_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <pwd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virConnectDriver openvzConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"openvz\", NULL },\n    .hypervisorDriver = &openvzHypervisorDriver,\n};\n\nint openvzRegister(void)\n{\n    return virRegisterConnectDriver(&openvzConnectDriver,\n                                    false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "testRegister",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "testRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/test/test_driver.c",
          "lines": "9534-9539",
          "snippet": "int\ntestRegister(void)\n{\n    return virRegisterConnectDriver(&testConnectDriver,\n                                    false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"virauth.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virxml.h\"",
            "#include \"node_device_event.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"storage_event.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virfdstream.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"interface_conf.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"capabilities.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"test_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xmlsave.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectDriver testConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"test\", NULL },\n    .hypervisorDriver = &testHypervisorDriver,\n    .interfaceDriver = &testInterfaceDriver,\n    .networkDriver = &testNetworkDriver,\n    .nodeDeviceDriver = &testNodeDeviceDriver,\n    .nwfilterDriver = NULL,\n    .secretDriver = NULL,\n    .storageDriver = &testStorageDriver,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virkeycode.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virhostcpu.h\"\n#include \"virinterfaceobj.h\"\n#include \"virdomainobjlist.h\"\n#include \"virauth.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virxml.h\"\n#include \"node_device_event.h\"\n#include \"virnodedeviceobj.h\"\n#include \"node_device_conf.h\"\n#include \"storage_event.h\"\n#include \"virstorageobj.h\"\n#include \"storage_conf.h\"\n#include \"virfdstream.h\"\n#include \"snapshot_conf.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"interface_conf.h\"\n#include \"virnetworkobj.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"capabilities.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"test_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <libxml/xmlsave.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virConnectDriver testConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"test\", NULL },\n    .hypervisorDriver = &testHypervisorDriver,\n    .interfaceDriver = &testInterfaceDriver,\n    .networkDriver = &testNetworkDriver,\n    .nodeDeviceDriver = &testNodeDeviceDriver,\n    .nwfilterDriver = NULL,\n    .secretDriver = NULL,\n    .storageDriver = &testStorageDriver,\n};\n\nint\ntestRegister(void)\n{\n    return virRegisterConnectDriver(&testConnectDriver,\n                                    false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bindtextdomain",
          "args": [
            "PACKAGE",
            "LOCALEDIR"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_networking_init",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"register drivers\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_global_init",
          "args": [
            "CURL_GLOBAL_DEFAULT"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSInit",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1441-1454",
          "snippet": "void virNetTLSInit(void)\n{\n    const char *gnutlsdebug;\n    if ((gnutlsdebug = getenv(\"LIBVIRT_GNUTLS_DEBUG\")) != NULL) {\n        int val;\n        if (virStrToLong_i(gnutlsdebug, NULL, 10, &val) < 0)\n            val = 10;\n        gnutls_global_set_log_level(val);\n        gnutls_global_set_log_function(virNetTLSLog);\n        VIR_DEBUG(\"Enabled GNUTLS debug\");\n    }\n\n    gnutls_global_init();\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetTLSInit(void)\n{\n    const char *gnutlsdebug;\n    if ((gnutlsdebug = getenv(\"LIBVIRT_GNUTLS_DEBUG\")) != NULL) {\n        int val;\n        if (virStrToLong_i(gnutlsdebug, NULL, 10, &val) < 0)\n            val = 10;\n        gnutls_global_set_log_level(val);\n        gnutls_global_set_log_function(virNetTLSLog);\n        VIR_DEBUG(\"Enabled GNUTLS debug\");\n    }\n\n    gnutls_global_init();\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetFromEnv",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFromEnv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1208-1225",
          "snippet": "void\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libvirt.so is not safe to use from setuid/setgid programs\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libvirt.so is not safe to use from setuid/setgid programs\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "getegid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "78-79",
          "snippet": "static inline int getegid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int getegid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "getgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "73-74",
          "snippet": "static inline int getgid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int getgid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "getuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "63-64",
          "snippet": "static inline int getuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int getuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "virFileActivateDirOverrideForLib",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virFileActivateDirOverrideForLib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1809-1814",
          "snippet": "void\nvirFileActivateDirOverrideForLib(void)\n{\n    if (getenv(\"LIBVIRT_DIR_OVERRIDE\") != NULL)\n        useDirOverride = true;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nvoid\nvirFileActivateDirOverrideForLib(void)\n{\n    if (getenv(\"LIBVIRT_DIR_OVERRIDE\") != NULL)\n        useDirOverride = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorInitialize",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "172-176",
          "snippet": "int\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal virLastErr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirThreadLocal virLastErr;\n\nint\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\n\nstatic void\nvirGlobalInit(void)\n{\n    /* It would be nice if we could trace the use of this call, to\n     * help diagnose in log files if a user calls something other than\n     * virConnectOpen first.  But we can't rely on VIR_DEBUG working\n     * until after initialization is complete, and since this is\n     * one-shot, we never get here again.  */\n    if (virErrorInitialize() < 0)\n        goto error;\n\n    virFileActivateDirOverrideForLib();\n\n    if (getuid() != geteuid() ||\n        getgid() != getegid()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libvirt.so is not safe to use from setuid/setgid programs\"));\n        goto error;\n    }\n\n    virLogSetFromEnv();\n\n    virNetTLSInit();\n\n#if WITH_CURL\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n#endif\n\n    VIR_DEBUG(\"register drivers\");\n\n    g_networking_init();\n\n#ifdef HAVE_LIBINTL_H\n    if (!bindtextdomain(PACKAGE, LOCALEDIR))\n        goto error;\n#endif /* HAVE_LIBINTL_H */\n\n    /*\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virConnectOpen.\n     */\n#ifdef WITH_TEST\n    if (testRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_OPENVZ\n    if (openvzRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_VMWARE\n    if (vmwareRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_ESX\n    if (esxRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_HYPERV\n    if (hypervRegister() == -1)\n        goto error;\n#endif\n#ifdef WITH_REMOTE\n    if (remoteRegister() == -1)\n        goto error;\n#endif\n\n    return;\n\n error:\n    virGlobalError = true;\n}"
  },
  {
    "function_name": "virConnectAuthCallbackDefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
    "lines": "105-175",
    "snippet": "static int\nvirConnectAuthCallbackDefault(virConnectCredentialPtr cred,\n                              unsigned int ncred,\n                              void *cbdata G_GNUC_UNUSED)\n{\n    size_t i;\n\n    for (i = 0; i < ncred; i++) {\n        char buf[1024];\n        char *bufptr = NULL;\n        size_t len;\n\n        switch (cred[i].type) {\n        case VIR_CRED_EXTERNAL: {\n            if (STRNEQ(cred[i].challenge, \"PolicyKit\"))\n                return -1;\n\n            /*\n             * Ignore & carry on. Although we can't auth\n             * directly, the user may have authenticated\n             * themselves already outside context of libvirt\n             */\n            break;\n        }\n\n        case VIR_CRED_USERNAME:\n        case VIR_CRED_AUTHNAME:\n        case VIR_CRED_ECHOPROMPT:\n        case VIR_CRED_REALM:\n            if (printf(\"%s: \", cred[i].prompt) < 0)\n                return -1;\n            if (fflush(stdout) != 0)\n                return -1;\n\n            if (!fgets(buf, sizeof(buf), stdin)) {\n                if (feof(stdin)) { /* Treat EOF as \"\" */\n                    break;\n                }\n                return -1;\n            }\n\n            len = strlen(buf);\n            if (len != 0 && buf[len-1] == '\\n')\n                buf[len-1] = '\\0';\n            bufptr = g_strdup(buf);\n            break;\n\n        case VIR_CRED_PASSPHRASE:\n        case VIR_CRED_NOECHOPROMPT:\n            if (printf(\"%s: \", cred[i].prompt) < 0)\n                return -1;\n            if (fflush(stdout) != 0)\n                return -1;\n\n            bufptr = virGetPassword();\n            if (STREQ(bufptr, \"\"))\n                VIR_FREE(bufptr);\n            break;\n\n        default:\n            return -1;\n        }\n\n        if (cred[i].type != VIR_CRED_EXTERNAL) {\n            cred[i].result = bufptr ? bufptr : g_strdup(cred[i].defresult ? cred[i].defresult : \"\");\n            cred[i].resultlen = strlen(cred[i].result);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"access/viraccessmanager.h\"",
      "# include \"bhyve/bhyve_driver.h\"",
      "# include \"hyperv/hyperv_driver.h\"",
      "# include \"esx/esx_driver.h\"",
      "# include \"vmware/vmware_driver.h\"",
      "# include \"openvz/openvz_driver.h\"",
      "# include \"remote/remote_driver.h\"",
      "# include \"test/test_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"viruri.h\"",
      "#include \"virrandom.h\"",
      "#include \"virfile.h\"",
      "#include \"virevent.h\"",
      "#include \"vircommand.h\"",
      "#include \"rpc/virnettlscontext.h\"",
      "#include \"virconf.h\"",
      "#include \"configmake.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "# include <curl/curl.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/parser.h>",
      "#include <gio/gnetworking.h>",
      "#include <time.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cred[i].result"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "cred[i].defresult ? cred[i].defresult : \"\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bufptr"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "bufptr",
            "\"\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetPassword",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virGetPassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1736-1753",
          "snippet": "char *virGetPassword(void)\n{\n#ifdef WIN32\n    GString *pw = g_string_new(\"\");\n\n    while (1) {\n        char c = _getch();\n        if (c == '\\r')\n            break;\n\n        g_string_append_c(pw, c);\n    }\n\n    return g_string_free(pw, FALSE);\n#else /* !WIN32 */\n    return g_strdup(getpass(\"\"));\n#endif /* ! WIN32 */\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetPassword(void)\n{\n#ifdef WIN32\n    GString *pw = g_string_new(\"\");\n\n    while (1) {\n        char c = _getch();\n        if (c == '\\r')\n            break;\n\n        g_string_append_c(pw, c);\n    }\n\n    return g_string_free(pw, FALSE);\n#else /* !WIN32 */\n    return g_strdup(getpass(\"\"));\n#endif /* ! WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: \"",
            "cred[i].prompt"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "stdin"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "stdin"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cred[i].challenge",
            "\"PolicyKit\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirConnectAuthCallbackDefault(virConnectCredentialPtr cred,\n                              unsigned int ncred,\n                              void *cbdata G_GNUC_UNUSED)\n{\n    size_t i;\n\n    for (i = 0; i < ncred; i++) {\n        char buf[1024];\n        char *bufptr = NULL;\n        size_t len;\n\n        switch (cred[i].type) {\n        case VIR_CRED_EXTERNAL: {\n            if (STRNEQ(cred[i].challenge, \"PolicyKit\"))\n                return -1;\n\n            /*\n             * Ignore & carry on. Although we can't auth\n             * directly, the user may have authenticated\n             * themselves already outside context of libvirt\n             */\n            break;\n        }\n\n        case VIR_CRED_USERNAME:\n        case VIR_CRED_AUTHNAME:\n        case VIR_CRED_ECHOPROMPT:\n        case VIR_CRED_REALM:\n            if (printf(\"%s: \", cred[i].prompt) < 0)\n                return -1;\n            if (fflush(stdout) != 0)\n                return -1;\n\n            if (!fgets(buf, sizeof(buf), stdin)) {\n                if (feof(stdin)) { /* Treat EOF as \"\" */\n                    break;\n                }\n                return -1;\n            }\n\n            len = strlen(buf);\n            if (len != 0 && buf[len-1] == '\\n')\n                buf[len-1] = '\\0';\n            bufptr = g_strdup(buf);\n            break;\n\n        case VIR_CRED_PASSPHRASE:\n        case VIR_CRED_NOECHOPROMPT:\n            if (printf(\"%s: \", cred[i].prompt) < 0)\n                return -1;\n            if (fflush(stdout) != 0)\n                return -1;\n\n            bufptr = virGetPassword();\n            if (STREQ(bufptr, \"\"))\n                VIR_FREE(bufptr);\n            break;\n\n        default:\n            return -1;\n        }\n\n        if (cred[i].type != VIR_CRED_EXTERNAL) {\n            cred[i].result = bufptr ? bufptr : g_strdup(cred[i].defresult ? cred[i].defresult : \"\");\n            cred[i].resultlen = strlen(cred[i].result);\n        }\n    }\n\n    return 0;\n}"
  }
]