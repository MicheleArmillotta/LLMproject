[
  {
    "function_name": "vboxArrayUnalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "341-361",
    "snippet": "void\nvboxArrayUnalloc(vboxArray *array)\n{\n    size_t i;\n    void *item;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        item = array->items[i];\n\n        if (item != NULL)\n            pVBoxFuncs_v2_2->pfnComUnallocMem(item);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pVBoxFuncs_v2_2->pfnComUnallocMem",
          "args": [
            "array->items"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pVBoxFuncs_v2_2->pfnComUnallocMem",
          "args": [
            "item"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayUnalloc(vboxArray *array)\n{\n    size_t i;\n    void *item;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        item = array->items[i];\n\n        if (item != NULL)\n            pVBoxFuncs_v2_2->pfnComUnallocMem(item);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
  },
  {
    "function_name": "vboxArrayRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "316-336",
    "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pVBoxFuncs_v2_2->pfnComUnallocMem",
          "args": [
            "array->items"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supports->vtbl->Release",
          "args": [
            "supports"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
  },
  {
    "function_name": "vboxArrayGetWithUintArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "301-311",
    "snippet": "nsresult\nvboxArrayGetWithUintArg(vboxArray *array, void *self, void *getter, PRUint32 arg)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetterWithUintArg)getter)(self, arg, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxArrayGetHelper",
          "args": [
            "array",
            "nsrc",
            "items",
            "count"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGetHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "250-263",
          "snippet": "static nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "self",
            "arg",
            "&count",
            "&items"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGetWithUintArg(vboxArray *array, void *self, void *getter, PRUint32 arg)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetterWithUintArg)getter)(self, arg, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
  },
  {
    "function_name": "vboxArrayGetWithPtrArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "285-295",
    "snippet": "nsresult\nvboxArrayGetWithPtrArg(vboxArray *array, void *self, void *getter, void *arg)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetterWithPtrArg)getter)(self, arg, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxArrayGetHelper",
          "args": [
            "array",
            "nsrc",
            "items",
            "count"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGetHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "250-263",
          "snippet": "static nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "self",
            "arg",
            "&count",
            "&items"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGetWithPtrArg(vboxArray *array, void *self, void *getter, void *arg)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetterWithPtrArg)getter)(self, arg, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
  },
  {
    "function_name": "vboxArrayGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "269-279",
    "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxArrayGetHelper",
          "args": [
            "array",
            "nsrc",
            "items",
            "count"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGetHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "250-263",
          "snippet": "static nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "self",
            "&count",
            "&items"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
  },
  {
    "function_name": "vboxArrayGetHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "250-263",
    "snippet": "static nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "nsrc"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic nsresult\nvboxArrayGetHelper(vboxArray *array, nsresult nsrc, void **items, PRUint32 count)\n{\n    array->items = NULL;\n    array->count = 0;\n\n    if (NS_FAILED(nsrc))\n        return nsrc;\n\n    array->items = items;\n    array->count = count;\n\n    return nsrc;\n}"
  },
  {
    "function_name": "VBoxCGlueTerm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "223-235",
    "snippet": "void\nVBoxCGlueTerm(void)\n{\n    if (hVBoxXPCOMC != NULL) {\n#if 0 /* VBoxRT.so doesn't like being reloaded. See @bugref{3725}. */\n        dlclose(g_hVBoxXPCOMC);\n#endif\n        hVBoxXPCOMC = NULL;\n    }\n\n    pVBoxFuncs_v2_2 = NULL;\n    g_pfnGetFunctions = NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *hVBoxXPCOMC;",
      "static PCVBOXXPCOM pVBoxFuncs_v2_2;",
      "PFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlclose",
          "args": [
            "g_hVBoxXPCOMC"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic void *hVBoxXPCOMC;\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\nPFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;\n\nvoid\nVBoxCGlueTerm(void)\n{\n    if (hVBoxXPCOMC != NULL) {\n#if 0 /* VBoxRT.so doesn't like being reloaded. See @bugref{3725}. */\n        dlclose(g_hVBoxXPCOMC);\n#endif\n        hVBoxXPCOMC = NULL;\n    }\n\n    pVBoxFuncs_v2_2 = NULL;\n    g_pfnGetFunctions = NULL;\n}"
  },
  {
    "function_name": "VBoxCGlueInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "171-217",
    "snippet": "int\nVBoxCGlueInit(unsigned int *version)\n{\n    size_t i;\n    static const char *knownDirs[] = {\n        \"/usr/lib/virtualbox\",\n        \"/usr/lib/virtualbox-ose\",\n        \"/usr/lib64/virtualbox\",\n        \"/usr/lib64/virtualbox-ose\",\n        \"/usr/lib/VirtualBox\",\n        \"/opt/virtualbox\",\n        \"/opt/VirtualBox\",\n        \"/opt/virtualbox/i386\",\n        \"/opt/VirtualBox/i386\",\n        \"/opt/virtualbox/amd64\",\n        \"/opt/VirtualBox/amd64\",\n        \"/usr/local/lib/virtualbox\",\n        \"/usr/local/lib/VirtualBox\",\n        \"/Applications/VirtualBox.app/Contents/MacOS\"\n    };\n    const char *home = getenv(\"VBOX_APP_HOME\");\n\n    /* If the user specifies the location, try only that. */\n    if (home != NULL) {\n        if (tryLoadOne(home, false, false, version) < 0)\n            return -1;\n    }\n\n    /* Try the additionally configured location. */\n    if (VBOX_XPCOMC_DIR[0] != '\\0') {\n        if (tryLoadOne(VBOX_XPCOMC_DIR, true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Try the known locations. */\n    for (i = 0; i < G_N_ELEMENTS(knownDirs); ++i) {\n        if (tryLoadOne(knownDirs[i], true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Finally try the dynamic linker search path. */\n    if (tryLoadOne(NULL, false, true, version) >= 0)\n        return 0;\n\n    /* No luck, return failure. */\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tryLoadOne",
          "args": [
            "NULL",
            "false",
            "true",
            "version"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "tryLoadOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "79-162",
          "snippet": "static int\ntryLoadOne(const char *dir, bool setAppHome, bool ignoreMissing,\n           unsigned int *version)\n{\n    int result = -1;\n    char *name = NULL;\n    PFNVBOXGETXPCOMCFUNCTIONS pfnGetFunctions;\n\n    if (dir != NULL) {\n        name = g_strdup_printf(\"%s/%s\", dir, DYNLIB_NAME);\n\n        if (!virFileExists(name)) {\n            if (!ignoreMissing)\n                VIR_ERROR(_(\"Library '%s' doesn't exist\"), name);\n\n            VIR_FREE(name);\n            return -1;\n        }\n    } else {\n        name = g_strdup(DYNLIB_NAME);\n    }\n\n    /*\n     * Try load it by that name, setting the VBOX_APP_HOME first (for now).\n     * Then resolve and call the function table getter.\n     */\n    if (setAppHome) {\n        if (dir != NULL) {\n            g_setenv(\"VBOX_APP_HOME\", dir, TRUE);\n        } else {\n            g_unsetenv(\"VBOX_APP_HOME\");\n        }\n    }\n\n    hVBoxXPCOMC = dlopen(name, RTLD_NOW | RTLD_LOCAL);\n\n    if (hVBoxXPCOMC == NULL) {\n        /*\n         * FIXME: Don't warn in this case as it currently breaks make check\n         *        on systems without VirtualBox.\n         */\n        if (dir != NULL)\n            VIR_WARN(\"Could not dlopen '%s': %s\", name, dlerror());\n\n        goto cleanup;\n    }\n\n    pfnGetFunctions = (PFNVBOXGETXPCOMCFUNCTIONS)\n        dlsym(hVBoxXPCOMC, VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME);\n\n    if (pfnGetFunctions == NULL) {\n        VIR_ERROR(_(\"Could not dlsym %s from '%s': %s\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name, dlerror());\n        goto cleanup;\n    }\n\n    pVBoxFuncs_v2_2 = pfnGetFunctions(VBOX_XPCOMC_VERSION);\n\n    if (pVBoxFuncs_v2_2 == NULL) {\n        VIR_ERROR(_(\"Calling %s from '%s' failed\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name);\n        goto cleanup;\n    }\n\n    *version = pVBoxFuncs_v2_2->pfnGetVersion();\n    g_pfnGetFunctions = pfnGetFunctions;\n    result = 0;\n\n    if (dir != NULL) {\n        VIR_DEBUG(\"Found %s in '%s'\", DYNLIB_NAME, dir);\n    } else {\n        VIR_DEBUG(\"Found %s in dynamic linker search path\", DYNLIB_NAME);\n    }\n\n cleanup:\n    if (hVBoxXPCOMC != NULL && result < 0) {\n        dlclose(hVBoxXPCOMC);\n        hVBoxXPCOMC = NULL;\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *hVBoxXPCOMC;",
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;",
            "PFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic void *hVBoxXPCOMC;\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\nPFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;\n\nstatic int\ntryLoadOne(const char *dir, bool setAppHome, bool ignoreMissing,\n           unsigned int *version)\n{\n    int result = -1;\n    char *name = NULL;\n    PFNVBOXGETXPCOMCFUNCTIONS pfnGetFunctions;\n\n    if (dir != NULL) {\n        name = g_strdup_printf(\"%s/%s\", dir, DYNLIB_NAME);\n\n        if (!virFileExists(name)) {\n            if (!ignoreMissing)\n                VIR_ERROR(_(\"Library '%s' doesn't exist\"), name);\n\n            VIR_FREE(name);\n            return -1;\n        }\n    } else {\n        name = g_strdup(DYNLIB_NAME);\n    }\n\n    /*\n     * Try load it by that name, setting the VBOX_APP_HOME first (for now).\n     * Then resolve and call the function table getter.\n     */\n    if (setAppHome) {\n        if (dir != NULL) {\n            g_setenv(\"VBOX_APP_HOME\", dir, TRUE);\n        } else {\n            g_unsetenv(\"VBOX_APP_HOME\");\n        }\n    }\n\n    hVBoxXPCOMC = dlopen(name, RTLD_NOW | RTLD_LOCAL);\n\n    if (hVBoxXPCOMC == NULL) {\n        /*\n         * FIXME: Don't warn in this case as it currently breaks make check\n         *        on systems without VirtualBox.\n         */\n        if (dir != NULL)\n            VIR_WARN(\"Could not dlopen '%s': %s\", name, dlerror());\n\n        goto cleanup;\n    }\n\n    pfnGetFunctions = (PFNVBOXGETXPCOMCFUNCTIONS)\n        dlsym(hVBoxXPCOMC, VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME);\n\n    if (pfnGetFunctions == NULL) {\n        VIR_ERROR(_(\"Could not dlsym %s from '%s': %s\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name, dlerror());\n        goto cleanup;\n    }\n\n    pVBoxFuncs_v2_2 = pfnGetFunctions(VBOX_XPCOMC_VERSION);\n\n    if (pVBoxFuncs_v2_2 == NULL) {\n        VIR_ERROR(_(\"Calling %s from '%s' failed\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name);\n        goto cleanup;\n    }\n\n    *version = pVBoxFuncs_v2_2->pfnGetVersion();\n    g_pfnGetFunctions = pfnGetFunctions;\n    result = 0;\n\n    if (dir != NULL) {\n        VIR_DEBUG(\"Found %s in '%s'\", DYNLIB_NAME, dir);\n    } else {\n        VIR_DEBUG(\"Found %s in dynamic linker search path\", DYNLIB_NAME);\n    }\n\n cleanup:\n    if (hVBoxXPCOMC != NULL && result < 0) {\n        dlclose(hVBoxXPCOMC);\n        hVBoxXPCOMC = NULL;\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "knownDirs"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"VBOX_APP_HOME\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nint\nVBoxCGlueInit(unsigned int *version)\n{\n    size_t i;\n    static const char *knownDirs[] = {\n        \"/usr/lib/virtualbox\",\n        \"/usr/lib/virtualbox-ose\",\n        \"/usr/lib64/virtualbox\",\n        \"/usr/lib64/virtualbox-ose\",\n        \"/usr/lib/VirtualBox\",\n        \"/opt/virtualbox\",\n        \"/opt/VirtualBox\",\n        \"/opt/virtualbox/i386\",\n        \"/opt/VirtualBox/i386\",\n        \"/opt/virtualbox/amd64\",\n        \"/opt/VirtualBox/amd64\",\n        \"/usr/local/lib/virtualbox\",\n        \"/usr/local/lib/VirtualBox\",\n        \"/Applications/VirtualBox.app/Contents/MacOS\"\n    };\n    const char *home = getenv(\"VBOX_APP_HOME\");\n\n    /* If the user specifies the location, try only that. */\n    if (home != NULL) {\n        if (tryLoadOne(home, false, false, version) < 0)\n            return -1;\n    }\n\n    /* Try the additionally configured location. */\n    if (VBOX_XPCOMC_DIR[0] != '\\0') {\n        if (tryLoadOne(VBOX_XPCOMC_DIR, true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Try the known locations. */\n    for (i = 0; i < G_N_ELEMENTS(knownDirs); ++i) {\n        if (tryLoadOne(knownDirs[i], true, true, version) >= 0)\n            return 0;\n    }\n\n    /* Finally try the dynamic linker search path. */\n    if (tryLoadOne(NULL, false, true, version) >= 0)\n        return 0;\n\n    /* No luck, return failure. */\n    return -1;\n}"
  },
  {
    "function_name": "tryLoadOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
    "lines": "79-162",
    "snippet": "static int\ntryLoadOne(const char *dir, bool setAppHome, bool ignoreMissing,\n           unsigned int *version)\n{\n    int result = -1;\n    char *name = NULL;\n    PFNVBOXGETXPCOMCFUNCTIONS pfnGetFunctions;\n\n    if (dir != NULL) {\n        name = g_strdup_printf(\"%s/%s\", dir, DYNLIB_NAME);\n\n        if (!virFileExists(name)) {\n            if (!ignoreMissing)\n                VIR_ERROR(_(\"Library '%s' doesn't exist\"), name);\n\n            VIR_FREE(name);\n            return -1;\n        }\n    } else {\n        name = g_strdup(DYNLIB_NAME);\n    }\n\n    /*\n     * Try load it by that name, setting the VBOX_APP_HOME first (for now).\n     * Then resolve and call the function table getter.\n     */\n    if (setAppHome) {\n        if (dir != NULL) {\n            g_setenv(\"VBOX_APP_HOME\", dir, TRUE);\n        } else {\n            g_unsetenv(\"VBOX_APP_HOME\");\n        }\n    }\n\n    hVBoxXPCOMC = dlopen(name, RTLD_NOW | RTLD_LOCAL);\n\n    if (hVBoxXPCOMC == NULL) {\n        /*\n         * FIXME: Don't warn in this case as it currently breaks make check\n         *        on systems without VirtualBox.\n         */\n        if (dir != NULL)\n            VIR_WARN(\"Could not dlopen '%s': %s\", name, dlerror());\n\n        goto cleanup;\n    }\n\n    pfnGetFunctions = (PFNVBOXGETXPCOMCFUNCTIONS)\n        dlsym(hVBoxXPCOMC, VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME);\n\n    if (pfnGetFunctions == NULL) {\n        VIR_ERROR(_(\"Could not dlsym %s from '%s': %s\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name, dlerror());\n        goto cleanup;\n    }\n\n    pVBoxFuncs_v2_2 = pfnGetFunctions(VBOX_XPCOMC_VERSION);\n\n    if (pVBoxFuncs_v2_2 == NULL) {\n        VIR_ERROR(_(\"Calling %s from '%s' failed\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name);\n        goto cleanup;\n    }\n\n    *version = pVBoxFuncs_v2_2->pfnGetVersion();\n    g_pfnGetFunctions = pfnGetFunctions;\n    result = 0;\n\n    if (dir != NULL) {\n        VIR_DEBUG(\"Found %s in '%s'\", DYNLIB_NAME, dir);\n    } else {\n        VIR_DEBUG(\"Found %s in dynamic linker search path\", DYNLIB_NAME);\n    }\n\n cleanup:\n    if (hVBoxXPCOMC != NULL && result < 0) {\n        dlclose(hVBoxXPCOMC);\n        hVBoxXPCOMC = NULL;\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"vbox_XPCOMCGlue.h\"",
      "#include <dlfcn.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *hVBoxXPCOMC;",
      "static PCVBOXXPCOM pVBoxFuncs_v2_2;",
      "PFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlclose",
          "args": [
            "hVBoxXPCOMC"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found %s in dynamic linker search path\"",
            "DYNLIB_NAME"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found %s in '%s'\"",
            "DYNLIB_NAME",
            "dir"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pVBoxFuncs_v2_2->pfnGetVersion",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Calling %s from '%s' failed\")",
            "VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME",
            "name"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Calling %s from '%s' failed\""
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfnGetFunctions",
          "args": [
            "VBOX_XPCOMC_VERSION"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Could not dlsym %s from '%s': %s\")",
            "VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME",
            "name",
            "dlerror()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlerror",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "hVBoxXPCOMC",
            "VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not dlopen '%s': %s\"",
            "name",
            "dlerror()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlerror",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlopen",
          "args": [
            "name",
            "RTLD_NOW | RTLD_LOCAL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_unsetenv",
          "args": [
            "\"VBOX_APP_HOME\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_setenv",
          "args": [
            "\"VBOX_APP_HOME\"",
            "dir",
            "TRUE"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "DYNLIB_NAME"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Library '%s' doesn't exist\")",
            "name"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "name"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic void *hVBoxXPCOMC;\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\nPFNVBOXGETXPCOMCFUNCTIONS g_pfnGetFunctions = NULL;\n\nstatic int\ntryLoadOne(const char *dir, bool setAppHome, bool ignoreMissing,\n           unsigned int *version)\n{\n    int result = -1;\n    char *name = NULL;\n    PFNVBOXGETXPCOMCFUNCTIONS pfnGetFunctions;\n\n    if (dir != NULL) {\n        name = g_strdup_printf(\"%s/%s\", dir, DYNLIB_NAME);\n\n        if (!virFileExists(name)) {\n            if (!ignoreMissing)\n                VIR_ERROR(_(\"Library '%s' doesn't exist\"), name);\n\n            VIR_FREE(name);\n            return -1;\n        }\n    } else {\n        name = g_strdup(DYNLIB_NAME);\n    }\n\n    /*\n     * Try load it by that name, setting the VBOX_APP_HOME first (for now).\n     * Then resolve and call the function table getter.\n     */\n    if (setAppHome) {\n        if (dir != NULL) {\n            g_setenv(\"VBOX_APP_HOME\", dir, TRUE);\n        } else {\n            g_unsetenv(\"VBOX_APP_HOME\");\n        }\n    }\n\n    hVBoxXPCOMC = dlopen(name, RTLD_NOW | RTLD_LOCAL);\n\n    if (hVBoxXPCOMC == NULL) {\n        /*\n         * FIXME: Don't warn in this case as it currently breaks make check\n         *        on systems without VirtualBox.\n         */\n        if (dir != NULL)\n            VIR_WARN(\"Could not dlopen '%s': %s\", name, dlerror());\n\n        goto cleanup;\n    }\n\n    pfnGetFunctions = (PFNVBOXGETXPCOMCFUNCTIONS)\n        dlsym(hVBoxXPCOMC, VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME);\n\n    if (pfnGetFunctions == NULL) {\n        VIR_ERROR(_(\"Could not dlsym %s from '%s': %s\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name, dlerror());\n        goto cleanup;\n    }\n\n    pVBoxFuncs_v2_2 = pfnGetFunctions(VBOX_XPCOMC_VERSION);\n\n    if (pVBoxFuncs_v2_2 == NULL) {\n        VIR_ERROR(_(\"Calling %s from '%s' failed\"),\n                  VBOX_GET_XPCOMC_FUNCTIONS_SYMBOL_NAME, name);\n        goto cleanup;\n    }\n\n    *version = pVBoxFuncs_v2_2->pfnGetVersion();\n    g_pfnGetFunctions = pfnGetFunctions;\n    result = 0;\n\n    if (dir != NULL) {\n        VIR_DEBUG(\"Found %s in '%s'\", DYNLIB_NAME, dir);\n    } else {\n        VIR_DEBUG(\"Found %s in dynamic linker search path\", DYNLIB_NAME);\n    }\n\n cleanup:\n    if (hVBoxXPCOMC != NULL && result < 0) {\n        dlclose(hVBoxXPCOMC);\n        hVBoxXPCOMC = NULL;\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}"
  }
]